
motordriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001d6  00800100  0000907c  00009130  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000907c  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001c8  008002d6  008002d6  00009306  2**0
                  ALLOC
  3 .eeprom       0000014b  00810000  00810000  00009306  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         00007680  00000000  00000000  00009454  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      0000308f  00000000  00000000  00010ad4  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1f 03 	jmp	0x63e	; 0x63e <__ctors_end>
       4:	0c 94 53 28 	jmp	0x50a6	; 0x50a6 <__vector_1>
       8:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
       c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      10:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      14:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      18:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      1c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      20:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      24:	0c 94 48 0c 	jmp	0x1890	; 0x1890 <__vector_9>
      28:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      2c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      30:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      34:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      38:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      3c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      40:	0c 94 4c 0a 	jmp	0x1498	; 0x1498 <__vector_16>
      44:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      48:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      4c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      50:	0c 94 fe 09 	jmp	0x13fc	; 0x13fc <__vector_20>
      54:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      58:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      5c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      60:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      64:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      68:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      6c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      70:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      74:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      78:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      7c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      80:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      84:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      88:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      8c:	30 38       	cpi	r19, 0x80	; 128
      8e:	1f 38       	cpi	r17, 0x8F	; 143
      90:	07 38       	cpi	r16, 0x87	; 135
      92:	fa 37       	cpi	r31, 0x7A	; 122
      94:	ed 37       	cpi	r30, 0x7D	; 125
      96:	e2 37       	cpi	r30, 0x72	; 114
      98:	d7 37       	cpi	r29, 0x77	; 119
      9a:	ca 37       	cpi	r28, 0x7A	; 122
      9c:	c7 37       	cpi	r28, 0x77	; 119
      9e:	c2 37       	cpi	r28, 0x72	; 114
      a0:	b7 37       	cpi	r27, 0x77	; 119
      a2:	ac 37       	cpi	r26, 0x7C	; 124
      a4:	a1 37       	cpi	r26, 0x71	; 113
      a6:	96 37       	cpi	r25, 0x76	; 118
      a8:	8b 37       	cpi	r24, 0x7B	; 123
      aa:	80 37       	cpi	r24, 0x70	; 112
      ac:	75 37       	cpi	r23, 0x75	; 117
      ae:	6a 37       	cpi	r22, 0x7A	; 122
      b0:	5f 37       	cpi	r21, 0x7F	; 127
      b2:	54 37       	cpi	r21, 0x74	; 116
      b4:	49 37       	cpi	r20, 0x79	; 121
      b6:	3e 37       	cpi	r19, 0x7E	; 126
      b8:	31 37       	cpi	r19, 0x71	; 113
      ba:	2b 37       	cpi	r18, 0x7B	; 123
      bc:	ec 36       	cpi	r30, 0x6C	; 108
      be:	df 36       	cpi	r29, 0x6F	; 111
      c0:	d4 36       	cpi	r29, 0x64	; 100
      c2:	c1 36       	cpi	r28, 0x61	; 97
      c4:	b8 36       	cpi	r27, 0x68	; 104
      c6:	b5 36       	cpi	r27, 0x65	; 101
      c8:	a8 36       	cpi	r26, 0x68	; 104
      ca:	9d 36       	cpi	r25, 0x6D	; 109
      cc:	92 36       	cpi	r25, 0x62	; 98
      ce:	87 36       	cpi	r24, 0x67	; 103
      d0:	7c 36       	cpi	r23, 0x6C	; 108
      d2:	34 38       	cpi	r19, 0x84	; 132

000000d4 <table>:
      d4:	00 00 00 00 ff ff 00 00 00 00 00 00 00 00 01 00     ................
      e4:	01 00 00 00 00 00 00 00 00 00 ff ff 00 00 00 00     ................

000000f4 <cmd_0_name>:
	...

000000f6 <cmd_0_>:
      f6:	f4 00 00 80                                         ....

000000fa <cmd_1_name>:
      fa:	2a 52 53 54 00 00                                   *RST..

00000100 <cmd_1_>:
     100:	fa 00 00 81                                         ....

00000104 <cmd_2_name>:
     104:	2a 49 44 4e 3f 00 00                                *IDN?..

0000010b <cmd_2_>:
     10b:	04 01 00 82                                         ....

0000010f <cmd_3_name>:
     10f:	2a 49 44 4e 00 00                                   *IDN..

00000115 <cmd_3_>:
     115:	0f 01 01 83                                         ....

00000119 <cmd_4_name>:
     119:	4d 4f 56 45 41 42 53 00 00                          MOVEABS..

00000122 <cmd_4_>:
     122:	19 01 03 84                                         ....

00000126 <cmd_5_name>:
     126:	4d 4f 56 45 52 45 4c 00 00                          MOVEREL..

0000012f <cmd_5_>:
     12f:	26 01 03 85                                         &...

00000133 <cmd_6_name>:
     133:	5a 45 52 4f 52 55 4e 00 00                          ZERORUN..

0000013c <cmd_6_>:
     13c:	33 01 01 86                                         3...

00000140 <cmd_7_name>:
     140:	45 4e 41 42 4c 45 00 00                             ENABLE..

00000148 <cmd_7_>:
     148:	40 01 02 87                                         @...

0000014c <cmd_8_name>:
     14c:	47 45 54 50 4f 53 00 00                             GETPOS..

00000154 <cmd_8_>:
     154:	4c 01 02 88                                         L...

00000158 <cmd_9_name>:
     158:	53 41 56 45 43 4f 4e 46 00 00                       SAVECONF..

00000162 <cmd_9_>:
     162:	58 01 00 89                                         X...

00000166 <cmd_10_name>:
     166:	4c 4f 41 44 43 4f 4e 46 00 00                       LOADCONF..

00000170 <cmd_10_>:
     170:	66 01 00 8a                                         f...

00000174 <cmd_11_name>:
     174:	49 53 4d 4f 56 49 4e 47 00 00                       ISMOVING..

0000017e <cmd_11_>:
     17e:	74 01 01 8b                                         t...

00000182 <cmd_12_name>:
     182:	47 45 54 41 4e 41 4c 4f 47 00 00                    GETANALOG..

0000018d <cmd_12_>:
     18d:	82 01 01 8c                                         ....

00000191 <cmd_13_name>:
     191:	47 45 54 5a 45 52 4f 50 4f 53 00 00                 GETZEROPOS..

0000019d <cmd_13_>:
     19d:	91 01 01 8d                                         ....

000001a1 <cmd_14_name>:
     1a1:	53 45 54 5a 45 52 4f 50 4f 53 00 00                 SETZEROPOS..

000001ad <cmd_14_>:
     1ad:	a1 01 02 8e                                         ....

000001b1 <cmd_15_name>:
     1b1:	47 45 54 47 45 41 52 52 41 54 49 4f 00 00           GETGEARRATIO..

000001bf <cmd_15_>:
     1bf:	b1 01 01 8f                                         ....

000001c3 <cmd_16_name>:
     1c3:	53 45 54 47 45 41 52 52 41 54 49 4f 00 00           SETGEARRATIO..

000001d1 <cmd_16_>:
     1d1:	c3 01 02 90                                         ....

000001d5 <cmd_17_name>:
     1d5:	47 45 54 46 55 4c 4c 52 4f 54 00 00                 GETFULLROT..

000001e1 <cmd_17_>:
     1e1:	d5 01 01 91                                         ....

000001e5 <cmd_18_name>:
     1e5:	53 45 54 46 55 4c 4c 52 4f 54 00 00                 SETFULLROT..

000001f1 <cmd_18_>:
     1f1:	e5 01 02 92                                         ....

000001f5 <cmd_19_name>:
     1f5:	47 45 54 53 55 42 53 54 45 50 53 00 00              GETSUBSTEPS..

00000202 <cmd_19_>:
     202:	f5 01 01 93                                         ....

00000206 <cmd_20_name>:
     206:	53 45 54 53 55 42 53 54 45 50 53 00 00              SETSUBSTEPS..

00000213 <cmd_20_>:
     213:	06 02 02 94                                         ....

00000217 <cmd_21_name>:
     217:	47 45 54 57 41 49 54 54 49 4d 45 00 00              GETWAITTIME..

00000224 <cmd_21_>:
     224:	17 02 01 95                                         ....

00000228 <cmd_22_name>:
     228:	53 45 54 57 41 49 54 54 49 4d 45 00 00              SETWAITTIME..

00000235 <cmd_22_>:
     235:	28 02 02 96                                         (...

00000239 <cmd_23_name>:
     239:	53 45 54 43 4f 4e 53 54 53 50 45 45 44 00 00        SETCONSTSPEED..

00000248 <cmd_23_>:
     248:	39 02 03 97                                         9...

0000024c <cmd_24_name>:
     24c:	46 41 43 54 4f 52 59 52 45 53 45 54 00 00           FACTORYRESET..

0000025a <cmd_24_>:
     25a:	4c 02 00 98                                         L...

0000025e <cmd_25_name>:
     25e:	53 54 4f 50 41 4c 4c 00 00                          STOPALL..

00000267 <cmd_25_>:
     267:	5e 02 00 99                                         ^...

0000026b <cmd_26_name>:
     26b:	53 45 54 46 4f 52 42 5a 4f 4e 45 00 00              SETFORBZONE..

00000278 <cmd_26_>:
     278:	6b 02 03 9a                                         k...

0000027c <cmd_27_name>:
     27c:	45 4e 41 42 46 4f 52 42 5a 4f 4e 45 00 00           ENABFORBZONE..

0000028a <cmd_27_>:
     28a:	7c 02 02 9b                                         |...

0000028e <cmd_28_name>:
     28e:	53 45 54 50 52 4f 47 53 54 45 50 00 00              SETPROGSTEP..

0000029b <cmd_28_>:
     29b:	8e 02 06 9c                                         ....

0000029f <cmd_29_name>:
     29f:	47 45 54 4d 4f 54 53 54 41 54 45 00 00              GETMOTSTATE..

000002ac <cmd_29_>:
     2ac:	9f 02 01 9d                                         ....

000002b0 <cmd_30_name>:
     2b0:	44 42 47 52 45 41 44 4f 55 54 00 00                 DBGREADOUT..

000002bc <cmd_30_>:
     2bc:	b0 02 00 9e                                         ....

000002c0 <cmd_31_name>:
     2c0:	4c 45 44 00 00                                      LED..

000002c5 <cmd_31_>:
     2c5:	c0 02 03 9f                                         ....

000002c9 <cmd_32_name>:
     2c9:	47 45 54 43 55 52 52 00 00                          GETCURR..

000002d2 <cmd_32_>:
     2d2:	c9 02 01 a0                                         ....

000002d6 <cmd_33_name>:
     2d6:	53 45 54 43 55 52 52 00 00                          SETCURR..

000002df <cmd_33_>:
     2df:	d6 02 02 a1                                         ....

000002e3 <cmd_34_name>:
     2e3:	47 45 54 44 45 43 41 59 00 00                       GETDECAY..

000002ed <cmd_34_>:
     2ed:	e3 02 01 a2                                         ....

000002f1 <cmd_35_name>:
     2f1:	53 45 54 44 45 43 41 59 00 00                       SETDECAY..

000002fb <cmd_35_>:
     2fb:	f1 02 02 a3                                         ....

000002ff <cmd_36_name>:
     2ff:	49 53 43 4f 4e 00 00                                ISCON..

00000306 <cmd_36_>:
     306:	ff 02 01 a4                                         ....

0000030a <commandList>:
     30a:	f6 00 00 01 0b 01 15 01 22 01 2f 01 3c 01 48 01     ........"./.<.H.
     31a:	54 01 62 01 70 01 7e 01 8d 01 9d 01 ad 01 bf 01     T.b.p.~.........
     32a:	d1 01 e1 01 f1 01 02 02 13 02 24 02 35 02 48 02     ..........$.5.H.
     33a:	5a 02 67 02 78 02 8a 02 9b 02 ac 02 bc 02 c5 02     Z.g.x...........
     34a:	d2 02 df 02 ed 02 fb 02 06 03                       ..........

00000354 <disp_0_text>:
     354:	4c 4b 2d 49 6e 73 74 72 75 6d 65 6e 74 73 0a 53     LK-Instruments.S
     364:	4d 43 34 32 34 32 00 00                             MC4242..

0000036c <disp_0_>:
     36c:	54 03 00                                            T..

0000036f <disp_1_text>:
     36f:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 70 6f 73     Change motor.pos
     37f:	69 74 69 6f 6e 00 00                                ition..

00000386 <disp_1_>:
     386:	6f 03 01                                            o..

00000389 <disp_2_text>:
     389:	53 65 74 20 73 74 65 70 0a 6d 75 6c 74 69 70 6c     Set step.multipl
     399:	69 65 72 00 00                                      ier..

0000039e <disp_2_>:
     39e:	89 03 02                                            ...

000003a1 <disp_3_text>:
     3a1:	43 68 61 6e 67 65 20 73 74 65 70 0a 75 6e 69 74     Change step.unit
	...

000003b3 <disp_3_>:
     3b3:	a1 03 03                                            ...

000003b6 <disp_4_text>:
     3b6:	52 75 6e 20 69 6e 74 65 72 6e 61 6c 0a 70 72 6f     Run internal.pro
     3c6:	67 72 61 6d 00 00                                   gram..

000003cc <disp_4_>:
     3cc:	b6 03 04                                            ...

000003cf <disp_5_text>:
     3cf:	52 75 6e 20 77 69 74 68 0a 63 6f 6e 73 74 61 6e     Run with.constan
     3df:	74 20 73 70 65 65 64 00 00                          t speed..

000003e8 <disp_5_>:
     3e8:	cf 03 05                                            ...

000003eb <disp_6_text>:
     3eb:	44 65 66 69 6e 65 20 7a 65 72 6f 0a 70 6f 73 69     Define zero.posi
     3fb:	74 69 6f 6e 00 00                                   tion..

00000401 <disp_6_>:
     401:	eb 03 06                                            ...

00000404 <disp_7_text>:
     404:	52 75 6e 20 7a 65 72 6f 0a 63 61 6c 69 62 72 61     Run zero.calibra
     414:	74 69 6f 6e 00 00                                   tion..

0000041a <disp_7_>:
     41a:	04 04 07                                            ...

0000041d <disp_8_text>:
     41d:	45 6e 74 65 72 0a 73 65 74 74 69 6e 67 73 20 6d     Enter.settings m
     42d:	65 6e 75 00 00                                      enu..

00000432 <disp_8_>:
     432:	1d 04 08                                            ...

00000435 <disp_9_text>:
     435:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     445:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
     455:	20 00 00                                             ..

00000458 <disp_9_>:
     458:	35 04 09                                            5..

0000045b <disp_10_text>:
     45b:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 73 75 62     Change motor.sub
     46b:	73 74 65 70 00 00                                   step..

00000471 <disp_10_>:
     471:	5b 04 0a                                            [..

00000474 <disp_11_text>:
     474:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 63 75 72     Change motor.cur
     484:	72 65 6e 74 00 00                                   rent..

0000048a <disp_11_>:
     48a:	74 04 0b                                            t..

0000048d <disp_12_text>:
     48d:	43 68 61 6e 67 65 20 73 74 65 70 0a 77 61 69 74     Change step.wait
     49d:	20 74 69 6d 65 00 00                                 time..

000004a4 <disp_12_>:
     4a4:	8d 04 0c                                            ...

000004a7 <disp_13_text>:
     4a7:	53 61 76 65 20 63 75 72 72 65 6e 74 0a 63 6f 6e     Save current.con
     4b7:	66 69 67 75 72 61 74 69 6f 6e 00 00                 figuration..

000004c3 <disp_13_>:
     4c3:	a7 04 0d                                            ...

000004c6 <disp_14_text>:
     4c6:	4c 6f 61 64 20 6c 61 73 74 0a 63 6f 6e 66 69 67     Load last.config
     4d6:	75 72 61 74 69 6f 6e 00 00                          uration..

000004df <disp_14_>:
     4df:	c6 04 0e                                            ...

000004e2 <menuList>:
     4e2:	6c 03 86 03 9e 03 b3 03 cc 03 e8 03 01 04 1a 04     l...............
     4f2:	32 04 58 04 71 04 8a 04 a4 04 c3 04 df 04           2.X.q.........

00000500 <__c.1790>:
     500:	6e 61 6e 00                                         nan.

00000504 <__c.1788>:
     504:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     514:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     524:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     534:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     544:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     554:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     564:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     574:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     584:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     594:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     5a4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     5b4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     5c4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     5d4:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     5e4:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     5f4:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000602 <pstr_inf>:
     602:	49 4e 46                                            INF

00000605 <pstr_inity>:
     605:	49 4e 49 54 59                                      INITY

0000060a <pstr_nan>:
     60a:	4e 41 4e                                            NAN

0000060d <pwr_m10>:
     60d:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     61d:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000625 <pwr_p10>:
     625:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     635:	ca 1b 0e 5a ae c5 9d 74 00                          ...Z...t.

0000063e <__ctors_end>:
     63e:	11 24       	eor	r1, r1
     640:	1f be       	out	0x3f, r1	; 63
     642:	cf ef       	ldi	r28, 0xFF	; 255
     644:	d0 e4       	ldi	r29, 0x40	; 64
     646:	de bf       	out	0x3e, r29	; 62
     648:	cd bf       	out	0x3d, r28	; 61

0000064a <__do_copy_data>:
     64a:	12 e0       	ldi	r17, 0x02	; 2
     64c:	a0 e0       	ldi	r26, 0x00	; 0
     64e:	b1 e0       	ldi	r27, 0x01	; 1
     650:	ec e7       	ldi	r30, 0x7C	; 124
     652:	f0 e9       	ldi	r31, 0x90	; 144
     654:	00 e0       	ldi	r16, 0x00	; 0
     656:	0b bf       	out	0x3b, r16	; 59
     658:	02 c0       	rjmp	.+4      	; 0x65e <__do_copy_data+0x14>
     65a:	07 90       	elpm	r0, Z+
     65c:	0d 92       	st	X+, r0
     65e:	a6 3d       	cpi	r26, 0xD6	; 214
     660:	b1 07       	cpc	r27, r17
     662:	d9 f7       	brne	.-10     	; 0x65a <__do_copy_data+0x10>

00000664 <__do_clear_bss>:
     664:	14 e0       	ldi	r17, 0x04	; 4
     666:	a6 ed       	ldi	r26, 0xD6	; 214
     668:	b2 e0       	ldi	r27, 0x02	; 2
     66a:	01 c0       	rjmp	.+2      	; 0x66e <.do_clear_bss_start>

0000066c <.do_clear_bss_loop>:
     66c:	1d 92       	st	X+, r1

0000066e <.do_clear_bss_start>:
     66e:	ae 39       	cpi	r26, 0x9E	; 158
     670:	b1 07       	cpc	r27, r17
     672:	e1 f7       	brne	.-8      	; 0x66c <.do_clear_bss_loop>
     674:	0e 94 44 35 	call	0x6a88	; 0x6a88 <main>
     678:	0c 94 3c 48 	jmp	0x9078	; 0x9078 <_exit>

0000067c <__bad_interrupt>:
     67c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000680 <initDataStructs>:
====================================================================== */

/* ---------------------------------------------------------------------
    initialize the internal data memory
 --------------------------------------------------------------------- */
void initDataStructs(void){
     680:	2f 92       	push	r2
     682:	3f 92       	push	r3
     684:	4f 92       	push	r4
     686:	5f 92       	push	r5
     688:	6f 92       	push	r6
     68a:	7f 92       	push	r7
     68c:	8f 92       	push	r8
     68e:	9f 92       	push	r9
     690:	af 92       	push	r10
     692:	bf 92       	push	r11
     694:	cf 92       	push	r12
     696:	df 92       	push	r13
     698:	ef 92       	push	r14
     69a:	ff 92       	push	r15
     69c:	0f 93       	push	r16
     69e:	1f 93       	push	r17
     6a0:	40 e0       	ldi	r20, 0x00	; 0
     6a2:	50 e0       	ldi	r21, 0x00	; 0

  for(i = 0; i <= MAX_MOTOR; i++){
    motor[i].actualPosition       = 0;
    motor[i].desiredPosition      = 0;
    motor[i].opticalZeroPosition  = 0;
    motor[i].stepError            = 0.0f;
     6a4:	0f 2e       	mov	r0, r31
     6a6:	f0 e0       	ldi	r31, 0x00	; 0
     6a8:	6f 2e       	mov	r6, r31
     6aa:	f0 e0       	ldi	r31, 0x00	; 0
     6ac:	7f 2e       	mov	r7, r31
     6ae:	f0 e0       	ldi	r31, 0x00	; 0
     6b0:	8f 2e       	mov	r8, r31
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
     6b4:	9f 2e       	mov	r9, r31
     6b6:	f0 2d       	mov	r31, r0
    motor[i].isMoving             = 0;
    motor[i].isTurnedOn           = 0;
    motor[i].isMovingInfinite     = MOTOR_MOVE_INFINITE_STOP;
    motor[i].gearRatio            = 60.0f/20.0f; /* TODO */
     6b8:	0f 2e       	mov	r0, r31
     6ba:	f0 e0       	ldi	r31, 0x00	; 0
     6bc:	2f 2e       	mov	r2, r31
     6be:	f0 e0       	ldi	r31, 0x00	; 0
     6c0:	3f 2e       	mov	r3, r31
     6c2:	f0 e4       	ldi	r31, 0x40	; 64
     6c4:	4f 2e       	mov	r4, r31
     6c6:	f0 e4       	ldi	r31, 0x40	; 64
     6c8:	5f 2e       	mov	r5, r31
     6ca:	f0 2d       	mov	r31, r0
    motor[i].stepsPerFullRotation = 400.0f;
    motor[i].subSteps             = 4.0f;
     6cc:	0f 2e       	mov	r0, r31
     6ce:	f0 e0       	ldi	r31, 0x00	; 0
     6d0:	af 2e       	mov	r10, r31
     6d2:	f0 e0       	ldi	r31, 0x00	; 0
     6d4:	bf 2e       	mov	r11, r31
     6d6:	f0 e8       	ldi	r31, 0x80	; 128
     6d8:	cf 2e       	mov	r12, r31
     6da:	f0 e4       	ldi	r31, 0x40	; 64
     6dc:	df 2e       	mov	r13, r31
     6de:	f0 2d       	mov	r31, r0
    motor[i].stepMultiplier       = 1.0f;
     6e0:	0f 2e       	mov	r0, r31
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	ef 2e       	mov	r14, r31
     6e6:	f0 e0       	ldi	r31, 0x00	; 0
     6e8:	ff 2e       	mov	r15, r31
     6ea:	f0 e8       	ldi	r31, 0x80	; 128
     6ec:	0f 2f       	mov	r16, r31
     6ee:	ff e3       	ldi	r31, 0x3F	; 63
     6f0:	1f 2f       	mov	r17, r31
     6f2:	f0 2d       	mov	r31, r0
    motor[i].stepUnit             = MOTOR_STEP_UNIT_DEGREE;
    motor[i].waitBetweenSteps     = 3;
     6f4:	63 e0       	ldi	r22, 0x03	; 3
     6f6:	70 e0       	ldi	r23, 0x00	; 0
void initDataStructs(void){

  uint8_t i, j;

  for(i = 0; i <= MAX_MOTOR; i++){
    motor[i].actualPosition       = 0;
     6f8:	fa 01       	movw	r30, r20
     6fa:	ee 0f       	add	r30, r30
     6fc:	ff 1f       	adc	r31, r31
     6fe:	ee 0f       	add	r30, r30
     700:	ff 1f       	adc	r31, r31
     702:	ee 0f       	add	r30, r30
     704:	ff 1f       	adc	r31, r31
     706:	cf 01       	movw	r24, r30
     708:	88 0f       	add	r24, r24
     70a:	99 1f       	adc	r25, r25
     70c:	88 0f       	add	r24, r24
     70e:	99 1f       	adc	r25, r25
     710:	e8 0f       	add	r30, r24
     712:	f9 1f       	adc	r31, r25
     714:	e0 51       	subi	r30, 0x10	; 16
     716:	fc 4f       	sbci	r31, 0xFC	; 252
     718:	11 82       	std	Z+1, r1	; 0x01
     71a:	10 82       	st	Z, r1
    motor[i].desiredPosition      = 0;
     71c:	fa 01       	movw	r30, r20
     71e:	ee 0f       	add	r30, r30
     720:	ff 1f       	adc	r31, r31
     722:	ee 0f       	add	r30, r30
     724:	ff 1f       	adc	r31, r31
     726:	cf 01       	movw	r24, r30
     728:	88 0f       	add	r24, r24
     72a:	99 1f       	adc	r25, r25
     72c:	88 0f       	add	r24, r24
     72e:	99 1f       	adc	r25, r25
     730:	e8 0f       	add	r30, r24
     732:	f9 1f       	adc	r31, r25
     734:	ee 0f       	add	r30, r30
     736:	ff 1f       	adc	r31, r31
     738:	ee 50       	subi	r30, 0x0E	; 14
     73a:	fc 4f       	sbci	r31, 0xFC	; 252
     73c:	11 82       	std	Z+1, r1	; 0x01
     73e:	10 82       	st	Z, r1
    motor[i].opticalZeroPosition  = 0;
     740:	ca 01       	movw	r24, r20
     742:	fa 01       	movw	r30, r20
     744:	ee 0f       	add	r30, r30
     746:	ff 1f       	adc	r31, r31
     748:	ee 0f       	add	r30, r30
     74a:	ff 1f       	adc	r31, r31
     74c:	ee 0f       	add	r30, r30
     74e:	ff 1f       	adc	r31, r31
     750:	88 0f       	add	r24, r24
     752:	99 1f       	adc	r25, r25
     754:	e8 0f       	add	r30, r24
     756:	f9 1f       	adc	r31, r25
     758:	ee 0f       	add	r30, r30
     75a:	ff 1f       	adc	r31, r31
     75c:	ee 0f       	add	r30, r30
     75e:	ff 1f       	adc	r31, r31
     760:	ec 50       	subi	r30, 0x0C	; 12
     762:	fc 4f       	sbci	r31, 0xFC	; 252
     764:	11 82       	std	Z+1, r1	; 0x01
     766:	10 82       	st	Z, r1
    motor[i].stepError            = 0.0f;
     768:	fa 01       	movw	r30, r20
     76a:	ee 0f       	add	r30, r30
     76c:	ff 1f       	adc	r31, r31
     76e:	ee 0f       	add	r30, r30
     770:	ff 1f       	adc	r31, r31
     772:	ee 0f       	add	r30, r30
     774:	ff 1f       	adc	r31, r31
     776:	cf 01       	movw	r24, r30
     778:	88 0f       	add	r24, r24
     77a:	99 1f       	adc	r25, r25
     77c:	88 0f       	add	r24, r24
     77e:	99 1f       	adc	r25, r25
     780:	e8 0f       	add	r30, r24
     782:	f9 1f       	adc	r31, r25
     784:	e0 51       	subi	r30, 0x10	; 16
     786:	fc 4f       	sbci	r31, 0xFC	; 252
     788:	66 82       	std	Z+6, r6	; 0x06
     78a:	77 82       	std	Z+7, r7	; 0x07
     78c:	80 86       	std	Z+8, r8	; 0x08
     78e:	91 86       	std	Z+9, r9	; 0x09
    motor[i].isMoving             = 0;
     790:	fa 01       	movw	r30, r20
     792:	ee 0f       	add	r30, r30
     794:	ff 1f       	adc	r31, r31
     796:	ee 0f       	add	r30, r30
     798:	ff 1f       	adc	r31, r31
     79a:	ee 0f       	add	r30, r30
     79c:	ff 1f       	adc	r31, r31
     79e:	cf 01       	movw	r24, r30
     7a0:	88 0f       	add	r24, r24
     7a2:	99 1f       	adc	r25, r25
     7a4:	88 0f       	add	r24, r24
     7a6:	99 1f       	adc	r25, r25
     7a8:	e8 0f       	add	r30, r24
     7aa:	f9 1f       	adc	r31, r25
     7ac:	e0 51       	subi	r30, 0x10	; 16
     7ae:	fc 4f       	sbci	r31, 0xFC	; 252
     7b0:	12 86       	std	Z+10, r1	; 0x0a
    motor[i].isTurnedOn           = 0;
     7b2:	fa 01       	movw	r30, r20
     7b4:	ee 0f       	add	r30, r30
     7b6:	ff 1f       	adc	r31, r31
     7b8:	ee 0f       	add	r30, r30
     7ba:	ff 1f       	adc	r31, r31
     7bc:	ee 0f       	add	r30, r30
     7be:	ff 1f       	adc	r31, r31
     7c0:	cf 01       	movw	r24, r30
     7c2:	88 0f       	add	r24, r24
     7c4:	99 1f       	adc	r25, r25
     7c6:	88 0f       	add	r24, r24
     7c8:	99 1f       	adc	r25, r25
     7ca:	e8 0f       	add	r30, r24
     7cc:	f9 1f       	adc	r31, r25
     7ce:	e0 51       	subi	r30, 0x10	; 16
     7d0:	fc 4f       	sbci	r31, 0xFC	; 252
     7d2:	13 86       	std	Z+11, r1	; 0x0b
    motor[i].isMovingInfinite     = MOTOR_MOVE_INFINITE_STOP;
     7d4:	fa 01       	movw	r30, r20
     7d6:	ee 0f       	add	r30, r30
     7d8:	ff 1f       	adc	r31, r31
     7da:	ee 0f       	add	r30, r30
     7dc:	ff 1f       	adc	r31, r31
     7de:	ee 0f       	add	r30, r30
     7e0:	ff 1f       	adc	r31, r31
     7e2:	cf 01       	movw	r24, r30
     7e4:	88 0f       	add	r24, r24
     7e6:	99 1f       	adc	r25, r25
     7e8:	88 0f       	add	r24, r24
     7ea:	99 1f       	adc	r25, r25
     7ec:	e8 0f       	add	r30, r24
     7ee:	f9 1f       	adc	r31, r25
     7f0:	e0 51       	subi	r30, 0x10	; 16
     7f2:	fc 4f       	sbci	r31, 0xFC	; 252
     7f4:	14 86       	std	Z+12, r1	; 0x0c
    motor[i].gearRatio            = 60.0f/20.0f; /* TODO */
     7f6:	fa 01       	movw	r30, r20
     7f8:	ee 0f       	add	r30, r30
     7fa:	ff 1f       	adc	r31, r31
     7fc:	ee 0f       	add	r30, r30
     7fe:	ff 1f       	adc	r31, r31
     800:	ee 0f       	add	r30, r30
     802:	ff 1f       	adc	r31, r31
     804:	cf 01       	movw	r24, r30
     806:	88 0f       	add	r24, r24
     808:	99 1f       	adc	r25, r25
     80a:	88 0f       	add	r24, r24
     80c:	99 1f       	adc	r25, r25
     80e:	e8 0f       	add	r30, r24
     810:	f9 1f       	adc	r31, r25
     812:	e0 51       	subi	r30, 0x10	; 16
     814:	fc 4f       	sbci	r31, 0xFC	; 252
     816:	25 86       	std	Z+13, r2	; 0x0d
     818:	36 86       	std	Z+14, r3	; 0x0e
     81a:	47 86       	std	Z+15, r4	; 0x0f
     81c:	50 8a       	std	Z+16, r5	; 0x10
    motor[i].stepsPerFullRotation = 400.0f;
     81e:	fa 01       	movw	r30, r20
     820:	ee 0f       	add	r30, r30
     822:	ff 1f       	adc	r31, r31
     824:	ee 0f       	add	r30, r30
     826:	ff 1f       	adc	r31, r31
     828:	ee 0f       	add	r30, r30
     82a:	ff 1f       	adc	r31, r31
     82c:	cf 01       	movw	r24, r30
     82e:	88 0f       	add	r24, r24
     830:	99 1f       	adc	r25, r25
     832:	88 0f       	add	r24, r24
     834:	99 1f       	adc	r25, r25
     836:	e8 0f       	add	r30, r24
     838:	f9 1f       	adc	r31, r25
     83a:	e0 51       	subi	r30, 0x10	; 16
     83c:	fc 4f       	sbci	r31, 0xFC	; 252
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	90 e0       	ldi	r25, 0x00	; 0
     842:	a8 ec       	ldi	r26, 0xC8	; 200
     844:	b3 e4       	ldi	r27, 0x43	; 67
     846:	81 8b       	std	Z+17, r24	; 0x11
     848:	92 8b       	std	Z+18, r25	; 0x12
     84a:	a3 8b       	std	Z+19, r26	; 0x13
     84c:	b4 8b       	std	Z+20, r27	; 0x14
    motor[i].subSteps             = 4.0f;
     84e:	fa 01       	movw	r30, r20
     850:	ee 0f       	add	r30, r30
     852:	ff 1f       	adc	r31, r31
     854:	ee 0f       	add	r30, r30
     856:	ff 1f       	adc	r31, r31
     858:	ee 0f       	add	r30, r30
     85a:	ff 1f       	adc	r31, r31
     85c:	cf 01       	movw	r24, r30
     85e:	88 0f       	add	r24, r24
     860:	99 1f       	adc	r25, r25
     862:	88 0f       	add	r24, r24
     864:	99 1f       	adc	r25, r25
     866:	e8 0f       	add	r30, r24
     868:	f9 1f       	adc	r31, r25
     86a:	e0 51       	subi	r30, 0x10	; 16
     86c:	fc 4f       	sbci	r31, 0xFC	; 252
     86e:	a5 8a       	std	Z+21, r10	; 0x15
     870:	b6 8a       	std	Z+22, r11	; 0x16
     872:	c7 8a       	std	Z+23, r12	; 0x17
     874:	d0 8e       	std	Z+24, r13	; 0x18
    motor[i].stepMultiplier       = 1.0f;
     876:	fa 01       	movw	r30, r20
     878:	ee 0f       	add	r30, r30
     87a:	ff 1f       	adc	r31, r31
     87c:	ee 0f       	add	r30, r30
     87e:	ff 1f       	adc	r31, r31
     880:	ee 0f       	add	r30, r30
     882:	ff 1f       	adc	r31, r31
     884:	cf 01       	movw	r24, r30
     886:	88 0f       	add	r24, r24
     888:	99 1f       	adc	r25, r25
     88a:	88 0f       	add	r24, r24
     88c:	99 1f       	adc	r25, r25
     88e:	e8 0f       	add	r30, r24
     890:	f9 1f       	adc	r31, r25
     892:	e0 51       	subi	r30, 0x10	; 16
     894:	fc 4f       	sbci	r31, 0xFC	; 252
     896:	e2 8e       	std	Z+26, r14	; 0x1a
     898:	f3 8e       	std	Z+27, r15	; 0x1b
     89a:	04 8f       	std	Z+28, r16	; 0x1c
     89c:	15 8f       	std	Z+29, r17	; 0x1d
    motor[i].stepUnit             = MOTOR_STEP_UNIT_DEGREE;
     89e:	fa 01       	movw	r30, r20
     8a0:	ee 0f       	add	r30, r30
     8a2:	ff 1f       	adc	r31, r31
     8a4:	ee 0f       	add	r30, r30
     8a6:	ff 1f       	adc	r31, r31
     8a8:	ee 0f       	add	r30, r30
     8aa:	ff 1f       	adc	r31, r31
     8ac:	cf 01       	movw	r24, r30
     8ae:	88 0f       	add	r24, r24
     8b0:	99 1f       	adc	r25, r25
     8b2:	88 0f       	add	r24, r24
     8b4:	99 1f       	adc	r25, r25
     8b6:	e8 0f       	add	r30, r24
     8b8:	f9 1f       	adc	r31, r25
     8ba:	e0 51       	subi	r30, 0x10	; 16
     8bc:	fc 4f       	sbci	r31, 0xFC	; 252
     8be:	91 e0       	ldi	r25, 0x01	; 1
     8c0:	91 8f       	std	Z+25, r25	; 0x19
    motor[i].waitBetweenSteps     = 3;
     8c2:	fa 01       	movw	r30, r20
     8c4:	ee 0f       	add	r30, r30
     8c6:	ff 1f       	adc	r31, r31
     8c8:	ee 0f       	add	r30, r30
     8ca:	ff 1f       	adc	r31, r31
     8cc:	ee 0f       	add	r30, r30
     8ce:	ff 1f       	adc	r31, r31
     8d0:	cf 01       	movw	r24, r30
     8d2:	88 0f       	add	r24, r24
     8d4:	99 1f       	adc	r25, r25
     8d6:	88 0f       	add	r24, r24
     8d8:	99 1f       	adc	r25, r25
     8da:	e8 0f       	add	r30, r24
     8dc:	f9 1f       	adc	r31, r25
     8de:	e0 51       	subi	r30, 0x10	; 16
     8e0:	fc 4f       	sbci	r31, 0xFC	; 252
     8e2:	77 8f       	std	Z+31, r23	; 0x1f
     8e4:	66 8f       	std	Z+30, r22	; 0x1e
    motor[i].delayCounter         = 2*motor[i].waitBetweenSteps-1;
     8e6:	fa 01       	movw	r30, r20
     8e8:	ee 0f       	add	r30, r30
     8ea:	ff 1f       	adc	r31, r31
     8ec:	ee 0f       	add	r30, r30
     8ee:	ff 1f       	adc	r31, r31
     8f0:	ee 0f       	add	r30, r30
     8f2:	ff 1f       	adc	r31, r31
     8f4:	cf 01       	movw	r24, r30
     8f6:	88 0f       	add	r24, r24
     8f8:	99 1f       	adc	r25, r25
     8fa:	88 0f       	add	r24, r24
     8fc:	99 1f       	adc	r25, r25
     8fe:	e8 0f       	add	r30, r24
     900:	f9 1f       	adc	r31, r25
     902:	e0 51       	subi	r30, 0x10	; 16
     904:	fc 4f       	sbci	r31, 0xFC	; 252
     906:	26 8d       	ldd	r18, Z+30	; 0x1e
     908:	37 8d       	ldd	r19, Z+31	; 0x1f
     90a:	22 0f       	add	r18, r18
     90c:	33 1f       	adc	r19, r19
     90e:	21 50       	subi	r18, 0x01	; 1
     910:	30 40       	sbci	r19, 0x00	; 0
     912:	fa 01       	movw	r30, r20
     914:	ee 0f       	add	r30, r30
     916:	ff 1f       	adc	r31, r31
     918:	ee 0f       	add	r30, r30
     91a:	ff 1f       	adc	r31, r31
     91c:	ee 0f       	add	r30, r30
     91e:	ff 1f       	adc	r31, r31
     920:	cf 01       	movw	r24, r30
     922:	88 0f       	add	r24, r24
     924:	99 1f       	adc	r25, r25
     926:	88 0f       	add	r24, r24
     928:	99 1f       	adc	r25, r25
     92a:	e8 0f       	add	r30, r24
     92c:	f9 1f       	adc	r31, r25
     92e:	e0 51       	subi	r30, 0x10	; 16
     930:	fc 4f       	sbci	r31, 0xFC	; 252
     932:	31 a3       	std	Z+33, r19	; 0x21
     934:	20 a3       	std	Z+32, r18	; 0x20
    motor[i].angularVelocity      = OFF;
     936:	fa 01       	movw	r30, r20
     938:	ee 0f       	add	r30, r30
     93a:	ff 1f       	adc	r31, r31
     93c:	ee 0f       	add	r30, r30
     93e:	ff 1f       	adc	r31, r31
     940:	ee 0f       	add	r30, r30
     942:	ff 1f       	adc	r31, r31
     944:	cf 01       	movw	r24, r30
     946:	88 0f       	add	r24, r24
     948:	99 1f       	adc	r25, r25
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	e8 0f       	add	r30, r24
     950:	f9 1f       	adc	r31, r25
     952:	e0 51       	subi	r30, 0x10	; 16
     954:	fc 4f       	sbci	r31, 0xFC	; 252
     956:	12 a2       	std	Z+34, r1	; 0x22
    motor[i].current              = 1.0;
     958:	fa 01       	movw	r30, r20
     95a:	ee 0f       	add	r30, r30
     95c:	ff 1f       	adc	r31, r31
     95e:	ee 0f       	add	r30, r30
     960:	ff 1f       	adc	r31, r31
     962:	ee 0f       	add	r30, r30
     964:	ff 1f       	adc	r31, r31
     966:	cf 01       	movw	r24, r30
     968:	88 0f       	add	r24, r24
     96a:	99 1f       	adc	r25, r25
     96c:	88 0f       	add	r24, r24
     96e:	99 1f       	adc	r25, r25
     970:	e8 0f       	add	r30, r24
     972:	f9 1f       	adc	r31, r25
     974:	e0 51       	subi	r30, 0x10	; 16
     976:	fc 4f       	sbci	r31, 0xFC	; 252
     978:	e3 a2       	std	Z+35, r14	; 0x23
     97a:	f4 a2       	std	Z+36, r15	; 0x24
     97c:	05 a3       	std	Z+37, r16	; 0x25
     97e:	16 a3       	std	Z+38, r17	; 0x26
    motor[i].decay                = 0;
     980:	fa 01       	movw	r30, r20
     982:	ee 0f       	add	r30, r30
     984:	ff 1f       	adc	r31, r31
     986:	ee 0f       	add	r30, r30
     988:	ff 1f       	adc	r31, r31
     98a:	ee 0f       	add	r30, r30
     98c:	ff 1f       	adc	r31, r31
     98e:	cf 01       	movw	r24, r30
     990:	88 0f       	add	r24, r24
     992:	99 1f       	adc	r25, r25
     994:	88 0f       	add	r24, r24
     996:	99 1f       	adc	r25, r25
     998:	e8 0f       	add	r30, r24
     99a:	f9 1f       	adc	r31, r25
     99c:	e0 51       	subi	r30, 0x10	; 16
     99e:	fc 4f       	sbci	r31, 0xFC	; 252
     9a0:	17 a2       	std	Z+39, r1	; 0x27
     9a2:	4f 5f       	subi	r20, 0xFF	; 255
     9a4:	5f 4f       	sbci	r21, 0xFF	; 255
 --------------------------------------------------------------------- */
void initDataStructs(void){

  uint8_t i, j;

  for(i = 0; i <= MAX_MOTOR; i++){
     9a6:	44 30       	cpi	r20, 0x04	; 4
     9a8:	51 05       	cpc	r21, r1
     9aa:	09 f0       	breq	.+2      	; 0x9ae <initDataStructs+0x32e>
     9ac:	a5 ce       	rjmp	.-694    	; 0x6f8 <initDataStructs+0x78>
    motor[i].angularVelocity      = OFF;
    motor[i].current              = 1.0;
    motor[i].decay                = 0;
  }

  rxString.charCount = 0;
     9ae:	10 92 f1 02 	sts	0x02F1, r1
  rxString.readyToProcess = 0;
     9b2:	10 92 f0 02 	sts	0x02F0, r1

  txString.charCount = 0;
     9b6:	10 92 ea 03 	sts	0x03EA, r1
  txString.readyToProcess = 0;
     9ba:	10 92 e9 03 	sts	0x03E9, r1

  status.status = 0;
     9be:	10 92 95 04 	sts	0x0495, r1
  status.inRemoteMode = 0;
     9c2:	10 92 96 04 	sts	0x0496, r1

  adc.ADCvalue = 0;
     9c6:	10 92 cc 03 	sts	0x03CC, r1
     9ca:	10 92 cb 03 	sts	0x03CB, r1
  adc.numberOfMeasurements = 8;
     9ce:	88 e0       	ldi	r24, 0x08	; 8
     9d0:	80 93 cd 03 	sts	0x03CD, r24

  menu.newDisplayedMenu = MENU_MAIN;
     9d4:	10 92 df 02 	sts	0x02DF, r1
  menu.currentDisplayedMenu = 42;
     9d8:	9a e2       	ldi	r25, 0x2A	; 42
     9da:	90 93 e0 02 	sts	0x02E0, r25
  menu.newMenuMode = MENU_SCROLL_MODE;
     9de:	82 e0       	ldi	r24, 0x02	; 2
     9e0:	80 93 e1 02 	sts	0x02E1, r24
  menu.fastMovingMode = OFF;
     9e4:	10 92 e2 02 	sts	0x02E2, r1
  menu.currentProgramStep = 0;
     9e8:	10 92 e3 02 	sts	0x02E3, r1
  menu.currentMenuMode = 42;
     9ec:	90 93 e4 02 	sts	0x02E4, r25
  menu.selectedMotor = NO_MOTOR|(1<<DUMMY_MOTOR);  /* DUMMY_MOTOR stays always selected */
     9f0:	80 e1       	ldi	r24, 0x10	; 16
     9f2:	80 93 e5 02 	sts	0x02E5, r24
  /* strings are initialized in main */

  buttonState.inputRegister = 0;
     9f6:	10 92 dc 02 	sts	0x02DC, r1
  buttonState.inDebouncingMode = 0;
     9fa:	10 92 dd 02 	sts	0x02DD, r1
  buttonState.readyToProcess = 0;
     9fe:	10 92 de 02 	sts	0x02DE, r1

  rotEnc.direction = NO_MOVE;
     a02:	10 92 ce 03 	sts	0x03CE, r1
  rotEnc.steps = 0;
     a06:	10 92 cf 03 	sts	0x03CF, r1
  rotEnc.readyToProcess = 0;
     a0a:	10 92 d0 03 	sts	0x03D0, r1
  rotEnc.buttonPressed = 0;
     a0e:	10 92 d1 03 	sts	0x03D1, r1
  rotEnc.buttonDebounce = 0;
     a12:	10 92 d2 03 	sts	0x03D2, r1

  IIC.operationInProgress = 0;
     a16:	10 92 ef 03 	sts	0x03EF, r1

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a1a:	10 92 d7 03 	sts	0x03D7, r1
    forbiddenZone[i].start  = 0;
     a1e:	10 92 d4 03 	sts	0x03D4, r1
     a22:	10 92 d3 03 	sts	0x03D3, r1
    forbiddenZone[i].stop   = 0;
     a26:	10 92 d6 03 	sts	0x03D6, r1
     a2a:	10 92 d5 03 	sts	0x03D5, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a2e:	10 92 dc 03 	sts	0x03DC, r1
    forbiddenZone[i].start  = 0;
     a32:	10 92 d9 03 	sts	0x03D9, r1
     a36:	10 92 d8 03 	sts	0x03D8, r1
    forbiddenZone[i].stop   = 0;
     a3a:	10 92 db 03 	sts	0x03DB, r1
     a3e:	10 92 da 03 	sts	0x03DA, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a42:	10 92 e1 03 	sts	0x03E1, r1
    forbiddenZone[i].start  = 0;
     a46:	10 92 de 03 	sts	0x03DE, r1
     a4a:	10 92 dd 03 	sts	0x03DD, r1
    forbiddenZone[i].stop   = 0;
     a4e:	10 92 e0 03 	sts	0x03E0, r1
     a52:	10 92 df 03 	sts	0x03DF, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a56:	10 92 e6 03 	sts	0x03E6, r1
    forbiddenZone[i].start  = 0;
     a5a:	10 92 e3 03 	sts	0x03E3, r1
     a5e:	10 92 e2 03 	sts	0x03E2, r1
    forbiddenZone[i].stop   = 0;
     a62:	10 92 e5 03 	sts	0x03E5, r1
     a66:	10 92 e4 03 	sts	0x03E4, r1
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    programList[i].isActive = 0;
    programList[i].absRel = PROG_RELATIVE_MOVEMENT;
     a6e:	41 e0       	ldi	r20, 0x01	; 1
    forbiddenZone[i].stop   = 0;
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    programList[i].isActive = 0;
     a70:	c9 01       	movw	r24, r18
     a72:	f9 01       	movw	r30, r18
     a74:	ee 0f       	add	r30, r30
     a76:	ff 1f       	adc	r31, r31
     a78:	ee 0f       	add	r30, r30
     a7a:	ff 1f       	adc	r31, r31
     a7c:	ee 0f       	add	r30, r30
     a7e:	ff 1f       	adc	r31, r31
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	e8 0f       	add	r30, r24
     a86:	f9 1f       	adc	r31, r25
     a88:	ed 50       	subi	r30, 0x0D	; 13
     a8a:	fd 4f       	sbci	r31, 0xFD	; 253
     a8c:	10 82       	st	Z, r1
    programList[i].absRel = PROG_RELATIVE_MOVEMENT;
     a8e:	c9 01       	movw	r24, r18
     a90:	f9 01       	movw	r30, r18
     a92:	ee 0f       	add	r30, r30
     a94:	ff 1f       	adc	r31, r31
     a96:	ee 0f       	add	r30, r30
     a98:	ff 1f       	adc	r31, r31
     a9a:	ee 0f       	add	r30, r30
     a9c:	ff 1f       	adc	r31, r31
     a9e:	88 0f       	add	r24, r24
     aa0:	99 1f       	adc	r25, r25
     aa2:	e8 0f       	add	r30, r24
     aa4:	f9 1f       	adc	r31, r25
     aa6:	ed 50       	subi	r30, 0x0D	; 13
     aa8:	fd 4f       	sbci	r31, 0xFD	; 253
     aaa:	41 87       	std	Z+9, r20	; 0x09
    for(j = 0; j <= MAX_MOTOR; j++){
      programList[i].position[j] = 0;
     aac:	c9 01       	movw	r24, r18
     aae:	f9 01       	movw	r30, r18
     ab0:	ee 0f       	add	r30, r30
     ab2:	ff 1f       	adc	r31, r31
     ab4:	ee 0f       	add	r30, r30
     ab6:	ff 1f       	adc	r31, r31
     ab8:	ee 0f       	add	r30, r30
     aba:	ff 1f       	adc	r31, r31
     abc:	88 0f       	add	r24, r24
     abe:	99 1f       	adc	r25, r25
     ac0:	e8 0f       	add	r30, r24
     ac2:	f9 1f       	adc	r31, r25
     ac4:	ed 50       	subi	r30, 0x0D	; 13
     ac6:	fd 4f       	sbci	r31, 0xFD	; 253
     ac8:	12 82       	std	Z+2, r1	; 0x02
     aca:	11 82       	std	Z+1, r1	; 0x01
     acc:	c9 01       	movw	r24, r18
     ace:	f9 01       	movw	r30, r18
     ad0:	ee 0f       	add	r30, r30
     ad2:	ff 1f       	adc	r31, r31
     ad4:	ee 0f       	add	r30, r30
     ad6:	ff 1f       	adc	r31, r31
     ad8:	ee 0f       	add	r30, r30
     ada:	ff 1f       	adc	r31, r31
     adc:	88 0f       	add	r24, r24
     ade:	99 1f       	adc	r25, r25
     ae0:	e8 0f       	add	r30, r24
     ae2:	f9 1f       	adc	r31, r25
     ae4:	ed 50       	subi	r30, 0x0D	; 13
     ae6:	fd 4f       	sbci	r31, 0xFD	; 253
     ae8:	14 82       	std	Z+4, r1	; 0x04
     aea:	13 82       	std	Z+3, r1	; 0x03
     aec:	c9 01       	movw	r24, r18
     aee:	f9 01       	movw	r30, r18
     af0:	ee 0f       	add	r30, r30
     af2:	ff 1f       	adc	r31, r31
     af4:	ee 0f       	add	r30, r30
     af6:	ff 1f       	adc	r31, r31
     af8:	ee 0f       	add	r30, r30
     afa:	ff 1f       	adc	r31, r31
     afc:	88 0f       	add	r24, r24
     afe:	99 1f       	adc	r25, r25
     b00:	e8 0f       	add	r30, r24
     b02:	f9 1f       	adc	r31, r25
     b04:	ed 50       	subi	r30, 0x0D	; 13
     b06:	fd 4f       	sbci	r31, 0xFD	; 253
     b08:	16 82       	std	Z+6, r1	; 0x06
     b0a:	15 82       	std	Z+5, r1	; 0x05
     b0c:	c9 01       	movw	r24, r18
     b0e:	f9 01       	movw	r30, r18
     b10:	ee 0f       	add	r30, r30
     b12:	ff 1f       	adc	r31, r31
     b14:	ee 0f       	add	r30, r30
     b16:	ff 1f       	adc	r31, r31
     b18:	ee 0f       	add	r30, r30
     b1a:	ff 1f       	adc	r31, r31
     b1c:	88 0f       	add	r24, r24
     b1e:	99 1f       	adc	r25, r25
     b20:	e8 0f       	add	r30, r24
     b22:	f9 1f       	adc	r31, r25
     b24:	ed 50       	subi	r30, 0x0D	; 13
     b26:	fd 4f       	sbci	r31, 0xFD	; 253
     b28:	10 86       	std	Z+8, r1	; 0x08
     b2a:	17 82       	std	Z+7, r1	; 0x07
     b2c:	2f 5f       	subi	r18, 0xFF	; 255
     b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    forbiddenZone[i].start  = 0;
    forbiddenZone[i].stop   = 0;
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
     b30:	20 31       	cpi	r18, 0x10	; 16
     b32:	31 05       	cpc	r19, r1
     b34:	09 f0       	breq	.+2      	; 0xb38 <initDataStructs+0x4b8>
     b36:	9c cf       	rjmp	.-200    	; 0xa70 <initDataStructs+0x3f0>
    for(j = 0; j <= MAX_MOTOR; j++){
      programList[i].position[j] = 0;
    }
  }
  /* define home position on program step 0 */
  programList[0].isActive = 1;
     b38:	81 e0       	ldi	r24, 0x01	; 1
     b3a:	80 93 f3 02 	sts	0x02F3, r24

  return;
}
     b3e:	1f 91       	pop	r17
     b40:	0f 91       	pop	r16
     b42:	ff 90       	pop	r15
     b44:	ef 90       	pop	r14
     b46:	df 90       	pop	r13
     b48:	cf 90       	pop	r12
     b4a:	bf 90       	pop	r11
     b4c:	af 90       	pop	r10
     b4e:	9f 90       	pop	r9
     b50:	8f 90       	pop	r8
     b52:	7f 90       	pop	r7
     b54:	6f 90       	pop	r6
     b56:	5f 90       	pop	r5
     b58:	4f 90       	pop	r4
     b5a:	3f 90       	pop	r3
     b5c:	2f 90       	pop	r2
     b5e:	08 95       	ret

00000b60 <initUSART>:
   - 8 bit character size
   - no flow control
  */

  /* set baud rate registers */
  UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
     b60:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = (uint8_t)(UBRR_VALUE & 0xFF);
     b64:	85 e1       	ldi	r24, 0x15	; 21
     b66:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B |= (1<<TXEN0) | (1<<RXEN0)        /* enable RX and TX */
     b6a:	e1 ec       	ldi	r30, 0xC1	; 193
     b6c:	f0 e0       	ldi	r31, 0x00	; 0
     b6e:	80 81       	ld	r24, Z
     b70:	88 69       	ori	r24, 0x98	; 152
     b72:	80 83       	st	Z, r24
           |(1<<RXCIE0);                   /* enable RX interrupt */

  return;
}
     b74:	08 95       	ret

00000b76 <sendChar>:
====================================================================== */

/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){
     b76:	98 2f       	mov	r25, r24

  while(!(UCSR0A & (1<<UDRE0))){
     b78:	80 91 c0 00 	lds	r24, 0x00C0
     b7c:	85 ff       	sbrs	r24, 5
     b7e:	fc cf       	rjmp	.-8      	; 0xb78 <sendChar+0x2>
    ;
  }

  UDR0 = c;
     b80:	90 93 c6 00 	sts	0x00C6, r25

  return;
}
     b84:	08 95       	ret

00000b86 <initMotorDelayTimer>:

  /*
   * the 8-bit Timer/Counter2 is used for that
   */

  TCCR2A |= (1<<WGM21);   /* enable CTC */
     b86:	e0 eb       	ldi	r30, 0xB0	; 176
     b88:	f0 e0       	ldi	r31, 0x00	; 0
     b8a:	80 81       	ld	r24, Z
     b8c:	82 60       	ori	r24, 0x02	; 2
     b8e:	80 83       	st	Z, r24
  OCR2A   = 77;
     b90:	8d e4       	ldi	r24, 0x4D	; 77
     b92:	80 93 b3 00 	sts	0x00B3, r24
  TIMSK2 |= (1<<OCIE2A);  /* enable interrupt */
     b96:	e0 e7       	ldi	r30, 0x70	; 112
     b98:	f0 e0       	ldi	r31, 0x00	; 0
     b9a:	80 81       	ld	r24, Z
     b9c:	82 60       	ori	r24, 0x02	; 2
     b9e:	80 83       	st	Z, r24
  TCNT2   = 0;
     ba0:	10 92 b2 00 	sts	0x00B2, r1

  /* start the timer/counter */
  TCCR2B |= (1<<CS22)|(1<<CS20);  /* prescaler = 1024 --> 51.2 us per clock */
     ba4:	e1 eb       	ldi	r30, 0xB1	; 177
     ba6:	f0 e0       	ldi	r31, 0x00	; 0
     ba8:	80 81       	ld	r24, Z
     baa:	85 60       	ori	r24, 0x05	; 5
     bac:	80 83       	st	Z, r24

  return;
}
     bae:	08 95       	ret

00000bb0 <moveMotorRelative>:
/* ---------------------------------------------------------------------
    moveMotorBySteps: move motor <steps> steps forward or backward
    This is a relative movement to the actual position.
    NOTE: this function is only used by motorZeroRun()
 --------------------------------------------------------------------- */
void moveMotorRelative(uint8_t mot, int16_t steps){
     bb0:	ff 92       	push	r15
     bb2:	0f 93       	push	r16
     bb4:	1f 93       	push	r17

  int16_t  i;
  uint16_t j;

  /* set direction */
  if(steps == 0){
     bb6:	61 15       	cp	r22, r1
     bb8:	71 05       	cpc	r23, r1
     bba:	09 f4       	brne	.+2      	; 0xbbe <moveMotorRelative+0xe>
     bbc:	58 c0       	rjmp	.+176    	; 0xc6e <moveMotorRelative+0xbe>
    /* no move */
    return;
  }
  else if(steps < 0){
     bbe:	77 fd       	sbrc	r23, 7
     bc0:	5a c0       	rjmp	.+180    	; 0xc76 <moveMotorRelative+0xc6>
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
  }
  else{
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
     bc2:	42 b1       	in	r20, 0x02	; 2
     bc4:	e8 2f       	mov	r30, r24
     bc6:	f0 e0       	ldi	r31, 0x00	; 0
     bc8:	9f 01       	movw	r18, r30
     bca:	22 0f       	add	r18, r18
     bcc:	33 1f       	adc	r19, r19
     bce:	2f 5f       	subi	r18, 0xFF	; 255
     bd0:	3f 4f       	sbci	r19, 0xFF	; 255
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	02 c0       	rjmp	.+4      	; 0xbdc <moveMotorRelative+0x2c>
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	2a 95       	dec	r18
     bde:	e2 f7       	brpl	.-8      	; 0xbd8 <moveMotorRelative+0x28>
     be0:	80 95       	com	r24
     be2:	84 23       	and	r24, r20
     be4:	82 b9       	out	0x02, r24	; 2
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     be6:	77 fd       	sbrc	r23, 7
     be8:	59 c0       	rjmp	.+178    	; 0xc9c <moveMotorRelative+0xec>
     bea:	16 16       	cp	r1, r22
     bec:	17 06       	cpc	r1, r23
     bee:	0c f0       	brlt	.+2      	; 0xbf2 <moveMotorRelative+0x42>
     bf0:	3e c0       	rjmp	.+124    	; 0xc6e <moveMotorRelative+0xbe>
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
  }
  else{
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
     bf2:	ee 0f       	add	r30, r30
     bf4:	ff 1f       	adc	r31, r31
     bf6:	81 e0       	ldi	r24, 0x01	; 1
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	0e 2e       	mov	r0, r30
     bfc:	02 c0       	rjmp	.+4      	; 0xc02 <moveMotorRelative+0x52>
     bfe:	88 0f       	add	r24, r24
     c00:	99 1f       	adc	r25, r25
     c02:	0a 94       	dec	r0
     c04:	e2 f7       	brpl	.-8      	; 0xbfe <moveMotorRelative+0x4e>
     c06:	18 2f       	mov	r17, r24
     c08:	08 2f       	mov	r16, r24
     c0a:	00 95       	com	r16
     c0c:	a0 e0       	ldi	r26, 0x00	; 0
     c0e:	b0 e0       	ldi	r27, 0x00	; 0
     c10:	cf 01       	movw	r24, r30
     c12:	88 0f       	add	r24, r24
     c14:	99 1f       	adc	r25, r25
     c16:	88 0f       	add	r24, r24
     c18:	99 1f       	adc	r25, r25
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     c1a:	5d e0       	ldi	r21, 0x0D	; 13
     c1c:	f5 2e       	mov	r15, r21
  for (i = 0; i < abs(steps); i++){
    PORTA |= (1 << (2*mot));
    _delay_us(2); /* as specified in datasheet */
    PORTA &= ~(1 << (2*mot));

    for(j = 0; j < motor[mot].waitBetweenSteps; j++){
     c1e:	fc 01       	movw	r30, r24
     c20:	ee 0f       	add	r30, r30
     c22:	ff 1f       	adc	r31, r31
     c24:	ee 0f       	add	r30, r30
     c26:	ff 1f       	adc	r31, r31
     c28:	e8 0f       	add	r30, r24
     c2a:	f9 1f       	adc	r31, r25
     c2c:	e2 5f       	subi	r30, 0xF2	; 242
     c2e:	fb 4f       	sbci	r31, 0xFB	; 251
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c30:	48 e8       	ldi	r20, 0x88	; 136
     c32:	53 e1       	ldi	r21, 0x13	; 19
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
    PORTA |= (1 << (2*mot));
     c34:	82 b1       	in	r24, 0x02	; 2
     c36:	81 2b       	or	r24, r17
     c38:	82 b9       	out	0x02, r24	; 2
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     c3a:	8f 2d       	mov	r24, r15
     c3c:	8a 95       	dec	r24
     c3e:	f1 f7       	brne	.-4      	; 0xc3c <moveMotorRelative+0x8c>
    _delay_us(2); /* as specified in datasheet */
    PORTA &= ~(1 << (2*mot));
     c40:	82 b1       	in	r24, 0x02	; 2
     c42:	80 23       	and	r24, r16
     c44:	82 b9       	out	0x02, r24	; 2

    for(j = 0; j < motor[mot].waitBetweenSteps; j++){
     c46:	80 81       	ld	r24, Z
     c48:	91 81       	ldd	r25, Z+1	; 0x01
     c4a:	89 2b       	or	r24, r25
     c4c:	61 f0       	breq	.+24     	; 0xc66 <moveMotorRelative+0xb6>
     c4e:	20 e0       	ldi	r18, 0x00	; 0
     c50:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c52:	ca 01       	movw	r24, r20
     c54:	01 97       	sbiw	r24, 0x01	; 1
     c56:	f1 f7       	brne	.-4      	; 0xc54 <moveMotorRelative+0xa4>
     c58:	2f 5f       	subi	r18, 0xFF	; 255
     c5a:	3f 4f       	sbci	r19, 0xFF	; 255
     c5c:	80 81       	ld	r24, Z
     c5e:	91 81       	ldd	r25, Z+1	; 0x01
     c60:	28 17       	cp	r18, r24
     c62:	39 07       	cpc	r19, r25
     c64:	b0 f3       	brcs	.-20     	; 0xc52 <moveMotorRelative+0xa2>
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     c66:	11 96       	adiw	r26, 0x01	; 1
     c68:	a6 17       	cp	r26, r22
     c6a:	b7 07       	cpc	r27, r23
     c6c:	1c f3       	brlt	.-58     	; 0xc34 <moveMotorRelative+0x84>
      _delay_ms(1);
    }
  }

  return;
}
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	08 95       	ret
    /* no move */
    return;
  }
  else if(steps < 0){
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
     c76:	42 b1       	in	r20, 0x02	; 2
     c78:	e8 2f       	mov	r30, r24
     c7a:	f0 e0       	ldi	r31, 0x00	; 0
     c7c:	9f 01       	movw	r18, r30
     c7e:	22 0f       	add	r18, r18
     c80:	33 1f       	adc	r19, r19
     c82:	2f 5f       	subi	r18, 0xFF	; 255
     c84:	3f 4f       	sbci	r19, 0xFF	; 255
     c86:	81 e0       	ldi	r24, 0x01	; 1
     c88:	90 e0       	ldi	r25, 0x00	; 0
     c8a:	02 c0       	rjmp	.+4      	; 0xc90 <moveMotorRelative+0xe0>
     c8c:	88 0f       	add	r24, r24
     c8e:	99 1f       	adc	r25, r25
     c90:	2a 95       	dec	r18
     c92:	e2 f7       	brpl	.-8      	; 0xc8c <moveMotorRelative+0xdc>
     c94:	48 2b       	or	r20, r24
     c96:	42 b9       	out	0x02, r20	; 2
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     c98:	77 ff       	sbrs	r23, 7
     c9a:	a7 cf       	rjmp	.-178    	; 0xbea <moveMotorRelative+0x3a>
     c9c:	70 95       	com	r23
     c9e:	61 95       	neg	r22
     ca0:	7f 4f       	sbci	r23, 0xFF	; 255
     ca2:	a3 cf       	rjmp	.-186    	; 0xbea <moveMotorRelative+0x3a>

00000ca4 <defineOpticalZeroPosition>:
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
     ca4:	a0 ef       	ldi	r26, 0xF0	; 240
     ca6:	b3 e0       	ldi	r27, 0x03	; 3
     ca8:	e8 2f       	mov	r30, r24
     caa:	f0 e0       	ldi	r31, 0x00	; 0
     cac:	ee 0f       	add	r30, r30
     cae:	ff 1f       	adc	r31, r31
     cb0:	ee 0f       	add	r30, r30
     cb2:	ff 1f       	adc	r31, r31
     cb4:	ee 0f       	add	r30, r30
     cb6:	ff 1f       	adc	r31, r31
     cb8:	9f 01       	movw	r18, r30
     cba:	22 0f       	add	r18, r18
     cbc:	33 1f       	adc	r19, r19
     cbe:	22 0f       	add	r18, r18
     cc0:	33 1f       	adc	r19, r19
     cc2:	e2 0f       	add	r30, r18
     cc4:	f3 1f       	adc	r31, r19
     cc6:	ea 0f       	add	r30, r26
     cc8:	fb 1f       	adc	r31, r27
     cca:	40 81       	ld	r20, Z
     ccc:	51 81       	ldd	r21, Z+1	; 0x01
     cce:	46 0f       	add	r20, r22
     cd0:	57 1f       	adc	r21, r23
     cd2:	e8 2f       	mov	r30, r24
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	ee 0f       	add	r30, r30
     cd8:	ff 1f       	adc	r31, r31
     cda:	ee 0f       	add	r30, r30
     cdc:	ff 1f       	adc	r31, r31
     cde:	9f 01       	movw	r18, r30
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	22 0f       	add	r18, r18
     ce6:	33 1f       	adc	r19, r19
     ce8:	e2 0f       	add	r30, r18
     cea:	f3 1f       	adc	r31, r19
     cec:	31 96       	adiw	r30, 0x01	; 1
     cee:	ee 0f       	add	r30, r30
     cf0:	ff 1f       	adc	r31, r31
     cf2:	ea 0f       	add	r30, r26
     cf4:	fb 1f       	adc	r31, r27
     cf6:	51 83       	std	Z+1, r21	; 0x01
     cf8:	40 83       	st	Z, r20
  motor[i].opticalZeroPosition = motor[i].desiredPosition;
     cfa:	e8 2f       	mov	r30, r24
     cfc:	f0 e0       	ldi	r31, 0x00	; 0
     cfe:	ee 0f       	add	r30, r30
     d00:	ff 1f       	adc	r31, r31
     d02:	ee 0f       	add	r30, r30
     d04:	ff 1f       	adc	r31, r31
     d06:	9f 01       	movw	r18, r30
     d08:	22 0f       	add	r18, r18
     d0a:	33 1f       	adc	r19, r19
     d0c:	22 0f       	add	r18, r18
     d0e:	33 1f       	adc	r19, r19
     d10:	e2 0f       	add	r30, r18
     d12:	f3 1f       	adc	r31, r19
     d14:	31 96       	adiw	r30, 0x01	; 1
     d16:	ee 0f       	add	r30, r30
     d18:	ff 1f       	adc	r31, r31
     d1a:	ea 0f       	add	r30, r26
     d1c:	fb 1f       	adc	r31, r27
     d1e:	40 81       	ld	r20, Z
     d20:	51 81       	ldd	r21, Z+1	; 0x01
     d22:	28 2f       	mov	r18, r24
     d24:	30 e0       	ldi	r19, 0x00	; 0
     d26:	c9 01       	movw	r24, r18
     d28:	88 0f       	add	r24, r24
     d2a:	99 1f       	adc	r25, r25
     d2c:	88 0f       	add	r24, r24
     d2e:	99 1f       	adc	r25, r25
     d30:	88 0f       	add	r24, r24
     d32:	99 1f       	adc	r25, r25
     d34:	22 0f       	add	r18, r18
     d36:	33 1f       	adc	r19, r19
     d38:	82 0f       	add	r24, r18
     d3a:	93 1f       	adc	r25, r19
     d3c:	01 96       	adiw	r24, 0x01	; 1
     d3e:	88 0f       	add	r24, r24
     d40:	99 1f       	adc	r25, r25
     d42:	88 0f       	add	r24, r24
     d44:	99 1f       	adc	r25, r25
     d46:	a8 0f       	add	r26, r24
     d48:	b9 1f       	adc	r27, r25
     d4a:	11 96       	adiw	r26, 0x01	; 1
     d4c:	5c 93       	st	X, r21
     d4e:	4e 93       	st	-X, r20

  return;
}
     d50:	08 95       	ret

00000d52 <getADCvalue>:

  uint8_t i = 0;
  uint8_t lowByte, highByte;

  // select channel
  ADMUX = (ADMUX & ~(0x1F)) | (sensPin & 0x1F);
     d52:	90 91 7c 00 	lds	r25, 0x007C
     d56:	8f 71       	andi	r24, 0x1F	; 31
     d58:	90 7e       	andi	r25, 0xE0	; 224
     d5a:	89 2b       	or	r24, r25
     d5c:	80 93 7c 00 	sts	0x007C, r24

  // reset all values and counters before starting new conversion
  adc.ADCvalue = 0;
     d60:	10 92 cc 03 	sts	0x03CC, r1
     d64:	10 92 cb 03 	sts	0x03CB, r1

  // start the conversion
  for(i = 0; i < adc.numberOfMeasurements; i++){
     d68:	80 91 cd 03 	lds	r24, 0x03CD
     d6c:	88 23       	and	r24, r24
     d6e:	11 f1       	breq	.+68     	; 0xdb4 <getADCvalue+0x62>
     d70:	60 e0       	ldi	r22, 0x00	; 0
    ADCSRA |= (1<<ADSC);
     d72:	80 91 7a 00 	lds	r24, 0x007A
     d76:	80 64       	ori	r24, 0x40	; 64
     d78:	80 93 7a 00 	sts	0x007A, r24
    while(ADCSRA & (1<<ADSC)){
     d7c:	80 91 7a 00 	lds	r24, 0x007A
     d80:	86 fd       	sbrc	r24, 6
     d82:	fc cf       	rjmp	.-8      	; 0xd7c <getADCvalue+0x2a>
      ;
    }
    lowByte = ADCL;
     d84:	80 91 78 00 	lds	r24, 0x0078
    highByte = ADCH;
     d88:	20 91 79 00 	lds	r18, 0x0079
    adc.ADCvalue += (highByte<<8) | lowByte;
     d8c:	40 91 cb 03 	lds	r20, 0x03CB
     d90:	50 91 cc 03 	lds	r21, 0x03CC
     d94:	32 2f       	mov	r19, r18
     d96:	20 e0       	ldi	r18, 0x00	; 0
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	82 2b       	or	r24, r18
     d9c:	93 2b       	or	r25, r19
     d9e:	84 0f       	add	r24, r20
     da0:	95 1f       	adc	r25, r21
     da2:	90 93 cc 03 	sts	0x03CC, r25
     da6:	80 93 cb 03 	sts	0x03CB, r24

  // reset all values and counters before starting new conversion
  adc.ADCvalue = 0;

  // start the conversion
  for(i = 0; i < adc.numberOfMeasurements; i++){
     daa:	6f 5f       	subi	r22, 0xFF	; 255
     dac:	80 91 cd 03 	lds	r24, 0x03CD
     db0:	68 17       	cp	r22, r24
     db2:	f8 f2       	brcs	.-66     	; 0xd72 <getADCvalue+0x20>
    lowByte = ADCL;
    highByte = ADCH;
    adc.ADCvalue += (highByte<<8) | lowByte;
  }

  return (adc.ADCvalue / adc.numberOfMeasurements);
     db4:	80 91 cb 03 	lds	r24, 0x03CB
     db8:	90 91 cc 03 	lds	r25, 0x03CC
     dbc:	60 91 cd 03 	lds	r22, 0x03CD
     dc0:	70 e0       	ldi	r23, 0x00	; 0
     dc2:	0e 94 c7 41 	call	0x838e	; 0x838e <__udivmodhi4>
     dc6:	cb 01       	movw	r24, r22
}
     dc8:	08 95       	ret

00000dca <changeButtonLED>:
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     dca:	82 30       	cpi	r24, 0x02	; 2
     dcc:	11 f1       	breq	.+68     	; 0xe12 <changeButtonLED+0x48>
     dce:	83 30       	cpi	r24, 0x03	; 3
     dd0:	78 f0       	brcs	.+30     	; 0xdf0 <changeButtonLED+0x26>
     dd2:	83 30       	cpi	r24, 0x03	; 3
     dd4:	a9 f1       	breq	.+106    	; 0xe40 <changeButtonLED+0x76>
     dd6:	84 30       	cpi	r24, 0x04	; 4
     dd8:	d9 f0       	breq	.+54     	; 0xe10 <changeButtonLED+0x46>
     dda:	a0 e0       	ldi	r26, 0x00	; 0
     ddc:	b0 e0       	ldi	r27, 0x00	; 0
     dde:	e3 e0       	ldi	r30, 0x03	; 3
     de0:	f0 e0       	ldi	r31, 0x00	; 0
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     de2:	ab 56       	subi	r26, 0x6B	; 107
     de4:	bc 4f       	sbci	r27, 0xFC	; 252
     de6:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     de8:	eb 56       	subi	r30, 0x6B	; 107
     dea:	fc 4f       	sbci	r31, 0xFC	; 252
     dec:	40 83       	st	Z, r20

  return;
}
     dee:	08 95       	ret
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     df0:	88 23       	and	r24, r24
     df2:	d1 f0       	breq	.+52     	; 0xe28 <changeButtonLED+0x5e>
     df4:	81 30       	cpi	r24, 0x01	; 1
     df6:	89 f7       	brne	.-30     	; 0xdda <changeButtonLED+0x10>
	case 0: chan = 6*2+color; break;
     df8:	6a 5f       	subi	r22, 0xFA	; 250
     dfa:	a6 2f       	mov	r26, r22
     dfc:	b0 e0       	ldi	r27, 0x00	; 0
     dfe:	fd 01       	movw	r30, r26
     e00:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e02:	ab 56       	subi	r26, 0x6B	; 107
     e04:	bc 4f       	sbci	r27, 0xFC	; 252
     e06:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e08:	eb 56       	subi	r30, 0x6B	; 107
     e0a:	fc 4f       	sbci	r31, 0xFC	; 252
     e0c:	40 83       	st	Z, r20

  return;
}
     e0e:	08 95       	ret
  
  switch(butt) {
	case 0: chan = 6*2+color; break;
	case 1: chan = 6*1+color; break;
	case 2: chan = 6*0+color; break;
	case 3: chan = 6*5+color; break;
     e10:	68 5e       	subi	r22, 0xE8	; 232
     e12:	a6 2f       	mov	r26, r22
     e14:	b0 e0       	ldi	r27, 0x00	; 0
     e16:	fd 01       	movw	r30, r26
     e18:	33 96       	adiw	r30, 0x03	; 3
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e1a:	ab 56       	subi	r26, 0x6B	; 107
     e1c:	bc 4f       	sbci	r27, 0xFC	; 252
     e1e:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e20:	eb 56       	subi	r30, 0x6B	; 107
     e22:	fc 4f       	sbci	r31, 0xFC	; 252
     e24:	40 83       	st	Z, r20

  return;
}
     e26:	08 95       	ret
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     e28:	64 5f       	subi	r22, 0xF4	; 244
     e2a:	a6 2f       	mov	r26, r22
     e2c:	b0 e0       	ldi	r27, 0x00	; 0
     e2e:	fd 01       	movw	r30, r26
     e30:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e32:	ab 56       	subi	r26, 0x6B	; 107
     e34:	bc 4f       	sbci	r27, 0xFC	; 252
     e36:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e38:	eb 56       	subi	r30, 0x6B	; 107
     e3a:	fc 4f       	sbci	r31, 0xFC	; 252
     e3c:	40 83       	st	Z, r20

  return;
}
     e3e:	08 95       	ret
  
  uint8_t chan = 0;
  
  switch(butt) {
	case 0: chan = 6*2+color; break;
	case 1: chan = 6*1+color; break;
     e40:	62 5e       	subi	r22, 0xE2	; 226
     e42:	a6 2f       	mov	r26, r22
     e44:	b0 e0       	ldi	r27, 0x00	; 0
     e46:	fd 01       	movw	r30, r26
     e48:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e4a:	ab 56       	subi	r26, 0x6B	; 107
     e4c:	bc 4f       	sbci	r27, 0xFC	; 252
     e4e:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e50:	eb 56       	subi	r30, 0x6B	; 107
     e52:	fc 4f       	sbci	r31, 0xFC	; 252
     e54:	40 83       	st	Z, r20

  return;
}
     e56:	08 95       	ret

00000e58 <updateLEDs>:

/* ---------------------------------------------------------------------
   update LEDs
 --------------------------------------------------------------------- */
void updateLEDs(void){
     e58:	6f e2       	ldi	r22, 0x2F	; 47
     e5a:	70 e0       	ldi	r23, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     e5c:	32 e4       	ldi	r19, 0x42	; 66
  //uint8_t  j = 0;
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
	data = buttLedData[i];
     e5e:	fb 01       	movw	r30, r22
     e60:	eb 56       	subi	r30, 0x6B	; 107
     e62:	fc 4f       	sbci	r31, 0xFC	; 252
     e64:	80 81       	ld	r24, Z
     e66:	48 2f       	mov	r20, r24
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	27 e0       	ldi	r18, 0x07	; 7
     e6c:	0f c0       	rjmp	.+30     	; 0xe8c <updateLEDs+0x34>
    {
        outbyte = (data>>i) & 0x01;
        // Set the data pin to given value, and clk pin to 0
        if(outbyte)
        {
            PORTC |= (outbyte << WS2803_SDI);
     e6e:	46 9a       	sbi	0x08, 6	; 8
        }
        else
        {
            PORTC &= ~(outbyte << WS2803_SDI);
        }
        PORTC &= ~(1 << WS2803_CKI);
     e70:	47 98       	cbi	0x08, 7	; 8
     e72:	83 2f       	mov	r24, r19
     e74:	8a 95       	dec	r24
     e76:	f1 f7       	brne	.-4      	; 0xe74 <updateLEDs+0x1c>
        _delay_us(10);

        // Keep the data pin, and set clk pin to 1 (strobe)
        PORTC |= 1 << WS2803_CKI;
     e78:	47 9a       	sbi	0x08, 7	; 8
     e7a:	83 2f       	mov	r24, r19
     e7c:	8a 95       	dec	r24
     e7e:	f1 f7       	brne	.-4      	; 0xe7c <updateLEDs+0x24>
        _delay_us(10);

        // Zero both clk and data pins
        PORTC &= ~((1 << WS2803_SDI) | (1 << WS2803_CKI));
     e80:	88 b1       	in	r24, 0x08	; 8
     e82:	8f 73       	andi	r24, 0x3F	; 63
     e84:	88 b9       	out	0x08, r24	; 8
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
	data = buttLedData[i];
	for(uint8_t i=7; i<255; i--)
     e86:	21 50       	subi	r18, 0x01	; 1
     e88:	2f 3f       	cpi	r18, 0xFF	; 255
     e8a:	61 f0       	breq	.+24     	; 0xea4 <updateLEDs+0x4c>
    {
        outbyte = (data>>i) & 0x01;
        // Set the data pin to given value, and clk pin to 0
        if(outbyte)
     e8c:	ca 01       	movw	r24, r20
     e8e:	02 2e       	mov	r0, r18
     e90:	02 c0       	rjmp	.+4      	; 0xe96 <updateLEDs+0x3e>
     e92:	95 95       	asr	r25
     e94:	87 95       	ror	r24
     e96:	0a 94       	dec	r0
     e98:	e2 f7       	brpl	.-8      	; 0xe92 <updateLEDs+0x3a>
     e9a:	80 fd       	sbrc	r24, 0
     e9c:	e8 cf       	rjmp	.-48     	; 0xe6e <updateLEDs+0x16>
        {
            PORTC |= (outbyte << WS2803_SDI);
        }
        else
        {
            PORTC &= ~(outbyte << WS2803_SDI);
     e9e:	88 b1       	in	r24, 0x08	; 8
     ea0:	88 b9       	out	0x08, r24	; 8
     ea2:	e6 cf       	rjmp	.-52     	; 0xe70 <updateLEDs+0x18>
  uint16_t i = 0;
  //uint8_t  j = 0;
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
     ea4:	61 50       	subi	r22, 0x01	; 1
     ea6:	70 40       	sbci	r23, 0x00	; 0
     ea8:	8f ef       	ldi	r24, 0xFF	; 255
     eaa:	6f 3f       	cpi	r22, 0xFF	; 255
     eac:	78 07       	cpc	r23, r24
     eae:	b9 f6       	brne	.-82     	; 0xe5e <updateLEDs+0x6>
        PORTC &= ~((1 << WS2803_SDI) | (1 << WS2803_CKI));
    }
  }

  return;
}
     eb0:	08 95       	ret

00000eb2 <changeMotorButtonLED>:

/* ---------------------------------------------------------------------
   change motor button LED color/intensity
 --------------------------------------------------------------------- */
void changeMotorButtonLED(uint8_t motor, uint8_t enable){
     eb2:	1f 93       	push	r17
     eb4:	18 2f       	mov	r17, r24
    
  if(enable){ //button lights white
     eb6:	66 23       	and	r22, r22
     eb8:	81 f4       	brne	.+32     	; 0xeda <changeMotorButtonLED+0x28>
    changeButtonLED(motor, BLUE, 0x0F);
    changeButtonLED(motor, GREEN, 0x0F);
    changeButtonLED(motor, RED, 0x08);
  }
  else{ //button lights green
    changeButtonLED(motor, BLUE, 0x00);
     eba:	60 e0       	ldi	r22, 0x00	; 0
     ebc:	40 e0       	ldi	r20, 0x00	; 0
     ebe:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, GREEN, 0x0F);
     ec2:	81 2f       	mov	r24, r17
     ec4:	61 e0       	ldi	r22, 0x01	; 1
     ec6:	4f e0       	ldi	r20, 0x0F	; 15
     ec8:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, RED, 0x00);
     ecc:	81 2f       	mov	r24, r17
     ece:	62 e0       	ldi	r22, 0x02	; 2
     ed0:	40 e0       	ldi	r20, 0x00	; 0
     ed2:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
  }
  //updateLEDs();

  return;
}
     ed6:	1f 91       	pop	r17
     ed8:	08 95       	ret
   change motor button LED color/intensity
 --------------------------------------------------------------------- */
void changeMotorButtonLED(uint8_t motor, uint8_t enable){
    
  if(enable){ //button lights white
    changeButtonLED(motor, BLUE, 0x0F);
     eda:	60 e0       	ldi	r22, 0x00	; 0
     edc:	4f e0       	ldi	r20, 0x0F	; 15
     ede:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, GREEN, 0x0F);
     ee2:	81 2f       	mov	r24, r17
     ee4:	61 e0       	ldi	r22, 0x01	; 1
     ee6:	4f e0       	ldi	r20, 0x0F	; 15
     ee8:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, RED, 0x08);
     eec:	81 2f       	mov	r24, r17
     eee:	62 e0       	ldi	r22, 0x02	; 2
     ef0:	48 e0       	ldi	r20, 0x08	; 8
     ef2:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, RED, 0x00);
  }
  //updateLEDs();

  return;
}
     ef6:	1f 91       	pop	r17
     ef8:	08 95       	ret

00000efa <updateMotorButtonLEDs>:

/* ---------------------------------------------------------------------
   update motor button LEDs
 --------------------------------------------------------------------- */
void updateMotorButtonLEDs(void){
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
     efe:	c0 e0       	ldi	r28, 0x00	; 0
     f00:	d0 e0       	ldi	r29, 0x00	; 0
  
  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    if(menu.selectedMotor & (1 << i)){
     f02:	80 91 e5 02 	lds	r24, 0x02E5
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	0c 2e       	mov	r0, r28
     f0a:	02 c0       	rjmp	.+4      	; 0xf10 <updateMotorButtonLEDs+0x16>
     f0c:	95 95       	asr	r25
     f0e:	87 95       	ror	r24
     f10:	0a 94       	dec	r0
     f12:	e2 f7       	brpl	.-8      	; 0xf0c <updateMotorButtonLEDs+0x12>
     f14:	80 ff       	sbrs	r24, 0
     f16:	0d c0       	rjmp	.+26     	; 0xf32 <updateMotorButtonLEDs+0x38>
      changeMotorButtonLED(i, 1);
     f18:	8c 2f       	mov	r24, r28
     f1a:	61 e0       	ldi	r22, 0x01	; 1
     f1c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <changeMotorButtonLED>
    }
    else{
      changeMotorButtonLED(i, 0);
     f20:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void updateMotorButtonLEDs(void){
  
  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
     f22:	c4 30       	cpi	r28, 0x04	; 4
     f24:	d1 05       	cpc	r29, r1
     f26:	69 f7       	brne	.-38     	; 0xf02 <updateMotorButtonLEDs+0x8>
    }
    else{
      changeMotorButtonLED(i, 0);
    }
  }
  updateLEDs();
     f28:	0e 94 2c 07 	call	0xe58	; 0xe58 <updateLEDs>
  
  return;
}
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret
  for(i = 0; i <= MAX_MOTOR; i++){
    if(menu.selectedMotor & (1 << i)){
      changeMotorButtonLED(i, 1);
    }
    else{
      changeMotorButtonLED(i, 0);
     f32:	8c 2f       	mov	r24, r28
     f34:	60 e0       	ldi	r22, 0x00	; 0
     f36:	0e 94 59 07 	call	0xeb2	; 0xeb2 <changeMotorButtonLED>
     f3a:	f2 cf       	rjmp	.-28     	; 0xf20 <updateMotorButtonLEDs+0x26>

00000f3c <stepsToDegree>:
}

/* ---------------------------------------------------------------------
   calculate degree from steps
 --------------------------------------------------------------------- */
double stepsToDegree(uint8_t mot, int16_t steps){
     f3c:	2f 92       	push	r2
     f3e:	3f 92       	push	r3
     f40:	4f 92       	push	r4
     f42:	5f 92       	push	r5
     f44:	6f 92       	push	r6
     f46:	7f 92       	push	r7
     f48:	8f 92       	push	r8
     f4a:	9f 92       	push	r9
     f4c:	af 92       	push	r10
     f4e:	bf 92       	push	r11
     f50:	cf 92       	push	r12
     f52:	df 92       	push	r13
     f54:	ef 92       	push	r14
     f56:	ff 92       	push	r15
     f58:	0f 93       	push	r16
     f5a:	1f 93       	push	r17
     f5c:	48 2f       	mov	r20, r24

  double radian = 0.0f;

  radian = (steps) * ( (360.0f)/(motor[mot].gearRatio
     f5e:	a0 ef       	ldi	r26, 0xF0	; 240
     f60:	b3 e0       	ldi	r27, 0x03	; 3
     f62:	e8 2f       	mov	r30, r24
     f64:	f0 e0       	ldi	r31, 0x00	; 0
     f66:	ee 0f       	add	r30, r30
     f68:	ff 1f       	adc	r31, r31
     f6a:	ee 0f       	add	r30, r30
     f6c:	ff 1f       	adc	r31, r31
     f6e:	ee 0f       	add	r30, r30
     f70:	ff 1f       	adc	r31, r31
     f72:	9f 01       	movw	r18, r30
     f74:	22 0f       	add	r18, r18
     f76:	33 1f       	adc	r19, r19
     f78:	22 0f       	add	r18, r18
     f7a:	33 1f       	adc	r19, r19
     f7c:	e2 0f       	add	r30, r18
     f7e:	f3 1f       	adc	r31, r19
     f80:	ea 0f       	add	r30, r26
     f82:	fb 1f       	adc	r31, r27
     f84:	25 84       	ldd	r2, Z+13	; 0x0d
     f86:	36 84       	ldd	r3, Z+14	; 0x0e
     f88:	47 84       	ldd	r4, Z+15	; 0x0f
     f8a:	50 88       	ldd	r5, Z+16	; 0x10
     f8c:	e4 2f       	mov	r30, r20
     f8e:	f0 e0       	ldi	r31, 0x00	; 0
     f90:	ee 0f       	add	r30, r30
     f92:	ff 1f       	adc	r31, r31
     f94:	ee 0f       	add	r30, r30
     f96:	ff 1f       	adc	r31, r31
     f98:	ee 0f       	add	r30, r30
     f9a:	ff 1f       	adc	r31, r31
     f9c:	9f 01       	movw	r18, r30
     f9e:	22 0f       	add	r18, r18
     fa0:	33 1f       	adc	r19, r19
     fa2:	22 0f       	add	r18, r18
     fa4:	33 1f       	adc	r19, r19
     fa6:	e2 0f       	add	r30, r18
     fa8:	f3 1f       	adc	r31, r19
     faa:	ea 0f       	add	r30, r26
     fac:	fb 1f       	adc	r31, r27
     fae:	65 88       	ldd	r6, Z+21	; 0x15
     fb0:	76 88       	ldd	r7, Z+22	; 0x16
     fb2:	87 88       	ldd	r8, Z+23	; 0x17
     fb4:	90 8c       	ldd	r9, Z+24	; 0x18
     fb6:	24 2f       	mov	r18, r20
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	22 0f       	add	r18, r18
     fbc:	33 1f       	adc	r19, r19
     fbe:	22 0f       	add	r18, r18
     fc0:	33 1f       	adc	r19, r19
     fc2:	22 0f       	add	r18, r18
     fc4:	33 1f       	adc	r19, r19
     fc6:	a9 01       	movw	r20, r18
     fc8:	44 0f       	add	r20, r20
     fca:	55 1f       	adc	r21, r21
     fcc:	44 0f       	add	r20, r20
     fce:	55 1f       	adc	r21, r21
     fd0:	24 0f       	add	r18, r20
     fd2:	35 1f       	adc	r19, r21
     fd4:	a2 0f       	add	r26, r18
     fd6:	b3 1f       	adc	r27, r19
     fd8:	51 96       	adiw	r26, 0x11	; 17
     fda:	ed 90       	ld	r14, X+
     fdc:	fd 90       	ld	r15, X+
     fde:	0d 91       	ld	r16, X+
     fe0:	1c 91       	ld	r17, X
     fe2:	54 97       	sbiw	r26, 0x14	; 20
     fe4:	88 27       	eor	r24, r24
     fe6:	77 fd       	sbrc	r23, 7
     fe8:	80 95       	com	r24
     fea:	98 2f       	mov	r25, r24
     fec:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
     ff0:	5b 01       	movw	r10, r22
     ff2:	6c 01       	movw	r12, r24
     ff4:	c2 01       	movw	r24, r4
     ff6:	b1 01       	movw	r22, r2
     ff8:	a4 01       	movw	r20, r8
     ffa:	93 01       	movw	r18, r6
     ffc:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    1000:	a8 01       	movw	r20, r16
    1002:	97 01       	movw	r18, r14
    1004:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    1008:	9b 01       	movw	r18, r22
    100a:	ac 01       	movw	r20, r24
    100c:	60 e0       	ldi	r22, 0x00	; 0
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	84 eb       	ldi	r24, 0xB4	; 180
    1012:	93 e4       	ldi	r25, 0x43	; 67
    1014:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>
    1018:	9b 01       	movw	r18, r22
    101a:	ac 01       	movw	r20, r24
    101c:	c6 01       	movw	r24, r12
    101e:	b5 01       	movw	r22, r10
    1020:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
                                *motor[mot].subSteps
                                *motor[mot].stepsPerFullRotation) );

  return radian;
}
    1024:	1f 91       	pop	r17
    1026:	0f 91       	pop	r16
    1028:	ff 90       	pop	r15
    102a:	ef 90       	pop	r14
    102c:	df 90       	pop	r13
    102e:	cf 90       	pop	r12
    1030:	bf 90       	pop	r11
    1032:	af 90       	pop	r10
    1034:	9f 90       	pop	r9
    1036:	8f 90       	pop	r8
    1038:	7f 90       	pop	r7
    103a:	6f 90       	pop	r6
    103c:	5f 90       	pop	r5
    103e:	4f 90       	pop	r4
    1040:	3f 90       	pop	r3
    1042:	2f 90       	pop	r2
    1044:	08 95       	ret

00001046 <stepsToRadian>:
}

/* ---------------------------------------------------------------------
   calculate radians from steps
 --------------------------------------------------------------------- */
double stepsToRadian(uint8_t mot, int16_t steps){
    1046:	2f 92       	push	r2
    1048:	3f 92       	push	r3
    104a:	4f 92       	push	r4
    104c:	5f 92       	push	r5
    104e:	6f 92       	push	r6
    1050:	7f 92       	push	r7
    1052:	8f 92       	push	r8
    1054:	9f 92       	push	r9
    1056:	af 92       	push	r10
    1058:	bf 92       	push	r11
    105a:	cf 92       	push	r12
    105c:	df 92       	push	r13
    105e:	ef 92       	push	r14
    1060:	ff 92       	push	r15
    1062:	0f 93       	push	r16
    1064:	1f 93       	push	r17
    1066:	48 2f       	mov	r20, r24

  double radian = 0.0f;

  radian = (steps) * ( (2.0f)/(motor[mot].gearRatio
    1068:	a0 ef       	ldi	r26, 0xF0	; 240
    106a:	b3 e0       	ldi	r27, 0x03	; 3
    106c:	e8 2f       	mov	r30, r24
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	ee 0f       	add	r30, r30
    1072:	ff 1f       	adc	r31, r31
    1074:	ee 0f       	add	r30, r30
    1076:	ff 1f       	adc	r31, r31
    1078:	ee 0f       	add	r30, r30
    107a:	ff 1f       	adc	r31, r31
    107c:	9f 01       	movw	r18, r30
    107e:	22 0f       	add	r18, r18
    1080:	33 1f       	adc	r19, r19
    1082:	22 0f       	add	r18, r18
    1084:	33 1f       	adc	r19, r19
    1086:	e2 0f       	add	r30, r18
    1088:	f3 1f       	adc	r31, r19
    108a:	ea 0f       	add	r30, r26
    108c:	fb 1f       	adc	r31, r27
    108e:	25 84       	ldd	r2, Z+13	; 0x0d
    1090:	36 84       	ldd	r3, Z+14	; 0x0e
    1092:	47 84       	ldd	r4, Z+15	; 0x0f
    1094:	50 88       	ldd	r5, Z+16	; 0x10
    1096:	e4 2f       	mov	r30, r20
    1098:	f0 e0       	ldi	r31, 0x00	; 0
    109a:	ee 0f       	add	r30, r30
    109c:	ff 1f       	adc	r31, r31
    109e:	ee 0f       	add	r30, r30
    10a0:	ff 1f       	adc	r31, r31
    10a2:	ee 0f       	add	r30, r30
    10a4:	ff 1f       	adc	r31, r31
    10a6:	9f 01       	movw	r18, r30
    10a8:	22 0f       	add	r18, r18
    10aa:	33 1f       	adc	r19, r19
    10ac:	22 0f       	add	r18, r18
    10ae:	33 1f       	adc	r19, r19
    10b0:	e2 0f       	add	r30, r18
    10b2:	f3 1f       	adc	r31, r19
    10b4:	ea 0f       	add	r30, r26
    10b6:	fb 1f       	adc	r31, r27
    10b8:	65 88       	ldd	r6, Z+21	; 0x15
    10ba:	76 88       	ldd	r7, Z+22	; 0x16
    10bc:	87 88       	ldd	r8, Z+23	; 0x17
    10be:	90 8c       	ldd	r9, Z+24	; 0x18
    10c0:	24 2f       	mov	r18, r20
    10c2:	30 e0       	ldi	r19, 0x00	; 0
    10c4:	22 0f       	add	r18, r18
    10c6:	33 1f       	adc	r19, r19
    10c8:	22 0f       	add	r18, r18
    10ca:	33 1f       	adc	r19, r19
    10cc:	22 0f       	add	r18, r18
    10ce:	33 1f       	adc	r19, r19
    10d0:	a9 01       	movw	r20, r18
    10d2:	44 0f       	add	r20, r20
    10d4:	55 1f       	adc	r21, r21
    10d6:	44 0f       	add	r20, r20
    10d8:	55 1f       	adc	r21, r21
    10da:	24 0f       	add	r18, r20
    10dc:	35 1f       	adc	r19, r21
    10de:	a2 0f       	add	r26, r18
    10e0:	b3 1f       	adc	r27, r19
    10e2:	51 96       	adiw	r26, 0x11	; 17
    10e4:	ed 90       	ld	r14, X+
    10e6:	fd 90       	ld	r15, X+
    10e8:	0d 91       	ld	r16, X+
    10ea:	1c 91       	ld	r17, X
    10ec:	54 97       	sbiw	r26, 0x14	; 20
    10ee:	88 27       	eor	r24, r24
    10f0:	77 fd       	sbrc	r23, 7
    10f2:	80 95       	com	r24
    10f4:	98 2f       	mov	r25, r24
    10f6:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    10fa:	5b 01       	movw	r10, r22
    10fc:	6c 01       	movw	r12, r24
    10fe:	c2 01       	movw	r24, r4
    1100:	b1 01       	movw	r22, r2
    1102:	a4 01       	movw	r20, r8
    1104:	93 01       	movw	r18, r6
    1106:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    110a:	a8 01       	movw	r20, r16
    110c:	97 01       	movw	r18, r14
    110e:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    1112:	9b 01       	movw	r18, r22
    1114:	ac 01       	movw	r20, r24
    1116:	60 e0       	ldi	r22, 0x00	; 0
    1118:	70 e0       	ldi	r23, 0x00	; 0
    111a:	80 e0       	ldi	r24, 0x00	; 0
    111c:	90 e4       	ldi	r25, 0x40	; 64
    111e:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>
    1122:	9b 01       	movw	r18, r22
    1124:	ac 01       	movw	r20, r24
    1126:	c6 01       	movw	r24, r12
    1128:	b5 01       	movw	r22, r10
    112a:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
                              *motor[mot].subSteps
                              *motor[mot].stepsPerFullRotation) );

  return radian;
}
    112e:	1f 91       	pop	r17
    1130:	0f 91       	pop	r16
    1132:	ff 90       	pop	r15
    1134:	ef 90       	pop	r14
    1136:	df 90       	pop	r13
    1138:	cf 90       	pop	r12
    113a:	bf 90       	pop	r11
    113c:	af 90       	pop	r10
    113e:	9f 90       	pop	r9
    1140:	8f 90       	pop	r8
    1142:	7f 90       	pop	r7
    1144:	6f 90       	pop	r6
    1146:	5f 90       	pop	r5
    1148:	4f 90       	pop	r4
    114a:	3f 90       	pop	r3
    114c:	2f 90       	pop	r2
    114e:	08 95       	ret

00001150 <setConstSpeed>:

/* ---------------------------------------------------------------------
   set constant angular velocity
 --------------------------------------------------------------------- */
void setConstSpeed(uint8_t i, uint8_t state){
    1150:	48 2f       	mov	r20, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1152:	f8 94       	cli

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    switch(state){
    1154:	61 30       	cpi	r22, 0x01	; 1
    1156:	09 f4       	brne	.+2      	; 0x115a <setConstSpeed+0xa>
    1158:	3d c0       	rjmp	.+122    	; 0x11d4 <setConstSpeed+0x84>
    115a:	61 30       	cpi	r22, 0x01	; 1
    115c:	08 f0       	brcs	.+2      	; 0x1160 <setConstSpeed+0x10>
    115e:	88 c0       	rjmp	.+272    	; 0x1270 <setConstSpeed+0x120>
      case MOTOR_MOVE_INFINITE_STOP:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    1160:	e8 2f       	mov	r30, r24
    1162:	f0 e0       	ldi	r31, 0x00	; 0
    1164:	ee 0f       	add	r30, r30
    1166:	ff 1f       	adc	r31, r31
    1168:	ee 0f       	add	r30, r30
    116a:	ff 1f       	adc	r31, r31
    116c:	ee 0f       	add	r30, r30
    116e:	ff 1f       	adc	r31, r31
    1170:	cf 01       	movw	r24, r30
    1172:	88 0f       	add	r24, r24
    1174:	99 1f       	adc	r25, r25
    1176:	88 0f       	add	r24, r24
    1178:	99 1f       	adc	r25, r25
    117a:	e8 0f       	add	r30, r24
    117c:	f9 1f       	adc	r31, r25
    117e:	e0 51       	subi	r30, 0x10	; 16
    1180:	fc 4f       	sbci	r31, 0xFC	; 252
    1182:	14 86       	std	Z+12, r1	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    1184:	e4 2f       	mov	r30, r20
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	ee 0f       	add	r30, r30
    118a:	ff 1f       	adc	r31, r31
    118c:	ee 0f       	add	r30, r30
    118e:	ff 1f       	adc	r31, r31
    1190:	ee 0f       	add	r30, r30
    1192:	ff 1f       	adc	r31, r31
    1194:	cf 01       	movw	r24, r30
    1196:	88 0f       	add	r24, r24
    1198:	99 1f       	adc	r25, r25
    119a:	88 0f       	add	r24, r24
    119c:	99 1f       	adc	r25, r25
    119e:	e8 0f       	add	r30, r24
    11a0:	f9 1f       	adc	r31, r25
    11a2:	e0 51       	subi	r30, 0x10	; 16
    11a4:	fc 4f       	sbci	r31, 0xFC	; 252
    11a6:	20 81       	ld	r18, Z
    11a8:	31 81       	ldd	r19, Z+1	; 0x01
        break;

      case MOTOR_MOVE_INFINITE_CCW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
        motor[i].desiredPosition  = motor[i].actualPosition;
        motor[i].desiredPosition += -1;
    11aa:	e4 2f       	mov	r30, r20
    11ac:	f0 e0       	ldi	r31, 0x00	; 0
    11ae:	ee 0f       	add	r30, r30
    11b0:	ff 1f       	adc	r31, r31
    11b2:	ee 0f       	add	r30, r30
    11b4:	ff 1f       	adc	r31, r31
    11b6:	cf 01       	movw	r24, r30
    11b8:	88 0f       	add	r24, r24
    11ba:	99 1f       	adc	r25, r25
    11bc:	88 0f       	add	r24, r24
    11be:	99 1f       	adc	r25, r25
    11c0:	e8 0f       	add	r30, r24
    11c2:	f9 1f       	adc	r31, r25
    11c4:	ee 0f       	add	r30, r30
    11c6:	ff 1f       	adc	r31, r31
    11c8:	ee 50       	subi	r30, 0x0E	; 14
    11ca:	fc 4f       	sbci	r31, 0xFC	; 252
    11cc:	31 83       	std	Z+1, r19	; 0x01
    11ce:	20 83       	st	Z, r18
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    11d0:	78 94       	sei
        break;
    }
  }

  return;
}
    11d2:	08 95       	ret
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
        motor[i].desiredPosition  = motor[i].actualPosition;
        break;

      case MOTOR_MOVE_INFINITE_CW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CW;
    11d4:	e8 2f       	mov	r30, r24
    11d6:	f0 e0       	ldi	r31, 0x00	; 0
    11d8:	ee 0f       	add	r30, r30
    11da:	ff 1f       	adc	r31, r31
    11dc:	ee 0f       	add	r30, r30
    11de:	ff 1f       	adc	r31, r31
    11e0:	ee 0f       	add	r30, r30
    11e2:	ff 1f       	adc	r31, r31
    11e4:	cf 01       	movw	r24, r30
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	88 0f       	add	r24, r24
    11ec:	99 1f       	adc	r25, r25
    11ee:	e8 0f       	add	r30, r24
    11f0:	f9 1f       	adc	r31, r25
    11f2:	e0 51       	subi	r30, 0x10	; 16
    11f4:	fc 4f       	sbci	r31, 0xFC	; 252
    11f6:	64 87       	std	Z+12, r22	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    11f8:	e4 2f       	mov	r30, r20
    11fa:	f0 e0       	ldi	r31, 0x00	; 0
    11fc:	ee 0f       	add	r30, r30
    11fe:	ff 1f       	adc	r31, r31
    1200:	ee 0f       	add	r30, r30
    1202:	ff 1f       	adc	r31, r31
    1204:	ee 0f       	add	r30, r30
    1206:	ff 1f       	adc	r31, r31
    1208:	cf 01       	movw	r24, r30
    120a:	88 0f       	add	r24, r24
    120c:	99 1f       	adc	r25, r25
    120e:	88 0f       	add	r24, r24
    1210:	99 1f       	adc	r25, r25
    1212:	e8 0f       	add	r30, r24
    1214:	f9 1f       	adc	r31, r25
    1216:	e0 51       	subi	r30, 0x10	; 16
    1218:	fc 4f       	sbci	r31, 0xFC	; 252
    121a:	20 81       	ld	r18, Z
    121c:	31 81       	ldd	r19, Z+1	; 0x01
    121e:	e4 2f       	mov	r30, r20
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	ee 0f       	add	r30, r30
    1224:	ff 1f       	adc	r31, r31
    1226:	ee 0f       	add	r30, r30
    1228:	ff 1f       	adc	r31, r31
    122a:	cf 01       	movw	r24, r30
    122c:	88 0f       	add	r24, r24
    122e:	99 1f       	adc	r25, r25
    1230:	88 0f       	add	r24, r24
    1232:	99 1f       	adc	r25, r25
    1234:	e8 0f       	add	r30, r24
    1236:	f9 1f       	adc	r31, r25
    1238:	ee 0f       	add	r30, r30
    123a:	ff 1f       	adc	r31, r31
    123c:	ee 50       	subi	r30, 0x0E	; 14
    123e:	fc 4f       	sbci	r31, 0xFC	; 252
    1240:	31 83       	std	Z+1, r19	; 0x01
    1242:	20 83       	st	Z, r18
        motor[i].desiredPosition += 1;
    1244:	e4 2f       	mov	r30, r20
    1246:	f0 e0       	ldi	r31, 0x00	; 0
    1248:	ee 0f       	add	r30, r30
    124a:	ff 1f       	adc	r31, r31
    124c:	ee 0f       	add	r30, r30
    124e:	ff 1f       	adc	r31, r31
    1250:	cf 01       	movw	r24, r30
    1252:	88 0f       	add	r24, r24
    1254:	99 1f       	adc	r25, r25
    1256:	88 0f       	add	r24, r24
    1258:	99 1f       	adc	r25, r25
    125a:	e8 0f       	add	r30, r24
    125c:	f9 1f       	adc	r31, r25
    125e:	ee 0f       	add	r30, r30
    1260:	ff 1f       	adc	r31, r31
    1262:	ee 50       	subi	r30, 0x0E	; 14
    1264:	fc 4f       	sbci	r31, 0xFC	; 252
    1266:	20 81       	ld	r18, Z
    1268:	31 81       	ldd	r19, Z+1	; 0x01
    126a:	2f 5f       	subi	r18, 0xFF	; 255
    126c:	3f 4f       	sbci	r19, 0xFF	; 255
    126e:	9d cf       	rjmp	.-198    	; 0x11aa <setConstSpeed+0x5a>
   set constant angular velocity
 --------------------------------------------------------------------- */
void setConstSpeed(uint8_t i, uint8_t state){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    switch(state){
    1270:	62 30       	cpi	r22, 0x02	; 2
    1272:	09 f0       	breq	.+2      	; 0x1276 <setConstSpeed+0x126>
    1274:	ad cf       	rjmp	.-166    	; 0x11d0 <setConstSpeed+0x80>
        motor[i].desiredPosition  = motor[i].actualPosition;
        motor[i].desiredPosition += 1;
        break;

      case MOTOR_MOVE_INFINITE_CCW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
    1276:	e8 2f       	mov	r30, r24
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	ee 0f       	add	r30, r30
    127c:	ff 1f       	adc	r31, r31
    127e:	ee 0f       	add	r30, r30
    1280:	ff 1f       	adc	r31, r31
    1282:	ee 0f       	add	r30, r30
    1284:	ff 1f       	adc	r31, r31
    1286:	cf 01       	movw	r24, r30
    1288:	88 0f       	add	r24, r24
    128a:	99 1f       	adc	r25, r25
    128c:	88 0f       	add	r24, r24
    128e:	99 1f       	adc	r25, r25
    1290:	e8 0f       	add	r30, r24
    1292:	f9 1f       	adc	r31, r25
    1294:	e0 51       	subi	r30, 0x10	; 16
    1296:	fc 4f       	sbci	r31, 0xFC	; 252
    1298:	64 87       	std	Z+12, r22	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    129a:	e4 2f       	mov	r30, r20
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	ee 0f       	add	r30, r30
    12a0:	ff 1f       	adc	r31, r31
    12a2:	ee 0f       	add	r30, r30
    12a4:	ff 1f       	adc	r31, r31
    12a6:	ee 0f       	add	r30, r30
    12a8:	ff 1f       	adc	r31, r31
    12aa:	cf 01       	movw	r24, r30
    12ac:	88 0f       	add	r24, r24
    12ae:	99 1f       	adc	r25, r25
    12b0:	88 0f       	add	r24, r24
    12b2:	99 1f       	adc	r25, r25
    12b4:	e8 0f       	add	r30, r24
    12b6:	f9 1f       	adc	r31, r25
    12b8:	e0 51       	subi	r30, 0x10	; 16
    12ba:	fc 4f       	sbci	r31, 0xFC	; 252
    12bc:	20 81       	ld	r18, Z
    12be:	31 81       	ldd	r19, Z+1	; 0x01
    12c0:	e4 2f       	mov	r30, r20
    12c2:	f0 e0       	ldi	r31, 0x00	; 0
    12c4:	ee 0f       	add	r30, r30
    12c6:	ff 1f       	adc	r31, r31
    12c8:	ee 0f       	add	r30, r30
    12ca:	ff 1f       	adc	r31, r31
    12cc:	cf 01       	movw	r24, r30
    12ce:	88 0f       	add	r24, r24
    12d0:	99 1f       	adc	r25, r25
    12d2:	88 0f       	add	r24, r24
    12d4:	99 1f       	adc	r25, r25
    12d6:	e8 0f       	add	r30, r24
    12d8:	f9 1f       	adc	r31, r25
    12da:	ee 0f       	add	r30, r30
    12dc:	ff 1f       	adc	r31, r31
    12de:	ee 50       	subi	r30, 0x0E	; 14
    12e0:	fc 4f       	sbci	r31, 0xFC	; 252
    12e2:	31 83       	std	Z+1, r19	; 0x01
    12e4:	20 83       	st	Z, r18
        motor[i].desiredPosition += -1;
    12e6:	e4 2f       	mov	r30, r20
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	ee 0f       	add	r30, r30
    12ec:	ff 1f       	adc	r31, r31
    12ee:	ee 0f       	add	r30, r30
    12f0:	ff 1f       	adc	r31, r31
    12f2:	cf 01       	movw	r24, r30
    12f4:	88 0f       	add	r24, r24
    12f6:	99 1f       	adc	r25, r25
    12f8:	88 0f       	add	r24, r24
    12fa:	99 1f       	adc	r25, r25
    12fc:	e8 0f       	add	r30, r24
    12fe:	f9 1f       	adc	r31, r25
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	ee 50       	subi	r30, 0x0E	; 14
    1306:	fc 4f       	sbci	r31, 0xFC	; 252
    1308:	20 81       	ld	r18, Z
    130a:	31 81       	ldd	r19, Z+1	; 0x01
    130c:	21 50       	subi	r18, 0x01	; 1
    130e:	30 40       	sbci	r19, 0x00	; 0
    1310:	4c cf       	rjmp	.-360    	; 0x11aa <setConstSpeed+0x5a>

00001312 <getPortExpanderAddress>:
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1312:	81 30       	cpi	r24, 0x01	; 1
    1314:	61 f0       	breq	.+24     	; 0x132e <getPortExpanderAddress+0x1c>
    1316:	81 30       	cpi	r24, 0x01	; 1
    1318:	30 f0       	brcs	.+12     	; 0x1326 <getPortExpanderAddress+0x14>
    131a:	82 30       	cpi	r24, 0x02	; 2
    131c:	51 f0       	breq	.+20     	; 0x1332 <getPortExpanderAddress+0x20>
    131e:	83 30       	cpi	r24, 0x03	; 3
    1320:	21 f0       	breq	.+8      	; 0x132a <getPortExpanderAddress+0x18>
      addr = IIC_MOTOR2_PORTEXP_ADDR;
      break;

    case MOTOR3:
      addr = IIC_MOTOR3_PORTEXP_ADDR;
      break;
    1322:	80 e0       	ldi	r24, 0x00	; 0
    default:
      addr = 0;
  }

  return addr;
}
    1324:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1326:	82 e4       	ldi	r24, 0x42	; 66
    1328:	08 95       	ret
      addr = IIC_MOTOR1_PORTEXP_ADDR;
      break;

    case MOTOR2:
      addr = IIC_MOTOR2_PORTEXP_ADDR;
      break;
    132a:	88 e4       	ldi	r24, 0x48	; 72
    132c:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    132e:	84 e4       	ldi	r24, 0x44	; 68
    1330:	08 95       	ret
    1332:	86 e4       	ldi	r24, 0x46	; 70
    1334:	08 95       	ret

00001336 <getDACAddress>:
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1336:	81 30       	cpi	r24, 0x01	; 1
    1338:	61 f0       	breq	.+24     	; 0x1352 <getDACAddress+0x1c>
    133a:	81 30       	cpi	r24, 0x01	; 1
    133c:	30 f0       	brcs	.+12     	; 0x134a <getDACAddress+0x14>
    133e:	82 30       	cpi	r24, 0x02	; 2
    1340:	51 f0       	breq	.+20     	; 0x1356 <getDACAddress+0x20>
    1342:	83 30       	cpi	r24, 0x03	; 3
    1344:	21 f0       	breq	.+8      	; 0x134e <getDACAddress+0x18>
      addr = IIC_MOTOR2_DAC_ADDR;
      break;

    case MOTOR3:
      addr = IIC_MOTOR3_DAC_ADDR;
      break;
    1346:	80 e0       	ldi	r24, 0x00	; 0
    default:
      addr = 0;
  }

  return addr;
}
    1348:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    134a:	82 e1       	ldi	r24, 0x12	; 18
    134c:	08 95       	ret
      addr = IIC_MOTOR1_DAC_ADDR;
      break;

    case MOTOR2:
      addr = IIC_MOTOR2_DAC_ADDR;
      break;
    134e:	8c e9       	ldi	r24, 0x9C	; 156
    1350:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1352:	84 e1       	ldi	r24, 0x14	; 20
    1354:	08 95       	ret
    1356:	8a e9       	ldi	r24, 0x9A	; 154
    1358:	08 95       	ret

0000135a <reverseBitOrder>:
   because of reversed bit order :'-(
   ... shit happens
 --------------------------------------------------------------------- */
uint8_t reverseBitOrder(uint8_t b){

  b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    135a:	28 2f       	mov	r18, r24
    135c:	22 95       	swap	r18
    135e:	2f 70       	andi	r18, 0x0F	; 15
    1360:	82 95       	swap	r24
    1362:	80 7f       	andi	r24, 0xF0	; 240
    1364:	28 2b       	or	r18, r24
  b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    1366:	30 e0       	ldi	r19, 0x00	; 0
    1368:	c9 01       	movw	r24, r18
    136a:	83 73       	andi	r24, 0x33	; 51
    136c:	90 70       	andi	r25, 0x00	; 0
    136e:	88 0f       	add	r24, r24
    1370:	99 1f       	adc	r25, r25
    1372:	88 0f       	add	r24, r24
    1374:	99 1f       	adc	r25, r25
    1376:	2c 7c       	andi	r18, 0xCC	; 204
    1378:	30 70       	andi	r19, 0x00	; 0
    137a:	35 95       	asr	r19
    137c:	27 95       	ror	r18
    137e:	35 95       	asr	r19
    1380:	27 95       	ror	r18
    1382:	82 2b       	or	r24, r18
  b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    1384:	28 2f       	mov	r18, r24
    1386:	30 e0       	ldi	r19, 0x00	; 0
    1388:	c9 01       	movw	r24, r18
    138a:	85 75       	andi	r24, 0x55	; 85
    138c:	90 70       	andi	r25, 0x00	; 0
    138e:	88 0f       	add	r24, r24
    1390:	99 1f       	adc	r25, r25
    1392:	2a 7a       	andi	r18, 0xAA	; 170
    1394:	30 70       	andi	r19, 0x00	; 0
    1396:	35 95       	asr	r19
    1398:	27 95       	ror	r18

  return b;
}
    139a:	82 2b       	or	r24, r18
    139c:	08 95       	ret

0000139e <getSubSteps>:
uint8_t getSubSteps(uint8_t mot){

  uint8_t steps = 0;

  return steps;
}
    139e:	80 e0       	ldi	r24, 0x00	; 0
    13a0:	08 95       	ret

000013a2 <getButtonEvent>:
uint8_t getButtonEvent(void){

  uint8_t state = 0;
  uint8_t button = NO_BUTTON;

  if(buttonState.readyToProcess){
    13a2:	80 91 de 02 	lds	r24, 0x02DE
    13a6:	88 23       	and	r24, r24
    13a8:	a1 f0       	breq	.+40     	; 0x13d2 <getButtonEvent+0x30>
    /* a button has been pressed */
    state = buttonState.inputRegister;
    13aa:	90 91 dc 02 	lds	r25, 0x02DC
	
	if(rotEnc.buttonPressed){
    13ae:	80 91 d1 03 	lds	r24, 0x03D1
    13b2:	88 23       	and	r24, r24
    13b4:	61 f4       	brne	.+24     	; 0x13ce <getButtonEvent+0x2c>
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
    13b6:	97 fd       	sbrc	r25, 7
    13b8:	10 c0       	rjmp	.+32     	; 0x13da <getButtonEvent+0x38>
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
    13ba:	96 fd       	sbrc	r25, 6
    13bc:	0c c0       	rjmp	.+24     	; 0x13d6 <getButtonEvent+0x34>
      button = BUTTON_MOTOR1;
    }
    else if(state & (1<<BUTTON_MOTOR2)){
    13be:	95 fd       	sbrc	r25, 5
    13c0:	0e c0       	rjmp	.+28     	; 0x13de <getButtonEvent+0x3c>
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
    13c2:	94 fd       	sbrc	r25, 4
    13c4:	0e c0       	rjmp	.+28     	; 0x13e2 <getButtonEvent+0x40>
      button = BUTTON_MOTOR3;
    }
    else if(state & (1<<BUTTON_MENUESCAPE)){
    13c6:	93 ff       	sbrs	r25, 3
    13c8:	04 c0       	rjmp	.+8      	; 0x13d2 <getButtonEvent+0x30>
    13ca:	83 e0       	ldi	r24, 0x03	; 3
    13cc:	08 95       	ret

  if(buttonState.readyToProcess){
    /* a button has been pressed */
    state = buttonState.inputRegister;
	
	if(rotEnc.buttonPressed){
    13ce:	88 e0       	ldi	r24, 0x08	; 8
    13d0:	08 95       	ret
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
      button = BUTTON_MOTOR3;
    }
    else if(state & (1<<BUTTON_MENUESCAPE)){
    13d2:	8a e2       	ldi	r24, 0x2A	; 42
      button = NO_BUTTON;
    }
  }

  return button;
}
    13d4:	08 95       	ret
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
    13d6:	86 e0       	ldi	r24, 0x06	; 6
    13d8:	08 95       	ret
    state = buttonState.inputRegister;
	
	if(rotEnc.buttonPressed){
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
    13da:	87 e0       	ldi	r24, 0x07	; 7
    13dc:	08 95       	ret
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
      button = BUTTON_MOTOR1;
    }
    else if(state & (1<<BUTTON_MOTOR2)){
    13de:	85 e0       	ldi	r24, 0x05	; 5
    13e0:	08 95       	ret
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
    13e2:	84 e0       	ldi	r24, 0x04	; 4
    13e4:	08 95       	ret

000013e6 <getRotaryEncoderEvent>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    13e6:	f8 94       	cli
   */

  int8_t steps = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(rotEnc.readyToProcess){
    13e8:	80 91 d0 03 	lds	r24, 0x03D0
    13ec:	88 23       	and	r24, r24
    13ee:	21 f0       	breq	.+8      	; 0x13f8 <getRotaryEncoderEvent+0x12>
      steps = rotEnc.steps;
    13f0:	80 91 cf 03 	lds	r24, 0x03CF
      rotEnc.steps = 0;
    13f4:	10 92 cf 03 	sts	0x03CF, r1
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    13f8:	78 94       	sei
    }
  }
  return steps;
}
    13fa:	08 95       	ret

000013fc <__vector_20>:
    A character in the USART receive buffer is ready for fetch.
    Build up the command string for parsing here. If the
    rxSerial.readyToProcess is NOT zero, the actual command
    in the buffer is not parsed yet. In this case refuse the new char.
 --------------------------------------------------------------------- */
ISR(USART0_RX_vect){
    13fc:	1f 92       	push	r1
    13fe:	0f 92       	push	r0
    1400:	0f b6       	in	r0, 0x3f	; 63
    1402:	0f 92       	push	r0
    1404:	0b b6       	in	r0, 0x3b	; 59
    1406:	0f 92       	push	r0
    1408:	11 24       	eor	r1, r1
    140a:	8f 93       	push	r24
    140c:	9f 93       	push	r25
    140e:	ef 93       	push	r30
    1410:	ff 93       	push	r31

  uint8_t c;

  c = UDR0;
    1412:	90 91 c6 00 	lds	r25, 0x00C6

  if(rxString.readyToProcess == 0){ /* actual rxString in buffer not parsed yet */
    1416:	80 91 f0 02 	lds	r24, 0x02F0
    141a:	88 23       	and	r24, r24
    141c:	e1 f4       	brne	.+56     	; 0x1456 <__vector_20+0x5a>
    if(c == '\r'){
    141e:	9d 30       	cpi	r25, 0x0D	; 13
    1420:	09 f1       	breq	.+66     	; 0x1464 <__vector_20+0x68>
      /* get rid of windoze line ending overhead bullshit */
      return;
    }
    if((c != '\n') && (rxString.charCount < SERIAL_BUFFERSIZE)){
    1422:	9a 30       	cpi	r25, 0x0A	; 10
    1424:	21 f0       	breq	.+8      	; 0x142e <__vector_20+0x32>
    1426:	80 91 f1 02 	lds	r24, 0x02F1
    142a:	80 34       	cpi	r24, 0x40	; 64
    142c:	30 f1       	brcs	.+76     	; 0x147a <__vector_20+0x7e>
      rxString.buffer[rxString.charCount] = c;
      rxString.charCount++;
    }
    else{
      /* end of command */
      rxString.buffer[rxString.charCount] = '\0';
    142e:	e0 91 ee 02 	lds	r30, 0x02EE
    1432:	f0 91 ef 02 	lds	r31, 0x02EF
    1436:	80 91 f1 02 	lds	r24, 0x02F1
    143a:	e8 0f       	add	r30, r24
    143c:	f1 1d       	adc	r31, r1
    143e:	10 82       	st	Z, r1
      rxString.readyToProcess = 1;
    1440:	81 e0       	ldi	r24, 0x01	; 1
    1442:	80 93 f0 02 	sts	0x02F0, r24
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    1446:	80 91 c0 00 	lds	r24, 0x00C0
    144a:	85 ff       	sbrs	r24, 5
    144c:	fc cf       	rjmp	.-8      	; 0x1446 <__vector_20+0x4a>
    ;
  }

  UDR0 = c;
    144e:	86 e0       	ldi	r24, 0x06	; 6
    1450:	80 93 c6 00 	sts	0x00C6, r24
    1454:	07 c0       	rjmp	.+14     	; 0x1464 <__vector_20+0x68>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    1456:	80 91 c0 00 	lds	r24, 0x00C0
    145a:	85 ff       	sbrs	r24, 5
    145c:	fc cf       	rjmp	.-8      	; 0x1456 <__vector_20+0x5a>
    ;
  }

  UDR0 = c;
    145e:	85 e1       	ldi	r24, 0x15	; 21
    1460:	80 93 c6 00 	sts	0x00C6, r24
  else{ /* actual command in buffer is not processed yet */
    sendChar(0x15);   /* send a NAK */
  }

  return;
}
    1464:	ff 91       	pop	r31
    1466:	ef 91       	pop	r30
    1468:	9f 91       	pop	r25
    146a:	8f 91       	pop	r24
    146c:	0f 90       	pop	r0
    146e:	0b be       	out	0x3b, r0	; 59
    1470:	0f 90       	pop	r0
    1472:	0f be       	out	0x3f, r0	; 63
    1474:	0f 90       	pop	r0
    1476:	1f 90       	pop	r1
    1478:	18 95       	reti
    if(c == '\r'){
      /* get rid of windoze line ending overhead bullshit */
      return;
    }
    if((c != '\n') && (rxString.charCount < SERIAL_BUFFERSIZE)){
      rxString.buffer[rxString.charCount] = c;
    147a:	e0 91 ee 02 	lds	r30, 0x02EE
    147e:	f0 91 ef 02 	lds	r31, 0x02EF
    1482:	80 91 f1 02 	lds	r24, 0x02F1
    1486:	e8 0f       	add	r30, r24
    1488:	f1 1d       	adc	r31, r1
    148a:	90 83       	st	Z, r25
      rxString.charCount++;
    148c:	80 91 f1 02 	lds	r24, 0x02F1
    1490:	8f 5f       	subi	r24, 0xFF	; 255
    1492:	80 93 f1 02 	sts	0x02F1, r24
    1496:	e6 cf       	rjmp	.-52     	; 0x1464 <__vector_20+0x68>

00001498 <__vector_16>:

/* ---------------------------------------------------------------------
    if any button is pressed or turned, this interrupt will
    handle the reaction
 --------------------------------------------------------------------- */
ISR(TIMER0_COMPA_vect){
    1498:	1f 92       	push	r1
    149a:	0f 92       	push	r0
    149c:	0f b6       	in	r0, 0x3f	; 63
    149e:	0f 92       	push	r0
    14a0:	0b b6       	in	r0, 0x3b	; 59
    14a2:	0f 92       	push	r0
    14a4:	11 24       	eor	r1, r1
    14a6:	8f 93       	push	r24
    14a8:	ef 93       	push	r30
    14aa:	ff 93       	push	r31

  uint8_t inputReg = 0;
  static int16_t last = 0;  /* save old rotEnc value */

  inputReg = PINC;  /* rotEnc is connected to PORTC */
    14ac:	86 b1       	in	r24, 0x06	; 6

  /* handle rotEnc's button */
  if((inputReg^0xFF) & (1<<BUTTON_ROT_ENC)){
    14ae:	80 95       	com	r24
    14b0:	83 ff       	sbrs	r24, 3
    14b2:	3a c0       	rjmp	.+116    	; 0x1528 <__vector_16+0x90>
    /* button was pressed */
    if(rotEnc.buttonDebounce == 0){
    14b4:	80 91 d2 03 	lds	r24, 0x03D2
    14b8:	88 23       	and	r24, r24
    14ba:	09 f4       	brne	.+2      	; 0x14be <__vector_16+0x26>
    14bc:	40 c0       	rjmp	.+128    	; 0x153e <__vector_16+0xa6>
  /* now care about the rotary encoder rotations
   *
   * code from:
   * http://www.mikrocontroller.net/articles/Drehgeber
   */
  last = (last << 2) & 0x0F;
    14be:	e0 91 d8 02 	lds	r30, 0x02D8
    14c2:	f0 91 d9 02 	lds	r31, 0x02D9
    14c6:	ee 0f       	add	r30, r30
    14c8:	ff 1f       	adc	r31, r31
    14ca:	ee 0f       	add	r30, r30
    14cc:	ff 1f       	adc	r31, r31
    14ce:	ef 70       	andi	r30, 0x0F	; 15
    14d0:	f0 70       	andi	r31, 0x00	; 0
    14d2:	f0 93 d9 02 	sts	0x02D9, r31
    14d6:	e0 93 d8 02 	sts	0x02D8, r30
  if(PHASE_A){
    14da:	35 9b       	sbis	0x06, 5	; 6
    14dc:	05 c0       	rjmp	.+10     	; 0x14e8 <__vector_16+0x50>
    last |= 2;
    14de:	e2 60       	ori	r30, 0x02	; 2
    14e0:	f0 93 d9 02 	sts	0x02D9, r31
    14e4:	e0 93 d8 02 	sts	0x02D8, r30
  }
  if(PHASE_B){
    14e8:	34 9b       	sbis	0x06, 4	; 6
    14ea:	05 c0       	rjmp	.+10     	; 0x14f6 <__vector_16+0x5e>
    last |= 1;
    14ec:	e1 60       	ori	r30, 0x01	; 1
    14ee:	f0 93 d9 02 	sts	0x02D9, r31
    14f2:	e0 93 d8 02 	sts	0x02D8, r30
  }
  if(pgm_read_byte(&table[last])){
    14f6:	ee 0f       	add	r30, r30
    14f8:	ff 1f       	adc	r31, r31
    14fa:	ec 52       	subi	r30, 0x2C	; 44
    14fc:	ff 4f       	sbci	r31, 0xFF	; 255
    14fe:	e4 91       	lpm	r30, Z+
    1500:	ee 23       	and	r30, r30
    1502:	41 f0       	breq	.+16     	; 0x1514 <__vector_16+0x7c>
    rotEnc.steps += pgm_read_byte(&table[last]);
    1504:	80 91 cf 03 	lds	r24, 0x03CF
    1508:	e8 0f       	add	r30, r24
    150a:	e0 93 cf 03 	sts	0x03CF, r30
    rotEnc.readyToProcess = 1;
    150e:	81 e0       	ldi	r24, 0x01	; 1
    1510:	80 93 d0 03 	sts	0x03D0, r24
  }
}
    1514:	ff 91       	pop	r31
    1516:	ef 91       	pop	r30
    1518:	8f 91       	pop	r24
    151a:	0f 90       	pop	r0
    151c:	0b be       	out	0x3b, r0	; 59
    151e:	0f 90       	pop	r0
    1520:	0f be       	out	0x3f, r0	; 63
    1522:	0f 90       	pop	r0
    1524:	1f 90       	pop	r1
    1526:	18 95       	reti
	  rotEnc.buttonDebounce = 1;
    }
  }
  else{
      /* button is no longer pressed ...*/
      if(rotEnc.buttonDebounce == 1){
    1528:	80 91 d2 03 	lds	r24, 0x03D2
    152c:	81 30       	cpi	r24, 0x01	; 1
    152e:	39 f6       	brne	.-114    	; 0x14be <__vector_16+0x26>
        /* ... and we are already in debouncing mode -> generate event */
        rotEnc.buttonPressed = 1;
    1530:	80 93 d1 03 	sts	0x03D1, r24
        rotEnc.buttonDebounce = 0;
    1534:	10 92 d2 03 	sts	0x03D2, r1
        buttonState.readyToProcess = 1;
    1538:	80 93 de 02 	sts	0x02DE, r24
    153c:	c0 cf       	rjmp	.-128    	; 0x14be <__vector_16+0x26>
  /* handle rotEnc's button */
  if((inputReg^0xFF) & (1<<BUTTON_ROT_ENC)){
    /* button was pressed */
    if(rotEnc.buttonDebounce == 0){
      // enter debouncing mode
	  rotEnc.buttonDebounce = 1;
    153e:	81 e0       	ldi	r24, 0x01	; 1
    1540:	80 93 d2 03 	sts	0x03D2, r24
    1544:	bc cf       	rjmp	.-136    	; 0x14be <__vector_16+0x26>

00001546 <loadConfigFromEEPROM>:
}

/* ---------------------------------------------------------------------
    load last stored motor configuration from EEPROM
 --------------------------------------------------------------------- */
void loadConfigFromEEPROM(void){
    1546:	7f 92       	push	r7
    1548:	8f 92       	push	r8
    154a:	9f 92       	push	r9
    154c:	af 92       	push	r10
    154e:	bf 92       	push	r11
    1550:	cf 92       	push	r12
    1552:	df 92       	push	r13
    1554:	ef 92       	push	r14
    1556:	ff 92       	push	r15
    1558:	0f 93       	push	r16
    155a:	1f 93       	push	r17
    155c:	cf 93       	push	r28
    155e:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1560:	f8 94       	cli
    1562:	cc 24       	eor	r12, r12
    1564:	dd 24       	eor	r13, r13
    1566:	88 24       	eor	r8, r8
    1568:	99 24       	eor	r9, r9
    156a:	aa 24       	eor	r10, r10
    156c:	bb 24       	eor	r11, r11
      eeprom_read_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
      eeprom_read_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));

      /* activate forbidden zone if necessary */
      if(forbiddenZone[i].start != forbiddenZone[i].stop){
        forbiddenZone[i].active = 1;
    156e:	77 24       	eor	r7, r7
    1570:	73 94       	inc	r7

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
      eeprom_read_block(&(motor[i].opticalZeroPosition), &(opticalZeroPositionEE[i]), sizeof(int16_t));
    1572:	c6 01       	movw	r24, r12
    1574:	88 0f       	add	r24, r24
    1576:	99 1f       	adc	r25, r25
    1578:	86 01       	movw	r16, r12
    157a:	00 0f       	add	r16, r16
    157c:	11 1f       	adc	r17, r17
    157e:	00 0f       	add	r16, r16
    1580:	11 1f       	adc	r17, r17
    1582:	00 0f       	add	r16, r16
    1584:	11 1f       	adc	r17, r17
    1586:	80 0f       	add	r24, r16
    1588:	91 1f       	adc	r25, r17
    158a:	88 0f       	add	r24, r24
    158c:	99 1f       	adc	r25, r25
    158e:	88 0f       	add	r24, r24
    1590:	99 1f       	adc	r25, r25
    1592:	b4 01       	movw	r22, r8
    1594:	6d 5c       	subi	r22, 0xCD	; 205
    1596:	7f 4f       	sbci	r23, 0xFF	; 255
    1598:	8c 50       	subi	r24, 0x0C	; 12
    159a:	9c 4f       	sbci	r25, 0xFC	; 252
    159c:	42 e0       	ldi	r20, 0x02	; 2
    159e:	50 e0       	ldi	r21, 0x00	; 0
    15a0:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].gearRatio), &(gearRatioEE[i]), sizeof(double));
    15a4:	78 01       	movw	r14, r16
    15a6:	ee 0c       	add	r14, r14
    15a8:	ff 1c       	adc	r15, r15
    15aa:	ee 0c       	add	r14, r14
    15ac:	ff 1c       	adc	r15, r15
    15ae:	e0 0e       	add	r14, r16
    15b0:	f1 1e       	adc	r15, r17
    15b2:	b5 01       	movw	r22, r10
    15b4:	65 5c       	subi	r22, 0xC5	; 197
    15b6:	7f 4f       	sbci	r23, 0xFF	; 255
    15b8:	c7 01       	movw	r24, r14
    15ba:	83 50       	subi	r24, 0x03	; 3
    15bc:	9c 4f       	sbci	r25, 0xFC	; 252
    15be:	44 e0       	ldi	r20, 0x04	; 4
    15c0:	50 e0       	ldi	r21, 0x00	; 0
    15c2:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepsPerFullRotation), &(stepsPerFullRotationEE[i]), sizeof(double));
    15c6:	b5 01       	movw	r22, r10
    15c8:	65 5b       	subi	r22, 0xB5	; 181
    15ca:	7f 4f       	sbci	r23, 0xFF	; 255
    15cc:	c7 01       	movw	r24, r14
    15ce:	8f 5f       	subi	r24, 0xFF	; 255
    15d0:	9b 4f       	sbci	r25, 0xFB	; 251
    15d2:	44 e0       	ldi	r20, 0x04	; 4
    15d4:	50 e0       	ldi	r21, 0x00	; 0
    15d6:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].subSteps), &(subStepsEE[i]), sizeof(double));
    15da:	b5 01       	movw	r22, r10
    15dc:	65 5a       	subi	r22, 0xA5	; 165
    15de:	7f 4f       	sbci	r23, 0xFF	; 255
    15e0:	c7 01       	movw	r24, r14
    15e2:	8b 5f       	subi	r24, 0xFB	; 251
    15e4:	9b 4f       	sbci	r25, 0xFB	; 251
    15e6:	44 e0       	ldi	r20, 0x04	; 4
    15e8:	50 e0       	ldi	r21, 0x00	; 0
    15ea:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepMultiplier), &(stepMultiplierEE[i]), sizeof(double));
    15ee:	b5 01       	movw	r22, r10
    15f0:	65 59       	subi	r22, 0x95	; 149
    15f2:	7f 4f       	sbci	r23, 0xFF	; 255
    15f4:	c7 01       	movw	r24, r14
    15f6:	86 5f       	subi	r24, 0xF6	; 246
    15f8:	9b 4f       	sbci	r25, 0xFB	; 251
    15fa:	44 e0       	ldi	r20, 0x04	; 4
    15fc:	50 e0       	ldi	r21, 0x00	; 0
    15fe:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
	    eeprom_read_block(&(motor[i].current), &(currentEE[i]), sizeof(double));
    1602:	b5 01       	movw	r22, r10
    1604:	65 58       	subi	r22, 0x85	; 133
    1606:	7f 4f       	sbci	r23, 0xFF	; 255
    1608:	c7 01       	movw	r24, r14
    160a:	8d 5e       	subi	r24, 0xED	; 237
    160c:	9b 4f       	sbci	r25, 0xFB	; 251
    160e:	44 e0       	ldi	r20, 0x04	; 4
    1610:	50 e0       	ldi	r21, 0x00	; 0
    1612:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].decay), &(decayEE[i]), sizeof(int8_t));
    1616:	b6 01       	movw	r22, r12
    1618:	65 57       	subi	r22, 0x75	; 117
    161a:	7f 4f       	sbci	r23, 0xFF	; 255
    161c:	c7 01       	movw	r24, r14
    161e:	89 5e       	subi	r24, 0xE9	; 233
    1620:	9b 4f       	sbci	r25, 0xFB	; 251
    1622:	41 e0       	ldi	r20, 0x01	; 1
    1624:	50 e0       	ldi	r21, 0x00	; 0
    1626:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepUnit), &(stepUnitEE[i]), sizeof(int8_t));
    162a:	b6 01       	movw	r22, r12
    162c:	61 57       	subi	r22, 0x71	; 113
    162e:	7f 4f       	sbci	r23, 0xFF	; 255
    1630:	c7 01       	movw	r24, r14
    1632:	87 5f       	subi	r24, 0xF7	; 247
    1634:	9b 4f       	sbci	r25, 0xFB	; 251
    1636:	41 e0       	ldi	r20, 0x01	; 1
    1638:	50 e0       	ldi	r21, 0x00	; 0
    163a:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].waitBetweenSteps), &(waitBetweenStepsEE[i]), sizeof(int16_t));
    163e:	b4 01       	movw	r22, r8
    1640:	6d 56       	subi	r22, 0x6D	; 109
    1642:	7f 4f       	sbci	r23, 0xFF	; 255
    1644:	c7 01       	movw	r24, r14
    1646:	82 5f       	subi	r24, 0xF2	; 242
    1648:	9b 4f       	sbci	r25, 0xFB	; 251
    164a:	42 e0       	ldi	r20, 0x02	; 2
    164c:	50 e0       	ldi	r21, 0x00	; 0
    164e:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>

      eeprom_read_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
    1652:	86 01       	movw	r16, r12
    1654:	00 0f       	add	r16, r16
    1656:	11 1f       	adc	r17, r17
    1658:	00 0f       	add	r16, r16
    165a:	11 1f       	adc	r17, r17
    165c:	0c 0d       	add	r16, r12
    165e:	1d 1d       	adc	r17, r13
    1660:	e8 01       	movw	r28, r16
    1662:	cd 52       	subi	r28, 0x2D	; 45
    1664:	dc 4f       	sbci	r29, 0xFC	; 252
    1666:	b4 01       	movw	r22, r8
    1668:	65 56       	subi	r22, 0x65	; 101
    166a:	7f 4f       	sbci	r23, 0xFF	; 255
    166c:	ce 01       	movw	r24, r28
    166e:	42 e0       	ldi	r20, 0x02	; 2
    1670:	50 e0       	ldi	r21, 0x00	; 0
    1672:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
      eeprom_read_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    1676:	b4 01       	movw	r22, r8
    1678:	6d 55       	subi	r22, 0x5D	; 93
    167a:	7f 4f       	sbci	r23, 0xFF	; 255
    167c:	c8 01       	movw	r24, r16
    167e:	8b 52       	subi	r24, 0x2B	; 43
    1680:	9c 4f       	sbci	r25, 0xFC	; 252
    1682:	42 e0       	ldi	r20, 0x02	; 2
    1684:	50 e0       	ldi	r21, 0x00	; 0
    1686:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>

      /* activate forbidden zone if necessary */
      if(forbiddenZone[i].start != forbiddenZone[i].stop){
    168a:	28 81       	ld	r18, Y
    168c:	39 81       	ldd	r19, Y+1	; 0x01
    168e:	8a 81       	ldd	r24, Y+2	; 0x02
    1690:	9b 81       	ldd	r25, Y+3	; 0x03
    1692:	28 17       	cp	r18, r24
    1694:	39 07       	cpc	r19, r25
    1696:	09 f0       	breq	.+2      	; 0x169a <loadConfigFromEEPROM+0x154>
        forbiddenZone[i].active = 1;
    1698:	7c 82       	std	Y+4, r7	; 0x04
    169a:	08 94       	sec
    169c:	c1 1c       	adc	r12, r1
    169e:	d1 1c       	adc	r13, r1
    16a0:	82 e0       	ldi	r24, 0x02	; 2
    16a2:	90 e0       	ldi	r25, 0x00	; 0
    16a4:	88 0e       	add	r8, r24
    16a6:	99 1e       	adc	r9, r25
    16a8:	84 e0       	ldi	r24, 0x04	; 4
    16aa:	90 e0       	ldi	r25, 0x00	; 0
    16ac:	a8 0e       	add	r10, r24
    16ae:	b9 1e       	adc	r11, r25
void loadConfigFromEEPROM(void){

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
    16b0:	94 e0       	ldi	r25, 0x04	; 4
    16b2:	c9 16       	cp	r12, r25
    16b4:	d1 04       	cpc	r13, r1
    16b6:	09 f0       	breq	.+2      	; 0x16ba <loadConfigFromEEPROM+0x174>
    16b8:	5c cf       	rjmp	.-328    	; 0x1572 <loadConfigFromEEPROM+0x2c>
    16ba:	c0 e0       	ldi	r28, 0x00	; 0
    16bc:	d0 e0       	ldi	r29, 0x00	; 0
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* load internal stores programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
      eeprom_read_block(&(programList[i]), &(programListEE[i]), sizeof(progStep));
    16be:	be 01       	movw	r22, r28
    16c0:	65 55       	subi	r22, 0x55	; 85
    16c2:	7f 4f       	sbci	r23, 0xFF	; 255
    16c4:	ce 01       	movw	r24, r28
    16c6:	8d 50       	subi	r24, 0x0D	; 13
    16c8:	9d 4f       	sbci	r25, 0xFD	; 253
    16ca:	4a e0       	ldi	r20, 0x0A	; 10
    16cc:	50 e0       	ldi	r21, 0x00	; 0
    16ce:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
    16d2:	2a 96       	adiw	r28, 0x0a	; 10
      }
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* load internal stores programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    16d4:	c0 3a       	cpi	r28, 0xA0	; 160
    16d6:	d1 05       	cpc	r29, r1
    16d8:	91 f7       	brne	.-28     	; 0x16be <loadConfigFromEEPROM+0x178>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    16da:	78 94       	sei
#endif

  }

  return;
}
    16dc:	df 91       	pop	r29
    16de:	cf 91       	pop	r28
    16e0:	1f 91       	pop	r17
    16e2:	0f 91       	pop	r16
    16e4:	ff 90       	pop	r15
    16e6:	ef 90       	pop	r14
    16e8:	df 90       	pop	r13
    16ea:	cf 90       	pop	r12
    16ec:	bf 90       	pop	r11
    16ee:	af 90       	pop	r10
    16f0:	9f 90       	pop	r9
    16f2:	8f 90       	pop	r8
    16f4:	7f 90       	pop	r7
    16f6:	08 95       	ret

000016f8 <saveConfigToEEPROM>:
}

/* ---------------------------------------------------------------------
    save current motor configuration to EEPROM
 --------------------------------------------------------------------- */
void saveConfigToEEPROM(void){
    16f8:	af 92       	push	r10
    16fa:	bf 92       	push	r11
    16fc:	cf 92       	push	r12
    16fe:	df 92       	push	r13
    1700:	ef 92       	push	r14
    1702:	ff 92       	push	r15
    1704:	0f 93       	push	r16
    1706:	1f 93       	push	r17
    1708:	cf 93       	push	r28
    170a:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    170c:	f8 94       	cli
    170e:	c0 e0       	ldi	r28, 0x00	; 0
    1710:	d0 e0       	ldi	r29, 0x00	; 0
    1712:	aa 24       	eor	r10, r10
    1714:	bb 24       	eor	r11, r11
    1716:	cc 24       	eor	r12, r12
    1718:	dd 24       	eor	r13, r13

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
      eeprom_update_block(&(motor[i].opticalZeroPosition), &(opticalZeroPositionEE[i]), sizeof(int16_t));
    171a:	ce 01       	movw	r24, r28
    171c:	88 0f       	add	r24, r24
    171e:	99 1f       	adc	r25, r25
    1720:	8e 01       	movw	r16, r28
    1722:	00 0f       	add	r16, r16
    1724:	11 1f       	adc	r17, r17
    1726:	00 0f       	add	r16, r16
    1728:	11 1f       	adc	r17, r17
    172a:	00 0f       	add	r16, r16
    172c:	11 1f       	adc	r17, r17
    172e:	80 0f       	add	r24, r16
    1730:	91 1f       	adc	r25, r17
    1732:	88 0f       	add	r24, r24
    1734:	99 1f       	adc	r25, r25
    1736:	88 0f       	add	r24, r24
    1738:	99 1f       	adc	r25, r25
    173a:	b5 01       	movw	r22, r10
    173c:	6d 5c       	subi	r22, 0xCD	; 205
    173e:	7f 4f       	sbci	r23, 0xFF	; 255
    1740:	8c 50       	subi	r24, 0x0C	; 12
    1742:	9c 4f       	sbci	r25, 0xFC	; 252
    1744:	42 e0       	ldi	r20, 0x02	; 2
    1746:	50 e0       	ldi	r21, 0x00	; 0
    1748:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].gearRatio), &(gearRatioEE[i]), sizeof(double));
    174c:	78 01       	movw	r14, r16
    174e:	ee 0c       	add	r14, r14
    1750:	ff 1c       	adc	r15, r15
    1752:	ee 0c       	add	r14, r14
    1754:	ff 1c       	adc	r15, r15
    1756:	e0 0e       	add	r14, r16
    1758:	f1 1e       	adc	r15, r17
    175a:	b6 01       	movw	r22, r12
    175c:	65 5c       	subi	r22, 0xC5	; 197
    175e:	7f 4f       	sbci	r23, 0xFF	; 255
    1760:	c7 01       	movw	r24, r14
    1762:	83 50       	subi	r24, 0x03	; 3
    1764:	9c 4f       	sbci	r25, 0xFC	; 252
    1766:	44 e0       	ldi	r20, 0x04	; 4
    1768:	50 e0       	ldi	r21, 0x00	; 0
    176a:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepsPerFullRotation), &(stepsPerFullRotationEE[i]), sizeof(double));
    176e:	b6 01       	movw	r22, r12
    1770:	65 5b       	subi	r22, 0xB5	; 181
    1772:	7f 4f       	sbci	r23, 0xFF	; 255
    1774:	c7 01       	movw	r24, r14
    1776:	8f 5f       	subi	r24, 0xFF	; 255
    1778:	9b 4f       	sbci	r25, 0xFB	; 251
    177a:	44 e0       	ldi	r20, 0x04	; 4
    177c:	50 e0       	ldi	r21, 0x00	; 0
    177e:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].subSteps), &(subStepsEE[i]), sizeof(double));
    1782:	b6 01       	movw	r22, r12
    1784:	65 5a       	subi	r22, 0xA5	; 165
    1786:	7f 4f       	sbci	r23, 0xFF	; 255
    1788:	c7 01       	movw	r24, r14
    178a:	8b 5f       	subi	r24, 0xFB	; 251
    178c:	9b 4f       	sbci	r25, 0xFB	; 251
    178e:	44 e0       	ldi	r20, 0x04	; 4
    1790:	50 e0       	ldi	r21, 0x00	; 0
    1792:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepMultiplier), &(stepMultiplierEE[i]), sizeof(double));
    1796:	b6 01       	movw	r22, r12
    1798:	65 59       	subi	r22, 0x95	; 149
    179a:	7f 4f       	sbci	r23, 0xFF	; 255
    179c:	c7 01       	movw	r24, r14
    179e:	86 5f       	subi	r24, 0xF6	; 246
    17a0:	9b 4f       	sbci	r25, 0xFB	; 251
    17a2:	44 e0       	ldi	r20, 0x04	; 4
    17a4:	50 e0       	ldi	r21, 0x00	; 0
    17a6:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
	    eeprom_update_block(&(motor[i].current), &(currentEE[i]), sizeof(double));
    17aa:	b6 01       	movw	r22, r12
    17ac:	65 58       	subi	r22, 0x85	; 133
    17ae:	7f 4f       	sbci	r23, 0xFF	; 255
    17b0:	c7 01       	movw	r24, r14
    17b2:	8d 5e       	subi	r24, 0xED	; 237
    17b4:	9b 4f       	sbci	r25, 0xFB	; 251
    17b6:	44 e0       	ldi	r20, 0x04	; 4
    17b8:	50 e0       	ldi	r21, 0x00	; 0
    17ba:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].decay), &(decayEE[i]), sizeof(int8_t));
    17be:	be 01       	movw	r22, r28
    17c0:	65 57       	subi	r22, 0x75	; 117
    17c2:	7f 4f       	sbci	r23, 0xFF	; 255
    17c4:	c7 01       	movw	r24, r14
    17c6:	89 5e       	subi	r24, 0xE9	; 233
    17c8:	9b 4f       	sbci	r25, 0xFB	; 251
    17ca:	41 e0       	ldi	r20, 0x01	; 1
    17cc:	50 e0       	ldi	r21, 0x00	; 0
    17ce:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepUnit), &(stepUnitEE[i]), sizeof(int8_t));
    17d2:	be 01       	movw	r22, r28
    17d4:	61 57       	subi	r22, 0x71	; 113
    17d6:	7f 4f       	sbci	r23, 0xFF	; 255
    17d8:	c7 01       	movw	r24, r14
    17da:	87 5f       	subi	r24, 0xF7	; 247
    17dc:	9b 4f       	sbci	r25, 0xFB	; 251
    17de:	41 e0       	ldi	r20, 0x01	; 1
    17e0:	50 e0       	ldi	r21, 0x00	; 0
    17e2:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].waitBetweenSteps), &(waitBetweenStepsEE[i]), sizeof(int16_t));
    17e6:	b5 01       	movw	r22, r10
    17e8:	6d 56       	subi	r22, 0x6D	; 109
    17ea:	7f 4f       	sbci	r23, 0xFF	; 255
    17ec:	c7 01       	movw	r24, r14
    17ee:	82 5f       	subi	r24, 0xF2	; 242
    17f0:	9b 4f       	sbci	r25, 0xFB	; 251
    17f2:	42 e0       	ldi	r20, 0x02	; 2
    17f4:	50 e0       	ldi	r21, 0x00	; 0
    17f6:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>

      eeprom_update_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
    17fa:	8e 01       	movw	r16, r28
    17fc:	00 0f       	add	r16, r16
    17fe:	11 1f       	adc	r17, r17
    1800:	00 0f       	add	r16, r16
    1802:	11 1f       	adc	r17, r17
    1804:	0c 0f       	add	r16, r28
    1806:	1d 1f       	adc	r17, r29
    1808:	b5 01       	movw	r22, r10
    180a:	65 56       	subi	r22, 0x65	; 101
    180c:	7f 4f       	sbci	r23, 0xFF	; 255
    180e:	c8 01       	movw	r24, r16
    1810:	8d 52       	subi	r24, 0x2D	; 45
    1812:	9c 4f       	sbci	r25, 0xFC	; 252
    1814:	42 e0       	ldi	r20, 0x02	; 2
    1816:	50 e0       	ldi	r21, 0x00	; 0
    1818:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
      eeprom_update_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    181c:	b5 01       	movw	r22, r10
    181e:	6d 55       	subi	r22, 0x5D	; 93
    1820:	7f 4f       	sbci	r23, 0xFF	; 255
    1822:	c8 01       	movw	r24, r16
    1824:	8b 52       	subi	r24, 0x2B	; 43
    1826:	9c 4f       	sbci	r25, 0xFC	; 252
    1828:	42 e0       	ldi	r20, 0x02	; 2
    182a:	50 e0       	ldi	r21, 0x00	; 0
    182c:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
    1830:	21 96       	adiw	r28, 0x01	; 1
    1832:	82 e0       	ldi	r24, 0x02	; 2
    1834:	90 e0       	ldi	r25, 0x00	; 0
    1836:	a8 0e       	add	r10, r24
    1838:	b9 1e       	adc	r11, r25
    183a:	84 e0       	ldi	r24, 0x04	; 4
    183c:	90 e0       	ldi	r25, 0x00	; 0
    183e:	c8 0e       	add	r12, r24
    1840:	d9 1e       	adc	r13, r25
void saveConfigToEEPROM(void){

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
    1842:	c4 30       	cpi	r28, 0x04	; 4
    1844:	d1 05       	cpc	r29, r1
    1846:	09 f0       	breq	.+2      	; 0x184a <saveConfigToEEPROM+0x152>
    1848:	68 cf       	rjmp	.-304    	; 0x171a <saveConfigToEEPROM+0x22>
    184a:	c0 e0       	ldi	r28, 0x00	; 0
    184c:	d0 e0       	ldi	r29, 0x00	; 0
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* save internal stored programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
      eeprom_update_block(&(programList[i]), &(programListEE[i]), sizeof(progStep));
    184e:	be 01       	movw	r22, r28
    1850:	65 55       	subi	r22, 0x55	; 85
    1852:	7f 4f       	sbci	r23, 0xFF	; 255
    1854:	ce 01       	movw	r24, r28
    1856:	8d 50       	subi	r24, 0x0D	; 13
    1858:	9d 4f       	sbci	r25, 0xFD	; 253
    185a:	4a e0       	ldi	r20, 0x0A	; 10
    185c:	50 e0       	ldi	r21, 0x00	; 0
    185e:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
    1862:	2a 96       	adiw	r28, 0x0a	; 10
      eeprom_update_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* save internal stored programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    1864:	c0 3a       	cpi	r28, 0xA0	; 160
    1866:	d1 05       	cpc	r29, r1
    1868:	91 f7       	brne	.-28     	; 0x184e <saveConfigToEEPROM+0x156>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    186a:	78 94       	sei
#endif

  }

  return;
}
    186c:	df 91       	pop	r29
    186e:	cf 91       	pop	r28
    1870:	1f 91       	pop	r17
    1872:	0f 91       	pop	r16
    1874:	ff 90       	pop	r15
    1876:	ef 90       	pop	r14
    1878:	df 90       	pop	r13
    187a:	cf 90       	pop	r12
    187c:	bf 90       	pop	r11
    187e:	af 90       	pop	r10
    1880:	08 95       	ret

00001882 <commandFactoryReset>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1882:	f8 94       	cli
    sets the whole system back to factory reset
 --------------------------------------------------------------------- */
void commandFactoryReset(void){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    initDataStructs();
    1884:	0e 94 40 03 	call	0x680	; 0x680 <initDataStructs>
    saveConfigToEEPROM();
    1888:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <saveConfigToEEPROM>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    188c:	78 94       	sei
  }

  return;
}
    188e:	08 95       	ret

00001890 <__vector_9>:
}

/* ---------------------------------------------------------------------
    handles all motor movement
 --------------------------------------------------------------------- */
ISR(TIMER2_COMPA_vect){
    1890:	1f 92       	push	r1
    1892:	0f 92       	push	r0
    1894:	0f b6       	in	r0, 0x3f	; 63
    1896:	0f 92       	push	r0
    1898:	0b b6       	in	r0, 0x3b	; 59
    189a:	0f 92       	push	r0
    189c:	11 24       	eor	r1, r1
    189e:	2f 92       	push	r2
    18a0:	3f 92       	push	r3
    18a2:	4f 92       	push	r4
    18a4:	5f 92       	push	r5
    18a6:	6f 92       	push	r6
    18a8:	7f 92       	push	r7
    18aa:	8f 92       	push	r8
    18ac:	9f 92       	push	r9
    18ae:	af 92       	push	r10
    18b0:	bf 92       	push	r11
    18b2:	cf 92       	push	r12
    18b4:	df 92       	push	r13
    18b6:	ef 92       	push	r14
    18b8:	ff 92       	push	r15
    18ba:	0f 93       	push	r16
    18bc:	1f 93       	push	r17
    18be:	2f 93       	push	r18
    18c0:	3f 93       	push	r19
    18c2:	4f 93       	push	r20
    18c4:	5f 93       	push	r21
    18c6:	6f 93       	push	r22
    18c8:	7f 93       	push	r23
    18ca:	8f 93       	push	r24
    18cc:	9f 93       	push	r25
    18ce:	af 93       	push	r26
    18d0:	bf 93       	push	r27
    18d2:	ef 93       	push	r30
    18d4:	ff 93       	push	r31
    18d6:	df 93       	push	r29
    18d8:	cf 93       	push	r28
    18da:	cd b7       	in	r28, 0x3d	; 61
    18dc:	de b7       	in	r29, 0x3e	; 62
    18de:	a0 97       	sbiw	r28, 0x20	; 32
    18e0:	de bf       	out	0x3e, r29	; 62
    18e2:	cd bf       	out	0x3d, r28	; 61
    18e4:	9e 01       	movw	r18, r28
    18e6:	27 5f       	subi	r18, 0xF7	; 247
    18e8:	3f 4f       	sbci	r19, 0xFF	; 255
    18ea:	3c 8f       	std	Y+28, r19	; 0x1c
    18ec:	2b 8f       	std	Y+27, r18	; 0x1b
    18ee:	3a 8f       	std	Y+26, r19	; 0x1a
    18f0:	29 8f       	std	Y+25, r18	; 0x19
    18f2:	18 a2       	std	Y+32, r1	; 0x20
    18f4:	1f 8e       	std	Y+31, r1	; 0x1f
    18f6:	66 24       	eor	r6, r6
    18f8:	77 24       	eor	r7, r7
    18fa:	1e 8e       	std	Y+30, r1	; 0x1e
    18fc:	1d 8e       	std	Y+29, r1	; 0x1d
  uint8_t outputStep = 0;

  double stepsPerFullRotation[MAX_MOTOR + 1];

  for(i = 0; i <= MAX_MOTOR; i++){
    stepDiff[i] = motor[i].desiredPosition - motor[i].actualPosition;
    18fe:	23 01       	movw	r4, r6
    1900:	44 0c       	add	r4, r4
    1902:	55 1c       	adc	r5, r5
    1904:	44 0c       	add	r4, r4
    1906:	55 1c       	adc	r5, r5
    1908:	42 01       	movw	r8, r4
    190a:	88 0c       	add	r8, r8
    190c:	99 1c       	adc	r9, r9
    190e:	88 0c       	add	r8, r8
    1910:	99 1c       	adc	r9, r9
    1912:	84 0c       	add	r8, r4
    1914:	95 1c       	adc	r9, r5
    1916:	88 0c       	add	r8, r8
    1918:	99 1c       	adc	r9, r9
    191a:	82 ef       	ldi	r24, 0xF2	; 242
    191c:	93 e0       	ldi	r25, 0x03	; 3
    191e:	88 0e       	add	r8, r24
    1920:	99 1e       	adc	r9, r25
    1922:	d4 01       	movw	r26, r8
    1924:	ad 90       	ld	r10, X+
    1926:	bc 90       	ld	r11, X
    1928:	13 01       	movw	r2, r6
    192a:	22 0c       	add	r2, r2
    192c:	33 1c       	adc	r3, r3
    192e:	22 0c       	add	r2, r2
    1930:	33 1c       	adc	r3, r3
    1932:	22 0c       	add	r2, r2
    1934:	33 1c       	adc	r3, r3
    1936:	61 01       	movw	r12, r2
    1938:	cc 0c       	add	r12, r12
    193a:	dd 1c       	adc	r13, r13
    193c:	cc 0c       	add	r12, r12
    193e:	dd 1c       	adc	r13, r13
    1940:	c2 0c       	add	r12, r2
    1942:	d3 1c       	adc	r13, r3
    1944:	e0 ef       	ldi	r30, 0xF0	; 240
    1946:	f3 e0       	ldi	r31, 0x03	; 3
    1948:	ce 0e       	add	r12, r30
    194a:	df 1e       	adc	r13, r31
    194c:	d6 01       	movw	r26, r12
    194e:	8d 91       	ld	r24, X+
    1950:	9c 91       	ld	r25, X
    1952:	11 97       	sbiw	r26, 0x01	; 1
    1954:	a8 1a       	sub	r10, r24
    1956:	b9 0a       	sbc	r11, r25
    1958:	e1 e0       	ldi	r30, 0x01	; 1
    195a:	f0 e0       	ldi	r31, 0x00	; 0
    195c:	ec 0f       	add	r30, r28
    195e:	fd 1f       	adc	r31, r29
    1960:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1962:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1964:	e2 0f       	add	r30, r18
    1966:	f3 1f       	adc	r31, r19
    1968:	b1 82       	std	Z+1, r11	; 0x01
    196a:	a0 82       	st	Z, r10

    stepsPerFullRotation[i] =  motor[i].gearRatio
    196c:	1d 96       	adiw	r26, 0x0d	; 13
    196e:	6d 91       	ld	r22, X+
    1970:	7d 91       	ld	r23, X+
    1972:	8d 91       	ld	r24, X+
    1974:	9c 91       	ld	r25, X
    1976:	50 97       	sbiw	r26, 0x10	; 16
    1978:	51 96       	adiw	r26, 0x11	; 17
    197a:	2d 91       	ld	r18, X+
    197c:	3d 91       	ld	r19, X+
    197e:	4d 91       	ld	r20, X+
    1980:	5c 91       	ld	r21, X
    1982:	54 97       	sbiw	r26, 0x14	; 20
    1984:	55 96       	adiw	r26, 0x15	; 21
    1986:	ed 90       	ld	r14, X+
    1988:	fd 90       	ld	r15, X+
    198a:	0d 91       	ld	r16, X+
    198c:	1c 91       	ld	r17, X
    198e:	58 97       	sbiw	r26, 0x18	; 24
    1990:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    1994:	a8 01       	movw	r20, r16
    1996:	97 01       	movw	r18, r14
    1998:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    199c:	a9 8d       	ldd	r26, Y+25	; 0x19
    199e:	ba 8d       	ldd	r27, Y+26	; 0x1a
    19a0:	6d 93       	st	X+, r22
    19a2:	7d 93       	st	X+, r23
    19a4:	8d 93       	st	X+, r24
    19a6:	9c 93       	st	X, r25
    19a8:	13 97       	sbiw	r26, 0x03	; 3
                              *motor[i].stepsPerFullRotation
                              *motor[i].subSteps;

    if(stepDiff[i] == 0){
    19aa:	a1 14       	cp	r10, r1
    19ac:	b1 04       	cpc	r11, r1
    19ae:	09 f4       	brne	.+2      	; 0x19b2 <__vector_9+0x122>
    19b0:	4c c0       	rjmp	.+152    	; 0x1a4a <__vector_9+0x1ba>
      /* no motor movement required */
      continue;
    }
    else{
      /* check if the wait-time between two steps is over */
      if(motor[i].delayCounter){
    19b2:	f6 01       	movw	r30, r12
    19b4:	80 a1       	ldd	r24, Z+32	; 0x20
    19b6:	91 a1       	ldd	r25, Z+33	; 0x21
    19b8:	89 2b       	or	r24, r25
    19ba:	09 f4       	brne	.+2      	; 0x19be <__vector_9+0x12e>
    19bc:	69 c1       	rjmp	.+722    	; 0x1c90 <__vector_9+0x400>
        /* seems not to be, so decrement */
        motor[i].delayCounter--;
    19be:	80 a1       	ldd	r24, Z+32	; 0x20
    19c0:	91 a1       	ldd	r25, Z+33	; 0x21
    19c2:	01 97       	sbiw	r24, 0x01	; 1
    19c4:	91 a3       	std	Z+33, r25	; 0x21
    19c6:	80 a3       	std	Z+32, r24	; 0x20

        /* and we also got time here to correct motor step error */
        if(motor[i].stepError > 1.0f){
    19c8:	66 81       	ldd	r22, Z+6	; 0x06
    19ca:	77 81       	ldd	r23, Z+7	; 0x07
    19cc:	80 85       	ldd	r24, Z+8	; 0x08
    19ce:	91 85       	ldd	r25, Z+9	; 0x09
    19d0:	20 e0       	ldi	r18, 0x00	; 0
    19d2:	30 e0       	ldi	r19, 0x00	; 0
    19d4:	40 e8       	ldi	r20, 0x80	; 128
    19d6:	5f e3       	ldi	r21, 0x3F	; 63
    19d8:	0e 94 40 41 	call	0x8280	; 0x8280 <__gesf2>
    19dc:	18 16       	cp	r1, r24
    19de:	d4 f4       	brge	.+52     	; 0x1a14 <__vector_9+0x184>
          motor[i].desiredPosition += 1;
    19e0:	d4 01       	movw	r26, r8
    19e2:	8d 91       	ld	r24, X+
    19e4:	9c 91       	ld	r25, X
    19e6:	11 97       	sbiw	r26, 0x01	; 1
    19e8:	01 96       	adiw	r24, 0x01	; 1
    19ea:	11 96       	adiw	r26, 0x01	; 1
    19ec:	9c 93       	st	X, r25
    19ee:	8e 93       	st	-X, r24
          motor[i].stepError -= 1.0f;
    19f0:	f6 01       	movw	r30, r12
    19f2:	66 81       	ldd	r22, Z+6	; 0x06
    19f4:	77 81       	ldd	r23, Z+7	; 0x07
    19f6:	80 85       	ldd	r24, Z+8	; 0x08
    19f8:	91 85       	ldd	r25, Z+9	; 0x09
    19fa:	20 e0       	ldi	r18, 0x00	; 0
    19fc:	30 e0       	ldi	r19, 0x00	; 0
    19fe:	40 e8       	ldi	r20, 0x80	; 128
    1a00:	5f e3       	ldi	r21, 0x3F	; 63
    1a02:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__subsf3>
    1a06:	d6 01       	movw	r26, r12
    1a08:	16 96       	adiw	r26, 0x06	; 6
    1a0a:	6d 93       	st	X+, r22
    1a0c:	7d 93       	st	X+, r23
    1a0e:	8d 93       	st	X+, r24
    1a10:	9c 93       	st	X, r25
    1a12:	19 97       	sbiw	r26, 0x09	; 9
        }
        if(motor[i].stepError < -1.0f){
    1a14:	61 01       	movw	r12, r2
    1a16:	cc 0c       	add	r12, r12
    1a18:	dd 1c       	adc	r13, r13
    1a1a:	cc 0c       	add	r12, r12
    1a1c:	dd 1c       	adc	r13, r13
    1a1e:	c2 0c       	add	r12, r2
    1a20:	d3 1c       	adc	r13, r3
    1a22:	e0 ef       	ldi	r30, 0xF0	; 240
    1a24:	f3 e0       	ldi	r31, 0x03	; 3
    1a26:	ce 0e       	add	r12, r30
    1a28:	df 1e       	adc	r13, r31
    1a2a:	d6 01       	movw	r26, r12
    1a2c:	16 96       	adiw	r26, 0x06	; 6
    1a2e:	6d 91       	ld	r22, X+
    1a30:	7d 91       	ld	r23, X+
    1a32:	8d 91       	ld	r24, X+
    1a34:	9c 91       	ld	r25, X
    1a36:	19 97       	sbiw	r26, 0x09	; 9
    1a38:	20 e0       	ldi	r18, 0x00	; 0
    1a3a:	30 e0       	ldi	r19, 0x00	; 0
    1a3c:	40 e8       	ldi	r20, 0x80	; 128
    1a3e:	5f eb       	ldi	r21, 0xBF	; 191
    1a40:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <__cmpsf2>
    1a44:	88 23       	and	r24, r24
    1a46:	0c f4       	brge	.+2      	; 0x1a4a <__vector_9+0x1ba>
    1a48:	0c c2       	rjmp	.+1048   	; 0x1e62 <__vector_9+0x5d2>
          else{
            outputStep |= (1 << (2*i));
          }
        }
        /* so we will move and therefore set back the delay counter */
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    1a4a:	08 94       	sec
    1a4c:	61 1c       	adc	r6, r1
    1a4e:	71 1c       	adc	r7, r1
    1a50:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1a52:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1a54:	2e 5f       	subi	r18, 0xFE	; 254
    1a56:	3f 4f       	sbci	r19, 0xFF	; 255
    1a58:	3e 8f       	std	Y+30, r19	; 0x1e
    1a5a:	2d 8f       	std	Y+29, r18	; 0x1d
    1a5c:	89 8d       	ldd	r24, Y+25	; 0x19
    1a5e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1a60:	04 96       	adiw	r24, 0x04	; 4
    1a62:	9a 8f       	std	Y+26, r25	; 0x1a
    1a64:	89 8f       	std	Y+25, r24	; 0x19
  uint8_t outputDir  = 0;
  uint8_t outputStep = 0;

  double stepsPerFullRotation[MAX_MOTOR + 1];

  for(i = 0; i <= MAX_MOTOR; i++){
    1a66:	94 e0       	ldi	r25, 0x04	; 4
    1a68:	69 16       	cp	r6, r25
    1a6a:	71 04       	cpc	r7, r1
    1a6c:	09 f0       	breq	.+2      	; 0x1a70 <__vector_9+0x1e0>
    1a6e:	47 cf       	rjmp	.-370    	; 0x18fe <__vector_9+0x6e>
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
      }
    }
  }

  PORTA |= outputDir;     /* set direction */
    1a70:	82 b1       	in	r24, 0x02	; 2
    1a72:	a8 a1       	ldd	r26, Y+32	; 0x20
    1a74:	a8 2b       	or	r26, r24
    1a76:	a2 b9       	out	0x02, r26	; 2
    1a78:	96 e0       	ldi	r25, 0x06	; 6
    1a7a:	89 2f       	mov	r24, r25
    1a7c:	8a 95       	dec	r24
    1a7e:	f1 f7       	brne	.-4      	; 0x1a7c <__vector_9+0x1ec>
  _delay_us(1.0);         /* sync */
  PORTA |= outputStep;    /* make exactly one step */
    1a80:	82 b1       	in	r24, 0x02	; 2
    1a82:	bf 8d       	ldd	r27, Y+31	; 0x1f
    1a84:	8b 2b       	or	r24, r27
    1a86:	82 b9       	out	0x02, r24	; 2
    1a88:	8d e0       	ldi	r24, 0x0D	; 13
    1a8a:	8a 95       	dec	r24
    1a8c:	f1 f7       	brne	.-4      	; 0x1a8a <__vector_9+0x1fa>
  _delay_us(2.0);         /* sync */
  PORTA &= ~outputStep;
    1a8e:	82 b1       	in	r24, 0x02	; 2
    1a90:	b0 95       	com	r27
    1a92:	b8 23       	and	r27, r24
    1a94:	b2 b9       	out	0x02, r27	; 2
    1a96:	9a 95       	dec	r25
    1a98:	f1 f7       	brne	.-4      	; 0x1a96 <__vector_9+0x206>
  _delay_us(1.0);
  PORTA = 0;
    1a9a:	12 b8       	out	0x02, r1	; 2
    1a9c:	3e 01       	movw	r6, r28
    1a9e:	08 94       	sec
    1aa0:	61 1c       	adc	r6, r1
    1aa2:	71 1c       	adc	r7, r1
    1aa4:	cc 24       	eor	r12, r12
    1aa6:	dd 24       	eor	r13, r13
    1aa8:	ec 2c       	mov	r14, r12
    1aaa:	5d 2c       	mov	r5, r13

  /* update motor positions */
  for(i = 0; i <= MAX_MOTOR; i++){
    if(motor[i].isMoving){
    1aac:	f6 01       	movw	r30, r12
    1aae:	ee 0f       	add	r30, r30
    1ab0:	ff 1f       	adc	r31, r31
    1ab2:	ee 0f       	add	r30, r30
    1ab4:	ff 1f       	adc	r31, r31
    1ab6:	ee 0f       	add	r30, r30
    1ab8:	ff 1f       	adc	r31, r31
    1aba:	cf 01       	movw	r24, r30
    1abc:	88 0f       	add	r24, r24
    1abe:	99 1f       	adc	r25, r25
    1ac0:	88 0f       	add	r24, r24
    1ac2:	99 1f       	adc	r25, r25
    1ac4:	e8 0f       	add	r30, r24
    1ac6:	f9 1f       	adc	r31, r25
    1ac8:	e0 51       	subi	r30, 0x10	; 16
    1aca:	fc 4f       	sbci	r31, 0xFC	; 252
    1acc:	82 85       	ldd	r24, Z+10	; 0x0a
    1ace:	88 23       	and	r24, r24
    1ad0:	09 f4       	brne	.+2      	; 0x1ad4 <__vector_9+0x244>
    1ad2:	a4 c0       	rjmp	.+328    	; 0x1c1c <__vector_9+0x38c>
      if(stepDiff[i] > 0){
    1ad4:	f3 01       	movw	r30, r6
    1ad6:	80 81       	ld	r24, Z
    1ad8:	91 81       	ldd	r25, Z+1	; 0x01
    1ada:	18 16       	cp	r1, r24
    1adc:	19 06       	cpc	r1, r25
    1ade:	0c f0       	brlt	.+2      	; 0x1ae2 <__vector_9+0x252>
    1ae0:	01 c1       	rjmp	.+514    	; 0x1ce4 <__vector_9+0x454>
        /* check if we got one full rotation */
        if(((motor[i].actualPosition) + 1) > stepsPerFullRotation[i]){
    1ae2:	f6 01       	movw	r30, r12
    1ae4:	ee 0f       	add	r30, r30
    1ae6:	ff 1f       	adc	r31, r31
    1ae8:	ee 0f       	add	r30, r30
    1aea:	ff 1f       	adc	r31, r31
    1aec:	ee 0f       	add	r30, r30
    1aee:	ff 1f       	adc	r31, r31
    1af0:	cf 01       	movw	r24, r30
    1af2:	88 0f       	add	r24, r24
    1af4:	99 1f       	adc	r25, r25
    1af6:	88 0f       	add	r24, r24
    1af8:	99 1f       	adc	r25, r25
    1afa:	e8 0f       	add	r30, r24
    1afc:	f9 1f       	adc	r31, r25
    1afe:	e0 51       	subi	r30, 0x10	; 16
    1b00:	fc 4f       	sbci	r31, 0xFC	; 252
    1b02:	60 81       	ld	r22, Z
    1b04:	71 81       	ldd	r23, Z+1	; 0x01
    1b06:	ab 8d       	ldd	r26, Y+27	; 0x1b
    1b08:	bc 8d       	ldd	r27, Y+28	; 0x1c
    1b0a:	8d 90       	ld	r8, X+
    1b0c:	9d 90       	ld	r9, X+
    1b0e:	ad 90       	ld	r10, X+
    1b10:	bc 90       	ld	r11, X
    1b12:	6f 5f       	subi	r22, 0xFF	; 255
    1b14:	7f 4f       	sbci	r23, 0xFF	; 255
    1b16:	88 27       	eor	r24, r24
    1b18:	77 fd       	sbrc	r23, 7
    1b1a:	80 95       	com	r24
    1b1c:	98 2f       	mov	r25, r24
    1b1e:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    1b22:	a5 01       	movw	r20, r10
    1b24:	94 01       	movw	r18, r8
    1b26:	0e 94 40 41 	call	0x8280	; 0x8280 <__gesf2>
    1b2a:	18 16       	cp	r1, r24
    1b2c:	0c f4       	brge	.+2      	; 0x1b30 <__vector_9+0x2a0>
    1b2e:	5a c1       	rjmp	.+692    	; 0x1de4 <__vector_9+0x554>
          /* so set back to 0 */
          motor[i].actualPosition = 0;
          /* correct desired motor position */
          motor[i].desiredPosition -= (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition++;
    1b30:	ee 2d       	mov	r30, r14
    1b32:	f5 2d       	mov	r31, r5
    1b34:	ee 0f       	add	r30, r30
    1b36:	ff 1f       	adc	r31, r31
    1b38:	ee 0f       	add	r30, r30
    1b3a:	ff 1f       	adc	r31, r31
    1b3c:	ee 0f       	add	r30, r30
    1b3e:	ff 1f       	adc	r31, r31
    1b40:	cf 01       	movw	r24, r30
    1b42:	88 0f       	add	r24, r24
    1b44:	99 1f       	adc	r25, r25
    1b46:	88 0f       	add	r24, r24
    1b48:	99 1f       	adc	r25, r25
    1b4a:	e8 0f       	add	r30, r24
    1b4c:	f9 1f       	adc	r31, r25
    1b4e:	e0 51       	subi	r30, 0x10	; 16
    1b50:	fc 4f       	sbci	r31, 0xFC	; 252
    1b52:	20 81       	ld	r18, Z
    1b54:	31 81       	ldd	r19, Z+1	; 0x01
    1b56:	2f 5f       	subi	r18, 0xFF	; 255
    1b58:	3f 4f       	sbci	r19, 0xFF	; 255
    1b5a:	ee 2d       	mov	r30, r14
    1b5c:	f5 2d       	mov	r31, r5
    1b5e:	ee 0f       	add	r30, r30
    1b60:	ff 1f       	adc	r31, r31
    1b62:	ee 0f       	add	r30, r30
    1b64:	ff 1f       	adc	r31, r31
    1b66:	ee 0f       	add	r30, r30
    1b68:	ff 1f       	adc	r31, r31
    1b6a:	cf 01       	movw	r24, r30
    1b6c:	88 0f       	add	r24, r24
    1b6e:	99 1f       	adc	r25, r25
    1b70:	88 0f       	add	r24, r24
    1b72:	99 1f       	adc	r25, r25
    1b74:	e8 0f       	add	r30, r24
    1b76:	f9 1f       	adc	r31, r25
    1b78:	e0 51       	subi	r30, 0x10	; 16
    1b7a:	fc 4f       	sbci	r31, 0xFC	; 252
    1b7c:	31 83       	std	Z+1, r19	; 0x01
    1b7e:	20 83       	st	Z, r18
        if(motor[i].isMovingInfinite){
    1b80:	ee 2d       	mov	r30, r14
    1b82:	f5 2d       	mov	r31, r5
    1b84:	ee 0f       	add	r30, r30
    1b86:	ff 1f       	adc	r31, r31
    1b88:	ee 0f       	add	r30, r30
    1b8a:	ff 1f       	adc	r31, r31
    1b8c:	ee 0f       	add	r30, r30
    1b8e:	ff 1f       	adc	r31, r31
    1b90:	cf 01       	movw	r24, r30
    1b92:	88 0f       	add	r24, r24
    1b94:	99 1f       	adc	r25, r25
    1b96:	88 0f       	add	r24, r24
    1b98:	99 1f       	adc	r25, r25
    1b9a:	e8 0f       	add	r30, r24
    1b9c:	f9 1f       	adc	r31, r25
    1b9e:	e0 51       	subi	r30, 0x10	; 16
    1ba0:	fc 4f       	sbci	r31, 0xFC	; 252
    1ba2:	84 85       	ldd	r24, Z+12	; 0x0c
    1ba4:	88 23       	and	r24, r24
    1ba6:	41 f1       	breq	.+80     	; 0x1bf8 <__vector_9+0x368>
          motor[i].desiredPosition += 1;
    1ba8:	ee 2d       	mov	r30, r14
    1baa:	f5 2d       	mov	r31, r5
    1bac:	ee 0f       	add	r30, r30
    1bae:	ff 1f       	adc	r31, r31
    1bb0:	ee 0f       	add	r30, r30
    1bb2:	ff 1f       	adc	r31, r31
    1bb4:	cf 01       	movw	r24, r30
    1bb6:	88 0f       	add	r24, r24
    1bb8:	99 1f       	adc	r25, r25
    1bba:	88 0f       	add	r24, r24
    1bbc:	99 1f       	adc	r25, r25
    1bbe:	e8 0f       	add	r30, r24
    1bc0:	f9 1f       	adc	r31, r25
    1bc2:	ee 0f       	add	r30, r30
    1bc4:	ff 1f       	adc	r31, r31
    1bc6:	ee 50       	subi	r30, 0x0E	; 14
    1bc8:	fc 4f       	sbci	r31, 0xFC	; 252
    1bca:	20 81       	ld	r18, Z
    1bcc:	31 81       	ldd	r19, Z+1	; 0x01
    1bce:	2f 5f       	subi	r18, 0xFF	; 255
    1bd0:	3f 4f       	sbci	r19, 0xFF	; 255
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition--;
        if(motor[i].isMovingInfinite){
          motor[i].desiredPosition += -1;
    1bd2:	ee 2d       	mov	r30, r14
    1bd4:	f5 2d       	mov	r31, r5
    1bd6:	ee 0f       	add	r30, r30
    1bd8:	ff 1f       	adc	r31, r31
    1bda:	ee 0f       	add	r30, r30
    1bdc:	ff 1f       	adc	r31, r31
    1bde:	cf 01       	movw	r24, r30
    1be0:	88 0f       	add	r24, r24
    1be2:	99 1f       	adc	r25, r25
    1be4:	88 0f       	add	r24, r24
    1be6:	99 1f       	adc	r25, r25
    1be8:	e8 0f       	add	r30, r24
    1bea:	f9 1f       	adc	r31, r25
    1bec:	ee 0f       	add	r30, r30
    1bee:	ff 1f       	adc	r31, r31
    1bf0:	ee 50       	subi	r30, 0x0E	; 14
    1bf2:	fc 4f       	sbci	r31, 0xFC	; 252
    1bf4:	31 83       	std	Z+1, r19	; 0x01
    1bf6:	20 83       	st	Z, r18
        }
      }
      motor[i].isMoving = 0;
    1bf8:	ee 2d       	mov	r30, r14
    1bfa:	f5 2d       	mov	r31, r5
    1bfc:	ee 0f       	add	r30, r30
    1bfe:	ff 1f       	adc	r31, r31
    1c00:	ee 0f       	add	r30, r30
    1c02:	ff 1f       	adc	r31, r31
    1c04:	ee 0f       	add	r30, r30
    1c06:	ff 1f       	adc	r31, r31
    1c08:	cf 01       	movw	r24, r30
    1c0a:	88 0f       	add	r24, r24
    1c0c:	99 1f       	adc	r25, r25
    1c0e:	88 0f       	add	r24, r24
    1c10:	99 1f       	adc	r25, r25
    1c12:	e8 0f       	add	r30, r24
    1c14:	f9 1f       	adc	r31, r25
    1c16:	e0 51       	subi	r30, 0x10	; 16
    1c18:	fc 4f       	sbci	r31, 0xFC	; 252
    1c1a:	12 86       	std	Z+10, r1	; 0x0a
    1c1c:	08 94       	sec
    1c1e:	c1 1c       	adc	r12, r1
    1c20:	d1 1c       	adc	r13, r1
    1c22:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1c24:	3c 8d       	ldd	r19, Y+28	; 0x1c
    1c26:	2c 5f       	subi	r18, 0xFC	; 252
    1c28:	3f 4f       	sbci	r19, 0xFF	; 255
    1c2a:	3c 8f       	std	Y+28, r19	; 0x1c
    1c2c:	2b 8f       	std	Y+27, r18	; 0x1b
    1c2e:	82 e0       	ldi	r24, 0x02	; 2
    1c30:	90 e0       	ldi	r25, 0x00	; 0
    1c32:	68 0e       	add	r6, r24
    1c34:	79 1e       	adc	r7, r25
  PORTA &= ~outputStep;
  _delay_us(1.0);
  PORTA = 0;

  /* update motor positions */
  for(i = 0; i <= MAX_MOTOR; i++){
    1c36:	94 e0       	ldi	r25, 0x04	; 4
    1c38:	c9 16       	cp	r12, r25
    1c3a:	d1 04       	cpc	r13, r1
    1c3c:	09 f0       	breq	.+2      	; 0x1c40 <__vector_9+0x3b0>
    1c3e:	34 cf       	rjmp	.-408    	; 0x1aa8 <__vector_9+0x218>
        }
      }
      motor[i].isMoving = 0;
    }
  }
}
    1c40:	a0 96       	adiw	r28, 0x20	; 32
    1c42:	de bf       	out	0x3e, r29	; 62
    1c44:	cd bf       	out	0x3d, r28	; 61
    1c46:	cf 91       	pop	r28
    1c48:	df 91       	pop	r29
    1c4a:	ff 91       	pop	r31
    1c4c:	ef 91       	pop	r30
    1c4e:	bf 91       	pop	r27
    1c50:	af 91       	pop	r26
    1c52:	9f 91       	pop	r25
    1c54:	8f 91       	pop	r24
    1c56:	7f 91       	pop	r23
    1c58:	6f 91       	pop	r22
    1c5a:	5f 91       	pop	r21
    1c5c:	4f 91       	pop	r20
    1c5e:	3f 91       	pop	r19
    1c60:	2f 91       	pop	r18
    1c62:	1f 91       	pop	r17
    1c64:	0f 91       	pop	r16
    1c66:	ff 90       	pop	r15
    1c68:	ef 90       	pop	r14
    1c6a:	df 90       	pop	r13
    1c6c:	cf 90       	pop	r12
    1c6e:	bf 90       	pop	r11
    1c70:	af 90       	pop	r10
    1c72:	9f 90       	pop	r9
    1c74:	8f 90       	pop	r8
    1c76:	7f 90       	pop	r7
    1c78:	6f 90       	pop	r6
    1c7a:	5f 90       	pop	r5
    1c7c:	4f 90       	pop	r4
    1c7e:	3f 90       	pop	r3
    1c80:	2f 90       	pop	r2
    1c82:	0f 90       	pop	r0
    1c84:	0b be       	out	0x3b, r0	; 59
    1c86:	0f 90       	pop	r0
    1c88:	0f be       	out	0x3f, r0	; 63
    1c8a:	0f 90       	pop	r0
    1c8c:	1f 90       	pop	r1
    1c8e:	18 95       	reti
          motor[i].stepError += 1.0f;
        }
      }
      else{
        /* here we just waited the specified time between two steps */
        motor[i].isMoving = 1;
    1c90:	21 e0       	ldi	r18, 0x01	; 1
    1c92:	f6 01       	movw	r30, r12
    1c94:	22 87       	std	Z+10, r18	; 0x0a

        if(stepDiff[i] < 0){
    1c96:	b7 fc       	sbrc	r11, 7
    1c98:	07 c1       	rjmp	.+526    	; 0x1ea8 <__vector_9+0x618>
          }
        }
        else{
          /* moving CW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1c9a:	f2 01       	movw	r30, r4
    1c9c:	e6 0d       	add	r30, r6
    1c9e:	f7 1d       	adc	r31, r7
    1ca0:	ed 52       	subi	r30, 0x2D	; 45
    1ca2:	fc 4f       	sbci	r31, 0xFC	; 252
    1ca4:	84 81       	ldd	r24, Z+4	; 0x04
    1ca6:	88 23       	and	r24, r24
    1ca8:	09 f0       	breq	.+2      	; 0x1cac <__vector_9+0x41c>
    1caa:	88 c0       	rjmp	.+272    	; 0x1dbc <__vector_9+0x52c>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].start)){
            motor[i].desiredPosition = motor[i].actualPosition;
            motor[i].isMoving = 0;
          }
          else{
            outputStep |= (1 << (2*i));
    1cac:	81 e0       	ldi	r24, 0x01	; 1
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	0d 8c       	ldd	r0, Y+29	; 0x1d
    1cb2:	02 c0       	rjmp	.+4      	; 0x1cb8 <__vector_9+0x428>
    1cb4:	88 0f       	add	r24, r24
    1cb6:	99 1f       	adc	r25, r25
    1cb8:	0a 94       	dec	r0
    1cba:	e2 f7       	brpl	.-8      	; 0x1cb4 <__vector_9+0x424>
    1cbc:	ff 8d       	ldd	r31, Y+31	; 0x1f
    1cbe:	f8 2b       	or	r31, r24
    1cc0:	ff 8f       	std	Y+31, r31	; 0x1f
          }
        }
        /* so we will move and therefore set back the delay counter */
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    1cc2:	f1 01       	movw	r30, r2
    1cc4:	ee 0f       	add	r30, r30
    1cc6:	ff 1f       	adc	r31, r31
    1cc8:	ee 0f       	add	r30, r30
    1cca:	ff 1f       	adc	r31, r31
    1ccc:	e2 0d       	add	r30, r2
    1cce:	f3 1d       	adc	r31, r3
    1cd0:	e0 51       	subi	r30, 0x10	; 16
    1cd2:	fc 4f       	sbci	r31, 0xFC	; 252
    1cd4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cd6:	97 8d       	ldd	r25, Z+31	; 0x1f
    1cd8:	88 0f       	add	r24, r24
    1cda:	99 1f       	adc	r25, r25
    1cdc:	01 97       	sbiw	r24, 0x01	; 1
    1cde:	91 a3       	std	Z+33, r25	; 0x21
    1ce0:	80 a3       	std	Z+32, r24	; 0x20
    1ce2:	b3 ce       	rjmp	.-666    	; 0x1a4a <__vector_9+0x1ba>
        motor[i].actualPosition++;
        if(motor[i].isMovingInfinite){
          motor[i].desiredPosition += 1;
        }
      }
      else if(stepDiff[i] < 0){
    1ce4:	89 2b       	or	r24, r25
    1ce6:	09 f4       	brne	.+2      	; 0x1cea <__vector_9+0x45a>
    1ce8:	87 cf       	rjmp	.-242    	; 0x1bf8 <__vector_9+0x368>
      /* check if we got one full rotation */
        if(((motor[i].actualPosition) - 1) < 0){
    1cea:	f6 01       	movw	r30, r12
    1cec:	ee 0f       	add	r30, r30
    1cee:	ff 1f       	adc	r31, r31
    1cf0:	ee 0f       	add	r30, r30
    1cf2:	ff 1f       	adc	r31, r31
    1cf4:	ee 0f       	add	r30, r30
    1cf6:	ff 1f       	adc	r31, r31
    1cf8:	cf 01       	movw	r24, r30
    1cfa:	88 0f       	add	r24, r24
    1cfc:	99 1f       	adc	r25, r25
    1cfe:	88 0f       	add	r24, r24
    1d00:	99 1f       	adc	r25, r25
    1d02:	e8 0f       	add	r30, r24
    1d04:	f9 1f       	adc	r31, r25
    1d06:	e0 51       	subi	r30, 0x10	; 16
    1d08:	fc 4f       	sbci	r31, 0xFC	; 252
    1d0a:	80 81       	ld	r24, Z
    1d0c:	91 81       	ldd	r25, Z+1	; 0x01
    1d0e:	18 16       	cp	r1, r24
    1d10:	19 06       	cpc	r1, r25
    1d12:	0c f0       	brlt	.+2      	; 0x1d16 <__vector_9+0x486>
    1d14:	fd c0       	rjmp	.+506    	; 0x1f10 <__vector_9+0x680>
          /* so set back to max steps per round */
          motor[i].actualPosition = (int16_t)round(stepsPerFullRotation[i]);
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition--;
    1d16:	ee 2d       	mov	r30, r14
    1d18:	f5 2d       	mov	r31, r5
    1d1a:	ee 0f       	add	r30, r30
    1d1c:	ff 1f       	adc	r31, r31
    1d1e:	ee 0f       	add	r30, r30
    1d20:	ff 1f       	adc	r31, r31
    1d22:	ee 0f       	add	r30, r30
    1d24:	ff 1f       	adc	r31, r31
    1d26:	cf 01       	movw	r24, r30
    1d28:	88 0f       	add	r24, r24
    1d2a:	99 1f       	adc	r25, r25
    1d2c:	88 0f       	add	r24, r24
    1d2e:	99 1f       	adc	r25, r25
    1d30:	e8 0f       	add	r30, r24
    1d32:	f9 1f       	adc	r31, r25
    1d34:	e0 51       	subi	r30, 0x10	; 16
    1d36:	fc 4f       	sbci	r31, 0xFC	; 252
    1d38:	20 81       	ld	r18, Z
    1d3a:	31 81       	ldd	r19, Z+1	; 0x01
    1d3c:	21 50       	subi	r18, 0x01	; 1
    1d3e:	30 40       	sbci	r19, 0x00	; 0
    1d40:	ee 2d       	mov	r30, r14
    1d42:	f5 2d       	mov	r31, r5
    1d44:	ee 0f       	add	r30, r30
    1d46:	ff 1f       	adc	r31, r31
    1d48:	ee 0f       	add	r30, r30
    1d4a:	ff 1f       	adc	r31, r31
    1d4c:	ee 0f       	add	r30, r30
    1d4e:	ff 1f       	adc	r31, r31
    1d50:	cf 01       	movw	r24, r30
    1d52:	88 0f       	add	r24, r24
    1d54:	99 1f       	adc	r25, r25
    1d56:	88 0f       	add	r24, r24
    1d58:	99 1f       	adc	r25, r25
    1d5a:	e8 0f       	add	r30, r24
    1d5c:	f9 1f       	adc	r31, r25
    1d5e:	e0 51       	subi	r30, 0x10	; 16
    1d60:	fc 4f       	sbci	r31, 0xFC	; 252
    1d62:	31 83       	std	Z+1, r19	; 0x01
    1d64:	20 83       	st	Z, r18
        if(motor[i].isMovingInfinite){
    1d66:	ee 2d       	mov	r30, r14
    1d68:	f5 2d       	mov	r31, r5
    1d6a:	ee 0f       	add	r30, r30
    1d6c:	ff 1f       	adc	r31, r31
    1d6e:	ee 0f       	add	r30, r30
    1d70:	ff 1f       	adc	r31, r31
    1d72:	ee 0f       	add	r30, r30
    1d74:	ff 1f       	adc	r31, r31
    1d76:	cf 01       	movw	r24, r30
    1d78:	88 0f       	add	r24, r24
    1d7a:	99 1f       	adc	r25, r25
    1d7c:	88 0f       	add	r24, r24
    1d7e:	99 1f       	adc	r25, r25
    1d80:	e8 0f       	add	r30, r24
    1d82:	f9 1f       	adc	r31, r25
    1d84:	e0 51       	subi	r30, 0x10	; 16
    1d86:	fc 4f       	sbci	r31, 0xFC	; 252
    1d88:	84 85       	ldd	r24, Z+12	; 0x0c
    1d8a:	88 23       	and	r24, r24
    1d8c:	09 f4       	brne	.+2      	; 0x1d90 <__vector_9+0x500>
    1d8e:	34 cf       	rjmp	.-408    	; 0x1bf8 <__vector_9+0x368>
          motor[i].desiredPosition += -1;
    1d90:	ee 2d       	mov	r30, r14
    1d92:	f5 2d       	mov	r31, r5
    1d94:	ee 0f       	add	r30, r30
    1d96:	ff 1f       	adc	r31, r31
    1d98:	ee 0f       	add	r30, r30
    1d9a:	ff 1f       	adc	r31, r31
    1d9c:	cf 01       	movw	r24, r30
    1d9e:	88 0f       	add	r24, r24
    1da0:	99 1f       	adc	r25, r25
    1da2:	88 0f       	add	r24, r24
    1da4:	99 1f       	adc	r25, r25
    1da6:	e8 0f       	add	r30, r24
    1da8:	f9 1f       	adc	r31, r25
    1daa:	ee 0f       	add	r30, r30
    1dac:	ff 1f       	adc	r31, r31
    1dae:	ee 50       	subi	r30, 0x0E	; 14
    1db0:	fc 4f       	sbci	r31, 0xFC	; 252
    1db2:	20 81       	ld	r18, Z
    1db4:	31 81       	ldd	r19, Z+1	; 0x01
    1db6:	21 50       	subi	r18, 0x01	; 1
    1db8:	30 40       	sbci	r19, 0x00	; 0
    1dba:	0b cf       	rjmp	.-490    	; 0x1bd2 <__vector_9+0x342>
          }
        }
        else{
          /* moving CW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1dbc:	d6 01       	movw	r26, r12
    1dbe:	8d 91       	ld	r24, X+
    1dc0:	9c 91       	ld	r25, X
    1dc2:	11 97       	sbiw	r26, 0x01	; 1
    1dc4:	20 81       	ld	r18, Z
    1dc6:	31 81       	ldd	r19, Z+1	; 0x01
    1dc8:	01 96       	adiw	r24, 0x01	; 1
    1dca:	82 17       	cp	r24, r18
    1dcc:	93 07       	cpc	r25, r19
    1dce:	09 f0       	breq	.+2      	; 0x1dd2 <__vector_9+0x542>
    1dd0:	6d cf       	rjmp	.-294    	; 0x1cac <__vector_9+0x41c>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].start)){
            motor[i].desiredPosition = motor[i].actualPosition;
    1dd2:	8d 91       	ld	r24, X+
    1dd4:	9c 91       	ld	r25, X
    1dd6:	11 97       	sbiw	r26, 0x01	; 1
    1dd8:	f4 01       	movw	r30, r8
    1dda:	91 83       	std	Z+1, r25	; 0x01
    1ddc:	80 83       	st	Z, r24
            motor[i].isMoving = 0;
    1dde:	1a 96       	adiw	r26, 0x0a	; 10
    1de0:	1c 92       	st	X, r1
    1de2:	6f cf       	rjmp	.-290    	; 0x1cc2 <__vector_9+0x432>
    if(motor[i].isMoving){
      if(stepDiff[i] > 0){
        /* check if we got one full rotation */
        if(((motor[i].actualPosition) + 1) > stepsPerFullRotation[i]){
          /* so set back to 0 */
          motor[i].actualPosition = 0;
    1de4:	f6 01       	movw	r30, r12
    1de6:	ee 0f       	add	r30, r30
    1de8:	ff 1f       	adc	r31, r31
    1dea:	ee 0f       	add	r30, r30
    1dec:	ff 1f       	adc	r31, r31
    1dee:	ee 0f       	add	r30, r30
    1df0:	ff 1f       	adc	r31, r31
    1df2:	cf 01       	movw	r24, r30
    1df4:	88 0f       	add	r24, r24
    1df6:	99 1f       	adc	r25, r25
    1df8:	88 0f       	add	r24, r24
    1dfa:	99 1f       	adc	r25, r25
    1dfc:	e8 0f       	add	r30, r24
    1dfe:	f9 1f       	adc	r31, r25
    1e00:	e0 51       	subi	r30, 0x10	; 16
    1e02:	fc 4f       	sbci	r31, 0xFC	; 252
    1e04:	11 82       	std	Z+1, r1	; 0x01
    1e06:	10 82       	st	Z, r1
          /* correct desired motor position */
          motor[i].desiredPosition -= (int16_t)round(stepsPerFullRotation[i]);
    1e08:	f6 01       	movw	r30, r12
    1e0a:	ee 0f       	add	r30, r30
    1e0c:	ff 1f       	adc	r31, r31
    1e0e:	ee 0f       	add	r30, r30
    1e10:	ff 1f       	adc	r31, r31
    1e12:	cf 01       	movw	r24, r30
    1e14:	88 0f       	add	r24, r24
    1e16:	99 1f       	adc	r25, r25
    1e18:	88 0f       	add	r24, r24
    1e1a:	99 1f       	adc	r25, r25
    1e1c:	e8 0f       	add	r30, r24
    1e1e:	f9 1f       	adc	r31, r25
    1e20:	ee 0f       	add	r30, r30
    1e22:	ff 1f       	adc	r31, r31
    1e24:	ee 50       	subi	r30, 0x0E	; 14
    1e26:	fc 4f       	sbci	r31, 0xFC	; 252
    1e28:	00 81       	ld	r16, Z
    1e2a:	11 81       	ldd	r17, Z+1	; 0x01
    1e2c:	c5 01       	movw	r24, r10
    1e2e:	b4 01       	movw	r22, r8
    1e30:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    1e34:	0e 94 0a 40 	call	0x8014	; 0x8014 <__fixsfsi>
    1e38:	06 1b       	sub	r16, r22
    1e3a:	17 0b       	sbc	r17, r23
    1e3c:	f6 01       	movw	r30, r12
    1e3e:	ee 0f       	add	r30, r30
    1e40:	ff 1f       	adc	r31, r31
    1e42:	ee 0f       	add	r30, r30
    1e44:	ff 1f       	adc	r31, r31
    1e46:	cf 01       	movw	r24, r30
    1e48:	88 0f       	add	r24, r24
    1e4a:	99 1f       	adc	r25, r25
    1e4c:	88 0f       	add	r24, r24
    1e4e:	99 1f       	adc	r25, r25
    1e50:	e8 0f       	add	r30, r24
    1e52:	f9 1f       	adc	r31, r25
    1e54:	ee 0f       	add	r30, r30
    1e56:	ff 1f       	adc	r31, r31
    1e58:	ee 50       	subi	r30, 0x0E	; 14
    1e5a:	fc 4f       	sbci	r31, 0xFC	; 252
    1e5c:	11 83       	std	Z+1, r17	; 0x01
    1e5e:	00 83       	st	Z, r16
    1e60:	67 ce       	rjmp	.-818    	; 0x1b30 <__vector_9+0x2a0>
        if(motor[i].stepError > 1.0f){
          motor[i].desiredPosition += 1;
          motor[i].stepError -= 1.0f;
        }
        if(motor[i].stepError < -1.0f){
          motor[i].desiredPosition += -1;
    1e62:	f2 01       	movw	r30, r4
    1e64:	ee 0f       	add	r30, r30
    1e66:	ff 1f       	adc	r31, r31
    1e68:	ee 0f       	add	r30, r30
    1e6a:	ff 1f       	adc	r31, r31
    1e6c:	e4 0d       	add	r30, r4
    1e6e:	f5 1d       	adc	r31, r5
    1e70:	ee 0f       	add	r30, r30
    1e72:	ff 1f       	adc	r31, r31
    1e74:	ee 50       	subi	r30, 0x0E	; 14
    1e76:	fc 4f       	sbci	r31, 0xFC	; 252
    1e78:	80 81       	ld	r24, Z
    1e7a:	91 81       	ldd	r25, Z+1	; 0x01
    1e7c:	01 97       	sbiw	r24, 0x01	; 1
    1e7e:	91 83       	std	Z+1, r25	; 0x01
    1e80:	80 83       	st	Z, r24
          motor[i].stepError += 1.0f;
    1e82:	f6 01       	movw	r30, r12
    1e84:	66 81       	ldd	r22, Z+6	; 0x06
    1e86:	77 81       	ldd	r23, Z+7	; 0x07
    1e88:	80 85       	ldd	r24, Z+8	; 0x08
    1e8a:	91 85       	ldd	r25, Z+9	; 0x09
    1e8c:	20 e0       	ldi	r18, 0x00	; 0
    1e8e:	30 e0       	ldi	r19, 0x00	; 0
    1e90:	40 e8       	ldi	r20, 0x80	; 128
    1e92:	5f e3       	ldi	r21, 0x3F	; 63
    1e94:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <__addsf3>
    1e98:	d6 01       	movw	r26, r12
    1e9a:	16 96       	adiw	r26, 0x06	; 6
    1e9c:	6d 93       	st	X+, r22
    1e9e:	7d 93       	st	X+, r23
    1ea0:	8d 93       	st	X+, r24
    1ea2:	9c 93       	st	X, r25
    1ea4:	19 97       	sbiw	r26, 0x09	; 9
    1ea6:	d1 cd       	rjmp	.-1118   	; 0x1a4a <__vector_9+0x1ba>
        motor[i].isMoving = 1;

        if(stepDiff[i] < 0){
          /* moving CCW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1ea8:	f2 01       	movw	r30, r4
    1eaa:	e6 0d       	add	r30, r6
    1eac:	f7 1d       	adc	r31, r7
    1eae:	ed 52       	subi	r30, 0x2D	; 45
    1eb0:	fc 4f       	sbci	r31, 0xFC	; 252
    1eb2:	84 81       	ldd	r24, Z+4	; 0x04
    1eb4:	88 23       	and	r24, r24
    1eb6:	09 f5       	brne	.+66     	; 0x1efa <__vector_9+0x66a>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].stop)){
            motor[i].desiredPosition = motor[i].actualPosition;
            motor[i].isMoving = 0;
          }
          else{
            outputDir  |= (1 << (2*i + 1)); /* 1 = CCW, 0 = CW */
    1eb8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1eba:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1ebc:	2f 5f       	subi	r18, 0xFF	; 255
    1ebe:	3f 4f       	sbci	r19, 0xFF	; 255
    1ec0:	3e 8f       	std	Y+30, r19	; 0x1e
    1ec2:	2d 8f       	std	Y+29, r18	; 0x1d
    1ec4:	81 e0       	ldi	r24, 0x01	; 1
    1ec6:	90 e0       	ldi	r25, 0x00	; 0
    1ec8:	0d 8c       	ldd	r0, Y+29	; 0x1d
    1eca:	02 c0       	rjmp	.+4      	; 0x1ed0 <__vector_9+0x640>
    1ecc:	88 0f       	add	r24, r24
    1ece:	99 1f       	adc	r25, r25
    1ed0:	0a 94       	dec	r0
    1ed2:	e2 f7       	brpl	.-8      	; 0x1ecc <__vector_9+0x63c>
    1ed4:	21 50       	subi	r18, 0x01	; 1
    1ed6:	30 40       	sbci	r19, 0x00	; 0
    1ed8:	3e 8f       	std	Y+30, r19	; 0x1e
    1eda:	2d 8f       	std	Y+29, r18	; 0x1d
    1edc:	38 a1       	ldd	r19, Y+32	; 0x20
    1ede:	38 2b       	or	r19, r24
    1ee0:	38 a3       	std	Y+32, r19	; 0x20
            outputStep |= (1 << (2*i));
    1ee2:	81 e0       	ldi	r24, 0x01	; 1
    1ee4:	90 e0       	ldi	r25, 0x00	; 0
    1ee6:	0d 8c       	ldd	r0, Y+29	; 0x1d
    1ee8:	02 c0       	rjmp	.+4      	; 0x1eee <__vector_9+0x65e>
    1eea:	88 0f       	add	r24, r24
    1eec:	99 1f       	adc	r25, r25
    1eee:	0a 94       	dec	r0
    1ef0:	e2 f7       	brpl	.-8      	; 0x1eea <__vector_9+0x65a>
    1ef2:	af 8d       	ldd	r26, Y+31	; 0x1f
    1ef4:	a8 2b       	or	r26, r24
    1ef6:	af 8f       	std	Y+31, r26	; 0x1f
    1ef8:	e4 ce       	rjmp	.-568    	; 0x1cc2 <__vector_9+0x432>
        motor[i].isMoving = 1;

        if(stepDiff[i] < 0){
          /* moving CCW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1efa:	d6 01       	movw	r26, r12
    1efc:	8d 91       	ld	r24, X+
    1efe:	9c 91       	ld	r25, X
    1f00:	11 97       	sbiw	r26, 0x01	; 1
    1f02:	22 81       	ldd	r18, Z+2	; 0x02
    1f04:	33 81       	ldd	r19, Z+3	; 0x03
    1f06:	01 96       	adiw	r24, 0x01	; 1
    1f08:	82 17       	cp	r24, r18
    1f0a:	93 07       	cpc	r25, r19
    1f0c:	a9 f6       	brne	.-86     	; 0x1eb8 <__vector_9+0x628>
    1f0e:	61 cf       	rjmp	.-318    	; 0x1dd2 <__vector_9+0x542>
      }
      else if(stepDiff[i] < 0){
      /* check if we got one full rotation */
        if(((motor[i].actualPosition) - 1) < 0){
          /* so set back to max steps per round */
          motor[i].actualPosition = (int16_t)round(stepsPerFullRotation[i]);
    1f10:	eb 8d       	ldd	r30, Y+27	; 0x1b
    1f12:	fc 8d       	ldd	r31, Y+28	; 0x1c
    1f14:	60 81       	ld	r22, Z
    1f16:	71 81       	ldd	r23, Z+1	; 0x01
    1f18:	82 81       	ldd	r24, Z+2	; 0x02
    1f1a:	93 81       	ldd	r25, Z+3	; 0x03
    1f1c:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    1f20:	0e 94 0a 40 	call	0x8014	; 0x8014 <__fixsfsi>
    1f24:	ab 01       	movw	r20, r22
    1f26:	f6 01       	movw	r30, r12
    1f28:	ee 0f       	add	r30, r30
    1f2a:	ff 1f       	adc	r31, r31
    1f2c:	ee 0f       	add	r30, r30
    1f2e:	ff 1f       	adc	r31, r31
    1f30:	ee 0f       	add	r30, r30
    1f32:	ff 1f       	adc	r31, r31
    1f34:	9f 01       	movw	r18, r30
    1f36:	22 0f       	add	r18, r18
    1f38:	33 1f       	adc	r19, r19
    1f3a:	22 0f       	add	r18, r18
    1f3c:	33 1f       	adc	r19, r19
    1f3e:	e2 0f       	add	r30, r18
    1f40:	f3 1f       	adc	r31, r19
    1f42:	e0 51       	subi	r30, 0x10	; 16
    1f44:	fc 4f       	sbci	r31, 0xFC	; 252
    1f46:	71 83       	std	Z+1, r23	; 0x01
    1f48:	60 83       	st	Z, r22
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
    1f4a:	f6 01       	movw	r30, r12
    1f4c:	ee 0f       	add	r30, r30
    1f4e:	ff 1f       	adc	r31, r31
    1f50:	ee 0f       	add	r30, r30
    1f52:	ff 1f       	adc	r31, r31
    1f54:	cf 01       	movw	r24, r30
    1f56:	88 0f       	add	r24, r24
    1f58:	99 1f       	adc	r25, r25
    1f5a:	88 0f       	add	r24, r24
    1f5c:	99 1f       	adc	r25, r25
    1f5e:	e8 0f       	add	r30, r24
    1f60:	f9 1f       	adc	r31, r25
    1f62:	ee 0f       	add	r30, r30
    1f64:	ff 1f       	adc	r31, r31
    1f66:	ee 50       	subi	r30, 0x0E	; 14
    1f68:	fc 4f       	sbci	r31, 0xFC	; 252
    1f6a:	80 81       	ld	r24, Z
    1f6c:	91 81       	ldd	r25, Z+1	; 0x01
    1f6e:	48 0f       	add	r20, r24
    1f70:	59 1f       	adc	r21, r25
    1f72:	f6 01       	movw	r30, r12
    1f74:	ee 0f       	add	r30, r30
    1f76:	ff 1f       	adc	r31, r31
    1f78:	ee 0f       	add	r30, r30
    1f7a:	ff 1f       	adc	r31, r31
    1f7c:	cf 01       	movw	r24, r30
    1f7e:	88 0f       	add	r24, r24
    1f80:	99 1f       	adc	r25, r25
    1f82:	88 0f       	add	r24, r24
    1f84:	99 1f       	adc	r25, r25
    1f86:	e8 0f       	add	r30, r24
    1f88:	f9 1f       	adc	r31, r25
    1f8a:	ee 0f       	add	r30, r30
    1f8c:	ff 1f       	adc	r31, r31
    1f8e:	ee 50       	subi	r30, 0x0E	; 14
    1f90:	fc 4f       	sbci	r31, 0xFC	; 252
    1f92:	51 83       	std	Z+1, r21	; 0x01
    1f94:	40 83       	st	Z, r20
    1f96:	bf ce       	rjmp	.-642    	; 0x1d16 <__vector_9+0x486>

00001f98 <radiansToSteps>:
}

/* ---------------------------------------------------------------------
   set desired motor position if unit is radian
 --------------------------------------------------------------------- */
void radiansToSteps(uint8_t mot, double rad, double multiply){
    1f98:	2f 92       	push	r2
    1f9a:	3f 92       	push	r3
    1f9c:	4f 92       	push	r4
    1f9e:	5f 92       	push	r5
    1fa0:	6f 92       	push	r6
    1fa2:	7f 92       	push	r7
    1fa4:	8f 92       	push	r8
    1fa6:	9f 92       	push	r9
    1fa8:	bf 92       	push	r11
    1faa:	cf 92       	push	r12
    1fac:	df 92       	push	r13
    1fae:	ef 92       	push	r14
    1fb0:	ff 92       	push	r15
    1fb2:	0f 93       	push	r16
    1fb4:	1f 93       	push	r17
    1fb6:	df 93       	push	r29
    1fb8:	cf 93       	push	r28
    1fba:	00 d0       	rcall	.+0      	; 0x1fbc <radiansToSteps+0x24>
    1fbc:	00 d0       	rcall	.+0      	; 0x1fbe <radiansToSteps+0x26>
    1fbe:	cd b7       	in	r28, 0x3d	; 61
    1fc0:	de b7       	in	r29, 0x3e	; 62
    1fc2:	b8 2e       	mov	r11, r24

  double roundedSteps = 0.0f;

  roundedSteps = round(rad * multiply *
    1fc4:	cb 01       	movw	r24, r22
    1fc6:	ba 01       	movw	r22, r20
    1fc8:	a9 01       	movw	r20, r18
    1fca:	98 01       	movw	r18, r16
    1fcc:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    1fd0:	69 83       	std	Y+1, r22	; 0x01
    1fd2:	7a 83       	std	Y+2, r23	; 0x02
    1fd4:	8b 83       	std	Y+3, r24	; 0x03
    1fd6:	9c 83       	std	Y+4, r25	; 0x04
    1fd8:	e0 ef       	ldi	r30, 0xF0	; 240
    1fda:	ce 2e       	mov	r12, r30
    1fdc:	e3 e0       	ldi	r30, 0x03	; 3
    1fde:	de 2e       	mov	r13, r30
    1fe0:	eb 2d       	mov	r30, r11
    1fe2:	f0 e0       	ldi	r31, 0x00	; 0
    1fe4:	ee 0f       	add	r30, r30
    1fe6:	ff 1f       	adc	r31, r31
    1fe8:	ee 0f       	add	r30, r30
    1fea:	ff 1f       	adc	r31, r31
    1fec:	ee 0f       	add	r30, r30
    1fee:	ff 1f       	adc	r31, r31
    1ff0:	cf 01       	movw	r24, r30
    1ff2:	88 0f       	add	r24, r24
    1ff4:	99 1f       	adc	r25, r25
    1ff6:	88 0f       	add	r24, r24
    1ff8:	99 1f       	adc	r25, r25
    1ffa:	e8 0f       	add	r30, r24
    1ffc:	f9 1f       	adc	r31, r25
    1ffe:	ec 0d       	add	r30, r12
    2000:	fd 1d       	adc	r31, r13
    2002:	61 89       	ldd	r22, Z+17	; 0x11
    2004:	72 89       	ldd	r23, Z+18	; 0x12
    2006:	83 89       	ldd	r24, Z+19	; 0x13
    2008:	94 89       	ldd	r25, Z+20	; 0x14
    200a:	eb 2d       	mov	r30, r11
    200c:	f0 e0       	ldi	r31, 0x00	; 0
    200e:	ee 0f       	add	r30, r30
    2010:	ff 1f       	adc	r31, r31
    2012:	ee 0f       	add	r30, r30
    2014:	ff 1f       	adc	r31, r31
    2016:	ee 0f       	add	r30, r30
    2018:	ff 1f       	adc	r31, r31
    201a:	9f 01       	movw	r18, r30
    201c:	22 0f       	add	r18, r18
    201e:	33 1f       	adc	r19, r19
    2020:	22 0f       	add	r18, r18
    2022:	33 1f       	adc	r19, r19
    2024:	e2 0f       	add	r30, r18
    2026:	f3 1f       	adc	r31, r19
    2028:	ec 0d       	add	r30, r12
    202a:	fd 1d       	adc	r31, r13
    202c:	25 85       	ldd	r18, Z+13	; 0x0d
    202e:	36 85       	ldd	r19, Z+14	; 0x0e
    2030:	47 85       	ldd	r20, Z+15	; 0x0f
    2032:	50 89       	ldd	r21, Z+16	; 0x10
    2034:	eb 2d       	mov	r30, r11
    2036:	f0 e0       	ldi	r31, 0x00	; 0
    2038:	ee 0f       	add	r30, r30
    203a:	ff 1f       	adc	r31, r31
    203c:	ee 0f       	add	r30, r30
    203e:	ff 1f       	adc	r31, r31
    2040:	ee 0f       	add	r30, r30
    2042:	ff 1f       	adc	r31, r31
    2044:	df 01       	movw	r26, r30
    2046:	aa 0f       	add	r26, r26
    2048:	bb 1f       	adc	r27, r27
    204a:	aa 0f       	add	r26, r26
    204c:	bb 1f       	adc	r27, r27
    204e:	ea 0f       	add	r30, r26
    2050:	fb 1f       	adc	r31, r27
    2052:	ec 0d       	add	r30, r12
    2054:	fd 1d       	adc	r31, r13
    2056:	e5 88       	ldd	r14, Z+21	; 0x15
    2058:	f6 88       	ldd	r15, Z+22	; 0x16
    205a:	07 89       	ldd	r16, Z+23	; 0x17
    205c:	10 8d       	ldd	r17, Z+24	; 0x18
    205e:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    2062:	a8 01       	movw	r20, r16
    2064:	97 01       	movw	r18, r14
    2066:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    206a:	20 e0       	ldi	r18, 0x00	; 0
    206c:	30 e0       	ldi	r19, 0x00	; 0
    206e:	40 e0       	ldi	r20, 0x00	; 0
    2070:	5f e3       	ldi	r21, 0x3F	; 63
    2072:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    2076:	9b 01       	movw	r18, r22
    2078:	ac 01       	movw	r20, r24
    207a:	69 81       	ldd	r22, Y+1	; 0x01
    207c:	7a 81       	ldd	r23, Y+2	; 0x02
    207e:	8b 81       	ldd	r24, Y+3	; 0x03
    2080:	9c 81       	ldd	r25, Y+4	; 0x04
    2082:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    2086:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    208a:	1b 01       	movw	r2, r22
    208c:	2c 01       	movw	r4, r24
          ((motor[mot].stepsPerFullRotation
           *motor[mot].gearRatio
           *motor[mot].subSteps)/(2.0f)));

  motor[mot].desiredPosition += (int16_t)roundedSteps;
    208e:	eb 2d       	mov	r30, r11
    2090:	f0 e0       	ldi	r31, 0x00	; 0
    2092:	ee 0f       	add	r30, r30
    2094:	ff 1f       	adc	r31, r31
    2096:	ee 0f       	add	r30, r30
    2098:	ff 1f       	adc	r31, r31
    209a:	cf 01       	movw	r24, r30
    209c:	88 0f       	add	r24, r24
    209e:	99 1f       	adc	r25, r25
    20a0:	88 0f       	add	r24, r24
    20a2:	99 1f       	adc	r25, r25
    20a4:	e8 0f       	add	r30, r24
    20a6:	f9 1f       	adc	r31, r25
    20a8:	31 96       	adiw	r30, 0x01	; 1
    20aa:	ee 0f       	add	r30, r30
    20ac:	ff 1f       	adc	r31, r31
    20ae:	ec 0d       	add	r30, r12
    20b0:	fd 1d       	adc	r31, r13
    20b2:	00 81       	ld	r16, Z
    20b4:	11 81       	ldd	r17, Z+1	; 0x01
    20b6:	c2 01       	movw	r24, r4
    20b8:	b1 01       	movw	r22, r2
    20ba:	0e 94 0a 40 	call	0x8014	; 0x8014 <__fixsfsi>
    20be:	60 0f       	add	r22, r16
    20c0:	71 1f       	adc	r23, r17
    20c2:	eb 2d       	mov	r30, r11
    20c4:	f0 e0       	ldi	r31, 0x00	; 0
    20c6:	ee 0f       	add	r30, r30
    20c8:	ff 1f       	adc	r31, r31
    20ca:	ee 0f       	add	r30, r30
    20cc:	ff 1f       	adc	r31, r31
    20ce:	9f 01       	movw	r18, r30
    20d0:	22 0f       	add	r18, r18
    20d2:	33 1f       	adc	r19, r19
    20d4:	22 0f       	add	r18, r18
    20d6:	33 1f       	adc	r19, r19
    20d8:	e2 0f       	add	r30, r18
    20da:	f3 1f       	adc	r31, r19
    20dc:	31 96       	adiw	r30, 0x01	; 1
    20de:	ee 0f       	add	r30, r30
    20e0:	ff 1f       	adc	r31, r31
    20e2:	ec 0d       	add	r30, r12
    20e4:	fd 1d       	adc	r31, r13
    20e6:	71 83       	std	Z+1, r23	; 0x01
    20e8:	60 83       	st	Z, r22

  /* calculate rounding-error */
  motor[mot].stepError +=
    20ea:	eb 2d       	mov	r30, r11
    20ec:	f0 e0       	ldi	r31, 0x00	; 0
    20ee:	ee 0f       	add	r30, r30
    20f0:	ff 1f       	adc	r31, r31
    20f2:	ee 0f       	add	r30, r30
    20f4:	ff 1f       	adc	r31, r31
    20f6:	ee 0f       	add	r30, r30
    20f8:	ff 1f       	adc	r31, r31
    20fa:	cf 01       	movw	r24, r30
    20fc:	88 0f       	add	r24, r24
    20fe:	99 1f       	adc	r25, r25
    2100:	88 0f       	add	r24, r24
    2102:	99 1f       	adc	r25, r25
    2104:	e8 0f       	add	r30, r24
    2106:	f9 1f       	adc	r31, r25
    2108:	ec 0d       	add	r30, r12
    210a:	fd 1d       	adc	r31, r13
    210c:	66 80       	ldd	r6, Z+6	; 0x06
    210e:	77 80       	ldd	r7, Z+7	; 0x07
    2110:	80 84       	ldd	r8, Z+8	; 0x08
    2112:	91 84       	ldd	r9, Z+9	; 0x09
    2114:	eb 2d       	mov	r30, r11
    2116:	f0 e0       	ldi	r31, 0x00	; 0
    2118:	ee 0f       	add	r30, r30
    211a:	ff 1f       	adc	r31, r31
    211c:	ee 0f       	add	r30, r30
    211e:	ff 1f       	adc	r31, r31
    2120:	ee 0f       	add	r30, r30
    2122:	ff 1f       	adc	r31, r31
    2124:	cf 01       	movw	r24, r30
    2126:	88 0f       	add	r24, r24
    2128:	99 1f       	adc	r25, r25
    212a:	88 0f       	add	r24, r24
    212c:	99 1f       	adc	r25, r25
    212e:	e8 0f       	add	r30, r24
    2130:	f9 1f       	adc	r31, r25
    2132:	ec 0d       	add	r30, r12
    2134:	fd 1d       	adc	r31, r13
    2136:	61 89       	ldd	r22, Z+17	; 0x11
    2138:	72 89       	ldd	r23, Z+18	; 0x12
    213a:	83 89       	ldd	r24, Z+19	; 0x13
    213c:	94 89       	ldd	r25, Z+20	; 0x14
    213e:	eb 2d       	mov	r30, r11
    2140:	f0 e0       	ldi	r31, 0x00	; 0
    2142:	ee 0f       	add	r30, r30
    2144:	ff 1f       	adc	r31, r31
    2146:	ee 0f       	add	r30, r30
    2148:	ff 1f       	adc	r31, r31
    214a:	ee 0f       	add	r30, r30
    214c:	ff 1f       	adc	r31, r31
    214e:	9f 01       	movw	r18, r30
    2150:	22 0f       	add	r18, r18
    2152:	33 1f       	adc	r19, r19
    2154:	22 0f       	add	r18, r18
    2156:	33 1f       	adc	r19, r19
    2158:	e2 0f       	add	r30, r18
    215a:	f3 1f       	adc	r31, r19
    215c:	ec 0d       	add	r30, r12
    215e:	fd 1d       	adc	r31, r13
    2160:	25 85       	ldd	r18, Z+13	; 0x0d
    2162:	36 85       	ldd	r19, Z+14	; 0x0e
    2164:	47 85       	ldd	r20, Z+15	; 0x0f
    2166:	50 89       	ldd	r21, Z+16	; 0x10
    2168:	eb 2d       	mov	r30, r11
    216a:	f0 e0       	ldi	r31, 0x00	; 0
    216c:	ee 0f       	add	r30, r30
    216e:	ff 1f       	adc	r31, r31
    2170:	ee 0f       	add	r30, r30
    2172:	ff 1f       	adc	r31, r31
    2174:	ee 0f       	add	r30, r30
    2176:	ff 1f       	adc	r31, r31
    2178:	df 01       	movw	r26, r30
    217a:	aa 0f       	add	r26, r26
    217c:	bb 1f       	adc	r27, r27
    217e:	aa 0f       	add	r26, r26
    2180:	bb 1f       	adc	r27, r27
    2182:	ea 0f       	add	r30, r26
    2184:	fb 1f       	adc	r31, r27
    2186:	ec 0d       	add	r30, r12
    2188:	fd 1d       	adc	r31, r13
    218a:	e5 88       	ldd	r14, Z+21	; 0x15
    218c:	f6 88       	ldd	r15, Z+22	; 0x16
    218e:	07 89       	ldd	r16, Z+23	; 0x17
    2190:	10 8d       	ldd	r17, Z+24	; 0x18
    2192:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    2196:	a8 01       	movw	r20, r16
    2198:	97 01       	movw	r18, r14
    219a:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    219e:	20 e0       	ldi	r18, 0x00	; 0
    21a0:	30 e0       	ldi	r19, 0x00	; 0
    21a2:	40 e0       	ldi	r20, 0x00	; 0
    21a4:	5f e3       	ldi	r21, 0x3F	; 63
    21a6:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    21aa:	9b 01       	movw	r18, r22
    21ac:	ac 01       	movw	r20, r24
    21ae:	69 81       	ldd	r22, Y+1	; 0x01
    21b0:	7a 81       	ldd	r23, Y+2	; 0x02
    21b2:	8b 81       	ldd	r24, Y+3	; 0x03
    21b4:	9c 81       	ldd	r25, Y+4	; 0x04
    21b6:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    21ba:	a2 01       	movw	r20, r4
    21bc:	91 01       	movw	r18, r2
    21be:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__subsf3>
    21c2:	9b 01       	movw	r18, r22
    21c4:	ac 01       	movw	r20, r24
    21c6:	c4 01       	movw	r24, r8
    21c8:	b3 01       	movw	r22, r6
    21ca:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <__addsf3>
    21ce:	2b 2d       	mov	r18, r11
    21d0:	30 e0       	ldi	r19, 0x00	; 0
    21d2:	22 0f       	add	r18, r18
    21d4:	33 1f       	adc	r19, r19
    21d6:	22 0f       	add	r18, r18
    21d8:	33 1f       	adc	r19, r19
    21da:	22 0f       	add	r18, r18
    21dc:	33 1f       	adc	r19, r19
    21de:	a9 01       	movw	r20, r18
    21e0:	44 0f       	add	r20, r20
    21e2:	55 1f       	adc	r21, r21
    21e4:	44 0f       	add	r20, r20
    21e6:	55 1f       	adc	r21, r21
    21e8:	24 0f       	add	r18, r20
    21ea:	35 1f       	adc	r19, r21
    21ec:	c2 0e       	add	r12, r18
    21ee:	d3 1e       	adc	r13, r19
    21f0:	f6 01       	movw	r30, r12
    21f2:	66 83       	std	Z+6, r22	; 0x06
    21f4:	77 83       	std	Z+7, r23	; 0x07
    21f6:	80 87       	std	Z+8, r24	; 0x08
    21f8:	91 87       	std	Z+9, r25	; 0x09
       *motor[mot].gearRatio
       *motor[mot].subSteps)/(2.0f))
       - roundedSteps;

  return;
}
    21fa:	0f 90       	pop	r0
    21fc:	0f 90       	pop	r0
    21fe:	0f 90       	pop	r0
    2200:	0f 90       	pop	r0
    2202:	cf 91       	pop	r28
    2204:	df 91       	pop	r29
    2206:	1f 91       	pop	r17
    2208:	0f 91       	pop	r16
    220a:	ff 90       	pop	r15
    220c:	ef 90       	pop	r14
    220e:	df 90       	pop	r13
    2210:	cf 90       	pop	r12
    2212:	bf 90       	pop	r11
    2214:	9f 90       	pop	r9
    2216:	8f 90       	pop	r8
    2218:	7f 90       	pop	r7
    221a:	6f 90       	pop	r6
    221c:	5f 90       	pop	r5
    221e:	4f 90       	pop	r4
    2220:	3f 90       	pop	r3
    2222:	2f 90       	pop	r2
    2224:	08 95       	ret

00002226 <degreeToSteps>:
}

/* ---------------------------------------------------------------------
   set desired motor position if unit is degree
 --------------------------------------------------------------------- */
void degreeToSteps(uint8_t mot, double degree, double multiply){
    2226:	2f 92       	push	r2
    2228:	3f 92       	push	r3
    222a:	4f 92       	push	r4
    222c:	5f 92       	push	r5
    222e:	6f 92       	push	r6
    2230:	7f 92       	push	r7
    2232:	8f 92       	push	r8
    2234:	9f 92       	push	r9
    2236:	bf 92       	push	r11
    2238:	cf 92       	push	r12
    223a:	df 92       	push	r13
    223c:	ef 92       	push	r14
    223e:	ff 92       	push	r15
    2240:	0f 93       	push	r16
    2242:	1f 93       	push	r17
    2244:	df 93       	push	r29
    2246:	cf 93       	push	r28
    2248:	00 d0       	rcall	.+0      	; 0x224a <degreeToSteps+0x24>
    224a:	00 d0       	rcall	.+0      	; 0x224c <degreeToSteps+0x26>
    224c:	cd b7       	in	r28, 0x3d	; 61
    224e:	de b7       	in	r29, 0x3e	; 62
    2250:	b8 2e       	mov	r11, r24

  double roundedSteps = 0.0;

  roundedSteps = round(degree * multiply *
    2252:	cb 01       	movw	r24, r22
    2254:	ba 01       	movw	r22, r20
    2256:	a9 01       	movw	r20, r18
    2258:	98 01       	movw	r18, r16
    225a:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    225e:	69 83       	std	Y+1, r22	; 0x01
    2260:	7a 83       	std	Y+2, r23	; 0x02
    2262:	8b 83       	std	Y+3, r24	; 0x03
    2264:	9c 83       	std	Y+4, r25	; 0x04
    2266:	e0 ef       	ldi	r30, 0xF0	; 240
    2268:	ce 2e       	mov	r12, r30
    226a:	e3 e0       	ldi	r30, 0x03	; 3
    226c:	de 2e       	mov	r13, r30
    226e:	eb 2d       	mov	r30, r11
    2270:	f0 e0       	ldi	r31, 0x00	; 0
    2272:	ee 0f       	add	r30, r30
    2274:	ff 1f       	adc	r31, r31
    2276:	ee 0f       	add	r30, r30
    2278:	ff 1f       	adc	r31, r31
    227a:	ee 0f       	add	r30, r30
    227c:	ff 1f       	adc	r31, r31
    227e:	cf 01       	movw	r24, r30
    2280:	88 0f       	add	r24, r24
    2282:	99 1f       	adc	r25, r25
    2284:	88 0f       	add	r24, r24
    2286:	99 1f       	adc	r25, r25
    2288:	e8 0f       	add	r30, r24
    228a:	f9 1f       	adc	r31, r25
    228c:	ec 0d       	add	r30, r12
    228e:	fd 1d       	adc	r31, r13
    2290:	61 89       	ldd	r22, Z+17	; 0x11
    2292:	72 89       	ldd	r23, Z+18	; 0x12
    2294:	83 89       	ldd	r24, Z+19	; 0x13
    2296:	94 89       	ldd	r25, Z+20	; 0x14
    2298:	eb 2d       	mov	r30, r11
    229a:	f0 e0       	ldi	r31, 0x00	; 0
    229c:	ee 0f       	add	r30, r30
    229e:	ff 1f       	adc	r31, r31
    22a0:	ee 0f       	add	r30, r30
    22a2:	ff 1f       	adc	r31, r31
    22a4:	ee 0f       	add	r30, r30
    22a6:	ff 1f       	adc	r31, r31
    22a8:	9f 01       	movw	r18, r30
    22aa:	22 0f       	add	r18, r18
    22ac:	33 1f       	adc	r19, r19
    22ae:	22 0f       	add	r18, r18
    22b0:	33 1f       	adc	r19, r19
    22b2:	e2 0f       	add	r30, r18
    22b4:	f3 1f       	adc	r31, r19
    22b6:	ec 0d       	add	r30, r12
    22b8:	fd 1d       	adc	r31, r13
    22ba:	25 85       	ldd	r18, Z+13	; 0x0d
    22bc:	36 85       	ldd	r19, Z+14	; 0x0e
    22be:	47 85       	ldd	r20, Z+15	; 0x0f
    22c0:	50 89       	ldd	r21, Z+16	; 0x10
    22c2:	eb 2d       	mov	r30, r11
    22c4:	f0 e0       	ldi	r31, 0x00	; 0
    22c6:	ee 0f       	add	r30, r30
    22c8:	ff 1f       	adc	r31, r31
    22ca:	ee 0f       	add	r30, r30
    22cc:	ff 1f       	adc	r31, r31
    22ce:	ee 0f       	add	r30, r30
    22d0:	ff 1f       	adc	r31, r31
    22d2:	df 01       	movw	r26, r30
    22d4:	aa 0f       	add	r26, r26
    22d6:	bb 1f       	adc	r27, r27
    22d8:	aa 0f       	add	r26, r26
    22da:	bb 1f       	adc	r27, r27
    22dc:	ea 0f       	add	r30, r26
    22de:	fb 1f       	adc	r31, r27
    22e0:	ec 0d       	add	r30, r12
    22e2:	fd 1d       	adc	r31, r13
    22e4:	e5 88       	ldd	r14, Z+21	; 0x15
    22e6:	f6 88       	ldd	r15, Z+22	; 0x16
    22e8:	07 89       	ldd	r16, Z+23	; 0x17
    22ea:	10 8d       	ldd	r17, Z+24	; 0x18
    22ec:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    22f0:	a8 01       	movw	r20, r16
    22f2:	97 01       	movw	r18, r14
    22f4:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    22f8:	20 e0       	ldi	r18, 0x00	; 0
    22fa:	30 e0       	ldi	r19, 0x00	; 0
    22fc:	44 eb       	ldi	r20, 0xB4	; 180
    22fe:	53 e4       	ldi	r21, 0x43	; 67
    2300:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>
    2304:	9b 01       	movw	r18, r22
    2306:	ac 01       	movw	r20, r24
    2308:	69 81       	ldd	r22, Y+1	; 0x01
    230a:	7a 81       	ldd	r23, Y+2	; 0x02
    230c:	8b 81       	ldd	r24, Y+3	; 0x03
    230e:	9c 81       	ldd	r25, Y+4	; 0x04
    2310:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    2314:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    2318:	1b 01       	movw	r2, r22
    231a:	2c 01       	movw	r4, r24
          ((motor[mot].stepsPerFullRotation
           *motor[mot].gearRatio
           *motor[mot].subSteps)/(360.0f)));

  motor[mot].desiredPosition += (int16_t)roundedSteps;
    231c:	eb 2d       	mov	r30, r11
    231e:	f0 e0       	ldi	r31, 0x00	; 0
    2320:	ee 0f       	add	r30, r30
    2322:	ff 1f       	adc	r31, r31
    2324:	ee 0f       	add	r30, r30
    2326:	ff 1f       	adc	r31, r31
    2328:	cf 01       	movw	r24, r30
    232a:	88 0f       	add	r24, r24
    232c:	99 1f       	adc	r25, r25
    232e:	88 0f       	add	r24, r24
    2330:	99 1f       	adc	r25, r25
    2332:	e8 0f       	add	r30, r24
    2334:	f9 1f       	adc	r31, r25
    2336:	31 96       	adiw	r30, 0x01	; 1
    2338:	ee 0f       	add	r30, r30
    233a:	ff 1f       	adc	r31, r31
    233c:	ec 0d       	add	r30, r12
    233e:	fd 1d       	adc	r31, r13
    2340:	00 81       	ld	r16, Z
    2342:	11 81       	ldd	r17, Z+1	; 0x01
    2344:	c2 01       	movw	r24, r4
    2346:	b1 01       	movw	r22, r2
    2348:	0e 94 0a 40 	call	0x8014	; 0x8014 <__fixsfsi>
    234c:	60 0f       	add	r22, r16
    234e:	71 1f       	adc	r23, r17
    2350:	eb 2d       	mov	r30, r11
    2352:	f0 e0       	ldi	r31, 0x00	; 0
    2354:	ee 0f       	add	r30, r30
    2356:	ff 1f       	adc	r31, r31
    2358:	ee 0f       	add	r30, r30
    235a:	ff 1f       	adc	r31, r31
    235c:	9f 01       	movw	r18, r30
    235e:	22 0f       	add	r18, r18
    2360:	33 1f       	adc	r19, r19
    2362:	22 0f       	add	r18, r18
    2364:	33 1f       	adc	r19, r19
    2366:	e2 0f       	add	r30, r18
    2368:	f3 1f       	adc	r31, r19
    236a:	31 96       	adiw	r30, 0x01	; 1
    236c:	ee 0f       	add	r30, r30
    236e:	ff 1f       	adc	r31, r31
    2370:	ec 0d       	add	r30, r12
    2372:	fd 1d       	adc	r31, r13
    2374:	71 83       	std	Z+1, r23	; 0x01
    2376:	60 83       	st	Z, r22

  /* calculate rounding-error */
  motor[mot].stepError +=
    2378:	eb 2d       	mov	r30, r11
    237a:	f0 e0       	ldi	r31, 0x00	; 0
    237c:	ee 0f       	add	r30, r30
    237e:	ff 1f       	adc	r31, r31
    2380:	ee 0f       	add	r30, r30
    2382:	ff 1f       	adc	r31, r31
    2384:	ee 0f       	add	r30, r30
    2386:	ff 1f       	adc	r31, r31
    2388:	cf 01       	movw	r24, r30
    238a:	88 0f       	add	r24, r24
    238c:	99 1f       	adc	r25, r25
    238e:	88 0f       	add	r24, r24
    2390:	99 1f       	adc	r25, r25
    2392:	e8 0f       	add	r30, r24
    2394:	f9 1f       	adc	r31, r25
    2396:	ec 0d       	add	r30, r12
    2398:	fd 1d       	adc	r31, r13
    239a:	66 80       	ldd	r6, Z+6	; 0x06
    239c:	77 80       	ldd	r7, Z+7	; 0x07
    239e:	80 84       	ldd	r8, Z+8	; 0x08
    23a0:	91 84       	ldd	r9, Z+9	; 0x09
    23a2:	eb 2d       	mov	r30, r11
    23a4:	f0 e0       	ldi	r31, 0x00	; 0
    23a6:	ee 0f       	add	r30, r30
    23a8:	ff 1f       	adc	r31, r31
    23aa:	ee 0f       	add	r30, r30
    23ac:	ff 1f       	adc	r31, r31
    23ae:	ee 0f       	add	r30, r30
    23b0:	ff 1f       	adc	r31, r31
    23b2:	cf 01       	movw	r24, r30
    23b4:	88 0f       	add	r24, r24
    23b6:	99 1f       	adc	r25, r25
    23b8:	88 0f       	add	r24, r24
    23ba:	99 1f       	adc	r25, r25
    23bc:	e8 0f       	add	r30, r24
    23be:	f9 1f       	adc	r31, r25
    23c0:	ec 0d       	add	r30, r12
    23c2:	fd 1d       	adc	r31, r13
    23c4:	61 89       	ldd	r22, Z+17	; 0x11
    23c6:	72 89       	ldd	r23, Z+18	; 0x12
    23c8:	83 89       	ldd	r24, Z+19	; 0x13
    23ca:	94 89       	ldd	r25, Z+20	; 0x14
    23cc:	eb 2d       	mov	r30, r11
    23ce:	f0 e0       	ldi	r31, 0x00	; 0
    23d0:	ee 0f       	add	r30, r30
    23d2:	ff 1f       	adc	r31, r31
    23d4:	ee 0f       	add	r30, r30
    23d6:	ff 1f       	adc	r31, r31
    23d8:	ee 0f       	add	r30, r30
    23da:	ff 1f       	adc	r31, r31
    23dc:	9f 01       	movw	r18, r30
    23de:	22 0f       	add	r18, r18
    23e0:	33 1f       	adc	r19, r19
    23e2:	22 0f       	add	r18, r18
    23e4:	33 1f       	adc	r19, r19
    23e6:	e2 0f       	add	r30, r18
    23e8:	f3 1f       	adc	r31, r19
    23ea:	ec 0d       	add	r30, r12
    23ec:	fd 1d       	adc	r31, r13
    23ee:	25 85       	ldd	r18, Z+13	; 0x0d
    23f0:	36 85       	ldd	r19, Z+14	; 0x0e
    23f2:	47 85       	ldd	r20, Z+15	; 0x0f
    23f4:	50 89       	ldd	r21, Z+16	; 0x10
    23f6:	eb 2d       	mov	r30, r11
    23f8:	f0 e0       	ldi	r31, 0x00	; 0
    23fa:	ee 0f       	add	r30, r30
    23fc:	ff 1f       	adc	r31, r31
    23fe:	ee 0f       	add	r30, r30
    2400:	ff 1f       	adc	r31, r31
    2402:	ee 0f       	add	r30, r30
    2404:	ff 1f       	adc	r31, r31
    2406:	df 01       	movw	r26, r30
    2408:	aa 0f       	add	r26, r26
    240a:	bb 1f       	adc	r27, r27
    240c:	aa 0f       	add	r26, r26
    240e:	bb 1f       	adc	r27, r27
    2410:	ea 0f       	add	r30, r26
    2412:	fb 1f       	adc	r31, r27
    2414:	ec 0d       	add	r30, r12
    2416:	fd 1d       	adc	r31, r13
    2418:	e5 88       	ldd	r14, Z+21	; 0x15
    241a:	f6 88       	ldd	r15, Z+22	; 0x16
    241c:	07 89       	ldd	r16, Z+23	; 0x17
    241e:	10 8d       	ldd	r17, Z+24	; 0x18
    2420:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    2424:	a8 01       	movw	r20, r16
    2426:	97 01       	movw	r18, r14
    2428:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    242c:	20 e0       	ldi	r18, 0x00	; 0
    242e:	30 e0       	ldi	r19, 0x00	; 0
    2430:	44 eb       	ldi	r20, 0xB4	; 180
    2432:	53 e4       	ldi	r21, 0x43	; 67
    2434:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>
    2438:	9b 01       	movw	r18, r22
    243a:	ac 01       	movw	r20, r24
    243c:	69 81       	ldd	r22, Y+1	; 0x01
    243e:	7a 81       	ldd	r23, Y+2	; 0x02
    2440:	8b 81       	ldd	r24, Y+3	; 0x03
    2442:	9c 81       	ldd	r25, Y+4	; 0x04
    2444:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    2448:	a2 01       	movw	r20, r4
    244a:	91 01       	movw	r18, r2
    244c:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__subsf3>
    2450:	9b 01       	movw	r18, r22
    2452:	ac 01       	movw	r20, r24
    2454:	c4 01       	movw	r24, r8
    2456:	b3 01       	movw	r22, r6
    2458:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <__addsf3>
    245c:	2b 2d       	mov	r18, r11
    245e:	30 e0       	ldi	r19, 0x00	; 0
    2460:	22 0f       	add	r18, r18
    2462:	33 1f       	adc	r19, r19
    2464:	22 0f       	add	r18, r18
    2466:	33 1f       	adc	r19, r19
    2468:	22 0f       	add	r18, r18
    246a:	33 1f       	adc	r19, r19
    246c:	a9 01       	movw	r20, r18
    246e:	44 0f       	add	r20, r20
    2470:	55 1f       	adc	r21, r21
    2472:	44 0f       	add	r20, r20
    2474:	55 1f       	adc	r21, r21
    2476:	24 0f       	add	r18, r20
    2478:	35 1f       	adc	r19, r21
    247a:	c2 0e       	add	r12, r18
    247c:	d3 1e       	adc	r13, r19
    247e:	f6 01       	movw	r30, r12
    2480:	66 83       	std	Z+6, r22	; 0x06
    2482:	77 83       	std	Z+7, r23	; 0x07
    2484:	80 87       	std	Z+8, r24	; 0x08
    2486:	91 87       	std	Z+9, r25	; 0x09
       *motor[mot].gearRatio
       *motor[mot].subSteps)/(360.0f))
       - roundedSteps;

  return;
}
    2488:	0f 90       	pop	r0
    248a:	0f 90       	pop	r0
    248c:	0f 90       	pop	r0
    248e:	0f 90       	pop	r0
    2490:	cf 91       	pop	r28
    2492:	df 91       	pop	r29
    2494:	1f 91       	pop	r17
    2496:	0f 91       	pop	r16
    2498:	ff 90       	pop	r15
    249a:	ef 90       	pop	r14
    249c:	df 90       	pop	r13
    249e:	cf 90       	pop	r12
    24a0:	bf 90       	pop	r11
    24a2:	9f 90       	pop	r9
    24a4:	8f 90       	pop	r8
    24a6:	7f 90       	pop	r7
    24a8:	6f 90       	pop	r6
    24aa:	5f 90       	pop	r5
    24ac:	4f 90       	pop	r4
    24ae:	3f 90       	pop	r3
    24b0:	2f 90       	pop	r2
    24b2:	08 95       	ret

000024b4 <commandGetMotorDecay>:
 --------------------------------------------------------------------- */
char* commandGetMotorDecay(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    24b4:	60 e0       	ldi	r22, 0x00	; 0
    24b6:	70 e0       	ldi	r23, 0x00	; 0
    24b8:	4a e0       	ldi	r20, 0x0A	; 10
    24ba:	50 e0       	ldi	r21, 0x00	; 0
    24bc:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    24c0:	64 30       	cpi	r22, 0x04	; 4
    24c2:	d8 f5       	brcc	.+118    	; 0x253a <commandGetMotorDecay+0x86>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].decay);
    24c4:	40 91 e7 03 	lds	r20, 0x03E7
    24c8:	50 91 e8 03 	lds	r21, 0x03E8
    24cc:	e6 2f       	mov	r30, r22
    24ce:	f0 e0       	ldi	r31, 0x00	; 0
    24d0:	ee 0f       	add	r30, r30
    24d2:	ff 1f       	adc	r31, r31
    24d4:	ee 0f       	add	r30, r30
    24d6:	ff 1f       	adc	r31, r31
    24d8:	ee 0f       	add	r30, r30
    24da:	ff 1f       	adc	r31, r31
    24dc:	cf 01       	movw	r24, r30
    24de:	88 0f       	add	r24, r24
    24e0:	99 1f       	adc	r25, r25
    24e2:	88 0f       	add	r24, r24
    24e4:	99 1f       	adc	r25, r25
    24e6:	e8 0f       	add	r30, r24
    24e8:	f9 1f       	adc	r31, r25
    24ea:	e0 51       	subi	r30, 0x10	; 16
    24ec:	fc 4f       	sbci	r31, 0xFC	; 252
    24ee:	27 a1       	ldd	r18, Z+39	; 0x27
    24f0:	00 d0       	rcall	.+0      	; 0x24f2 <commandGetMotorDecay+0x3e>
    24f2:	00 d0       	rcall	.+0      	; 0x24f4 <commandGetMotorDecay+0x40>
    24f4:	00 d0       	rcall	.+0      	; 0x24f6 <commandGetMotorDecay+0x42>
    24f6:	ed b7       	in	r30, 0x3d	; 61
    24f8:	fe b7       	in	r31, 0x3e	; 62
    24fa:	31 96       	adiw	r30, 0x01	; 1
    24fc:	ad b7       	in	r26, 0x3d	; 61
    24fe:	be b7       	in	r27, 0x3e	; 62
    2500:	12 96       	adiw	r26, 0x02	; 2
    2502:	5c 93       	st	X, r21
    2504:	4e 93       	st	-X, r20
    2506:	11 97       	sbiw	r26, 0x01	; 1
    2508:	87 e1       	ldi	r24, 0x17	; 23
    250a:	91 e0       	ldi	r25, 0x01	; 1
    250c:	93 83       	std	Z+3, r25	; 0x03
    250e:	82 83       	std	Z+2, r24	; 0x02
    2510:	33 27       	eor	r19, r19
    2512:	27 fd       	sbrc	r18, 7
    2514:	30 95       	com	r19
    2516:	35 83       	std	Z+5, r19	; 0x05
    2518:	24 83       	std	Z+4, r18	; 0x04
    251a:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    251e:	8d b7       	in	r24, 0x3d	; 61
    2520:	9e b7       	in	r25, 0x3e	; 62
    2522:	06 96       	adiw	r24, 0x06	; 6
    2524:	0f b6       	in	r0, 0x3f	; 63
    2526:	f8 94       	cli
    2528:	9e bf       	out	0x3e, r25	; 62
    252a:	0f be       	out	0x3f, r0	; 63
    252c:	8d bf       	out	0x3d, r24	; 61
  }
  
  return txString.buffer;
    252e:	20 91 e7 03 	lds	r18, 0x03E7
    2532:	30 91 e8 03 	lds	r19, 0x03E8
}
    2536:	c9 01       	movw	r24, r18
    2538:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    253a:	80 91 e7 03 	lds	r24, 0x03E7
    253e:	90 91 e8 03 	lds	r25, 0x03E8
    2542:	00 d0       	rcall	.+0      	; 0x2544 <commandGetMotorDecay+0x90>
    2544:	00 d0       	rcall	.+0      	; 0x2546 <commandGetMotorDecay+0x92>
    2546:	00 d0       	rcall	.+0      	; 0x2548 <commandGetMotorDecay+0x94>
    2548:	ed b7       	in	r30, 0x3d	; 61
    254a:	fe b7       	in	r31, 0x3e	; 62
    254c:	31 96       	adiw	r30, 0x01	; 1
    254e:	ad b7       	in	r26, 0x3d	; 61
    2550:	be b7       	in	r27, 0x3e	; 62
    2552:	12 96       	adiw	r26, 0x02	; 2
    2554:	9c 93       	st	X, r25
    2556:	8e 93       	st	-X, r24
    2558:	11 97       	sbiw	r26, 0x01	; 1
    255a:	80 e0       	ldi	r24, 0x00	; 0
    255c:	91 e0       	ldi	r25, 0x01	; 1
    255e:	93 83       	std	Z+3, r25	; 0x03
    2560:	82 83       	std	Z+2, r24	; 0x02
    2562:	64 83       	std	Z+4, r22	; 0x04
    2564:	15 82       	std	Z+5, r1	; 0x05
    2566:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    256a:	8d b7       	in	r24, 0x3d	; 61
    256c:	9e b7       	in	r25, 0x3e	; 62
    256e:	06 96       	adiw	r24, 0x06	; 6
    2570:	0f b6       	in	r0, 0x3f	; 63
    2572:	f8 94       	cli
    2574:	9e bf       	out	0x3e, r25	; 62
    2576:	0f be       	out	0x3f, r0	; 63
    2578:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].decay);
  }
  
  return txString.buffer;
    257a:	20 91 e7 03 	lds	r18, 0x03E7
    257e:	30 91 e8 03 	lds	r19, 0x03E8
}
    2582:	c9 01       	movw	r24, r18
    2584:	08 95       	ret

00002586 <commandGetWaitTime>:
 --------------------------------------------------------------------- */
char* commandGetWaitTime(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2586:	60 e0       	ldi	r22, 0x00	; 0
    2588:	70 e0       	ldi	r23, 0x00	; 0
    258a:	4a e0       	ldi	r20, 0x0A	; 10
    258c:	50 e0       	ldi	r21, 0x00	; 0
    258e:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    2592:	64 30       	cpi	r22, 0x04	; 4
    2594:	c8 f5       	brcc	.+114    	; 0x2608 <commandGetWaitTime+0x82>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].waitBetweenSteps);
    2596:	40 91 e7 03 	lds	r20, 0x03E7
    259a:	50 91 e8 03 	lds	r21, 0x03E8
    259e:	e6 2f       	mov	r30, r22
    25a0:	f0 e0       	ldi	r31, 0x00	; 0
    25a2:	ee 0f       	add	r30, r30
    25a4:	ff 1f       	adc	r31, r31
    25a6:	ee 0f       	add	r30, r30
    25a8:	ff 1f       	adc	r31, r31
    25aa:	ee 0f       	add	r30, r30
    25ac:	ff 1f       	adc	r31, r31
    25ae:	cf 01       	movw	r24, r30
    25b0:	88 0f       	add	r24, r24
    25b2:	99 1f       	adc	r25, r25
    25b4:	88 0f       	add	r24, r24
    25b6:	99 1f       	adc	r25, r25
    25b8:	e8 0f       	add	r30, r24
    25ba:	f9 1f       	adc	r31, r25
    25bc:	e0 51       	subi	r30, 0x10	; 16
    25be:	fc 4f       	sbci	r31, 0xFC	; 252
    25c0:	26 8d       	ldd	r18, Z+30	; 0x1e
    25c2:	37 8d       	ldd	r19, Z+31	; 0x1f
    25c4:	00 d0       	rcall	.+0      	; 0x25c6 <commandGetWaitTime+0x40>
    25c6:	00 d0       	rcall	.+0      	; 0x25c8 <commandGetWaitTime+0x42>
    25c8:	00 d0       	rcall	.+0      	; 0x25ca <commandGetWaitTime+0x44>
    25ca:	ed b7       	in	r30, 0x3d	; 61
    25cc:	fe b7       	in	r31, 0x3e	; 62
    25ce:	31 96       	adiw	r30, 0x01	; 1
    25d0:	ad b7       	in	r26, 0x3d	; 61
    25d2:	be b7       	in	r27, 0x3e	; 62
    25d4:	12 96       	adiw	r26, 0x02	; 2
    25d6:	5c 93       	st	X, r21
    25d8:	4e 93       	st	-X, r20
    25da:	11 97       	sbiw	r26, 0x01	; 1
    25dc:	87 e1       	ldi	r24, 0x17	; 23
    25de:	91 e0       	ldi	r25, 0x01	; 1
    25e0:	93 83       	std	Z+3, r25	; 0x03
    25e2:	82 83       	std	Z+2, r24	; 0x02
    25e4:	35 83       	std	Z+5, r19	; 0x05
    25e6:	24 83       	std	Z+4, r18	; 0x04
    25e8:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    25ec:	8d b7       	in	r24, 0x3d	; 61
    25ee:	9e b7       	in	r25, 0x3e	; 62
    25f0:	06 96       	adiw	r24, 0x06	; 6
    25f2:	0f b6       	in	r0, 0x3f	; 63
    25f4:	f8 94       	cli
    25f6:	9e bf       	out	0x3e, r25	; 62
    25f8:	0f be       	out	0x3f, r0	; 63
    25fa:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    25fc:	20 91 e7 03 	lds	r18, 0x03E7
    2600:	30 91 e8 03 	lds	r19, 0x03E8
}
    2604:	c9 01       	movw	r24, r18
    2606:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2608:	80 91 e7 03 	lds	r24, 0x03E7
    260c:	90 91 e8 03 	lds	r25, 0x03E8
    2610:	00 d0       	rcall	.+0      	; 0x2612 <commandGetWaitTime+0x8c>
    2612:	00 d0       	rcall	.+0      	; 0x2614 <commandGetWaitTime+0x8e>
    2614:	00 d0       	rcall	.+0      	; 0x2616 <commandGetWaitTime+0x90>
    2616:	ed b7       	in	r30, 0x3d	; 61
    2618:	fe b7       	in	r31, 0x3e	; 62
    261a:	31 96       	adiw	r30, 0x01	; 1
    261c:	ad b7       	in	r26, 0x3d	; 61
    261e:	be b7       	in	r27, 0x3e	; 62
    2620:	12 96       	adiw	r26, 0x02	; 2
    2622:	9c 93       	st	X, r25
    2624:	8e 93       	st	-X, r24
    2626:	11 97       	sbiw	r26, 0x01	; 1
    2628:	80 e0       	ldi	r24, 0x00	; 0
    262a:	91 e0       	ldi	r25, 0x01	; 1
    262c:	93 83       	std	Z+3, r25	; 0x03
    262e:	82 83       	std	Z+2, r24	; 0x02
    2630:	64 83       	std	Z+4, r22	; 0x04
    2632:	15 82       	std	Z+5, r1	; 0x05
    2634:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    2638:	8d b7       	in	r24, 0x3d	; 61
    263a:	9e b7       	in	r25, 0x3e	; 62
    263c:	06 96       	adiw	r24, 0x06	; 6
    263e:	0f b6       	in	r0, 0x3f	; 63
    2640:	f8 94       	cli
    2642:	9e bf       	out	0x3e, r25	; 62
    2644:	0f be       	out	0x3f, r0	; 63
    2646:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].waitBetweenSteps);
  }

  return txString.buffer;
    2648:	20 91 e7 03 	lds	r18, 0x03E7
    264c:	30 91 e8 03 	lds	r19, 0x03E8
}
    2650:	c9 01       	movw	r24, r18
    2652:	08 95       	ret

00002654 <commandGetSubSteps>:
 --------------------------------------------------------------------- */
char* commandGetSubSteps(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2654:	60 e0       	ldi	r22, 0x00	; 0
    2656:	70 e0       	ldi	r23, 0x00	; 0
    2658:	4a e0       	ldi	r20, 0x0A	; 10
    265a:	50 e0       	ldi	r21, 0x00	; 0
    265c:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    2660:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    2662:	64 30       	cpi	r22, 0x04	; 4
    2664:	08 f0       	brcs	.+2      	; 0x2668 <commandGetSubSteps+0x14>
    2666:	40 c0       	rjmp	.+128    	; 0x26e8 <commandGetSubSteps+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].subSteps);
    2668:	60 91 e7 03 	lds	r22, 0x03E7
    266c:	70 91 e8 03 	lds	r23, 0x03E8
    2670:	e2 2f       	mov	r30, r18
    2672:	f0 e0       	ldi	r31, 0x00	; 0
    2674:	ee 0f       	add	r30, r30
    2676:	ff 1f       	adc	r31, r31
    2678:	ee 0f       	add	r30, r30
    267a:	ff 1f       	adc	r31, r31
    267c:	ee 0f       	add	r30, r30
    267e:	ff 1f       	adc	r31, r31
    2680:	cf 01       	movw	r24, r30
    2682:	88 0f       	add	r24, r24
    2684:	99 1f       	adc	r25, r25
    2686:	88 0f       	add	r24, r24
    2688:	99 1f       	adc	r25, r25
    268a:	e8 0f       	add	r30, r24
    268c:	f9 1f       	adc	r31, r25
    268e:	e0 51       	subi	r30, 0x10	; 16
    2690:	fc 4f       	sbci	r31, 0xFC	; 252
    2692:	25 89       	ldd	r18, Z+21	; 0x15
    2694:	36 89       	ldd	r19, Z+22	; 0x16
    2696:	47 89       	ldd	r20, Z+23	; 0x17
    2698:	50 8d       	ldd	r21, Z+24	; 0x18
    269a:	ad b7       	in	r26, 0x3d	; 61
    269c:	be b7       	in	r27, 0x3e	; 62
    269e:	18 97       	sbiw	r26, 0x08	; 8
    26a0:	0f b6       	in	r0, 0x3f	; 63
    26a2:	f8 94       	cli
    26a4:	be bf       	out	0x3e, r27	; 62
    26a6:	0f be       	out	0x3f, r0	; 63
    26a8:	ad bf       	out	0x3d, r26	; 61
    26aa:	ed b7       	in	r30, 0x3d	; 61
    26ac:	fe b7       	in	r31, 0x3e	; 62
    26ae:	31 96       	adiw	r30, 0x01	; 1
    26b0:	12 96       	adiw	r26, 0x02	; 2
    26b2:	7c 93       	st	X, r23
    26b4:	6e 93       	st	-X, r22
    26b6:	11 97       	sbiw	r26, 0x01	; 1
    26b8:	8a e1       	ldi	r24, 0x1A	; 26
    26ba:	91 e0       	ldi	r25, 0x01	; 1
    26bc:	93 83       	std	Z+3, r25	; 0x03
    26be:	82 83       	std	Z+2, r24	; 0x02
    26c0:	24 83       	std	Z+4, r18	; 0x04
    26c2:	35 83       	std	Z+5, r19	; 0x05
    26c4:	46 83       	std	Z+6, r20	; 0x06
    26c6:	57 83       	std	Z+7, r21	; 0x07
    26c8:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    26cc:	8d b7       	in	r24, 0x3d	; 61
    26ce:	9e b7       	in	r25, 0x3e	; 62
    26d0:	08 96       	adiw	r24, 0x08	; 8
    26d2:	0f b6       	in	r0, 0x3f	; 63
    26d4:	f8 94       	cli
    26d6:	9e bf       	out	0x3e, r25	; 62
    26d8:	0f be       	out	0x3f, r0	; 63
    26da:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    26dc:	20 91 e7 03 	lds	r18, 0x03E7
    26e0:	30 91 e8 03 	lds	r19, 0x03E8
}
    26e4:	c9 01       	movw	r24, r18
    26e6:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    26e8:	80 91 e7 03 	lds	r24, 0x03E7
    26ec:	90 91 e8 03 	lds	r25, 0x03E8
    26f0:	00 d0       	rcall	.+0      	; 0x26f2 <commandGetSubSteps+0x9e>
    26f2:	00 d0       	rcall	.+0      	; 0x26f4 <commandGetSubSteps+0xa0>
    26f4:	00 d0       	rcall	.+0      	; 0x26f6 <commandGetSubSteps+0xa2>
    26f6:	ed b7       	in	r30, 0x3d	; 61
    26f8:	fe b7       	in	r31, 0x3e	; 62
    26fa:	31 96       	adiw	r30, 0x01	; 1
    26fc:	ad b7       	in	r26, 0x3d	; 61
    26fe:	be b7       	in	r27, 0x3e	; 62
    2700:	12 96       	adiw	r26, 0x02	; 2
    2702:	9c 93       	st	X, r25
    2704:	8e 93       	st	-X, r24
    2706:	11 97       	sbiw	r26, 0x01	; 1
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	91 e0       	ldi	r25, 0x01	; 1
    270c:	93 83       	std	Z+3, r25	; 0x03
    270e:	82 83       	std	Z+2, r24	; 0x02
    2710:	24 83       	std	Z+4, r18	; 0x04
    2712:	15 82       	std	Z+5, r1	; 0x05
    2714:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    2718:	8d b7       	in	r24, 0x3d	; 61
    271a:	9e b7       	in	r25, 0x3e	; 62
    271c:	06 96       	adiw	r24, 0x06	; 6
    271e:	0f b6       	in	r0, 0x3f	; 63
    2720:	f8 94       	cli
    2722:	9e bf       	out	0x3e, r25	; 62
    2724:	0f be       	out	0x3f, r0	; 63
    2726:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].subSteps);
  }

  return txString.buffer;
    2728:	20 91 e7 03 	lds	r18, 0x03E7
    272c:	30 91 e8 03 	lds	r19, 0x03E8
}
    2730:	c9 01       	movw	r24, r18
    2732:	08 95       	ret

00002734 <commandGetFullRotation>:
 --------------------------------------------------------------------- */
char* commandGetFullRotation(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2734:	60 e0       	ldi	r22, 0x00	; 0
    2736:	70 e0       	ldi	r23, 0x00	; 0
    2738:	4a e0       	ldi	r20, 0x0A	; 10
    273a:	50 e0       	ldi	r21, 0x00	; 0
    273c:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    2740:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    2742:	64 30       	cpi	r22, 0x04	; 4
    2744:	08 f0       	brcs	.+2      	; 0x2748 <commandGetFullRotation+0x14>
    2746:	40 c0       	rjmp	.+128    	; 0x27c8 <commandGetFullRotation+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].stepsPerFullRotation);
    2748:	60 91 e7 03 	lds	r22, 0x03E7
    274c:	70 91 e8 03 	lds	r23, 0x03E8
    2750:	e2 2f       	mov	r30, r18
    2752:	f0 e0       	ldi	r31, 0x00	; 0
    2754:	ee 0f       	add	r30, r30
    2756:	ff 1f       	adc	r31, r31
    2758:	ee 0f       	add	r30, r30
    275a:	ff 1f       	adc	r31, r31
    275c:	ee 0f       	add	r30, r30
    275e:	ff 1f       	adc	r31, r31
    2760:	cf 01       	movw	r24, r30
    2762:	88 0f       	add	r24, r24
    2764:	99 1f       	adc	r25, r25
    2766:	88 0f       	add	r24, r24
    2768:	99 1f       	adc	r25, r25
    276a:	e8 0f       	add	r30, r24
    276c:	f9 1f       	adc	r31, r25
    276e:	e0 51       	subi	r30, 0x10	; 16
    2770:	fc 4f       	sbci	r31, 0xFC	; 252
    2772:	21 89       	ldd	r18, Z+17	; 0x11
    2774:	32 89       	ldd	r19, Z+18	; 0x12
    2776:	43 89       	ldd	r20, Z+19	; 0x13
    2778:	54 89       	ldd	r21, Z+20	; 0x14
    277a:	ad b7       	in	r26, 0x3d	; 61
    277c:	be b7       	in	r27, 0x3e	; 62
    277e:	18 97       	sbiw	r26, 0x08	; 8
    2780:	0f b6       	in	r0, 0x3f	; 63
    2782:	f8 94       	cli
    2784:	be bf       	out	0x3e, r27	; 62
    2786:	0f be       	out	0x3f, r0	; 63
    2788:	ad bf       	out	0x3d, r26	; 61
    278a:	ed b7       	in	r30, 0x3d	; 61
    278c:	fe b7       	in	r31, 0x3e	; 62
    278e:	31 96       	adiw	r30, 0x01	; 1
    2790:	12 96       	adiw	r26, 0x02	; 2
    2792:	7c 93       	st	X, r23
    2794:	6e 93       	st	-X, r22
    2796:	11 97       	sbiw	r26, 0x01	; 1
    2798:	8a e1       	ldi	r24, 0x1A	; 26
    279a:	91 e0       	ldi	r25, 0x01	; 1
    279c:	93 83       	std	Z+3, r25	; 0x03
    279e:	82 83       	std	Z+2, r24	; 0x02
    27a0:	24 83       	std	Z+4, r18	; 0x04
    27a2:	35 83       	std	Z+5, r19	; 0x05
    27a4:	46 83       	std	Z+6, r20	; 0x06
    27a6:	57 83       	std	Z+7, r21	; 0x07
    27a8:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    27ac:	8d b7       	in	r24, 0x3d	; 61
    27ae:	9e b7       	in	r25, 0x3e	; 62
    27b0:	08 96       	adiw	r24, 0x08	; 8
    27b2:	0f b6       	in	r0, 0x3f	; 63
    27b4:	f8 94       	cli
    27b6:	9e bf       	out	0x3e, r25	; 62
    27b8:	0f be       	out	0x3f, r0	; 63
    27ba:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    27bc:	20 91 e7 03 	lds	r18, 0x03E7
    27c0:	30 91 e8 03 	lds	r19, 0x03E8
}
    27c4:	c9 01       	movw	r24, r18
    27c6:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    27c8:	80 91 e7 03 	lds	r24, 0x03E7
    27cc:	90 91 e8 03 	lds	r25, 0x03E8
    27d0:	00 d0       	rcall	.+0      	; 0x27d2 <commandGetFullRotation+0x9e>
    27d2:	00 d0       	rcall	.+0      	; 0x27d4 <commandGetFullRotation+0xa0>
    27d4:	00 d0       	rcall	.+0      	; 0x27d6 <commandGetFullRotation+0xa2>
    27d6:	ed b7       	in	r30, 0x3d	; 61
    27d8:	fe b7       	in	r31, 0x3e	; 62
    27da:	31 96       	adiw	r30, 0x01	; 1
    27dc:	ad b7       	in	r26, 0x3d	; 61
    27de:	be b7       	in	r27, 0x3e	; 62
    27e0:	12 96       	adiw	r26, 0x02	; 2
    27e2:	9c 93       	st	X, r25
    27e4:	8e 93       	st	-X, r24
    27e6:	11 97       	sbiw	r26, 0x01	; 1
    27e8:	80 e0       	ldi	r24, 0x00	; 0
    27ea:	91 e0       	ldi	r25, 0x01	; 1
    27ec:	93 83       	std	Z+3, r25	; 0x03
    27ee:	82 83       	std	Z+2, r24	; 0x02
    27f0:	24 83       	std	Z+4, r18	; 0x04
    27f2:	15 82       	std	Z+5, r1	; 0x05
    27f4:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    27f8:	8d b7       	in	r24, 0x3d	; 61
    27fa:	9e b7       	in	r25, 0x3e	; 62
    27fc:	06 96       	adiw	r24, 0x06	; 6
    27fe:	0f b6       	in	r0, 0x3f	; 63
    2800:	f8 94       	cli
    2802:	9e bf       	out	0x3e, r25	; 62
    2804:	0f be       	out	0x3f, r0	; 63
    2806:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].stepsPerFullRotation);
  }

  return txString.buffer;
    2808:	20 91 e7 03 	lds	r18, 0x03E7
    280c:	30 91 e8 03 	lds	r19, 0x03E8
}
    2810:	c9 01       	movw	r24, r18
    2812:	08 95       	ret

00002814 <commandGetGearRatio>:
 --------------------------------------------------------------------- */
char* commandGetGearRatio(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2814:	60 e0       	ldi	r22, 0x00	; 0
    2816:	70 e0       	ldi	r23, 0x00	; 0
    2818:	4a e0       	ldi	r20, 0x0A	; 10
    281a:	50 e0       	ldi	r21, 0x00	; 0
    281c:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    2820:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    2822:	64 30       	cpi	r22, 0x04	; 4
    2824:	08 f0       	brcs	.+2      	; 0x2828 <commandGetGearRatio+0x14>
    2826:	40 c0       	rjmp	.+128    	; 0x28a8 <commandGetGearRatio+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%f", motor[i].gearRatio);
    2828:	60 91 e7 03 	lds	r22, 0x03E7
    282c:	70 91 e8 03 	lds	r23, 0x03E8
    2830:	e2 2f       	mov	r30, r18
    2832:	f0 e0       	ldi	r31, 0x00	; 0
    2834:	ee 0f       	add	r30, r30
    2836:	ff 1f       	adc	r31, r31
    2838:	ee 0f       	add	r30, r30
    283a:	ff 1f       	adc	r31, r31
    283c:	ee 0f       	add	r30, r30
    283e:	ff 1f       	adc	r31, r31
    2840:	cf 01       	movw	r24, r30
    2842:	88 0f       	add	r24, r24
    2844:	99 1f       	adc	r25, r25
    2846:	88 0f       	add	r24, r24
    2848:	99 1f       	adc	r25, r25
    284a:	e8 0f       	add	r30, r24
    284c:	f9 1f       	adc	r31, r25
    284e:	e0 51       	subi	r30, 0x10	; 16
    2850:	fc 4f       	sbci	r31, 0xFC	; 252
    2852:	25 85       	ldd	r18, Z+13	; 0x0d
    2854:	36 85       	ldd	r19, Z+14	; 0x0e
    2856:	47 85       	ldd	r20, Z+15	; 0x0f
    2858:	50 89       	ldd	r21, Z+16	; 0x10
    285a:	ad b7       	in	r26, 0x3d	; 61
    285c:	be b7       	in	r27, 0x3e	; 62
    285e:	18 97       	sbiw	r26, 0x08	; 8
    2860:	0f b6       	in	r0, 0x3f	; 63
    2862:	f8 94       	cli
    2864:	be bf       	out	0x3e, r27	; 62
    2866:	0f be       	out	0x3f, r0	; 63
    2868:	ad bf       	out	0x3d, r26	; 61
    286a:	ed b7       	in	r30, 0x3d	; 61
    286c:	fe b7       	in	r31, 0x3e	; 62
    286e:	31 96       	adiw	r30, 0x01	; 1
    2870:	12 96       	adiw	r26, 0x02	; 2
    2872:	7c 93       	st	X, r23
    2874:	6e 93       	st	-X, r22
    2876:	11 97       	sbiw	r26, 0x01	; 1
    2878:	8f e1       	ldi	r24, 0x1F	; 31
    287a:	91 e0       	ldi	r25, 0x01	; 1
    287c:	93 83       	std	Z+3, r25	; 0x03
    287e:	82 83       	std	Z+2, r24	; 0x02
    2880:	24 83       	std	Z+4, r18	; 0x04
    2882:	35 83       	std	Z+5, r19	; 0x05
    2884:	46 83       	std	Z+6, r20	; 0x06
    2886:	57 83       	std	Z+7, r21	; 0x07
    2888:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    288c:	8d b7       	in	r24, 0x3d	; 61
    288e:	9e b7       	in	r25, 0x3e	; 62
    2890:	08 96       	adiw	r24, 0x08	; 8
    2892:	0f b6       	in	r0, 0x3f	; 63
    2894:	f8 94       	cli
    2896:	9e bf       	out	0x3e, r25	; 62
    2898:	0f be       	out	0x3f, r0	; 63
    289a:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    289c:	20 91 e7 03 	lds	r18, 0x03E7
    28a0:	30 91 e8 03 	lds	r19, 0x03E8
}
    28a4:	c9 01       	movw	r24, r18
    28a6:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    28a8:	80 91 e7 03 	lds	r24, 0x03E7
    28ac:	90 91 e8 03 	lds	r25, 0x03E8
    28b0:	00 d0       	rcall	.+0      	; 0x28b2 <commandGetGearRatio+0x9e>
    28b2:	00 d0       	rcall	.+0      	; 0x28b4 <commandGetGearRatio+0xa0>
    28b4:	00 d0       	rcall	.+0      	; 0x28b6 <commandGetGearRatio+0xa2>
    28b6:	ed b7       	in	r30, 0x3d	; 61
    28b8:	fe b7       	in	r31, 0x3e	; 62
    28ba:	31 96       	adiw	r30, 0x01	; 1
    28bc:	ad b7       	in	r26, 0x3d	; 61
    28be:	be b7       	in	r27, 0x3e	; 62
    28c0:	12 96       	adiw	r26, 0x02	; 2
    28c2:	9c 93       	st	X, r25
    28c4:	8e 93       	st	-X, r24
    28c6:	11 97       	sbiw	r26, 0x01	; 1
    28c8:	80 e0       	ldi	r24, 0x00	; 0
    28ca:	91 e0       	ldi	r25, 0x01	; 1
    28cc:	93 83       	std	Z+3, r25	; 0x03
    28ce:	82 83       	std	Z+2, r24	; 0x02
    28d0:	24 83       	std	Z+4, r18	; 0x04
    28d2:	15 82       	std	Z+5, r1	; 0x05
    28d4:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    28d8:	8d b7       	in	r24, 0x3d	; 61
    28da:	9e b7       	in	r25, 0x3e	; 62
    28dc:	06 96       	adiw	r24, 0x06	; 6
    28de:	0f b6       	in	r0, 0x3f	; 63
    28e0:	f8 94       	cli
    28e2:	9e bf       	out	0x3e, r25	; 62
    28e4:	0f be       	out	0x3f, r0	; 63
    28e6:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%f", motor[i].gearRatio);
  }

  return txString.buffer;
    28e8:	20 91 e7 03 	lds	r18, 0x03E7
    28ec:	30 91 e8 03 	lds	r19, 0x03E8
}
    28f0:	c9 01       	movw	r24, r18
    28f2:	08 95       	ret

000028f4 <commandGetOptZeroPos>:
 --------------------------------------------------------------------- */
char* commandGetOptZeroPos(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    28f4:	60 e0       	ldi	r22, 0x00	; 0
    28f6:	70 e0       	ldi	r23, 0x00	; 0
    28f8:	4a e0       	ldi	r20, 0x0A	; 10
    28fa:	50 e0       	ldi	r21, 0x00	; 0
    28fc:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    2900:	64 30       	cpi	r22, 0x04	; 4
    2902:	d8 f5       	brcc	.+118    	; 0x297a <commandGetOptZeroPos+0x86>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].opticalZeroPosition);
    2904:	40 91 e7 03 	lds	r20, 0x03E7
    2908:	50 91 e8 03 	lds	r21, 0x03E8
    290c:	86 2f       	mov	r24, r22
    290e:	90 e0       	ldi	r25, 0x00	; 0
    2910:	fc 01       	movw	r30, r24
    2912:	ee 0f       	add	r30, r30
    2914:	ff 1f       	adc	r31, r31
    2916:	ee 0f       	add	r30, r30
    2918:	ff 1f       	adc	r31, r31
    291a:	ee 0f       	add	r30, r30
    291c:	ff 1f       	adc	r31, r31
    291e:	88 0f       	add	r24, r24
    2920:	99 1f       	adc	r25, r25
    2922:	e8 0f       	add	r30, r24
    2924:	f9 1f       	adc	r31, r25
    2926:	ee 0f       	add	r30, r30
    2928:	ff 1f       	adc	r31, r31
    292a:	ee 0f       	add	r30, r30
    292c:	ff 1f       	adc	r31, r31
    292e:	ec 50       	subi	r30, 0x0C	; 12
    2930:	fc 4f       	sbci	r31, 0xFC	; 252
    2932:	20 81       	ld	r18, Z
    2934:	31 81       	ldd	r19, Z+1	; 0x01
    2936:	00 d0       	rcall	.+0      	; 0x2938 <commandGetOptZeroPos+0x44>
    2938:	00 d0       	rcall	.+0      	; 0x293a <commandGetOptZeroPos+0x46>
    293a:	00 d0       	rcall	.+0      	; 0x293c <commandGetOptZeroPos+0x48>
    293c:	ed b7       	in	r30, 0x3d	; 61
    293e:	fe b7       	in	r31, 0x3e	; 62
    2940:	31 96       	adiw	r30, 0x01	; 1
    2942:	ad b7       	in	r26, 0x3d	; 61
    2944:	be b7       	in	r27, 0x3e	; 62
    2946:	12 96       	adiw	r26, 0x02	; 2
    2948:	5c 93       	st	X, r21
    294a:	4e 93       	st	-X, r20
    294c:	11 97       	sbiw	r26, 0x01	; 1
    294e:	87 e1       	ldi	r24, 0x17	; 23
    2950:	91 e0       	ldi	r25, 0x01	; 1
    2952:	93 83       	std	Z+3, r25	; 0x03
    2954:	82 83       	std	Z+2, r24	; 0x02
    2956:	35 83       	std	Z+5, r19	; 0x05
    2958:	24 83       	std	Z+4, r18	; 0x04
    295a:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    295e:	8d b7       	in	r24, 0x3d	; 61
    2960:	9e b7       	in	r25, 0x3e	; 62
    2962:	06 96       	adiw	r24, 0x06	; 6
    2964:	0f b6       	in	r0, 0x3f	; 63
    2966:	f8 94       	cli
    2968:	9e bf       	out	0x3e, r25	; 62
    296a:	0f be       	out	0x3f, r0	; 63
    296c:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    296e:	20 91 e7 03 	lds	r18, 0x03E7
    2972:	30 91 e8 03 	lds	r19, 0x03E8
}
    2976:	c9 01       	movw	r24, r18
    2978:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    297a:	80 91 e7 03 	lds	r24, 0x03E7
    297e:	90 91 e8 03 	lds	r25, 0x03E8
    2982:	00 d0       	rcall	.+0      	; 0x2984 <commandGetOptZeroPos+0x90>
    2984:	00 d0       	rcall	.+0      	; 0x2986 <commandGetOptZeroPos+0x92>
    2986:	00 d0       	rcall	.+0      	; 0x2988 <commandGetOptZeroPos+0x94>
    2988:	ed b7       	in	r30, 0x3d	; 61
    298a:	fe b7       	in	r31, 0x3e	; 62
    298c:	31 96       	adiw	r30, 0x01	; 1
    298e:	ad b7       	in	r26, 0x3d	; 61
    2990:	be b7       	in	r27, 0x3e	; 62
    2992:	12 96       	adiw	r26, 0x02	; 2
    2994:	9c 93       	st	X, r25
    2996:	8e 93       	st	-X, r24
    2998:	11 97       	sbiw	r26, 0x01	; 1
    299a:	80 e0       	ldi	r24, 0x00	; 0
    299c:	91 e0       	ldi	r25, 0x01	; 1
    299e:	93 83       	std	Z+3, r25	; 0x03
    29a0:	82 83       	std	Z+2, r24	; 0x02
    29a2:	64 83       	std	Z+4, r22	; 0x04
    29a4:	15 82       	std	Z+5, r1	; 0x05
    29a6:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    29aa:	8d b7       	in	r24, 0x3d	; 61
    29ac:	9e b7       	in	r25, 0x3e	; 62
    29ae:	06 96       	adiw	r24, 0x06	; 6
    29b0:	0f b6       	in	r0, 0x3f	; 63
    29b2:	f8 94       	cli
    29b4:	9e bf       	out	0x3e, r25	; 62
    29b6:	0f be       	out	0x3f, r0	; 63
    29b8:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].opticalZeroPosition);
  }

  return txString.buffer;
    29ba:	20 91 e7 03 	lds	r18, 0x03E7
    29be:	30 91 e8 03 	lds	r19, 0x03E8
}
    29c2:	c9 01       	movw	r24, r18
    29c4:	08 95       	ret

000029c6 <commandGetAnalog>:
char* commandGetAnalog(char* param0){

  uint8_t i = 0;
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    29c6:	60 e0       	ldi	r22, 0x00	; 0
    29c8:	70 e0       	ldi	r23, 0x00	; 0
    29ca:	4a e0       	ldi	r20, 0x0A	; 10
    29cc:	50 e0       	ldi	r21, 0x00	; 0
    29ce:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if((i < MOTOR_SENS0) || (i > MOTOR_SENS_MAX)){
    29d2:	64 30       	cpi	r22, 0x04	; 4
    29d4:	48 f5       	brcc	.+82     	; 0x2a28 <commandGetAnalog+0x62>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    val = getADCvalue(i);
    29d6:	86 2f       	mov	r24, r22
    29d8:	0e 94 a9 06 	call	0xd52	; 0xd52 <getADCvalue>
    sprintf(txString.buffer, "%d", val);
    29dc:	20 91 e7 03 	lds	r18, 0x03E7
    29e0:	30 91 e8 03 	lds	r19, 0x03E8
    29e4:	00 d0       	rcall	.+0      	; 0x29e6 <commandGetAnalog+0x20>
    29e6:	00 d0       	rcall	.+0      	; 0x29e8 <commandGetAnalog+0x22>
    29e8:	00 d0       	rcall	.+0      	; 0x29ea <commandGetAnalog+0x24>
    29ea:	ed b7       	in	r30, 0x3d	; 61
    29ec:	fe b7       	in	r31, 0x3e	; 62
    29ee:	31 96       	adiw	r30, 0x01	; 1
    29f0:	ad b7       	in	r26, 0x3d	; 61
    29f2:	be b7       	in	r27, 0x3e	; 62
    29f4:	12 96       	adiw	r26, 0x02	; 2
    29f6:	3c 93       	st	X, r19
    29f8:	2e 93       	st	-X, r18
    29fa:	11 97       	sbiw	r26, 0x01	; 1
    29fc:	27 e1       	ldi	r18, 0x17	; 23
    29fe:	31 e0       	ldi	r19, 0x01	; 1
    2a00:	33 83       	std	Z+3, r19	; 0x03
    2a02:	22 83       	std	Z+2, r18	; 0x02
    2a04:	95 83       	std	Z+5, r25	; 0x05
    2a06:	84 83       	std	Z+4, r24	; 0x04
    2a08:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    2a0c:	8d b7       	in	r24, 0x3d	; 61
    2a0e:	9e b7       	in	r25, 0x3e	; 62
    2a10:	06 96       	adiw	r24, 0x06	; 6
    2a12:	0f b6       	in	r0, 0x3f	; 63
    2a14:	f8 94       	cli
    2a16:	9e bf       	out	0x3e, r25	; 62
    2a18:	0f be       	out	0x3f, r0	; 63
    2a1a:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    2a1c:	20 91 e7 03 	lds	r18, 0x03E7
    2a20:	30 91 e8 03 	lds	r19, 0x03E8
}
    2a24:	c9 01       	movw	r24, r18
    2a26:	08 95       	ret
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if((i < MOTOR_SENS0) || (i > MOTOR_SENS_MAX)){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2a28:	80 91 e7 03 	lds	r24, 0x03E7
    2a2c:	90 91 e8 03 	lds	r25, 0x03E8
    2a30:	00 d0       	rcall	.+0      	; 0x2a32 <commandGetAnalog+0x6c>
    2a32:	00 d0       	rcall	.+0      	; 0x2a34 <commandGetAnalog+0x6e>
    2a34:	00 d0       	rcall	.+0      	; 0x2a36 <commandGetAnalog+0x70>
    2a36:	ed b7       	in	r30, 0x3d	; 61
    2a38:	fe b7       	in	r31, 0x3e	; 62
    2a3a:	31 96       	adiw	r30, 0x01	; 1
    2a3c:	ad b7       	in	r26, 0x3d	; 61
    2a3e:	be b7       	in	r27, 0x3e	; 62
    2a40:	12 96       	adiw	r26, 0x02	; 2
    2a42:	9c 93       	st	X, r25
    2a44:	8e 93       	st	-X, r24
    2a46:	11 97       	sbiw	r26, 0x01	; 1
    2a48:	80 e0       	ldi	r24, 0x00	; 0
    2a4a:	91 e0       	ldi	r25, 0x01	; 1
    2a4c:	93 83       	std	Z+3, r25	; 0x03
    2a4e:	82 83       	std	Z+2, r24	; 0x02
    2a50:	64 83       	std	Z+4, r22	; 0x04
    2a52:	15 82       	std	Z+5, r1	; 0x05
    2a54:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    2a58:	8d b7       	in	r24, 0x3d	; 61
    2a5a:	9e b7       	in	r25, 0x3e	; 62
    2a5c:	06 96       	adiw	r24, 0x06	; 6
    2a5e:	0f b6       	in	r0, 0x3f	; 63
    2a60:	f8 94       	cli
    2a62:	9e bf       	out	0x3e, r25	; 62
    2a64:	0f be       	out	0x3f, r0	; 63
    2a66:	8d bf       	out	0x3d, r24	; 61
  else{
    val = getADCvalue(i);
    sprintf(txString.buffer, "%d", val);
  }

  return txString.buffer;
    2a68:	20 91 e7 03 	lds	r18, 0x03E7
    2a6c:	30 91 e8 03 	lds	r19, 0x03E8
}
    2a70:	c9 01       	movw	r24, r18
    2a72:	08 95       	ret

00002a74 <commandIsMoving>:
 --------------------------------------------------------------------- */
char* commandIsMoving(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2a74:	60 e0       	ldi	r22, 0x00	; 0
    2a76:	70 e0       	ldi	r23, 0x00	; 0
    2a78:	4a e0       	ldi	r20, 0x0A	; 10
    2a7a:	50 e0       	ldi	r21, 0x00	; 0
    2a7c:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if(i > MAX_MOTOR){
    2a80:	64 30       	cpi	r22, 0x04	; 4
    2a82:	08 f0       	brcs	.+2      	; 0x2a86 <commandIsMoving+0x12>
    2a84:	45 c0       	rjmp	.+138    	; 0x2b10 <commandIsMoving+0x9c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(motor[i].desiredPosition - motor[i].actualPosition){
    2a86:	e6 2f       	mov	r30, r22
    2a88:	f0 e0       	ldi	r31, 0x00	; 0
    2a8a:	ee 0f       	add	r30, r30
    2a8c:	ff 1f       	adc	r31, r31
    2a8e:	ee 0f       	add	r30, r30
    2a90:	ff 1f       	adc	r31, r31
    2a92:	cf 01       	movw	r24, r30
    2a94:	88 0f       	add	r24, r24
    2a96:	99 1f       	adc	r25, r25
    2a98:	88 0f       	add	r24, r24
    2a9a:	99 1f       	adc	r25, r25
    2a9c:	e8 0f       	add	r30, r24
    2a9e:	f9 1f       	adc	r31, r25
    2aa0:	ee 0f       	add	r30, r30
    2aa2:	ff 1f       	adc	r31, r31
    2aa4:	ee 50       	subi	r30, 0x0E	; 14
    2aa6:	fc 4f       	sbci	r31, 0xFC	; 252
    2aa8:	20 81       	ld	r18, Z
    2aaa:	31 81       	ldd	r19, Z+1	; 0x01
    2aac:	e6 2f       	mov	r30, r22
    2aae:	f0 e0       	ldi	r31, 0x00	; 0
    2ab0:	ee 0f       	add	r30, r30
    2ab2:	ff 1f       	adc	r31, r31
    2ab4:	ee 0f       	add	r30, r30
    2ab6:	ff 1f       	adc	r31, r31
    2ab8:	ee 0f       	add	r30, r30
    2aba:	ff 1f       	adc	r31, r31
    2abc:	cf 01       	movw	r24, r30
    2abe:	88 0f       	add	r24, r24
    2ac0:	99 1f       	adc	r25, r25
    2ac2:	88 0f       	add	r24, r24
    2ac4:	99 1f       	adc	r25, r25
    2ac6:	e8 0f       	add	r30, r24
    2ac8:	f9 1f       	adc	r31, r25
    2aca:	e0 51       	subi	r30, 0x10	; 16
    2acc:	fc 4f       	sbci	r31, 0xFC	; 252
    2ace:	80 81       	ld	r24, Z
    2ad0:	91 81       	ldd	r25, Z+1	; 0x01
    2ad2:	28 17       	cp	r18, r24
    2ad4:	39 07       	cpc	r19, r25
    2ad6:	71 f0       	breq	.+28     	; 0x2af4 <commandIsMoving+0x80>
      sprintf(txString.buffer, "1");
    2ad8:	e0 91 e7 03 	lds	r30, 0x03E7
    2adc:	f0 91 e8 03 	lds	r31, 0x03E8
    2ae0:	81 e3       	ldi	r24, 0x31	; 49
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	91 83       	std	Z+1, r25	; 0x01
    2ae6:	80 83       	st	Z, r24
    else{
      sprintf(txString.buffer, "0");
    }
  }

  return txString.buffer;
    2ae8:	20 91 e7 03 	lds	r18, 0x03E7
    2aec:	30 91 e8 03 	lds	r19, 0x03E8
}
    2af0:	c9 01       	movw	r24, r18
    2af2:	08 95       	ret
  else{
    if(motor[i].desiredPosition - motor[i].actualPosition){
      sprintf(txString.buffer, "1");
    }
    else{
      sprintf(txString.buffer, "0");
    2af4:	e0 91 e7 03 	lds	r30, 0x03E7
    2af8:	f0 91 e8 03 	lds	r31, 0x03E8
    2afc:	80 e3       	ldi	r24, 0x30	; 48
    2afe:	90 e0       	ldi	r25, 0x00	; 0
    2b00:	91 83       	std	Z+1, r25	; 0x01
    2b02:	80 83       	st	Z, r24
    }
  }

  return txString.buffer;
    2b04:	20 91 e7 03 	lds	r18, 0x03E7
    2b08:	30 91 e8 03 	lds	r19, 0x03E8
}
    2b0c:	c9 01       	movw	r24, r18
    2b0e:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2b10:	80 91 e7 03 	lds	r24, 0x03E7
    2b14:	90 91 e8 03 	lds	r25, 0x03E8
    2b18:	00 d0       	rcall	.+0      	; 0x2b1a <commandIsMoving+0xa6>
    2b1a:	00 d0       	rcall	.+0      	; 0x2b1c <commandIsMoving+0xa8>
    2b1c:	00 d0       	rcall	.+0      	; 0x2b1e <commandIsMoving+0xaa>
    2b1e:	ed b7       	in	r30, 0x3d	; 61
    2b20:	fe b7       	in	r31, 0x3e	; 62
    2b22:	31 96       	adiw	r30, 0x01	; 1
    2b24:	ad b7       	in	r26, 0x3d	; 61
    2b26:	be b7       	in	r27, 0x3e	; 62
    2b28:	12 96       	adiw	r26, 0x02	; 2
    2b2a:	9c 93       	st	X, r25
    2b2c:	8e 93       	st	-X, r24
    2b2e:	11 97       	sbiw	r26, 0x01	; 1
    2b30:	80 e0       	ldi	r24, 0x00	; 0
    2b32:	91 e0       	ldi	r25, 0x01	; 1
    2b34:	93 83       	std	Z+3, r25	; 0x03
    2b36:	82 83       	std	Z+2, r24	; 0x02
    2b38:	64 83       	std	Z+4, r22	; 0x04
    2b3a:	15 82       	std	Z+5, r1	; 0x05
    2b3c:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    2b40:	8d b7       	in	r24, 0x3d	; 61
    2b42:	9e b7       	in	r25, 0x3e	; 62
    2b44:	06 96       	adiw	r24, 0x06	; 6
    2b46:	0f b6       	in	r0, 0x3f	; 63
    2b48:	f8 94       	cli
    2b4a:	9e bf       	out	0x3e, r25	; 62
    2b4c:	0f be       	out	0x3f, r0	; 63
    2b4e:	8d bf       	out	0x3d, r24	; 61
    else{
      sprintf(txString.buffer, "0");
    }
  }

  return txString.buffer;
    2b50:	20 91 e7 03 	lds	r18, 0x03E7
    2b54:	30 91 e8 03 	lds	r19, 0x03E8
}
    2b58:	c9 01       	movw	r24, r18
    2b5a:	08 95       	ret

00002b5c <updateDisplayChangeValues>:

/* ---------------------------------------------------------------------
   update the display after switching to value-changing-mode
   or update changed values for a motor on the display
 --------------------------------------------------------------------- */
void updateDisplayChangeValues(uint8_t thisMenu){
    2b5c:	2f 92       	push	r2
    2b5e:	3f 92       	push	r3
    2b60:	4f 92       	push	r4
    2b62:	5f 92       	push	r5
    2b64:	6f 92       	push	r6
    2b66:	7f 92       	push	r7
    2b68:	8f 92       	push	r8
    2b6a:	9f 92       	push	r9
    2b6c:	af 92       	push	r10
    2b6e:	bf 92       	push	r11
    2b70:	df 92       	push	r13
    2b72:	ef 92       	push	r14
    2b74:	ff 92       	push	r15
    2b76:	0f 93       	push	r16
    2b78:	1f 93       	push	r17
    2b7a:	cf 93       	push	r28
    2b7c:	df 93       	push	r29

  uint8_t sLen;
  uint8_t c = 0;

  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
    2b7e:	90 e0       	ldi	r25, 0x00	; 0
    2b80:	88 0f       	add	r24, r24
    2b82:	99 1f       	adc	r25, r25
    2b84:	8e 51       	subi	r24, 0x1E	; 30
    2b86:	9b 4f       	sbci	r25, 0xFB	; 251
    2b88:	fc 01       	movw	r30, r24
    2b8a:	25 91       	lpm	r18, Z+
    2b8c:	34 91       	lpm	r19, Z+
  state = (uint8_t)pgm_read_byte(&menuPtr->state);
    2b8e:	2e 5f       	subi	r18, 0xFE	; 254
    2b90:	3f 4f       	sbci	r19, 0xFF	; 255
    2b92:	f9 01       	movw	r30, r18
    2b94:	84 91       	lpm	r24, Z+

  /* load the values of all 4 motors */
  switch(state){
    2b96:	86 30       	cpi	r24, 0x06	; 6
    2b98:	09 f4       	brne	.+2      	; 0x2b9c <updateDisplayChangeValues+0x40>
    2b9a:	61 c4       	rjmp	.+2242   	; 0x345e <updateDisplayChangeValues+0x902>
    2b9c:	87 30       	cpi	r24, 0x07	; 7
    2b9e:	08 f4       	brcc	.+2      	; 0x2ba2 <updateDisplayChangeValues+0x46>
    2ba0:	55 c0       	rjmp	.+170    	; 0x2c4c <updateDisplayChangeValues+0xf0>
    2ba2:	8b 30       	cpi	r24, 0x0B	; 11
    2ba4:	09 f4       	brne	.+2      	; 0x2ba8 <updateDisplayChangeValues+0x4c>
    2ba6:	c8 c5       	rjmp	.+2960   	; 0x3738 <updateDisplayChangeValues+0xbdc>
    2ba8:	8c 30       	cpi	r24, 0x0C	; 12
    2baa:	08 f0       	brcs	.+2      	; 0x2bae <updateDisplayChangeValues+0x52>
    2bac:	bd c0       	rjmp	.+378    	; 0x2d28 <updateDisplayChangeValues+0x1cc>
    2bae:	88 30       	cpi	r24, 0x08	; 8
    2bb0:	09 f4       	brne	.+2      	; 0x2bb4 <updateDisplayChangeValues+0x58>
    2bb2:	82 c5       	rjmp	.+2820   	; 0x36b8 <updateDisplayChangeValues+0xb5c>
    2bb4:	88 30       	cpi	r24, 0x08	; 8
    2bb6:	08 f4       	brcc	.+2      	; 0x2bba <updateDisplayChangeValues+0x5e>
    2bb8:	0f c5       	rjmp	.+2590   	; 0x35d8 <updateDisplayChangeValues+0xa7c>
    2bba:	8a 30       	cpi	r24, 0x0A	; 10
    2bbc:	09 f4       	brne	.+2      	; 0x2bc0 <updateDisplayChangeValues+0x64>
    2bbe:	af c4       	rjmp	.+2398   	; 0x351e <updateDisplayChangeValues+0x9c2>
    case MENU_SETTINGS:
      sprintf(menu.newDisplayValue[0], "test    ");
      sprintf(menu.newDisplayValue[1], "test    ");
      sprintf(menu.newDisplayValue[2], "test    ");
      sprintf(menu.newDisplayValue[3], "test    ");
      menu.currentMenuMode = MENU_SETTINGS_MODE;
    2bc0:	20 e0       	ldi	r18, 0x00	; 0
    2bc2:	30 e0       	ldi	r19, 0x00	; 0

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
      menu.newDisplayValue[i][j] = ' ';
    2bc4:	90 e2       	ldi	r25, 0x20	; 32
      break;
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    2bc6:	a0 91 e8 02 	lds	r26, 0x02E8
    2bca:	b0 91 e9 02 	lds	r27, 0x02E9
    2bce:	a2 0f       	add	r26, r18
    2bd0:	b3 1f       	adc	r27, r19
    2bd2:	ec 91       	ld	r30, X
    2bd4:	11 96       	adiw	r26, 0x01	; 1
    2bd6:	fc 91       	ld	r31, X
    2bd8:	df 01       	movw	r26, r30
    2bda:	0d 90       	ld	r0, X+
    2bdc:	00 20       	and	r0, r0
    2bde:	e9 f7       	brne	.-6      	; 0x2bda <updateDisplayChangeValues+0x7e>
    2be0:	11 97       	sbiw	r26, 0x01	; 1
    2be2:	ae 1b       	sub	r26, r30
    2be4:	bf 0b       	sbc	r27, r31
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
    2be6:	a8 30       	cpi	r26, 0x08	; 8
    2be8:	80 f4       	brcc	.+32     	; 0x2c0a <updateDisplayChangeValues+0xae>
    2bea:	8a 2f       	mov	r24, r26
      menu.newDisplayValue[i][j] = ' ';
    2bec:	e0 91 e8 02 	lds	r30, 0x02E8
    2bf0:	f0 91 e9 02 	lds	r31, 0x02E9
    2bf4:	e2 0f       	add	r30, r18
    2bf6:	f3 1f       	adc	r31, r19
    2bf8:	01 90       	ld	r0, Z+
    2bfa:	f0 81       	ld	r31, Z
    2bfc:	e0 2d       	mov	r30, r0
    2bfe:	e8 0f       	add	r30, r24
    2c00:	f1 1d       	adc	r31, r1
    2c02:	90 83       	st	Z, r25
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
    2c04:	8f 5f       	subi	r24, 0xFF	; 255
    2c06:	88 30       	cpi	r24, 0x08	; 8
    2c08:	88 f3       	brcs	.-30     	; 0x2bec <updateDisplayChangeValues+0x90>
      menu.newDisplayValue[i][j] = ' ';
    }
    menu.newDisplayValue[i][DISPLAY_VALUE_STRING_LENGTH-1] = '\0';
    2c0a:	e0 91 e8 02 	lds	r30, 0x02E8
    2c0e:	f0 91 e9 02 	lds	r31, 0x02E9
    2c12:	e2 0f       	add	r30, r18
    2c14:	f3 1f       	adc	r31, r19
    2c16:	01 90       	ld	r0, Z+
    2c18:	f0 81       	ld	r31, Z
    2c1a:	e0 2d       	mov	r30, r0
    2c1c:	10 86       	std	Z+8, r1	; 0x08
    2c1e:	2e 5f       	subi	r18, 0xFE	; 254
    2c20:	3f 4f       	sbci	r19, 0xFF	; 255
    default:  /* in case of fire ;-) */
      break;
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    2c22:	28 30       	cpi	r18, 0x08	; 8
    2c24:	31 05       	cpc	r19, r1
    2c26:	79 f6       	brne	.-98     	; 0x2bc6 <updateDisplayChangeValues+0x6a>
    }
    menu.newDisplayValue[i][DISPLAY_VALUE_STRING_LENGTH-1] = '\0';
  }

  return;
}
    2c28:	df 91       	pop	r29
    2c2a:	cf 91       	pop	r28
    2c2c:	1f 91       	pop	r17
    2c2e:	0f 91       	pop	r16
    2c30:	ff 90       	pop	r15
    2c32:	ef 90       	pop	r14
    2c34:	df 90       	pop	r13
    2c36:	bf 90       	pop	r11
    2c38:	af 90       	pop	r10
    2c3a:	9f 90       	pop	r9
    2c3c:	8f 90       	pop	r8
    2c3e:	7f 90       	pop	r7
    2c40:	6f 90       	pop	r6
    2c42:	5f 90       	pop	r5
    2c44:	4f 90       	pop	r4
    2c46:	3f 90       	pop	r3
    2c48:	2f 90       	pop	r2
    2c4a:	08 95       	ret
  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    2c4c:	82 30       	cpi	r24, 0x02	; 2
    2c4e:	09 f4       	brne	.+2      	; 0x2c52 <updateDisplayChangeValues+0xf6>
    2c50:	a9 c3       	rjmp	.+1874   	; 0x33a4 <updateDisplayChangeValues+0x848>
    2c52:	83 30       	cpi	r24, 0x03	; 3
    2c54:	08 f4       	brcc	.+2      	; 0x2c58 <updateDisplayChangeValues+0xfc>
    2c56:	ae c0       	rjmp	.+348    	; 0x2db4 <updateDisplayChangeValues+0x258>
    2c58:	84 30       	cpi	r24, 0x04	; 4
    2c5a:	09 f4       	brne	.+2      	; 0x2c5e <updateDisplayChangeValues+0x102>
    2c5c:	f0 c1       	rjmp	.+992    	; 0x303e <updateDisplayChangeValues+0x4e2>
    2c5e:	85 30       	cpi	r24, 0x05	; 5
    2c60:	08 f4       	brcc	.+2      	; 0x2c64 <updateDisplayChangeValues+0x108>
    2c62:	50 c1       	rjmp	.+672    	; 0x2f04 <updateDisplayChangeValues+0x3a8>
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
    2c64:	c0 e0       	ldi	r28, 0x00	; 0
    2c66:	d0 e0       	ldi	r29, 0x00	; 0
    2c68:	ee 24       	eor	r14, r14
    2c6a:	ff 24       	eor	r15, r15
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    2c6c:	90 ee       	ldi	r25, 0xE0	; 224
    2c6e:	a9 2e       	mov	r10, r25
    2c70:	91 e0       	ldi	r25, 0x01	; 1
    2c72:	b9 2e       	mov	r11, r25
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
    2c74:	8b ed       	ldi	r24, 0xDB	; 219
    2c76:	88 2e       	mov	r8, r24
    2c78:	81 e0       	ldi	r24, 0x01	; 1
    2c7a:	98 2e       	mov	r9, r24
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
    2c7c:	04 ed       	ldi	r16, 0xD4	; 212
    2c7e:	60 2e       	mov	r6, r16
    2c80:	01 e0       	ldi	r16, 0x01	; 1
    2c82:	70 2e       	mov	r7, r16
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    2c84:	80 91 e5 02 	lds	r24, 0x02E5
    2c88:	90 e0       	ldi	r25, 0x00	; 0
    2c8a:	0c 2e       	mov	r0, r28
    2c8c:	02 c0       	rjmp	.+4      	; 0x2c92 <updateDisplayChangeValues+0x136>
    2c8e:	95 95       	asr	r25
    2c90:	87 95       	ror	r24
    2c92:	0a 94       	dec	r0
    2c94:	e2 f7       	brpl	.-8      	; 0x2c8e <updateDisplayChangeValues+0x132>
    2c96:	80 fd       	sbrc	r24, 0
    2c98:	1d c1       	rjmp	.+570    	; 0x2ed4 <updateDisplayChangeValues+0x378>
    2c9a:	10 e2       	ldi	r17, 0x20	; 32
    2c9c:	d1 2e       	mov	r13, r17
        if(forbiddenZone[i].active){
    2c9e:	fe 01       	movw	r30, r28
    2ca0:	ee 0f       	add	r30, r30
    2ca2:	ff 1f       	adc	r31, r31
    2ca4:	ee 0f       	add	r30, r30
    2ca6:	ff 1f       	adc	r31, r31
    2ca8:	ec 0f       	add	r30, r28
    2caa:	fd 1f       	adc	r31, r29
    2cac:	ed 52       	subi	r30, 0x2D	; 45
    2cae:	fc 4f       	sbci	r31, 0xFC	; 252
    2cb0:	84 81       	ldd	r24, Z+4	; 0x04
    2cb2:	88 23       	and	r24, r24
    2cb4:	09 f0       	breq	.+2      	; 0x2cb8 <updateDisplayChangeValues+0x15c>
    2cb6:	11 c1       	rjmp	.+546    	; 0x2eda <updateDisplayChangeValues+0x37e>
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
    2cb8:	8e 01       	movw	r16, r28
    2cba:	00 0f       	add	r16, r16
    2cbc:	11 1f       	adc	r17, r17
    2cbe:	00 0f       	add	r16, r16
    2cc0:	11 1f       	adc	r17, r17
    2cc2:	00 0f       	add	r16, r16
    2cc4:	11 1f       	adc	r17, r17
    2cc6:	f8 01       	movw	r30, r16
    2cc8:	ee 0f       	add	r30, r30
    2cca:	ff 1f       	adc	r31, r31
    2ccc:	ee 0f       	add	r30, r30
    2cce:	ff 1f       	adc	r31, r31
    2cd0:	e0 0f       	add	r30, r16
    2cd2:	f1 1f       	adc	r31, r17
    2cd4:	e0 51       	subi	r30, 0x10	; 16
    2cd6:	fc 4f       	sbci	r31, 0xFC	; 252
    2cd8:	82 a1       	ldd	r24, Z+34	; 0x22
    2cda:	88 23       	and	r24, r24
    2cdc:	09 f4       	brne	.+2      	; 0x2ce0 <updateDisplayChangeValues+0x184>
    2cde:	8c c5       	rjmp	.+2840   	; 0x37f8 <updateDisplayChangeValues+0xc9c>
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
    2ce0:	f8 01       	movw	r30, r16
    2ce2:	ee 0f       	add	r30, r30
    2ce4:	ff 1f       	adc	r31, r31
    2ce6:	ee 0f       	add	r30, r30
    2ce8:	ff 1f       	adc	r31, r31
    2cea:	e0 0f       	add	r30, r16
    2cec:	f1 1f       	adc	r31, r17
    2cee:	e0 51       	subi	r30, 0x10	; 16
    2cf0:	fc 4f       	sbci	r31, 0xFC	; 252
    2cf2:	82 a1       	ldd	r24, Z+34	; 0x22
    2cf4:	81 30       	cpi	r24, 0x01	; 1
    2cf6:	09 f4       	brne	.+2      	; 0x2cfa <updateDisplayChangeValues+0x19e>
    2cf8:	2f c6       	rjmp	.+3166   	; 0x3958 <updateDisplayChangeValues+0xdfc>
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
    2cfa:	f8 01       	movw	r30, r16
    2cfc:	ee 0f       	add	r30, r30
    2cfe:	ff 1f       	adc	r31, r31
    2d00:	ee 0f       	add	r30, r30
    2d02:	ff 1f       	adc	r31, r31
    2d04:	e0 0f       	add	r30, r16
    2d06:	f1 1f       	adc	r31, r17
    2d08:	e0 51       	subi	r30, 0x10	; 16
    2d0a:	fc 4f       	sbci	r31, 0xFC	; 252
    2d0c:	82 a1       	ldd	r24, Z+34	; 0x22
    2d0e:	82 30       	cpi	r24, 0x02	; 2
    2d10:	09 f4       	brne	.+2      	; 0x2d14 <updateDisplayChangeValues+0x1b8>
    2d12:	fb c5       	rjmp	.+3062   	; 0x390a <updateDisplayChangeValues+0xdae>
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    2d14:	21 96       	adiw	r28, 0x01	; 1
    2d16:	82 e0       	ldi	r24, 0x02	; 2
    2d18:	90 e0       	ldi	r25, 0x00	; 0
    2d1a:	e8 0e       	add	r14, r24
    2d1c:	f9 1e       	adc	r15, r25
        sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].opticalZeroPosition);
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
    2d1e:	c4 30       	cpi	r28, 0x04	; 4
    2d20:	d1 05       	cpc	r29, r1
    2d22:	09 f0       	breq	.+2      	; 0x2d26 <updateDisplayChangeValues+0x1ca>
    2d24:	af cf       	rjmp	.-162    	; 0x2c84 <updateDisplayChangeValues+0x128>
    2d26:	4c cf       	rjmp	.-360    	; 0x2bc0 <updateDisplayChangeValues+0x64>
  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    2d28:	8d 30       	cpi	r24, 0x0D	; 13
    2d2a:	09 f4       	brne	.+2      	; 0x2d2e <updateDisplayChangeValues+0x1d2>
    2d2c:	39 c2       	rjmp	.+1138   	; 0x31a0 <updateDisplayChangeValues+0x644>
    2d2e:	8d 30       	cpi	r24, 0x0D	; 13
    2d30:	08 f4       	brcc	.+2      	; 0x2d34 <updateDisplayChangeValues+0x1d8>
    2d32:	dd c1       	rjmp	.+954    	; 0x30ee <updateDisplayChangeValues+0x592>
    2d34:	8e 30       	cpi	r24, 0x0E	; 14
    2d36:	09 f0       	breq	.+2      	; 0x2d3a <updateDisplayChangeValues+0x1de>
    2d38:	43 cf       	rjmp	.-378    	; 0x2bc0 <updateDisplayChangeValues+0x64>
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_LOAD_CONFIG:
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Load all");
    2d3a:	e0 91 e8 02 	lds	r30, 0x02E8
    2d3e:	f0 91 e9 02 	lds	r31, 0x02E9
    2d42:	20 81       	ld	r18, Z
    2d44:	31 81       	ldd	r19, Z+1	; 0x01
    2d46:	c9 01       	movw	r24, r18
    2d48:	dc 01       	movw	r26, r24
    2d4a:	e2 ec       	ldi	r30, 0xC2	; 194
    2d4c:	f1 e0       	ldi	r31, 0x01	; 1
    2d4e:	89 e0       	ldi	r24, 0x09	; 9
    2d50:	01 90       	ld	r0, Z+
    2d52:	0d 92       	st	X+, r0
    2d54:	81 50       	subi	r24, 0x01	; 1
    2d56:	e1 f7       	brne	.-8      	; 0x2d50 <updateDisplayChangeValues+0x1f4>
      sprintf(menu.newDisplayValue[1], " saved  ");
    2d58:	e0 91 e8 02 	lds	r30, 0x02E8
    2d5c:	f0 91 e9 02 	lds	r31, 0x02E9
    2d60:	22 81       	ldd	r18, Z+2	; 0x02
    2d62:	33 81       	ldd	r19, Z+3	; 0x03
    2d64:	c9 01       	movw	r24, r18
    2d66:	dc 01       	movw	r26, r24
    2d68:	eb ec       	ldi	r30, 0xCB	; 203
    2d6a:	f1 e0       	ldi	r31, 0x01	; 1
    2d6c:	89 e0       	ldi	r24, 0x09	; 9
    2d6e:	01 90       	ld	r0, Z+
    2d70:	0d 92       	st	X+, r0
    2d72:	81 50       	subi	r24, 0x01	; 1
    2d74:	e1 f7       	brne	.-8      	; 0x2d6e <updateDisplayChangeValues+0x212>
      sprintf(menu.newDisplayValue[2], "configur");
    2d76:	e0 91 e8 02 	lds	r30, 0x02E8
    2d7a:	f0 91 e9 02 	lds	r31, 0x02E9
    2d7e:	24 81       	ldd	r18, Z+4	; 0x04
    2d80:	35 81       	ldd	r19, Z+5	; 0x05
    2d82:	c9 01       	movw	r24, r18
    2d84:	dc 01       	movw	r26, r24
    2d86:	e0 eb       	ldi	r30, 0xB0	; 176
    2d88:	f1 e0       	ldi	r31, 0x01	; 1
    2d8a:	89 e0       	ldi	r24, 0x09	; 9
    2d8c:	01 90       	ld	r0, Z+
    2d8e:	0d 92       	st	X+, r0
    2d90:	81 50       	subi	r24, 0x01	; 1
    2d92:	e1 f7       	brne	.-8      	; 0x2d8c <updateDisplayChangeValues+0x230>
      sprintf(menu.newDisplayValue[3], "ations  ");
    2d94:	e0 91 e8 02 	lds	r30, 0x02E8
    2d98:	f0 91 e9 02 	lds	r31, 0x02E9
    2d9c:	26 81       	ldd	r18, Z+6	; 0x06
    2d9e:	37 81       	ldd	r19, Z+7	; 0x07
    2da0:	c9 01       	movw	r24, r18
    2da2:	dc 01       	movw	r26, r24
    2da4:	e9 eb       	ldi	r30, 0xB9	; 185
    2da6:	f1 e0       	ldi	r31, 0x01	; 1
    2da8:	89 e0       	ldi	r24, 0x09	; 9
    2daa:	01 90       	ld	r0, Z+
    2dac:	0d 92       	st	X+, r0
    2dae:	81 50       	subi	r24, 0x01	; 1
    2db0:	e1 f7       	brne	.-8      	; 0x2daa <updateDisplayChangeValues+0x24e>
    2db2:	06 cf       	rjmp	.-500    	; 0x2bc0 <updateDisplayChangeValues+0x64>
  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    2db4:	88 23       	and	r24, r24
    2db6:	09 f4       	brne	.+2      	; 0x2dba <updateDisplayChangeValues+0x25e>
    2db8:	30 c2       	rjmp	.+1120   	; 0x321a <updateDisplayChangeValues+0x6be>
    2dba:	81 30       	cpi	r24, 0x01	; 1
    2dbc:	09 f0       	breq	.+2      	; 0x2dc0 <updateDisplayChangeValues+0x264>
    2dbe:	00 cf       	rjmp	.-512    	; 0x2bc0 <updateDisplayChangeValues+0x64>
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
      sprintf(menu.newDisplayValue[1], "        ");
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;
    2dc0:	c0 e0       	ldi	r28, 0x00	; 0
    2dc2:	d0 e0       	ldi	r29, 0x00	; 0
    2dc4:	ee 24       	eor	r14, r14
    2dc6:	ff 24       	eor	r15, r15
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
            break;

          case MOTOR_STEP_UNIT_DEGREE:
            /* 0xDF is the display code for the degree-circle */
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
    2dc8:	bb e4       	ldi	r27, 0x4B	; 75
    2dca:	ab 2e       	mov	r10, r27
    2dcc:	b1 e0       	ldi	r27, 0x01	; 1
    2dce:	bb 2e       	mov	r11, r27
    2dd0:	af ed       	ldi	r26, 0xDF	; 223
    2dd2:	8a 2e       	mov	r8, r26
    2dd4:	91 2c       	mov	r9, r1
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    2dd6:	f4 e5       	ldi	r31, 0x54	; 84
    2dd8:	6f 2e       	mov	r6, r31
    2dda:	f1 e0       	ldi	r31, 0x01	; 1
    2ddc:	7f 2e       	mov	r7, r31
    2dde:	e7 ef       	ldi	r30, 0xF7	; 247
    2de0:	4e 2e       	mov	r4, r30
    2de2:	51 2c       	mov	r5, r1
            c = 0x3E;
          }
        }
        switch(motor[i].stepUnit){
          case MOTOR_STEP_UNIT_STEP:
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
    2de4:	74 e4       	ldi	r23, 0x44	; 68
    2de6:	27 2e       	mov	r2, r23
    2de8:	71 e0       	ldi	r23, 0x01	; 1
    2dea:	37 2e       	mov	r3, r23
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
      sprintf(menu.newDisplayValue[1], "        ");
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;
    2dec:	4c 2f       	mov	r20, r28

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    2dee:	80 91 e5 02 	lds	r24, 0x02E5
    2df2:	9e 01       	movw	r18, r28
    2df4:	90 e0       	ldi	r25, 0x00	; 0
    2df6:	0c 2e       	mov	r0, r28
    2df8:	02 c0       	rjmp	.+4      	; 0x2dfe <updateDisplayChangeValues+0x2a2>
    2dfa:	95 95       	asr	r25
    2dfc:	87 95       	ror	r24
    2dfe:	0a 94       	dec	r0
    2e00:	e2 f7       	brpl	.-8      	; 0x2dfa <updateDisplayChangeValues+0x29e>
    2e02:	80 fd       	sbrc	r24, 0
    2e04:	60 c0       	rjmp	.+192    	; 0x2ec6 <updateDisplayChangeValues+0x36a>
    2e06:	60 e2       	ldi	r22, 0x20	; 32
    2e08:	d6 2e       	mov	r13, r22
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        switch(motor[i].stepUnit){
    2e0a:	f9 01       	movw	r30, r18
    2e0c:	ee 0f       	add	r30, r30
    2e0e:	ff 1f       	adc	r31, r31
    2e10:	ee 0f       	add	r30, r30
    2e12:	ff 1f       	adc	r31, r31
    2e14:	ee 0f       	add	r30, r30
    2e16:	ff 1f       	adc	r31, r31
    2e18:	cf 01       	movw	r24, r30
    2e1a:	88 0f       	add	r24, r24
    2e1c:	99 1f       	adc	r25, r25
    2e1e:	88 0f       	add	r24, r24
    2e20:	99 1f       	adc	r25, r25
    2e22:	e8 0f       	add	r30, r24
    2e24:	f9 1f       	adc	r31, r25
    2e26:	e0 51       	subi	r30, 0x10	; 16
    2e28:	fc 4f       	sbci	r31, 0xFC	; 252
    2e2a:	81 8d       	ldd	r24, Z+25	; 0x19
    2e2c:	81 30       	cpi	r24, 0x01	; 1
    2e2e:	09 f4       	brne	.+2      	; 0x2e32 <updateDisplayChangeValues+0x2d6>
    2e30:	75 c2       	rjmp	.+1258   	; 0x331c <updateDisplayChangeValues+0x7c0>
    2e32:	82 30       	cpi	r24, 0x02	; 2
    2e34:	09 f4       	brne	.+2      	; 0x2e38 <updateDisplayChangeValues+0x2dc>
    2e36:	2e c2       	rjmp	.+1116   	; 0x3294 <updateDisplayChangeValues+0x738>
    2e38:	88 23       	and	r24, r24
    2e3a:	d9 f5       	brne	.+118    	; 0x2eb2 <updateDisplayChangeValues+0x356>
          case MOTOR_STEP_UNIT_STEP:
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
    2e3c:	a0 91 e8 02 	lds	r26, 0x02E8
    2e40:	b0 91 e9 02 	lds	r27, 0x02E9
    2e44:	f9 01       	movw	r30, r18
    2e46:	ee 0f       	add	r30, r30
    2e48:	ff 1f       	adc	r31, r31
    2e4a:	ee 0f       	add	r30, r30
    2e4c:	ff 1f       	adc	r31, r31
    2e4e:	ee 0f       	add	r30, r30
    2e50:	ff 1f       	adc	r31, r31
    2e52:	cf 01       	movw	r24, r30
    2e54:	88 0f       	add	r24, r24
    2e56:	99 1f       	adc	r25, r25
    2e58:	88 0f       	add	r24, r24
    2e5a:	99 1f       	adc	r25, r25
    2e5c:	e8 0f       	add	r30, r24
    2e5e:	f9 1f       	adc	r31, r25
    2e60:	e0 51       	subi	r30, 0x10	; 16
    2e62:	fc 4f       	sbci	r31, 0xFC	; 252
    2e64:	20 81       	ld	r18, Z
    2e66:	31 81       	ldd	r19, Z+1	; 0x01
    2e68:	8d b7       	in	r24, 0x3d	; 61
    2e6a:	9e b7       	in	r25, 0x3e	; 62
    2e6c:	08 97       	sbiw	r24, 0x08	; 8
    2e6e:	0f b6       	in	r0, 0x3f	; 63
    2e70:	f8 94       	cli
    2e72:	9e bf       	out	0x3e, r25	; 62
    2e74:	0f be       	out	0x3f, r0	; 63
    2e76:	8d bf       	out	0x3d, r24	; 61
    2e78:	ed b7       	in	r30, 0x3d	; 61
    2e7a:	fe b7       	in	r31, 0x3e	; 62
    2e7c:	31 96       	adiw	r30, 0x01	; 1
    2e7e:	ae 0d       	add	r26, r14
    2e80:	bf 1d       	adc	r27, r15
    2e82:	8d 91       	ld	r24, X+
    2e84:	9c 91       	ld	r25, X
    2e86:	ad b7       	in	r26, 0x3d	; 61
    2e88:	be b7       	in	r27, 0x3e	; 62
    2e8a:	12 96       	adiw	r26, 0x02	; 2
    2e8c:	9c 93       	st	X, r25
    2e8e:	8e 93       	st	-X, r24
    2e90:	11 97       	sbiw	r26, 0x01	; 1
    2e92:	33 82       	std	Z+3, r3	; 0x03
    2e94:	22 82       	std	Z+2, r2	; 0x02
    2e96:	d4 82       	std	Z+4, r13	; 0x04
    2e98:	15 82       	std	Z+5, r1	; 0x05
    2e9a:	37 83       	std	Z+7, r19	; 0x07
    2e9c:	26 83       	std	Z+6, r18	; 0x06
    2e9e:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    2ea2:	ed b7       	in	r30, 0x3d	; 61
    2ea4:	fe b7       	in	r31, 0x3e	; 62
    2ea6:	38 96       	adiw	r30, 0x08	; 8
    2ea8:	0f b6       	in	r0, 0x3f	; 63
    2eaa:	f8 94       	cli
    2eac:	fe bf       	out	0x3e, r31	; 62
    2eae:	0f be       	out	0x3f, r0	; 63
    2eb0:	ed bf       	out	0x3d, r30	; 61
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    2eb2:	21 96       	adiw	r28, 0x01	; 1
    2eb4:	22 e0       	ldi	r18, 0x02	; 2
    2eb6:	30 e0       	ldi	r19, 0x00	; 0
    2eb8:	e2 0e       	add	r14, r18
    2eba:	f3 1e       	adc	r15, r19
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
    2ebc:	c4 30       	cpi	r28, 0x04	; 4
    2ebe:	d1 05       	cpc	r29, r1
    2ec0:	09 f0       	breq	.+2      	; 0x2ec4 <updateDisplayChangeValues+0x368>
    2ec2:	94 cf       	rjmp	.-216    	; 0x2dec <updateDisplayChangeValues+0x290>
    2ec4:	7d ce       	rjmp	.-774    	; 0x2bc0 <updateDisplayChangeValues+0x64>
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    2ec6:	80 91 e2 02 	lds	r24, 0x02E2
    2eca:	88 23       	and	r24, r24
    2ecc:	c1 f0       	breq	.+48     	; 0x2efe <updateDisplayChangeValues+0x3a2>
    2ece:	5e e3       	ldi	r21, 0x3E	; 62
    2ed0:	d5 2e       	mov	r13, r21
    2ed2:	9b cf       	rjmp	.-202    	; 0x2e0a <updateDisplayChangeValues+0x2ae>
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    2ed4:	be e7       	ldi	r27, 0x7E	; 126
    2ed6:	db 2e       	mov	r13, r27
    2ed8:	e2 ce       	rjmp	.-572    	; 0x2c9e <updateDisplayChangeValues+0x142>
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
    2eda:	e0 91 e8 02 	lds	r30, 0x02E8
    2ede:	f0 91 e9 02 	lds	r31, 0x02E9
    2ee2:	ee 0d       	add	r30, r14
    2ee4:	ff 1d       	adc	r31, r15
    2ee6:	20 81       	ld	r18, Z
    2ee8:	31 81       	ldd	r19, Z+1	; 0x01
    2eea:	c9 01       	movw	r24, r18
    2eec:	dc 01       	movw	r26, r24
    2eee:	e5 e8       	ldi	r30, 0x85	; 133
    2ef0:	f1 e0       	ldi	r31, 0x01	; 1
    2ef2:	89 e0       	ldi	r24, 0x09	; 9
    2ef4:	01 90       	ld	r0, Z+
    2ef6:	0d 92       	st	X+, r0
    2ef8:	81 50       	subi	r24, 0x01	; 1
    2efa:	e1 f7       	brne	.-8      	; 0x2ef4 <updateDisplayChangeValues+0x398>
    2efc:	0b cf       	rjmp	.-490    	; 0x2d14 <updateDisplayChangeValues+0x1b8>
    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    2efe:	9e e7       	ldi	r25, 0x7E	; 126
    2f00:	d9 2e       	mov	r13, r25
    2f02:	83 cf       	rjmp	.-250    	; 0x2e0a <updateDisplayChangeValues+0x2ae>
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
    2f04:	c0 e0       	ldi	r28, 0x00	; 0
    2f06:	d0 e0       	ldi	r29, 0x00	; 0
    2f08:	00 e0       	ldi	r16, 0x00	; 0
    2f0a:	10 e0       	ldi	r17, 0x00	; 0

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
    2f0c:	9d e5       	ldi	r25, 0x5D	; 93
    2f0e:	a9 2e       	mov	r10, r25
    2f10:	91 e0       	ldi	r25, 0x01	; 1
    2f12:	b9 2e       	mov	r11, r25
    2f14:	82 e6       	ldi	r24, 0x62	; 98
    2f16:	88 2e       	mov	r8, r24
    2f18:	81 e0       	ldi	r24, 0x01	; 1
    2f1a:	98 2e       	mov	r9, r24
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
    2f1c:	b7 e6       	ldi	r27, 0x67	; 103
    2f1e:	6b 2e       	mov	r6, r27
    2f20:	b1 e0       	ldi	r27, 0x01	; 1
    2f22:	7b 2e       	mov	r7, r27
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    2f24:	ae e6       	ldi	r26, 0x6E	; 110
    2f26:	4a 2e       	mov	r4, r26
    2f28:	a1 e0       	ldi	r26, 0x01	; 1
    2f2a:	5a 2e       	mov	r5, r26
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    2f2c:	80 91 e5 02 	lds	r24, 0x02E5
    2f30:	fc 2e       	mov	r15, r28
    2f32:	ed 2e       	mov	r14, r29
    2f34:	90 e0       	ldi	r25, 0x00	; 0
    2f36:	0c 2e       	mov	r0, r28
    2f38:	02 c0       	rjmp	.+4      	; 0x2f3e <updateDisplayChangeValues+0x3e2>
    2f3a:	95 95       	asr	r25
    2f3c:	87 95       	ror	r24
    2f3e:	0a 94       	dec	r0
    2f40:	e2 f7       	brpl	.-8      	; 0x2f3a <updateDisplayChangeValues+0x3de>
    2f42:	80 fd       	sbrc	r24, 0
    2f44:	48 c0       	rjmp	.+144    	; 0x2fd6 <updateDisplayChangeValues+0x47a>
    2f46:	f0 e2       	ldi	r31, 0x20	; 32
    2f48:	df 2e       	mov	r13, r31
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
    2f4a:	ef 2d       	mov	r30, r15
    2f4c:	fe 2d       	mov	r31, r14
    2f4e:	ee 0f       	add	r30, r30
    2f50:	ff 1f       	adc	r31, r31
    2f52:	ee 0f       	add	r30, r30
    2f54:	ff 1f       	adc	r31, r31
    2f56:	ee 0f       	add	r30, r30
    2f58:	ff 1f       	adc	r31, r31
    2f5a:	cf 01       	movw	r24, r30
    2f5c:	88 0f       	add	r24, r24
    2f5e:	99 1f       	adc	r25, r25
    2f60:	88 0f       	add	r24, r24
    2f62:	99 1f       	adc	r25, r25
    2f64:	e8 0f       	add	r30, r24
    2f66:	f9 1f       	adc	r31, r25
    2f68:	e0 51       	subi	r30, 0x10	; 16
    2f6a:	fc 4f       	sbci	r31, 0xFC	; 252
    2f6c:	81 8d       	ldd	r24, Z+25	; 0x19
    2f6e:	88 23       	and	r24, r24
    2f70:	a9 f1       	breq	.+106    	; 0x2fdc <updateDisplayChangeValues+0x480>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
    2f72:	ef 2d       	mov	r30, r15
    2f74:	fe 2d       	mov	r31, r14
    2f76:	ee 0f       	add	r30, r30
    2f78:	ff 1f       	adc	r31, r31
    2f7a:	ee 0f       	add	r30, r30
    2f7c:	ff 1f       	adc	r31, r31
    2f7e:	ee 0f       	add	r30, r30
    2f80:	ff 1f       	adc	r31, r31
    2f82:	cf 01       	movw	r24, r30
    2f84:	88 0f       	add	r24, r24
    2f86:	99 1f       	adc	r25, r25
    2f88:	88 0f       	add	r24, r24
    2f8a:	99 1f       	adc	r25, r25
    2f8c:	e8 0f       	add	r30, r24
    2f8e:	f9 1f       	adc	r31, r25
    2f90:	e0 51       	subi	r30, 0x10	; 16
    2f92:	fc 4f       	sbci	r31, 0xFC	; 252
    2f94:	81 8d       	ldd	r24, Z+25	; 0x19
    2f96:	81 30       	cpi	r24, 0x01	; 1
    2f98:	09 f4       	brne	.+2      	; 0x2f9c <updateDisplayChangeValues+0x440>
    2f9a:	55 c4       	rjmp	.+2218   	; 0x3846 <updateDisplayChangeValues+0xcea>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
    2f9c:	ef 2d       	mov	r30, r15
    2f9e:	fe 2d       	mov	r31, r14
    2fa0:	ee 0f       	add	r30, r30
    2fa2:	ff 1f       	adc	r31, r31
    2fa4:	ee 0f       	add	r30, r30
    2fa6:	ff 1f       	adc	r31, r31
    2fa8:	ee 0f       	add	r30, r30
    2faa:	ff 1f       	adc	r31, r31
    2fac:	cf 01       	movw	r24, r30
    2fae:	88 0f       	add	r24, r24
    2fb0:	99 1f       	adc	r25, r25
    2fb2:	88 0f       	add	r24, r24
    2fb4:	99 1f       	adc	r25, r25
    2fb6:	e8 0f       	add	r30, r24
    2fb8:	f9 1f       	adc	r31, r25
    2fba:	e0 51       	subi	r30, 0x10	; 16
    2fbc:	fc 4f       	sbci	r31, 0xFC	; 252
    2fbe:	81 8d       	ldd	r24, Z+25	; 0x19
    2fc0:	82 30       	cpi	r24, 0x02	; 2
    2fc2:	09 f4       	brne	.+2      	; 0x2fc6 <updateDisplayChangeValues+0x46a>
    2fc4:	71 c4       	rjmp	.+2274   	; 0x38a8 <updateDisplayChangeValues+0xd4c>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    2fc6:	21 96       	adiw	r28, 0x01	; 1
    2fc8:	0e 5f       	subi	r16, 0xFE	; 254
    2fca:	1f 4f       	sbci	r17, 0xFF	; 255
        }
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
    2fcc:	c4 30       	cpi	r28, 0x04	; 4
    2fce:	d1 05       	cpc	r29, r1
    2fd0:	09 f0       	breq	.+2      	; 0x2fd4 <updateDisplayChangeValues+0x478>
    2fd2:	ac cf       	rjmp	.-168    	; 0x2f2c <updateDisplayChangeValues+0x3d0>
    2fd4:	f5 cd       	rjmp	.-1046   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    2fd6:	ee e7       	ldi	r30, 0x7E	; 126
    2fd8:	de 2e       	mov	r13, r30
    2fda:	b7 cf       	rjmp	.-146    	; 0x2f4a <updateDisplayChangeValues+0x3ee>
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
    2fdc:	e0 91 e8 02 	lds	r30, 0x02E8
    2fe0:	f0 91 e9 02 	lds	r31, 0x02E9
    2fe4:	8d b7       	in	r24, 0x3d	; 61
    2fe6:	9e b7       	in	r25, 0x3e	; 62
    2fe8:	08 97       	sbiw	r24, 0x08	; 8
    2fea:	0f b6       	in	r0, 0x3f	; 63
    2fec:	f8 94       	cli
    2fee:	9e bf       	out	0x3e, r25	; 62
    2ff0:	0f be       	out	0x3f, r0	; 63
    2ff2:	8d bf       	out	0x3d, r24	; 61
    2ff4:	ad b7       	in	r26, 0x3d	; 61
    2ff6:	be b7       	in	r27, 0x3e	; 62
    2ff8:	11 96       	adiw	r26, 0x01	; 1
    2ffa:	e0 0f       	add	r30, r16
    2ffc:	f1 1f       	adc	r31, r17
    2ffe:	80 81       	ld	r24, Z
    3000:	91 81       	ldd	r25, Z+1	; 0x01
    3002:	ed b7       	in	r30, 0x3d	; 61
    3004:	fe b7       	in	r31, 0x3e	; 62
    3006:	92 83       	std	Z+2, r25	; 0x02
    3008:	81 83       	std	Z+1, r24	; 0x01
    300a:	13 96       	adiw	r26, 0x03	; 3
    300c:	bc 92       	st	X, r11
    300e:	ae 92       	st	-X, r10
    3010:	12 97       	sbiw	r26, 0x02	; 2
    3012:	14 96       	adiw	r26, 0x04	; 4
    3014:	dc 92       	st	X, r13
    3016:	14 97       	sbiw	r26, 0x04	; 4
    3018:	15 96       	adiw	r26, 0x05	; 5
    301a:	1c 92       	st	X, r1
    301c:	15 97       	sbiw	r26, 0x05	; 5
    301e:	17 96       	adiw	r26, 0x07	; 7
    3020:	9c 92       	st	X, r9
    3022:	8e 92       	st	-X, r8
    3024:	16 97       	sbiw	r26, 0x06	; 6
    3026:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    302a:	2d b7       	in	r18, 0x3d	; 61
    302c:	3e b7       	in	r19, 0x3e	; 62
    302e:	28 5f       	subi	r18, 0xF8	; 248
    3030:	3f 4f       	sbci	r19, 0xFF	; 255
    3032:	0f b6       	in	r0, 0x3f	; 63
    3034:	f8 94       	cli
    3036:	3e bf       	out	0x3e, r19	; 62
    3038:	0f be       	out	0x3f, r0	; 63
    303a:	2d bf       	out	0x3d, r18	; 61
    303c:	9a cf       	rjmp	.-204    	; 0x2f72 <updateDisplayChangeValues+0x416>
        }
      }
      break;

    case MENU_RUN_PROGRAM:
      sprintf(menu.newDisplayValue[0], "Program ");
    303e:	e0 91 e8 02 	lds	r30, 0x02E8
    3042:	f0 91 e9 02 	lds	r31, 0x02E9
    3046:	20 81       	ld	r18, Z
    3048:	31 81       	ldd	r19, Z+1	; 0x01
    304a:	c9 01       	movw	r24, r18
    304c:	dc 01       	movw	r26, r24
    304e:	e6 ee       	ldi	r30, 0xE6	; 230
    3050:	f1 e0       	ldi	r31, 0x01	; 1
    3052:	89 e0       	ldi	r24, 0x09	; 9
    3054:	01 90       	ld	r0, Z+
    3056:	0d 92       	st	X+, r0
    3058:	81 50       	subi	r24, 0x01	; 1
    305a:	e1 f7       	brne	.-8      	; 0x3054 <updateDisplayChangeValues+0x4f8>
      sprintf(menu.newDisplayValue[1], "running ");
    305c:	e0 91 e8 02 	lds	r30, 0x02E8
    3060:	f0 91 e9 02 	lds	r31, 0x02E9
    3064:	22 81       	ldd	r18, Z+2	; 0x02
    3066:	33 81       	ldd	r19, Z+3	; 0x03
    3068:	c9 01       	movw	r24, r18
    306a:	dc 01       	movw	r26, r24
    306c:	ef ee       	ldi	r30, 0xEF	; 239
    306e:	f1 e0       	ldi	r31, 0x01	; 1
    3070:	89 e0       	ldi	r24, 0x09	; 9
    3072:	01 90       	ld	r0, Z+
    3074:	0d 92       	st	X+, r0
    3076:	81 50       	subi	r24, 0x01	; 1
    3078:	e1 f7       	brne	.-8      	; 0x3072 <updateDisplayChangeValues+0x516>
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
    307a:	e0 91 e8 02 	lds	r30, 0x02E8
    307e:	f0 91 e9 02 	lds	r31, 0x02E9
    3082:	20 91 e3 02 	lds	r18, 0x02E3
    3086:	00 d0       	rcall	.+0      	; 0x3088 <updateDisplayChangeValues+0x52c>
    3088:	00 d0       	rcall	.+0      	; 0x308a <updateDisplayChangeValues+0x52e>
    308a:	00 d0       	rcall	.+0      	; 0x308c <updateDisplayChangeValues+0x530>
    308c:	ad b7       	in	r26, 0x3d	; 61
    308e:	be b7       	in	r27, 0x3e	; 62
    3090:	11 96       	adiw	r26, 0x01	; 1
    3092:	84 81       	ldd	r24, Z+4	; 0x04
    3094:	95 81       	ldd	r25, Z+5	; 0x05
    3096:	ed b7       	in	r30, 0x3d	; 61
    3098:	fe b7       	in	r31, 0x3e	; 62
    309a:	92 83       	std	Z+2, r25	; 0x02
    309c:	81 83       	std	Z+1, r24	; 0x01
    309e:	88 ef       	ldi	r24, 0xF8	; 248
    30a0:	91 e0       	ldi	r25, 0x01	; 1
    30a2:	13 96       	adiw	r26, 0x03	; 3
    30a4:	9c 93       	st	X, r25
    30a6:	8e 93       	st	-X, r24
    30a8:	12 97       	sbiw	r26, 0x02	; 2
    30aa:	33 27       	eor	r19, r19
    30ac:	27 fd       	sbrc	r18, 7
    30ae:	30 95       	com	r19
    30b0:	15 96       	adiw	r26, 0x05	; 5
    30b2:	3c 93       	st	X, r19
    30b4:	2e 93       	st	-X, r18
    30b6:	14 97       	sbiw	r26, 0x04	; 4
    30b8:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
      sprintf(menu.newDisplayValue[3], "        ");
    30bc:	e0 91 e8 02 	lds	r30, 0x02E8
    30c0:	f0 91 e9 02 	lds	r31, 0x02E9
    30c4:	26 81       	ldd	r18, Z+6	; 0x06
    30c6:	37 81       	ldd	r19, Z+7	; 0x07
    30c8:	c9 01       	movw	r24, r18
    30ca:	dc 01       	movw	r26, r24
    30cc:	eb e2       	ldi	r30, 0x2B	; 43
    30ce:	f1 e0       	ldi	r31, 0x01	; 1
    30d0:	89 e0       	ldi	r24, 0x09	; 9
    30d2:	01 90       	ld	r0, Z+
    30d4:	0d 92       	st	X+, r0
    30d6:	81 50       	subi	r24, 0x01	; 1
    30d8:	e1 f7       	brne	.-8      	; 0x30d2 <updateDisplayChangeValues+0x576>
    30da:	2d b7       	in	r18, 0x3d	; 61
    30dc:	3e b7       	in	r19, 0x3e	; 62
    30de:	2a 5f       	subi	r18, 0xFA	; 250
    30e0:	3f 4f       	sbci	r19, 0xFF	; 255
    30e2:	0f b6       	in	r0, 0x3f	; 63
    30e4:	f8 94       	cli
    30e6:	3e bf       	out	0x3e, r19	; 62
    30e8:	0f be       	out	0x3f, r0	; 63
    30ea:	2d bf       	out	0x3d, r18	; 61
    30ec:	69 cd       	rjmp	.-1326   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        }
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
    30ee:	c0 e0       	ldi	r28, 0x00	; 0
    30f0:	d0 e0       	ldi	r29, 0x00	; 0
    30f2:	05 e7       	ldi	r16, 0x75	; 117
    30f4:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    30f6:	80 91 e5 02 	lds	r24, 0x02E5
    30fa:	9e 01       	movw	r18, r28
    30fc:	90 e0       	ldi	r25, 0x00	; 0
    30fe:	0c 2e       	mov	r0, r28
    3100:	02 c0       	rjmp	.+4      	; 0x3106 <updateDisplayChangeValues+0x5aa>
    3102:	95 95       	asr	r25
    3104:	87 95       	ror	r24
    3106:	0a 94       	dec	r0
    3108:	e2 f7       	brpl	.-8      	; 0x3102 <updateDisplayChangeValues+0x5a6>
    310a:	80 fd       	sbrc	r24, 0
    310c:	46 c0       	rjmp	.+140    	; 0x319a <updateDisplayChangeValues+0x63e>
    310e:	40 e2       	ldi	r20, 0x20	; 32
    3110:	50 e0       	ldi	r21, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
    3112:	a0 91 e8 02 	lds	r26, 0x02E8
    3116:	b0 91 e9 02 	lds	r27, 0x02E9
    311a:	f9 01       	movw	r30, r18
    311c:	ee 0f       	add	r30, r30
    311e:	ff 1f       	adc	r31, r31
    3120:	ee 0f       	add	r30, r30
    3122:	ff 1f       	adc	r31, r31
    3124:	ee 0f       	add	r30, r30
    3126:	ff 1f       	adc	r31, r31
    3128:	cf 01       	movw	r24, r30
    312a:	88 0f       	add	r24, r24
    312c:	99 1f       	adc	r25, r25
    312e:	88 0f       	add	r24, r24
    3130:	99 1f       	adc	r25, r25
    3132:	e8 0f       	add	r30, r24
    3134:	f9 1f       	adc	r31, r25
    3136:	e0 51       	subi	r30, 0x10	; 16
    3138:	fc 4f       	sbci	r31, 0xFC	; 252
    313a:	26 8d       	ldd	r18, Z+30	; 0x1e
    313c:	37 8d       	ldd	r19, Z+31	; 0x1f
    313e:	8d b7       	in	r24, 0x3d	; 61
    3140:	9e b7       	in	r25, 0x3e	; 62
    3142:	08 97       	sbiw	r24, 0x08	; 8
    3144:	0f b6       	in	r0, 0x3f	; 63
    3146:	f8 94       	cli
    3148:	9e bf       	out	0x3e, r25	; 62
    314a:	0f be       	out	0x3f, r0	; 63
    314c:	8d bf       	out	0x3d, r24	; 61
    314e:	ed b7       	in	r30, 0x3d	; 61
    3150:	fe b7       	in	r31, 0x3e	; 62
    3152:	31 96       	adiw	r30, 0x01	; 1
    3154:	ce 01       	movw	r24, r28
    3156:	88 0f       	add	r24, r24
    3158:	99 1f       	adc	r25, r25
    315a:	a8 0f       	add	r26, r24
    315c:	b9 1f       	adc	r27, r25
    315e:	8d 91       	ld	r24, X+
    3160:	9c 91       	ld	r25, X
    3162:	ad b7       	in	r26, 0x3d	; 61
    3164:	be b7       	in	r27, 0x3e	; 62
    3166:	12 96       	adiw	r26, 0x02	; 2
    3168:	9c 93       	st	X, r25
    316a:	8e 93       	st	-X, r24
    316c:	11 97       	sbiw	r26, 0x01	; 1
    316e:	13 83       	std	Z+3, r17	; 0x03
    3170:	02 83       	std	Z+2, r16	; 0x02
    3172:	55 83       	std	Z+5, r21	; 0x05
    3174:	44 83       	std	Z+4, r20	; 0x04
    3176:	37 83       	std	Z+7, r19	; 0x07
    3178:	26 83       	std	Z+6, r18	; 0x06
    317a:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    317e:	21 96       	adiw	r28, 0x01	; 1
        }
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
    3180:	ed b7       	in	r30, 0x3d	; 61
    3182:	fe b7       	in	r31, 0x3e	; 62
    3184:	38 96       	adiw	r30, 0x08	; 8
    3186:	0f b6       	in	r0, 0x3f	; 63
    3188:	f8 94       	cli
    318a:	fe bf       	out	0x3e, r31	; 62
    318c:	0f be       	out	0x3f, r0	; 63
    318e:	ed bf       	out	0x3d, r30	; 61
    3190:	c4 30       	cpi	r28, 0x04	; 4
    3192:	d1 05       	cpc	r29, r1
    3194:	09 f0       	breq	.+2      	; 0x3198 <updateDisplayChangeValues+0x63c>
    3196:	af cf       	rjmp	.-162    	; 0x30f6 <updateDisplayChangeValues+0x59a>
    3198:	13 cd       	rjmp	.-1498   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    319a:	4e e7       	ldi	r20, 0x7E	; 126
    319c:	50 e0       	ldi	r21, 0x00	; 0
    319e:	b9 cf       	rjmp	.-142    	; 0x3112 <updateDisplayChangeValues+0x5b6>
      }
      break;

    case MENU_SAVE_CONFIG:
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Save all");
    31a0:	e0 91 e8 02 	lds	r30, 0x02E8
    31a4:	f0 91 e9 02 	lds	r31, 0x02E9
    31a8:	20 81       	ld	r18, Z
    31aa:	31 81       	ldd	r19, Z+1	; 0x01
    31ac:	c9 01       	movw	r24, r18
    31ae:	dc 01       	movw	r26, r24
    31b0:	ee e9       	ldi	r30, 0x9E	; 158
    31b2:	f1 e0       	ldi	r31, 0x01	; 1
    31b4:	89 e0       	ldi	r24, 0x09	; 9
    31b6:	01 90       	ld	r0, Z+
    31b8:	0d 92       	st	X+, r0
    31ba:	81 50       	subi	r24, 0x01	; 1
    31bc:	e1 f7       	brne	.-8      	; 0x31b6 <updateDisplayChangeValues+0x65a>
      sprintf(menu.newDisplayValue[1], " current");
    31be:	e0 91 e8 02 	lds	r30, 0x02E8
    31c2:	f0 91 e9 02 	lds	r31, 0x02E9
    31c6:	22 81       	ldd	r18, Z+2	; 0x02
    31c8:	33 81       	ldd	r19, Z+3	; 0x03
    31ca:	c9 01       	movw	r24, r18
    31cc:	dc 01       	movw	r26, r24
    31ce:	e7 ea       	ldi	r30, 0xA7	; 167
    31d0:	f1 e0       	ldi	r31, 0x01	; 1
    31d2:	89 e0       	ldi	r24, 0x09	; 9
    31d4:	01 90       	ld	r0, Z+
    31d6:	0d 92       	st	X+, r0
    31d8:	81 50       	subi	r24, 0x01	; 1
    31da:	e1 f7       	brne	.-8      	; 0x31d4 <updateDisplayChangeValues+0x678>
      sprintf(menu.newDisplayValue[2], "configur");
    31dc:	e0 91 e8 02 	lds	r30, 0x02E8
    31e0:	f0 91 e9 02 	lds	r31, 0x02E9
    31e4:	24 81       	ldd	r18, Z+4	; 0x04
    31e6:	35 81       	ldd	r19, Z+5	; 0x05
    31e8:	c9 01       	movw	r24, r18
    31ea:	dc 01       	movw	r26, r24
    31ec:	e0 eb       	ldi	r30, 0xB0	; 176
    31ee:	f1 e0       	ldi	r31, 0x01	; 1
    31f0:	89 e0       	ldi	r24, 0x09	; 9
    31f2:	01 90       	ld	r0, Z+
    31f4:	0d 92       	st	X+, r0
    31f6:	81 50       	subi	r24, 0x01	; 1
    31f8:	e1 f7       	brne	.-8      	; 0x31f2 <updateDisplayChangeValues+0x696>
      sprintf(menu.newDisplayValue[3], "ations  ");
    31fa:	e0 91 e8 02 	lds	r30, 0x02E8
    31fe:	f0 91 e9 02 	lds	r31, 0x02E9
    3202:	26 81       	ldd	r18, Z+6	; 0x06
    3204:	37 81       	ldd	r19, Z+7	; 0x07
    3206:	c9 01       	movw	r24, r18
    3208:	dc 01       	movw	r26, r24
    320a:	e9 eb       	ldi	r30, 0xB9	; 185
    320c:	f1 e0       	ldi	r31, 0x01	; 1
    320e:	89 e0       	ldi	r24, 0x09	; 9
    3210:	01 90       	ld	r0, Z+
    3212:	0d 92       	st	X+, r0
    3214:	81 50       	subi	r24, 0x01	; 1
    3216:	e1 f7       	brne	.-8      	; 0x3210 <updateDisplayChangeValues+0x6b4>
    3218:	d3 cc       	rjmp	.-1626   	; 0x2bc0 <updateDisplayChangeValues+0x64>
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
    321a:	e0 91 e8 02 	lds	r30, 0x02E8
    321e:	f0 91 e9 02 	lds	r31, 0x02E9
    3222:	20 81       	ld	r18, Z
    3224:	31 81       	ldd	r19, Z+1	; 0x01
    3226:	c9 01       	movw	r24, r18
    3228:	dc 01       	movw	r26, r24
    322a:	e2 e2       	ldi	r30, 0x22	; 34
    322c:	f1 e0       	ldi	r31, 0x01	; 1
    322e:	89 e0       	ldi	r24, 0x09	; 9
    3230:	01 90       	ld	r0, Z+
    3232:	0d 92       	st	X+, r0
    3234:	81 50       	subi	r24, 0x01	; 1
    3236:	e1 f7       	brne	.-8      	; 0x3230 <updateDisplayChangeValues+0x6d4>
      sprintf(menu.newDisplayValue[1], "        ");
    3238:	e0 91 e8 02 	lds	r30, 0x02E8
    323c:	f0 91 e9 02 	lds	r31, 0x02E9
    3240:	22 81       	ldd	r18, Z+2	; 0x02
    3242:	33 81       	ldd	r19, Z+3	; 0x03
    3244:	c9 01       	movw	r24, r18
    3246:	dc 01       	movw	r26, r24
    3248:	eb e2       	ldi	r30, 0x2B	; 43
    324a:	f1 e0       	ldi	r31, 0x01	; 1
    324c:	89 e0       	ldi	r24, 0x09	; 9
    324e:	01 90       	ld	r0, Z+
    3250:	0d 92       	st	X+, r0
    3252:	81 50       	subi	r24, 0x01	; 1
    3254:	e1 f7       	brne	.-8      	; 0x324e <updateDisplayChangeValues+0x6f2>
      sprintf(menu.newDisplayValue[2], "Firmware");
    3256:	e0 91 e8 02 	lds	r30, 0x02E8
    325a:	f0 91 e9 02 	lds	r31, 0x02E9
    325e:	24 81       	ldd	r18, Z+4	; 0x04
    3260:	35 81       	ldd	r19, Z+5	; 0x05
    3262:	c9 01       	movw	r24, r18
    3264:	dc 01       	movw	r26, r24
    3266:	e4 e3       	ldi	r30, 0x34	; 52
    3268:	f1 e0       	ldi	r31, 0x01	; 1
    326a:	89 e0       	ldi	r24, 0x09	; 9
    326c:	01 90       	ld	r0, Z+
    326e:	0d 92       	st	X+, r0
    3270:	81 50       	subi	r24, 0x01	; 1
    3272:	e1 f7       	brne	.-8      	; 0x326c <updateDisplayChangeValues+0x710>
      sprintf(menu.newDisplayValue[3], FW_VERSION);
    3274:	e0 91 e8 02 	lds	r30, 0x02E8
    3278:	f0 91 e9 02 	lds	r31, 0x02E9
    327c:	26 81       	ldd	r18, Z+6	; 0x06
    327e:	37 81       	ldd	r19, Z+7	; 0x07
    3280:	c9 01       	movw	r24, r18
    3282:	dc 01       	movw	r26, r24
    3284:	ed e3       	ldi	r30, 0x3D	; 61
    3286:	f1 e0       	ldi	r31, 0x01	; 1
    3288:	87 e0       	ldi	r24, 0x07	; 7
    328a:	01 90       	ld	r0, Z+
    328c:	0d 92       	st	X+, r0
    328e:	81 50       	subi	r24, 0x01	; 1
    3290:	e1 f7       	brne	.-8      	; 0x328a <updateDisplayChangeValues+0x72e>
    3292:	96 cc       	rjmp	.-1748   	; 0x2bc0 <updateDisplayChangeValues+0x64>
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    3294:	e0 91 e8 02 	lds	r30, 0x02E8
    3298:	f0 91 e9 02 	lds	r31, 0x02E9
    329c:	ee 0d       	add	r30, r14
    329e:	ff 1d       	adc	r31, r15
    32a0:	00 81       	ld	r16, Z
    32a2:	11 81       	ldd	r17, Z+1	; 0x01
    32a4:	f9 01       	movw	r30, r18
    32a6:	ee 0f       	add	r30, r30
    32a8:	ff 1f       	adc	r31, r31
    32aa:	ee 0f       	add	r30, r30
    32ac:	ff 1f       	adc	r31, r31
    32ae:	ee 0f       	add	r30, r30
    32b0:	ff 1f       	adc	r31, r31
    32b2:	cf 01       	movw	r24, r30
    32b4:	88 0f       	add	r24, r24
    32b6:	99 1f       	adc	r25, r25
    32b8:	88 0f       	add	r24, r24
    32ba:	99 1f       	adc	r25, r25
    32bc:	e8 0f       	add	r30, r24
    32be:	f9 1f       	adc	r31, r25
    32c0:	e0 51       	subi	r30, 0x10	; 16
    32c2:	fc 4f       	sbci	r31, 0xFC	; 252
    32c4:	60 81       	ld	r22, Z
    32c6:	71 81       	ldd	r23, Z+1	; 0x01
    32c8:	84 2f       	mov	r24, r20
    32ca:	0e 94 23 08 	call	0x1046	; 0x1046 <stepsToRadian>
    32ce:	2d b7       	in	r18, 0x3d	; 61
    32d0:	3e b7       	in	r19, 0x3e	; 62
    32d2:	2c 50       	subi	r18, 0x0C	; 12
    32d4:	30 40       	sbci	r19, 0x00	; 0
    32d6:	0f b6       	in	r0, 0x3f	; 63
    32d8:	f8 94       	cli
    32da:	3e bf       	out	0x3e, r19	; 62
    32dc:	0f be       	out	0x3f, r0	; 63
    32de:	2d bf       	out	0x3d, r18	; 61
    32e0:	ed b7       	in	r30, 0x3d	; 61
    32e2:	fe b7       	in	r31, 0x3e	; 62
    32e4:	31 96       	adiw	r30, 0x01	; 1
    32e6:	ad b7       	in	r26, 0x3d	; 61
    32e8:	be b7       	in	r27, 0x3e	; 62
    32ea:	12 96       	adiw	r26, 0x02	; 2
    32ec:	1c 93       	st	X, r17
    32ee:	0e 93       	st	-X, r16
    32f0:	11 97       	sbiw	r26, 0x01	; 1
    32f2:	73 82       	std	Z+3, r7	; 0x03
    32f4:	62 82       	std	Z+2, r6	; 0x02
    32f6:	d4 82       	std	Z+4, r13	; 0x04
    32f8:	15 82       	std	Z+5, r1	; 0x05
    32fa:	66 83       	std	Z+6, r22	; 0x06
    32fc:	77 83       	std	Z+7, r23	; 0x07
    32fe:	80 87       	std	Z+8, r24	; 0x08
    3300:	91 87       	std	Z+9, r25	; 0x09
    3302:	53 86       	std	Z+11, r5	; 0x0b
    3304:	42 86       	std	Z+10, r4	; 0x0a
    3306:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    330a:	ed b7       	in	r30, 0x3d	; 61
    330c:	fe b7       	in	r31, 0x3e	; 62
    330e:	3c 96       	adiw	r30, 0x0c	; 12
    3310:	0f b6       	in	r0, 0x3f	; 63
    3312:	f8 94       	cli
    3314:	fe bf       	out	0x3e, r31	; 62
    3316:	0f be       	out	0x3f, r0	; 63
    3318:	ed bf       	out	0x3d, r30	; 61
    331a:	cb cd       	rjmp	.-1130   	; 0x2eb2 <updateDisplayChangeValues+0x356>
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
            break;

          case MOTOR_STEP_UNIT_DEGREE:
            /* 0xDF is the display code for the degree-circle */
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
    331c:	e0 91 e8 02 	lds	r30, 0x02E8
    3320:	f0 91 e9 02 	lds	r31, 0x02E9
    3324:	ee 0d       	add	r30, r14
    3326:	ff 1d       	adc	r31, r15
    3328:	00 81       	ld	r16, Z
    332a:	11 81       	ldd	r17, Z+1	; 0x01
    332c:	f9 01       	movw	r30, r18
    332e:	ee 0f       	add	r30, r30
    3330:	ff 1f       	adc	r31, r31
    3332:	ee 0f       	add	r30, r30
    3334:	ff 1f       	adc	r31, r31
    3336:	ee 0f       	add	r30, r30
    3338:	ff 1f       	adc	r31, r31
    333a:	cf 01       	movw	r24, r30
    333c:	88 0f       	add	r24, r24
    333e:	99 1f       	adc	r25, r25
    3340:	88 0f       	add	r24, r24
    3342:	99 1f       	adc	r25, r25
    3344:	e8 0f       	add	r30, r24
    3346:	f9 1f       	adc	r31, r25
    3348:	e0 51       	subi	r30, 0x10	; 16
    334a:	fc 4f       	sbci	r31, 0xFC	; 252
    334c:	60 81       	ld	r22, Z
    334e:	71 81       	ldd	r23, Z+1	; 0x01
    3350:	84 2f       	mov	r24, r20
    3352:	0e 94 9e 07 	call	0xf3c	; 0xf3c <stepsToDegree>
    3356:	2d b7       	in	r18, 0x3d	; 61
    3358:	3e b7       	in	r19, 0x3e	; 62
    335a:	2c 50       	subi	r18, 0x0C	; 12
    335c:	30 40       	sbci	r19, 0x00	; 0
    335e:	0f b6       	in	r0, 0x3f	; 63
    3360:	f8 94       	cli
    3362:	3e bf       	out	0x3e, r19	; 62
    3364:	0f be       	out	0x3f, r0	; 63
    3366:	2d bf       	out	0x3d, r18	; 61
    3368:	ed b7       	in	r30, 0x3d	; 61
    336a:	fe b7       	in	r31, 0x3e	; 62
    336c:	31 96       	adiw	r30, 0x01	; 1
    336e:	ad b7       	in	r26, 0x3d	; 61
    3370:	be b7       	in	r27, 0x3e	; 62
    3372:	12 96       	adiw	r26, 0x02	; 2
    3374:	1c 93       	st	X, r17
    3376:	0e 93       	st	-X, r16
    3378:	11 97       	sbiw	r26, 0x01	; 1
    337a:	b3 82       	std	Z+3, r11	; 0x03
    337c:	a2 82       	std	Z+2, r10	; 0x02
    337e:	d4 82       	std	Z+4, r13	; 0x04
    3380:	15 82       	std	Z+5, r1	; 0x05
    3382:	66 83       	std	Z+6, r22	; 0x06
    3384:	77 83       	std	Z+7, r23	; 0x07
    3386:	80 87       	std	Z+8, r24	; 0x08
    3388:	91 87       	std	Z+9, r25	; 0x09
    338a:	93 86       	std	Z+11, r9	; 0x0b
    338c:	82 86       	std	Z+10, r8	; 0x0a
    338e:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3392:	ed b7       	in	r30, 0x3d	; 61
    3394:	fe b7       	in	r31, 0x3e	; 62
    3396:	3c 96       	adiw	r30, 0x0c	; 12
    3398:	0f b6       	in	r0, 0x3f	; 63
    339a:	f8 94       	cli
    339c:	fe bf       	out	0x3e, r31	; 62
    339e:	0f be       	out	0x3f, r0	; 63
    33a0:	ed bf       	out	0x3d, r30	; 61
    33a2:	87 cd       	rjmp	.-1266   	; 0x2eb2 <updateDisplayChangeValues+0x356>
        }
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
    33a4:	c0 e0       	ldi	r28, 0x00	; 0
    33a6:	d0 e0       	ldi	r29, 0x00	; 0
    33a8:	0d e7       	ldi	r16, 0x7D	; 125
    33aa:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    33ac:	80 91 e5 02 	lds	r24, 0x02E5
    33b0:	9e 01       	movw	r18, r28
    33b2:	90 e0       	ldi	r25, 0x00	; 0
    33b4:	0c 2e       	mov	r0, r28
    33b6:	02 c0       	rjmp	.+4      	; 0x33bc <updateDisplayChangeValues+0x860>
    33b8:	95 95       	asr	r25
    33ba:	87 95       	ror	r24
    33bc:	0a 94       	dec	r0
    33be:	e2 f7       	brpl	.-8      	; 0x33b8 <updateDisplayChangeValues+0x85c>
    33c0:	80 fd       	sbrc	r24, 0
    33c2:	4a c0       	rjmp	.+148    	; 0x3458 <updateDisplayChangeValues+0x8fc>
    33c4:	60 e2       	ldi	r22, 0x20	; 32
    33c6:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
    33c8:	a0 91 e8 02 	lds	r26, 0x02E8
    33cc:	b0 91 e9 02 	lds	r27, 0x02E9
    33d0:	f9 01       	movw	r30, r18
    33d2:	ee 0f       	add	r30, r30
    33d4:	ff 1f       	adc	r31, r31
    33d6:	ee 0f       	add	r30, r30
    33d8:	ff 1f       	adc	r31, r31
    33da:	ee 0f       	add	r30, r30
    33dc:	ff 1f       	adc	r31, r31
    33de:	cf 01       	movw	r24, r30
    33e0:	88 0f       	add	r24, r24
    33e2:	99 1f       	adc	r25, r25
    33e4:	88 0f       	add	r24, r24
    33e6:	99 1f       	adc	r25, r25
    33e8:	e8 0f       	add	r30, r24
    33ea:	f9 1f       	adc	r31, r25
    33ec:	e0 51       	subi	r30, 0x10	; 16
    33ee:	fc 4f       	sbci	r31, 0xFC	; 252
    33f0:	22 8d       	ldd	r18, Z+26	; 0x1a
    33f2:	33 8d       	ldd	r19, Z+27	; 0x1b
    33f4:	44 8d       	ldd	r20, Z+28	; 0x1c
    33f6:	55 8d       	ldd	r21, Z+29	; 0x1d
    33f8:	8d b7       	in	r24, 0x3d	; 61
    33fa:	9e b7       	in	r25, 0x3e	; 62
    33fc:	0a 97       	sbiw	r24, 0x0a	; 10
    33fe:	0f b6       	in	r0, 0x3f	; 63
    3400:	f8 94       	cli
    3402:	9e bf       	out	0x3e, r25	; 62
    3404:	0f be       	out	0x3f, r0	; 63
    3406:	8d bf       	out	0x3d, r24	; 61
    3408:	ed b7       	in	r30, 0x3d	; 61
    340a:	fe b7       	in	r31, 0x3e	; 62
    340c:	31 96       	adiw	r30, 0x01	; 1
    340e:	ce 01       	movw	r24, r28
    3410:	88 0f       	add	r24, r24
    3412:	99 1f       	adc	r25, r25
    3414:	a8 0f       	add	r26, r24
    3416:	b9 1f       	adc	r27, r25
    3418:	8d 91       	ld	r24, X+
    341a:	9c 91       	ld	r25, X
    341c:	ad b7       	in	r26, 0x3d	; 61
    341e:	be b7       	in	r27, 0x3e	; 62
    3420:	12 96       	adiw	r26, 0x02	; 2
    3422:	9c 93       	st	X, r25
    3424:	8e 93       	st	-X, r24
    3426:	11 97       	sbiw	r26, 0x01	; 1
    3428:	13 83       	std	Z+3, r17	; 0x03
    342a:	02 83       	std	Z+2, r16	; 0x02
    342c:	75 83       	std	Z+5, r23	; 0x05
    342e:	64 83       	std	Z+4, r22	; 0x04
    3430:	26 83       	std	Z+6, r18	; 0x06
    3432:	37 83       	std	Z+7, r19	; 0x07
    3434:	40 87       	std	Z+8, r20	; 0x08
    3436:	51 87       	std	Z+9, r21	; 0x09
    3438:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    343c:	21 96       	adiw	r28, 0x01	; 1
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
    343e:	ed b7       	in	r30, 0x3d	; 61
    3440:	fe b7       	in	r31, 0x3e	; 62
    3442:	3a 96       	adiw	r30, 0x0a	; 10
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	fe bf       	out	0x3e, r31	; 62
    344a:	0f be       	out	0x3f, r0	; 63
    344c:	ed bf       	out	0x3d, r30	; 61
    344e:	c4 30       	cpi	r28, 0x04	; 4
    3450:	d1 05       	cpc	r29, r1
    3452:	09 f0       	breq	.+2      	; 0x3456 <updateDisplayChangeValues+0x8fa>
    3454:	ab cf       	rjmp	.-170    	; 0x33ac <updateDisplayChangeValues+0x850>
    3456:	b4 cb       	rjmp	.-2200   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3458:	6e e7       	ldi	r22, 0x7E	; 126
    345a:	70 e0       	ldi	r23, 0x00	; 0
    345c:	b5 cf       	rjmp	.-150    	; 0x33c8 <updateDisplayChangeValues+0x86c>
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Load all");
      sprintf(menu.newDisplayValue[1], " saved  ");
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;
    345e:	c0 e0       	ldi	r28, 0x00	; 0
    3460:	d0 e0       	ldi	r29, 0x00	; 0
    3462:	04 e4       	ldi	r16, 0x44	; 68
    3464:	11 e0       	ldi	r17, 0x01	; 1

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    3466:	80 91 e5 02 	lds	r24, 0x02E5
    346a:	9e 01       	movw	r18, r28
    346c:	90 e0       	ldi	r25, 0x00	; 0
    346e:	0c 2e       	mov	r0, r28
    3470:	02 c0       	rjmp	.+4      	; 0x3476 <updateDisplayChangeValues+0x91a>
    3472:	95 95       	asr	r25
    3474:	87 95       	ror	r24
    3476:	0a 94       	dec	r0
    3478:	e2 f7       	brpl	.-8      	; 0x3472 <updateDisplayChangeValues+0x916>
    347a:	80 fd       	sbrc	r24, 0
    347c:	48 c0       	rjmp	.+144    	; 0x350e <updateDisplayChangeValues+0x9b2>
    347e:	40 e2       	ldi	r20, 0x20	; 32
    3480:	50 e0       	ldi	r21, 0x00	; 0
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].opticalZeroPosition);
    3482:	a0 91 e8 02 	lds	r26, 0x02E8
    3486:	b0 91 e9 02 	lds	r27, 0x02E9
    348a:	c9 01       	movw	r24, r18
    348c:	f9 01       	movw	r30, r18
    348e:	ee 0f       	add	r30, r30
    3490:	ff 1f       	adc	r31, r31
    3492:	ee 0f       	add	r30, r30
    3494:	ff 1f       	adc	r31, r31
    3496:	ee 0f       	add	r30, r30
    3498:	ff 1f       	adc	r31, r31
    349a:	88 0f       	add	r24, r24
    349c:	99 1f       	adc	r25, r25
    349e:	e8 0f       	add	r30, r24
    34a0:	f9 1f       	adc	r31, r25
    34a2:	ee 0f       	add	r30, r30
    34a4:	ff 1f       	adc	r31, r31
    34a6:	ee 0f       	add	r30, r30
    34a8:	ff 1f       	adc	r31, r31
    34aa:	ec 50       	subi	r30, 0x0C	; 12
    34ac:	fc 4f       	sbci	r31, 0xFC	; 252
    34ae:	20 81       	ld	r18, Z
    34b0:	31 81       	ldd	r19, Z+1	; 0x01
    34b2:	8d b7       	in	r24, 0x3d	; 61
    34b4:	9e b7       	in	r25, 0x3e	; 62
    34b6:	08 97       	sbiw	r24, 0x08	; 8
    34b8:	0f b6       	in	r0, 0x3f	; 63
    34ba:	f8 94       	cli
    34bc:	9e bf       	out	0x3e, r25	; 62
    34be:	0f be       	out	0x3f, r0	; 63
    34c0:	8d bf       	out	0x3d, r24	; 61
    34c2:	ed b7       	in	r30, 0x3d	; 61
    34c4:	fe b7       	in	r31, 0x3e	; 62
    34c6:	31 96       	adiw	r30, 0x01	; 1
    34c8:	ce 01       	movw	r24, r28
    34ca:	88 0f       	add	r24, r24
    34cc:	99 1f       	adc	r25, r25
    34ce:	a8 0f       	add	r26, r24
    34d0:	b9 1f       	adc	r27, r25
    34d2:	8d 91       	ld	r24, X+
    34d4:	9c 91       	ld	r25, X
    34d6:	ad b7       	in	r26, 0x3d	; 61
    34d8:	be b7       	in	r27, 0x3e	; 62
    34da:	12 96       	adiw	r26, 0x02	; 2
    34dc:	9c 93       	st	X, r25
    34de:	8e 93       	st	-X, r24
    34e0:	11 97       	sbiw	r26, 0x01	; 1
    34e2:	13 83       	std	Z+3, r17	; 0x03
    34e4:	02 83       	std	Z+2, r16	; 0x02
    34e6:	55 83       	std	Z+5, r21	; 0x05
    34e8:	44 83       	std	Z+4, r20	; 0x04
    34ea:	37 83       	std	Z+7, r19	; 0x07
    34ec:	26 83       	std	Z+6, r18	; 0x06
    34ee:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    34f2:	21 96       	adiw	r28, 0x01	; 1
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
    34f4:	ed b7       	in	r30, 0x3d	; 61
    34f6:	fe b7       	in	r31, 0x3e	; 62
    34f8:	38 96       	adiw	r30, 0x08	; 8
    34fa:	0f b6       	in	r0, 0x3f	; 63
    34fc:	f8 94       	cli
    34fe:	fe bf       	out	0x3e, r31	; 62
    3500:	0f be       	out	0x3f, r0	; 63
    3502:	ed bf       	out	0x3d, r30	; 61
    3504:	c4 30       	cpi	r28, 0x04	; 4
    3506:	d1 05       	cpc	r29, r1
    3508:	09 f0       	breq	.+2      	; 0x350c <updateDisplayChangeValues+0x9b0>
    350a:	ad cf       	rjmp	.-166    	; 0x3466 <updateDisplayChangeValues+0x90a>
    350c:	59 cb       	rjmp	.-2382   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    350e:	80 91 e2 02 	lds	r24, 0x02E2
    3512:	88 23       	and	r24, r24
    3514:	09 f4       	brne	.+2      	; 0x3518 <updateDisplayChangeValues+0x9bc>
    3516:	6d c1       	rjmp	.+730    	; 0x37f2 <updateDisplayChangeValues+0xc96>
    3518:	4e e3       	ldi	r20, 0x3E	; 62
    351a:	50 e0       	ldi	r21, 0x00	; 0
    351c:	b2 cf       	rjmp	.-156    	; 0x3482 <updateDisplayChangeValues+0x926>
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    351e:	c0 e0       	ldi	r28, 0x00	; 0
    3520:	d0 e0       	ldi	r29, 0x00	; 0
    3522:	07 e9       	ldi	r16, 0x97	; 151
    3524:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_CHANGE_SUBSTEPS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3526:	80 91 e5 02 	lds	r24, 0x02E5
    352a:	9e 01       	movw	r18, r28
    352c:	90 e0       	ldi	r25, 0x00	; 0
    352e:	0c 2e       	mov	r0, r28
    3530:	02 c0       	rjmp	.+4      	; 0x3536 <updateDisplayChangeValues+0x9da>
    3532:	95 95       	asr	r25
    3534:	87 95       	ror	r24
    3536:	0a 94       	dec	r0
    3538:	e2 f7       	brpl	.-8      	; 0x3532 <updateDisplayChangeValues+0x9d6>
    353a:	80 fd       	sbrc	r24, 0
    353c:	4a c0       	rjmp	.+148    	; 0x35d2 <updateDisplayChangeValues+0xa76>
    353e:	60 e2       	ldi	r22, 0x20	; 32
    3540:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.0f", c, motor[i].subSteps);
    3542:	a0 91 e8 02 	lds	r26, 0x02E8
    3546:	b0 91 e9 02 	lds	r27, 0x02E9
    354a:	f9 01       	movw	r30, r18
    354c:	ee 0f       	add	r30, r30
    354e:	ff 1f       	adc	r31, r31
    3550:	ee 0f       	add	r30, r30
    3552:	ff 1f       	adc	r31, r31
    3554:	ee 0f       	add	r30, r30
    3556:	ff 1f       	adc	r31, r31
    3558:	cf 01       	movw	r24, r30
    355a:	88 0f       	add	r24, r24
    355c:	99 1f       	adc	r25, r25
    355e:	88 0f       	add	r24, r24
    3560:	99 1f       	adc	r25, r25
    3562:	e8 0f       	add	r30, r24
    3564:	f9 1f       	adc	r31, r25
    3566:	e0 51       	subi	r30, 0x10	; 16
    3568:	fc 4f       	sbci	r31, 0xFC	; 252
    356a:	25 89       	ldd	r18, Z+21	; 0x15
    356c:	36 89       	ldd	r19, Z+22	; 0x16
    356e:	47 89       	ldd	r20, Z+23	; 0x17
    3570:	50 8d       	ldd	r21, Z+24	; 0x18
    3572:	8d b7       	in	r24, 0x3d	; 61
    3574:	9e b7       	in	r25, 0x3e	; 62
    3576:	0a 97       	sbiw	r24, 0x0a	; 10
    3578:	0f b6       	in	r0, 0x3f	; 63
    357a:	f8 94       	cli
    357c:	9e bf       	out	0x3e, r25	; 62
    357e:	0f be       	out	0x3f, r0	; 63
    3580:	8d bf       	out	0x3d, r24	; 61
    3582:	ed b7       	in	r30, 0x3d	; 61
    3584:	fe b7       	in	r31, 0x3e	; 62
    3586:	31 96       	adiw	r30, 0x01	; 1
    3588:	ce 01       	movw	r24, r28
    358a:	88 0f       	add	r24, r24
    358c:	99 1f       	adc	r25, r25
    358e:	a8 0f       	add	r26, r24
    3590:	b9 1f       	adc	r27, r25
    3592:	8d 91       	ld	r24, X+
    3594:	9c 91       	ld	r25, X
    3596:	ad b7       	in	r26, 0x3d	; 61
    3598:	be b7       	in	r27, 0x3e	; 62
    359a:	12 96       	adiw	r26, 0x02	; 2
    359c:	9c 93       	st	X, r25
    359e:	8e 93       	st	-X, r24
    35a0:	11 97       	sbiw	r26, 0x01	; 1
    35a2:	13 83       	std	Z+3, r17	; 0x03
    35a4:	02 83       	std	Z+2, r16	; 0x02
    35a6:	75 83       	std	Z+5, r23	; 0x05
    35a8:	64 83       	std	Z+4, r22	; 0x04
    35aa:	26 83       	std	Z+6, r18	; 0x06
    35ac:	37 83       	std	Z+7, r19	; 0x07
    35ae:	40 87       	std	Z+8, r20	; 0x08
    35b0:	51 87       	std	Z+9, r21	; 0x09
    35b2:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    35b6:	21 96       	adiw	r28, 0x01	; 1
        }
      }
      break;

    case MENU_CHANGE_SUBSTEPS:
      for(i = 0; i <= MAX_MOTOR; i++){
    35b8:	ed b7       	in	r30, 0x3d	; 61
    35ba:	fe b7       	in	r31, 0x3e	; 62
    35bc:	3a 96       	adiw	r30, 0x0a	; 10
    35be:	0f b6       	in	r0, 0x3f	; 63
    35c0:	f8 94       	cli
    35c2:	fe bf       	out	0x3e, r31	; 62
    35c4:	0f be       	out	0x3f, r0	; 63
    35c6:	ed bf       	out	0x3d, r30	; 61
    35c8:	c4 30       	cpi	r28, 0x04	; 4
    35ca:	d1 05       	cpc	r29, r1
    35cc:	09 f0       	breq	.+2      	; 0x35d0 <updateDisplayChangeValues+0xa74>
    35ce:	ab cf       	rjmp	.-170    	; 0x3526 <updateDisplayChangeValues+0x9ca>
    35d0:	f7 ca       	rjmp	.-2578   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    35d2:	6e e7       	ldi	r22, 0x7E	; 126
    35d4:	70 e0       	ldi	r23, 0x00	; 0
    35d6:	b5 cf       	rjmp	.-150    	; 0x3542 <updateDisplayChangeValues+0x9e6>
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
    35d8:	40 e0       	ldi	r20, 0x00	; 0
    35da:	50 e0       	ldi	r21, 0x00	; 0
    35dc:	00 e0       	ldi	r16, 0x00	; 0
    35de:	10 e0       	ldi	r17, 0x00	; 0
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          sprintf(menu.newDisplayValue[i], "%cMot %d", c, i+1);
    35e0:	7e e8       	ldi	r23, 0x8E	; 142
    35e2:	e7 2e       	mov	r14, r23
    35e4:	71 e0       	ldi	r23, 0x01	; 1
    35e6:	f7 2e       	mov	r15, r23
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    35e8:	80 91 e5 02 	lds	r24, 0x02E5
    35ec:	90 e0       	ldi	r25, 0x00	; 0
    35ee:	04 2e       	mov	r0, r20
    35f0:	02 c0       	rjmp	.+4      	; 0x35f6 <updateDisplayChangeValues+0xa9a>
    35f2:	95 95       	asr	r25
    35f4:	87 95       	ror	r24
    35f6:	0a 94       	dec	r0
    35f8:	e2 f7       	brpl	.-8      	; 0x35f2 <updateDisplayChangeValues+0xa96>
    35fa:	80 fd       	sbrc	r24, 0
    35fc:	21 c0       	rjmp	.+66     	; 0x3640 <updateDisplayChangeValues+0xae4>
    35fe:	20 e2       	ldi	r18, 0x20	; 32
        if(forbiddenZone[i].active){
    3600:	fa 01       	movw	r30, r20
    3602:	ee 0f       	add	r30, r30
    3604:	ff 1f       	adc	r31, r31
    3606:	ee 0f       	add	r30, r30
    3608:	ff 1f       	adc	r31, r31
    360a:	e4 0f       	add	r30, r20
    360c:	f5 1f       	adc	r31, r21
    360e:	ed 52       	subi	r30, 0x2D	; 45
    3610:	fc 4f       	sbci	r31, 0xFC	; 252
    3612:	84 81       	ldd	r24, Z+4	; 0x04
    3614:	88 23       	and	r24, r24
    3616:	b1 f0       	breq	.+44     	; 0x3644 <updateDisplayChangeValues+0xae8>
          sprintf(menu.newDisplayValue[i], "ForbZone");
    3618:	e0 91 e8 02 	lds	r30, 0x02E8
    361c:	f0 91 e9 02 	lds	r31, 0x02E9
    3620:	e0 0f       	add	r30, r16
    3622:	f1 1f       	adc	r31, r17
    3624:	20 81       	ld	r18, Z
    3626:	31 81       	ldd	r19, Z+1	; 0x01
    3628:	c9 01       	movw	r24, r18
    362a:	dc 01       	movw	r26, r24
    362c:	e5 e8       	ldi	r30, 0x85	; 133
    362e:	f1 e0       	ldi	r31, 0x01	; 1
    3630:	89 e0       	ldi	r24, 0x09	; 9
    3632:	01 90       	ld	r0, Z+
    3634:	0d 92       	st	X+, r0
    3636:	81 50       	subi	r24, 0x01	; 1
    3638:	e1 f7       	brne	.-8      	; 0x3632 <updateDisplayChangeValues+0xad6>
    363a:	ea 01       	movw	r28, r20
    363c:	21 96       	adiw	r28, 0x01	; 1
    363e:	34 c0       	rjmp	.+104    	; 0x36a8 <updateDisplayChangeValues+0xb4c>
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3640:	2e e7       	ldi	r18, 0x7E	; 126
    3642:	de cf       	rjmp	.-68     	; 0x3600 <updateDisplayChangeValues+0xaa4>
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          sprintf(menu.newDisplayValue[i], "%cMot %d", c, i+1);
    3644:	e0 91 e8 02 	lds	r30, 0x02E8
    3648:	f0 91 e9 02 	lds	r31, 0x02E9
    364c:	8d b7       	in	r24, 0x3d	; 61
    364e:	9e b7       	in	r25, 0x3e	; 62
    3650:	08 97       	sbiw	r24, 0x08	; 8
    3652:	0f b6       	in	r0, 0x3f	; 63
    3654:	f8 94       	cli
    3656:	9e bf       	out	0x3e, r25	; 62
    3658:	0f be       	out	0x3f, r0	; 63
    365a:	8d bf       	out	0x3d, r24	; 61
    365c:	ad b7       	in	r26, 0x3d	; 61
    365e:	be b7       	in	r27, 0x3e	; 62
    3660:	11 96       	adiw	r26, 0x01	; 1
    3662:	e0 0f       	add	r30, r16
    3664:	f1 1f       	adc	r31, r17
    3666:	80 81       	ld	r24, Z
    3668:	91 81       	ldd	r25, Z+1	; 0x01
    366a:	ed b7       	in	r30, 0x3d	; 61
    366c:	fe b7       	in	r31, 0x3e	; 62
    366e:	92 83       	std	Z+2, r25	; 0x02
    3670:	81 83       	std	Z+1, r24	; 0x01
    3672:	13 96       	adiw	r26, 0x03	; 3
    3674:	fc 92       	st	X, r15
    3676:	ee 92       	st	-X, r14
    3678:	12 97       	sbiw	r26, 0x02	; 2
    367a:	14 96       	adiw	r26, 0x04	; 4
    367c:	2c 93       	st	X, r18
    367e:	14 97       	sbiw	r26, 0x04	; 4
    3680:	15 96       	adiw	r26, 0x05	; 5
    3682:	1c 92       	st	X, r1
    3684:	15 97       	sbiw	r26, 0x05	; 5
    3686:	ea 01       	movw	r28, r20
    3688:	21 96       	adiw	r28, 0x01	; 1
    368a:	17 96       	adiw	r26, 0x07	; 7
    368c:	dc 93       	st	X, r29
    368e:	ce 93       	st	-X, r28
    3690:	16 97       	sbiw	r26, 0x06	; 6
    3692:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3696:	2d b7       	in	r18, 0x3d	; 61
    3698:	3e b7       	in	r19, 0x3e	; 62
    369a:	28 5f       	subi	r18, 0xF8	; 248
    369c:	3f 4f       	sbci	r19, 0xFF	; 255
    369e:	0f b6       	in	r0, 0x3f	; 63
    36a0:	f8 94       	cli
    36a2:	3e bf       	out	0x3e, r19	; 62
    36a4:	0f be       	out	0x3f, r0	; 63
    36a6:	2d bf       	out	0x3d, r18	; 61
    36a8:	ae 01       	movw	r20, r28
    36aa:	0e 5f       	subi	r16, 0xFE	; 254
    36ac:	1f 4f       	sbci	r17, 0xFF	; 255
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    36ae:	c4 30       	cpi	r28, 0x04	; 4
    36b0:	d1 05       	cpc	r29, r1
    36b2:	09 f0       	breq	.+2      	; 0x36b6 <updateDisplayChangeValues+0xb5a>
    36b4:	99 cf       	rjmp	.-206    	; 0x35e8 <updateDisplayChangeValues+0xa8c>
    36b6:	84 ca       	rjmp	.-2808   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        sprintf(menu.newDisplayValue[i], "%c%.1f A", c, motor[i].current);
      }
      break;
      
    case MENU_SETTINGS:
      sprintf(menu.newDisplayValue[0], "test    ");
    36b8:	e0 91 e8 02 	lds	r30, 0x02E8
    36bc:	f0 91 e9 02 	lds	r31, 0x02E9
    36c0:	20 81       	ld	r18, Z
    36c2:	31 81       	ldd	r19, Z+1	; 0x01
    36c4:	c9 01       	movw	r24, r18
    36c6:	dc 01       	movw	r26, r24
    36c8:	e9 e0       	ldi	r30, 0x09	; 9
    36ca:	f2 e0       	ldi	r31, 0x02	; 2
    36cc:	89 e0       	ldi	r24, 0x09	; 9
    36ce:	01 90       	ld	r0, Z+
    36d0:	0d 92       	st	X+, r0
    36d2:	81 50       	subi	r24, 0x01	; 1
    36d4:	e1 f7       	brne	.-8      	; 0x36ce <updateDisplayChangeValues+0xb72>
      sprintf(menu.newDisplayValue[1], "test    ");
    36d6:	e0 91 e8 02 	lds	r30, 0x02E8
    36da:	f0 91 e9 02 	lds	r31, 0x02E9
    36de:	22 81       	ldd	r18, Z+2	; 0x02
    36e0:	33 81       	ldd	r19, Z+3	; 0x03
    36e2:	c9 01       	movw	r24, r18
    36e4:	dc 01       	movw	r26, r24
    36e6:	e9 e0       	ldi	r30, 0x09	; 9
    36e8:	f2 e0       	ldi	r31, 0x02	; 2
    36ea:	89 e0       	ldi	r24, 0x09	; 9
    36ec:	01 90       	ld	r0, Z+
    36ee:	0d 92       	st	X+, r0
    36f0:	81 50       	subi	r24, 0x01	; 1
    36f2:	e1 f7       	brne	.-8      	; 0x36ec <updateDisplayChangeValues+0xb90>
      sprintf(menu.newDisplayValue[2], "test    ");
    36f4:	e0 91 e8 02 	lds	r30, 0x02E8
    36f8:	f0 91 e9 02 	lds	r31, 0x02E9
    36fc:	24 81       	ldd	r18, Z+4	; 0x04
    36fe:	35 81       	ldd	r19, Z+5	; 0x05
    3700:	c9 01       	movw	r24, r18
    3702:	dc 01       	movw	r26, r24
    3704:	e9 e0       	ldi	r30, 0x09	; 9
    3706:	f2 e0       	ldi	r31, 0x02	; 2
    3708:	89 e0       	ldi	r24, 0x09	; 9
    370a:	01 90       	ld	r0, Z+
    370c:	0d 92       	st	X+, r0
    370e:	81 50       	subi	r24, 0x01	; 1
    3710:	e1 f7       	brne	.-8      	; 0x370a <updateDisplayChangeValues+0xbae>
      sprintf(menu.newDisplayValue[3], "test    ");
    3712:	e0 91 e8 02 	lds	r30, 0x02E8
    3716:	f0 91 e9 02 	lds	r31, 0x02E9
    371a:	26 81       	ldd	r18, Z+6	; 0x06
    371c:	37 81       	ldd	r19, Z+7	; 0x07
    371e:	c9 01       	movw	r24, r18
    3720:	dc 01       	movw	r26, r24
    3722:	e9 e0       	ldi	r30, 0x09	; 9
    3724:	f2 e0       	ldi	r31, 0x02	; 2
    3726:	89 e0       	ldi	r24, 0x09	; 9
    3728:	01 90       	ld	r0, Z+
    372a:	0d 92       	st	X+, r0
    372c:	81 50       	subi	r24, 0x01	; 1
    372e:	e1 f7       	brne	.-8      	; 0x3728 <updateDisplayChangeValues+0xbcc>
      menu.currentMenuMode = MENU_SETTINGS_MODE;
    3730:	85 e0       	ldi	r24, 0x05	; 5
    3732:	80 93 e4 02 	sts	0x02E4, r24
    3736:	44 ca       	rjmp	.-2936   	; 0x2bc0 <updateDisplayChangeValues+0x64>
    case MENU_RUN_PROGRAM:
      sprintf(menu.newDisplayValue[0], "Program ");
      sprintf(menu.newDisplayValue[1], "running ");
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
      sprintf(menu.newDisplayValue[3], "        ");
      break;
    3738:	c0 e0       	ldi	r28, 0x00	; 0
    373a:	d0 e0       	ldi	r29, 0x00	; 0
    373c:	00 e0       	ldi	r16, 0x00	; 0
    373e:	12 e0       	ldi	r17, 0x02	; 2
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3740:	80 91 e5 02 	lds	r24, 0x02E5
    3744:	9e 01       	movw	r18, r28
    3746:	90 e0       	ldi	r25, 0x00	; 0
    3748:	0c 2e       	mov	r0, r28
    374a:	02 c0       	rjmp	.+4      	; 0x3750 <updateDisplayChangeValues+0xbf4>
    374c:	95 95       	asr	r25
    374e:	87 95       	ror	r24
    3750:	0a 94       	dec	r0
    3752:	e2 f7       	brpl	.-8      	; 0x374c <updateDisplayChangeValues+0xbf0>
    3754:	80 fd       	sbrc	r24, 0
    3756:	4a c0       	rjmp	.+148    	; 0x37ec <updateDisplayChangeValues+0xc90>
    3758:	60 e2       	ldi	r22, 0x20	; 32
    375a:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.1f A", c, motor[i].current);
    375c:	a0 91 e8 02 	lds	r26, 0x02E8
    3760:	b0 91 e9 02 	lds	r27, 0x02E9
    3764:	f9 01       	movw	r30, r18
    3766:	ee 0f       	add	r30, r30
    3768:	ff 1f       	adc	r31, r31
    376a:	ee 0f       	add	r30, r30
    376c:	ff 1f       	adc	r31, r31
    376e:	ee 0f       	add	r30, r30
    3770:	ff 1f       	adc	r31, r31
    3772:	cf 01       	movw	r24, r30
    3774:	88 0f       	add	r24, r24
    3776:	99 1f       	adc	r25, r25
    3778:	88 0f       	add	r24, r24
    377a:	99 1f       	adc	r25, r25
    377c:	e8 0f       	add	r30, r24
    377e:	f9 1f       	adc	r31, r25
    3780:	e0 51       	subi	r30, 0x10	; 16
    3782:	fc 4f       	sbci	r31, 0xFC	; 252
    3784:	23 a1       	ldd	r18, Z+35	; 0x23
    3786:	34 a1       	ldd	r19, Z+36	; 0x24
    3788:	45 a1       	ldd	r20, Z+37	; 0x25
    378a:	56 a1       	ldd	r21, Z+38	; 0x26
    378c:	8d b7       	in	r24, 0x3d	; 61
    378e:	9e b7       	in	r25, 0x3e	; 62
    3790:	0a 97       	sbiw	r24, 0x0a	; 10
    3792:	0f b6       	in	r0, 0x3f	; 63
    3794:	f8 94       	cli
    3796:	9e bf       	out	0x3e, r25	; 62
    3798:	0f be       	out	0x3f, r0	; 63
    379a:	8d bf       	out	0x3d, r24	; 61
    379c:	ed b7       	in	r30, 0x3d	; 61
    379e:	fe b7       	in	r31, 0x3e	; 62
    37a0:	31 96       	adiw	r30, 0x01	; 1
    37a2:	ce 01       	movw	r24, r28
    37a4:	88 0f       	add	r24, r24
    37a6:	99 1f       	adc	r25, r25
    37a8:	a8 0f       	add	r26, r24
    37aa:	b9 1f       	adc	r27, r25
    37ac:	8d 91       	ld	r24, X+
    37ae:	9c 91       	ld	r25, X
    37b0:	ad b7       	in	r26, 0x3d	; 61
    37b2:	be b7       	in	r27, 0x3e	; 62
    37b4:	12 96       	adiw	r26, 0x02	; 2
    37b6:	9c 93       	st	X, r25
    37b8:	8e 93       	st	-X, r24
    37ba:	11 97       	sbiw	r26, 0x01	; 1
    37bc:	13 83       	std	Z+3, r17	; 0x03
    37be:	02 83       	std	Z+2, r16	; 0x02
    37c0:	75 83       	std	Z+5, r23	; 0x05
    37c2:	64 83       	std	Z+4, r22	; 0x04
    37c4:	26 83       	std	Z+6, r18	; 0x06
    37c6:	37 83       	std	Z+7, r19	; 0x07
    37c8:	40 87       	std	Z+8, r20	; 0x08
    37ca:	51 87       	std	Z+9, r21	; 0x09
    37cc:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    37d0:	21 96       	adiw	r28, 0x01	; 1
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
      sprintf(menu.newDisplayValue[3], "        ");
      break;
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
    37d2:	ed b7       	in	r30, 0x3d	; 61
    37d4:	fe b7       	in	r31, 0x3e	; 62
    37d6:	3a 96       	adiw	r30, 0x0a	; 10
    37d8:	0f b6       	in	r0, 0x3f	; 63
    37da:	f8 94       	cli
    37dc:	fe bf       	out	0x3e, r31	; 62
    37de:	0f be       	out	0x3f, r0	; 63
    37e0:	ed bf       	out	0x3d, r30	; 61
    37e2:	c4 30       	cpi	r28, 0x04	; 4
    37e4:	d1 05       	cpc	r29, r1
    37e6:	09 f0       	breq	.+2      	; 0x37ea <updateDisplayChangeValues+0xc8e>
    37e8:	ab cf       	rjmp	.-170    	; 0x3740 <updateDisplayChangeValues+0xbe4>
    37ea:	ea c9       	rjmp	.-3116   	; 0x2bc0 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    37ec:	6e e7       	ldi	r22, 0x7E	; 126
    37ee:	70 e0       	ldi	r23, 0x00	; 0
    37f0:	b5 cf       	rjmp	.-150    	; 0x375c <updateDisplayChangeValues+0xc00>
    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    37f2:	4e e7       	ldi	r20, 0x7E	; 126
    37f4:	50 e0       	ldi	r21, 0x00	; 0
    37f6:	45 ce       	rjmp	.-886    	; 0x3482 <updateDisplayChangeValues+0x926>
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
    37f8:	e0 91 e8 02 	lds	r30, 0x02E8
    37fc:	f0 91 e9 02 	lds	r31, 0x02E9
    3800:	00 d0       	rcall	.+0      	; 0x3802 <updateDisplayChangeValues+0xca6>
    3802:	00 d0       	rcall	.+0      	; 0x3804 <updateDisplayChangeValues+0xca8>
    3804:	00 d0       	rcall	.+0      	; 0x3806 <updateDisplayChangeValues+0xcaa>
    3806:	ad b7       	in	r26, 0x3d	; 61
    3808:	be b7       	in	r27, 0x3e	; 62
    380a:	11 96       	adiw	r26, 0x01	; 1
    380c:	ee 0d       	add	r30, r14
    380e:	ff 1d       	adc	r31, r15
    3810:	80 81       	ld	r24, Z
    3812:	91 81       	ldd	r25, Z+1	; 0x01
    3814:	ed b7       	in	r30, 0x3d	; 61
    3816:	fe b7       	in	r31, 0x3e	; 62
    3818:	92 83       	std	Z+2, r25	; 0x02
    381a:	81 83       	std	Z+1, r24	; 0x01
    381c:	13 96       	adiw	r26, 0x03	; 3
    381e:	7c 92       	st	X, r7
    3820:	6e 92       	st	-X, r6
    3822:	12 97       	sbiw	r26, 0x02	; 2
    3824:	14 96       	adiw	r26, 0x04	; 4
    3826:	dc 92       	st	X, r13
    3828:	14 97       	sbiw	r26, 0x04	; 4
    382a:	15 96       	adiw	r26, 0x05	; 5
    382c:	1c 92       	st	X, r1
    382e:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3832:	2d b7       	in	r18, 0x3d	; 61
    3834:	3e b7       	in	r19, 0x3e	; 62
    3836:	2a 5f       	subi	r18, 0xFA	; 250
    3838:	3f 4f       	sbci	r19, 0xFF	; 255
    383a:	0f b6       	in	r0, 0x3f	; 63
    383c:	f8 94       	cli
    383e:	3e bf       	out	0x3e, r19	; 62
    3840:	0f be       	out	0x3f, r0	; 63
    3842:	2d bf       	out	0x3d, r18	; 61
    3844:	4d ca       	rjmp	.-2918   	; 0x2ce0 <updateDisplayChangeValues+0x184>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
    3846:	e0 91 e8 02 	lds	r30, 0x02E8
    384a:	f0 91 e9 02 	lds	r31, 0x02E9
    384e:	8d b7       	in	r24, 0x3d	; 61
    3850:	9e b7       	in	r25, 0x3e	; 62
    3852:	08 97       	sbiw	r24, 0x08	; 8
    3854:	0f b6       	in	r0, 0x3f	; 63
    3856:	f8 94       	cli
    3858:	9e bf       	out	0x3e, r25	; 62
    385a:	0f be       	out	0x3f, r0	; 63
    385c:	8d bf       	out	0x3d, r24	; 61
    385e:	ad b7       	in	r26, 0x3d	; 61
    3860:	be b7       	in	r27, 0x3e	; 62
    3862:	11 96       	adiw	r26, 0x01	; 1
    3864:	e0 0f       	add	r30, r16
    3866:	f1 1f       	adc	r31, r17
    3868:	80 81       	ld	r24, Z
    386a:	91 81       	ldd	r25, Z+1	; 0x01
    386c:	ed b7       	in	r30, 0x3d	; 61
    386e:	fe b7       	in	r31, 0x3e	; 62
    3870:	92 83       	std	Z+2, r25	; 0x02
    3872:	81 83       	std	Z+1, r24	; 0x01
    3874:	13 96       	adiw	r26, 0x03	; 3
    3876:	bc 92       	st	X, r11
    3878:	ae 92       	st	-X, r10
    387a:	12 97       	sbiw	r26, 0x02	; 2
    387c:	14 96       	adiw	r26, 0x04	; 4
    387e:	dc 92       	st	X, r13
    3880:	14 97       	sbiw	r26, 0x04	; 4
    3882:	15 96       	adiw	r26, 0x05	; 5
    3884:	1c 92       	st	X, r1
    3886:	15 97       	sbiw	r26, 0x05	; 5
    3888:	17 96       	adiw	r26, 0x07	; 7
    388a:	7c 92       	st	X, r7
    388c:	6e 92       	st	-X, r6
    388e:	16 97       	sbiw	r26, 0x06	; 6
    3890:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3894:	2d b7       	in	r18, 0x3d	; 61
    3896:	3e b7       	in	r19, 0x3e	; 62
    3898:	28 5f       	subi	r18, 0xF8	; 248
    389a:	3f 4f       	sbci	r19, 0xFF	; 255
    389c:	0f b6       	in	r0, 0x3f	; 63
    389e:	f8 94       	cli
    38a0:	3e bf       	out	0x3e, r19	; 62
    38a2:	0f be       	out	0x3f, r0	; 63
    38a4:	2d bf       	out	0x3d, r18	; 61
    38a6:	7a cb       	rjmp	.-2316   	; 0x2f9c <updateDisplayChangeValues+0x440>
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    38a8:	e0 91 e8 02 	lds	r30, 0x02E8
    38ac:	f0 91 e9 02 	lds	r31, 0x02E9
    38b0:	8d b7       	in	r24, 0x3d	; 61
    38b2:	9e b7       	in	r25, 0x3e	; 62
    38b4:	08 97       	sbiw	r24, 0x08	; 8
    38b6:	0f b6       	in	r0, 0x3f	; 63
    38b8:	f8 94       	cli
    38ba:	9e bf       	out	0x3e, r25	; 62
    38bc:	0f be       	out	0x3f, r0	; 63
    38be:	8d bf       	out	0x3d, r24	; 61
    38c0:	ad b7       	in	r26, 0x3d	; 61
    38c2:	be b7       	in	r27, 0x3e	; 62
    38c4:	11 96       	adiw	r26, 0x01	; 1
    38c6:	e0 0f       	add	r30, r16
    38c8:	f1 1f       	adc	r31, r17
    38ca:	80 81       	ld	r24, Z
    38cc:	91 81       	ldd	r25, Z+1	; 0x01
    38ce:	ed b7       	in	r30, 0x3d	; 61
    38d0:	fe b7       	in	r31, 0x3e	; 62
    38d2:	92 83       	std	Z+2, r25	; 0x02
    38d4:	81 83       	std	Z+1, r24	; 0x01
    38d6:	13 96       	adiw	r26, 0x03	; 3
    38d8:	bc 92       	st	X, r11
    38da:	ae 92       	st	-X, r10
    38dc:	12 97       	sbiw	r26, 0x02	; 2
    38de:	14 96       	adiw	r26, 0x04	; 4
    38e0:	dc 92       	st	X, r13
    38e2:	14 97       	sbiw	r26, 0x04	; 4
    38e4:	15 96       	adiw	r26, 0x05	; 5
    38e6:	1c 92       	st	X, r1
    38e8:	15 97       	sbiw	r26, 0x05	; 5
    38ea:	17 96       	adiw	r26, 0x07	; 7
    38ec:	5c 92       	st	X, r5
    38ee:	4e 92       	st	-X, r4
    38f0:	16 97       	sbiw	r26, 0x06	; 6
    38f2:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    38f6:	2d b7       	in	r18, 0x3d	; 61
    38f8:	3e b7       	in	r19, 0x3e	; 62
    38fa:	28 5f       	subi	r18, 0xF8	; 248
    38fc:	3f 4f       	sbci	r19, 0xFF	; 255
    38fe:	0f b6       	in	r0, 0x3f	; 63
    3900:	f8 94       	cli
    3902:	3e bf       	out	0x3e, r19	; 62
    3904:	0f be       	out	0x3f, r0	; 63
    3906:	2d bf       	out	0x3d, r18	; 61
    3908:	5e cb       	rjmp	.-2372   	; 0x2fc6 <updateDisplayChangeValues+0x46a>
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    390a:	e0 91 e8 02 	lds	r30, 0x02E8
    390e:	f0 91 e9 02 	lds	r31, 0x02E9
    3912:	00 d0       	rcall	.+0      	; 0x3914 <updateDisplayChangeValues+0xdb8>
    3914:	00 d0       	rcall	.+0      	; 0x3916 <updateDisplayChangeValues+0xdba>
    3916:	00 d0       	rcall	.+0      	; 0x3918 <updateDisplayChangeValues+0xdbc>
    3918:	ad b7       	in	r26, 0x3d	; 61
    391a:	be b7       	in	r27, 0x3e	; 62
    391c:	11 96       	adiw	r26, 0x01	; 1
    391e:	ee 0d       	add	r30, r14
    3920:	ff 1d       	adc	r31, r15
    3922:	80 81       	ld	r24, Z
    3924:	91 81       	ldd	r25, Z+1	; 0x01
    3926:	ed b7       	in	r30, 0x3d	; 61
    3928:	fe b7       	in	r31, 0x3e	; 62
    392a:	92 83       	std	Z+2, r25	; 0x02
    392c:	81 83       	std	Z+1, r24	; 0x01
    392e:	13 96       	adiw	r26, 0x03	; 3
    3930:	bc 92       	st	X, r11
    3932:	ae 92       	st	-X, r10
    3934:	12 97       	sbiw	r26, 0x02	; 2
    3936:	14 96       	adiw	r26, 0x04	; 4
    3938:	dc 92       	st	X, r13
    393a:	14 97       	sbiw	r26, 0x04	; 4
    393c:	15 96       	adiw	r26, 0x05	; 5
    393e:	1c 92       	st	X, r1
    3940:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3944:	2d b7       	in	r18, 0x3d	; 61
    3946:	3e b7       	in	r19, 0x3e	; 62
    3948:	2a 5f       	subi	r18, 0xFA	; 250
    394a:	3f 4f       	sbci	r19, 0xFF	; 255
    394c:	0f b6       	in	r0, 0x3f	; 63
    394e:	f8 94       	cli
    3950:	3e bf       	out	0x3e, r19	; 62
    3952:	0f be       	out	0x3f, r0	; 63
    3954:	2d bf       	out	0x3d, r18	; 61
    3956:	de c9       	rjmp	.-3140   	; 0x2d14 <updateDisplayChangeValues+0x1b8>
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
    3958:	e0 91 e8 02 	lds	r30, 0x02E8
    395c:	f0 91 e9 02 	lds	r31, 0x02E9
    3960:	00 d0       	rcall	.+0      	; 0x3962 <updateDisplayChangeValues+0xe06>
    3962:	00 d0       	rcall	.+0      	; 0x3964 <updateDisplayChangeValues+0xe08>
    3964:	00 d0       	rcall	.+0      	; 0x3966 <updateDisplayChangeValues+0xe0a>
    3966:	ad b7       	in	r26, 0x3d	; 61
    3968:	be b7       	in	r27, 0x3e	; 62
    396a:	11 96       	adiw	r26, 0x01	; 1
    396c:	ee 0d       	add	r30, r14
    396e:	ff 1d       	adc	r31, r15
    3970:	80 81       	ld	r24, Z
    3972:	91 81       	ldd	r25, Z+1	; 0x01
    3974:	ed b7       	in	r30, 0x3d	; 61
    3976:	fe b7       	in	r31, 0x3e	; 62
    3978:	92 83       	std	Z+2, r25	; 0x02
    397a:	81 83       	std	Z+1, r24	; 0x01
    397c:	13 96       	adiw	r26, 0x03	; 3
    397e:	9c 92       	st	X, r9
    3980:	8e 92       	st	-X, r8
    3982:	12 97       	sbiw	r26, 0x02	; 2
    3984:	14 96       	adiw	r26, 0x04	; 4
    3986:	dc 92       	st	X, r13
    3988:	14 97       	sbiw	r26, 0x04	; 4
    398a:	15 96       	adiw	r26, 0x05	; 5
    398c:	1c 92       	st	X, r1
    398e:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3992:	2d b7       	in	r18, 0x3d	; 61
    3994:	3e b7       	in	r19, 0x3e	; 62
    3996:	2a 5f       	subi	r18, 0xFA	; 250
    3998:	3f 4f       	sbci	r19, 0xFF	; 255
    399a:	0f b6       	in	r0, 0x3f	; 63
    399c:	f8 94       	cli
    399e:	3e bf       	out	0x3e, r19	; 62
    39a0:	0f be       	out	0x3f, r0	; 63
    39a2:	2d bf       	out	0x3d, r18	; 61
    39a4:	aa c9       	rjmp	.-3244   	; 0x2cfa <updateDisplayChangeValues+0x19e>

000039a6 <commandSetProgStep>:
    param5: absolute or relative movement

    always gets param1..param4 in steps (calculated by python interface)
 --------------------------------------------------------------------- */
void commandSetProgStep(char* param0, char* param1, char* param2,
                        char* param3, char* param4, char* param5){
    39a6:	8f 92       	push	r8
    39a8:	9f 92       	push	r9
    39aa:	af 92       	push	r10
    39ac:	bf 92       	push	r11
    39ae:	cf 92       	push	r12
    39b0:	df 92       	push	r13
    39b2:	ef 92       	push	r14
    39b4:	ff 92       	push	r15
    39b6:	0f 93       	push	r16
    39b8:	1f 93       	push	r17
    39ba:	cf 93       	push	r28
    39bc:	df 93       	push	r29
    39be:	eb 01       	movw	r28, r22
    39c0:	6a 01       	movw	r12, r20
    39c2:	59 01       	movw	r10, r18
    39c4:	48 01       	movw	r8, r16

  uint8_t step, i;

  step = (uint8_t)strtol(param0, (char **)NULL, 10);
    39c6:	60 e0       	ldi	r22, 0x00	; 0
    39c8:	70 e0       	ldi	r23, 0x00	; 0
    39ca:	4a e0       	ldi	r20, 0x0A	; 10
    39cc:	50 e0       	ldi	r21, 0x00	; 0
    39ce:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    39d2:	16 2f       	mov	r17, r22

  if(step >= MAX_PROGRAM_STEPS){
    39d4:	60 31       	cpi	r22, 0x10	; 16
    39d6:	68 f0       	brcs	.+26     	; 0x39f2 <commandSetProgStep+0x4c>
  if(strcmp(param5, "REL") == 0){
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
  }

  return;
}
    39d8:	df 91       	pop	r29
    39da:	cf 91       	pop	r28
    39dc:	1f 91       	pop	r17
    39de:	0f 91       	pop	r16
    39e0:	ff 90       	pop	r15
    39e2:	ef 90       	pop	r14
    39e4:	df 90       	pop	r13
    39e6:	cf 90       	pop	r12
    39e8:	bf 90       	pop	r11
    39ea:	af 90       	pop	r10
    39ec:	9f 90       	pop	r9
    39ee:	8f 90       	pop	r8
    39f0:	08 95       	ret
  if(step >= MAX_PROGRAM_STEPS){
    /* not more than MAX_PROGAM_STEPS allowed */
    return;
  }

  if(strcmp(param5, "NONE") == 0){
    39f2:	c7 01       	movw	r24, r14
    39f4:	62 e1       	ldi	r22, 0x12	; 18
    39f6:	72 e0       	ldi	r23, 0x02	; 2
    39f8:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    39fc:	00 97       	sbiw	r24, 0x00	; 0
    39fe:	09 f0       	breq	.+2      	; 0x3a02 <commandSetProgStep+0x5c>
    3a00:	66 c0       	rjmp	.+204    	; 0x3ace <commandSetProgStep+0x128>
    programList[step].isActive = 0;
    3a02:	81 2f       	mov	r24, r17
    3a04:	90 e0       	ldi	r25, 0x00	; 0
    3a06:	fc 01       	movw	r30, r24
    3a08:	ee 0f       	add	r30, r30
    3a0a:	ff 1f       	adc	r31, r31
    3a0c:	ee 0f       	add	r30, r30
    3a0e:	ff 1f       	adc	r31, r31
    3a10:	ee 0f       	add	r30, r30
    3a12:	ff 1f       	adc	r31, r31
    3a14:	88 0f       	add	r24, r24
    3a16:	99 1f       	adc	r25, r25
    3a18:	e8 0f       	add	r30, r24
    3a1a:	f9 1f       	adc	r31, r25
    3a1c:	ed 50       	subi	r30, 0x0D	; 13
    3a1e:	fd 4f       	sbci	r31, 0xFD	; 253
    3a20:	10 82       	st	Z, r1
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
    3a22:	81 2f       	mov	r24, r17
    3a24:	90 e0       	ldi	r25, 0x00	; 0
    3a26:	fc 01       	movw	r30, r24
    3a28:	ee 0f       	add	r30, r30
    3a2a:	ff 1f       	adc	r31, r31
    3a2c:	ee 0f       	add	r30, r30
    3a2e:	ff 1f       	adc	r31, r31
    3a30:	ee 0f       	add	r30, r30
    3a32:	ff 1f       	adc	r31, r31
    3a34:	88 0f       	add	r24, r24
    3a36:	99 1f       	adc	r25, r25
    3a38:	e8 0f       	add	r30, r24
    3a3a:	f9 1f       	adc	r31, r25
    3a3c:	ed 50       	subi	r30, 0x0D	; 13
    3a3e:	fd 4f       	sbci	r31, 0xFD	; 253
    3a40:	81 e0       	ldi	r24, 0x01	; 1
    3a42:	81 87       	std	Z+9, r24	; 0x09
    for(i = 0; i <= MAX_MOTOR; i++){
      programList[step].position[i] = 0;
    3a44:	81 2f       	mov	r24, r17
    3a46:	90 e0       	ldi	r25, 0x00	; 0
    3a48:	fc 01       	movw	r30, r24
    3a4a:	ee 0f       	add	r30, r30
    3a4c:	ff 1f       	adc	r31, r31
    3a4e:	ee 0f       	add	r30, r30
    3a50:	ff 1f       	adc	r31, r31
    3a52:	ee 0f       	add	r30, r30
    3a54:	ff 1f       	adc	r31, r31
    3a56:	88 0f       	add	r24, r24
    3a58:	99 1f       	adc	r25, r25
    3a5a:	e8 0f       	add	r30, r24
    3a5c:	f9 1f       	adc	r31, r25
    3a5e:	ed 50       	subi	r30, 0x0D	; 13
    3a60:	fd 4f       	sbci	r31, 0xFD	; 253
    3a62:	12 82       	std	Z+2, r1	; 0x02
    3a64:	11 82       	std	Z+1, r1	; 0x01
    3a66:	81 2f       	mov	r24, r17
    3a68:	90 e0       	ldi	r25, 0x00	; 0
    3a6a:	fc 01       	movw	r30, r24
    3a6c:	ee 0f       	add	r30, r30
    3a6e:	ff 1f       	adc	r31, r31
    3a70:	ee 0f       	add	r30, r30
    3a72:	ff 1f       	adc	r31, r31
    3a74:	ee 0f       	add	r30, r30
    3a76:	ff 1f       	adc	r31, r31
    3a78:	88 0f       	add	r24, r24
    3a7a:	99 1f       	adc	r25, r25
    3a7c:	e8 0f       	add	r30, r24
    3a7e:	f9 1f       	adc	r31, r25
    3a80:	ed 50       	subi	r30, 0x0D	; 13
    3a82:	fd 4f       	sbci	r31, 0xFD	; 253
    3a84:	14 82       	std	Z+4, r1	; 0x04
    3a86:	13 82       	std	Z+3, r1	; 0x03
    3a88:	81 2f       	mov	r24, r17
    3a8a:	90 e0       	ldi	r25, 0x00	; 0
    3a8c:	fc 01       	movw	r30, r24
    3a8e:	ee 0f       	add	r30, r30
    3a90:	ff 1f       	adc	r31, r31
    3a92:	ee 0f       	add	r30, r30
    3a94:	ff 1f       	adc	r31, r31
    3a96:	ee 0f       	add	r30, r30
    3a98:	ff 1f       	adc	r31, r31
    3a9a:	88 0f       	add	r24, r24
    3a9c:	99 1f       	adc	r25, r25
    3a9e:	e8 0f       	add	r30, r24
    3aa0:	f9 1f       	adc	r31, r25
    3aa2:	ed 50       	subi	r30, 0x0D	; 13
    3aa4:	fd 4f       	sbci	r31, 0xFD	; 253
    3aa6:	16 82       	std	Z+6, r1	; 0x06
    3aa8:	15 82       	std	Z+5, r1	; 0x05
    3aaa:	81 2f       	mov	r24, r17
    3aac:	90 e0       	ldi	r25, 0x00	; 0
    3aae:	fc 01       	movw	r30, r24
    3ab0:	ee 0f       	add	r30, r30
    3ab2:	ff 1f       	adc	r31, r31
    3ab4:	ee 0f       	add	r30, r30
    3ab6:	ff 1f       	adc	r31, r31
    3ab8:	ee 0f       	add	r30, r30
    3aba:	ff 1f       	adc	r31, r31
    3abc:	88 0f       	add	r24, r24
    3abe:	99 1f       	adc	r25, r25
    3ac0:	e8 0f       	add	r30, r24
    3ac2:	f9 1f       	adc	r31, r25
    3ac4:	ed 50       	subi	r30, 0x0D	; 13
    3ac6:	fd 4f       	sbci	r31, 0xFD	; 253
    3ac8:	10 86       	std	Z+8, r1	; 0x08
    3aca:	17 82       	std	Z+7, r1	; 0x07
    3acc:	85 cf       	rjmp	.-246    	; 0x39d8 <commandSetProgStep+0x32>
    }
    return;
  }

  programList[step].position[0] = (int16_t)strtol(param1, (char **)NULL, 10);
    3ace:	ce 01       	movw	r24, r28
    3ad0:	60 e0       	ldi	r22, 0x00	; 0
    3ad2:	70 e0       	ldi	r23, 0x00	; 0
    3ad4:	4a e0       	ldi	r20, 0x0A	; 10
    3ad6:	50 e0       	ldi	r21, 0x00	; 0
    3ad8:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    3adc:	21 2f       	mov	r18, r17
    3ade:	30 e0       	ldi	r19, 0x00	; 0
    3ae0:	f9 01       	movw	r30, r18
    3ae2:	ee 0f       	add	r30, r30
    3ae4:	ff 1f       	adc	r31, r31
    3ae6:	ee 0f       	add	r30, r30
    3ae8:	ff 1f       	adc	r31, r31
    3aea:	ee 0f       	add	r30, r30
    3aec:	ff 1f       	adc	r31, r31
    3aee:	22 0f       	add	r18, r18
    3af0:	33 1f       	adc	r19, r19
    3af2:	e2 0f       	add	r30, r18
    3af4:	f3 1f       	adc	r31, r19
    3af6:	ed 50       	subi	r30, 0x0D	; 13
    3af8:	fd 4f       	sbci	r31, 0xFD	; 253
    3afa:	72 83       	std	Z+2, r23	; 0x02
    3afc:	61 83       	std	Z+1, r22	; 0x01
  programList[step].position[1] = (int16_t)strtol(param2, (char **)NULL, 10);
    3afe:	c6 01       	movw	r24, r12
    3b00:	60 e0       	ldi	r22, 0x00	; 0
    3b02:	70 e0       	ldi	r23, 0x00	; 0
    3b04:	4a e0       	ldi	r20, 0x0A	; 10
    3b06:	50 e0       	ldi	r21, 0x00	; 0
    3b08:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    3b0c:	21 2f       	mov	r18, r17
    3b0e:	30 e0       	ldi	r19, 0x00	; 0
    3b10:	f9 01       	movw	r30, r18
    3b12:	ee 0f       	add	r30, r30
    3b14:	ff 1f       	adc	r31, r31
    3b16:	ee 0f       	add	r30, r30
    3b18:	ff 1f       	adc	r31, r31
    3b1a:	ee 0f       	add	r30, r30
    3b1c:	ff 1f       	adc	r31, r31
    3b1e:	22 0f       	add	r18, r18
    3b20:	33 1f       	adc	r19, r19
    3b22:	e2 0f       	add	r30, r18
    3b24:	f3 1f       	adc	r31, r19
    3b26:	ed 50       	subi	r30, 0x0D	; 13
    3b28:	fd 4f       	sbci	r31, 0xFD	; 253
    3b2a:	74 83       	std	Z+4, r23	; 0x04
    3b2c:	63 83       	std	Z+3, r22	; 0x03
  programList[step].position[2] = (int16_t)strtol(param3, (char **)NULL, 10);
    3b2e:	c5 01       	movw	r24, r10
    3b30:	60 e0       	ldi	r22, 0x00	; 0
    3b32:	70 e0       	ldi	r23, 0x00	; 0
    3b34:	4a e0       	ldi	r20, 0x0A	; 10
    3b36:	50 e0       	ldi	r21, 0x00	; 0
    3b38:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    3b3c:	21 2f       	mov	r18, r17
    3b3e:	30 e0       	ldi	r19, 0x00	; 0
    3b40:	f9 01       	movw	r30, r18
    3b42:	ee 0f       	add	r30, r30
    3b44:	ff 1f       	adc	r31, r31
    3b46:	ee 0f       	add	r30, r30
    3b48:	ff 1f       	adc	r31, r31
    3b4a:	ee 0f       	add	r30, r30
    3b4c:	ff 1f       	adc	r31, r31
    3b4e:	22 0f       	add	r18, r18
    3b50:	33 1f       	adc	r19, r19
    3b52:	e2 0f       	add	r30, r18
    3b54:	f3 1f       	adc	r31, r19
    3b56:	ed 50       	subi	r30, 0x0D	; 13
    3b58:	fd 4f       	sbci	r31, 0xFD	; 253
    3b5a:	76 83       	std	Z+6, r23	; 0x06
    3b5c:	65 83       	std	Z+5, r22	; 0x05
  programList[step].position[3] = (int16_t)strtol(param4, (char **)NULL, 10);
    3b5e:	c4 01       	movw	r24, r8
    3b60:	60 e0       	ldi	r22, 0x00	; 0
    3b62:	70 e0       	ldi	r23, 0x00	; 0
    3b64:	4a e0       	ldi	r20, 0x0A	; 10
    3b66:	50 e0       	ldi	r21, 0x00	; 0
    3b68:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    3b6c:	21 2f       	mov	r18, r17
    3b6e:	30 e0       	ldi	r19, 0x00	; 0
    3b70:	f9 01       	movw	r30, r18
    3b72:	ee 0f       	add	r30, r30
    3b74:	ff 1f       	adc	r31, r31
    3b76:	ee 0f       	add	r30, r30
    3b78:	ff 1f       	adc	r31, r31
    3b7a:	ee 0f       	add	r30, r30
    3b7c:	ff 1f       	adc	r31, r31
    3b7e:	22 0f       	add	r18, r18
    3b80:	33 1f       	adc	r19, r19
    3b82:	e2 0f       	add	r30, r18
    3b84:	f3 1f       	adc	r31, r19
    3b86:	ed 50       	subi	r30, 0x0D	; 13
    3b88:	fd 4f       	sbci	r31, 0xFD	; 253
    3b8a:	70 87       	std	Z+8, r23	; 0x08
    3b8c:	67 83       	std	Z+7, r22	; 0x07

  programList[step].isActive = 1;
    3b8e:	81 2f       	mov	r24, r17
    3b90:	90 e0       	ldi	r25, 0x00	; 0
    3b92:	fc 01       	movw	r30, r24
    3b94:	ee 0f       	add	r30, r30
    3b96:	ff 1f       	adc	r31, r31
    3b98:	ee 0f       	add	r30, r30
    3b9a:	ff 1f       	adc	r31, r31
    3b9c:	ee 0f       	add	r30, r30
    3b9e:	ff 1f       	adc	r31, r31
    3ba0:	88 0f       	add	r24, r24
    3ba2:	99 1f       	adc	r25, r25
    3ba4:	e8 0f       	add	r30, r24
    3ba6:	f9 1f       	adc	r31, r25
    3ba8:	ed 50       	subi	r30, 0x0D	; 13
    3baa:	fd 4f       	sbci	r31, 0xFD	; 253
    3bac:	81 e0       	ldi	r24, 0x01	; 1
    3bae:	80 83       	st	Z, r24

  if(strcmp(param5, "ABS") == 0){
    3bb0:	c7 01       	movw	r24, r14
    3bb2:	67 e1       	ldi	r22, 0x17	; 23
    3bb4:	72 e0       	ldi	r23, 0x02	; 2
    3bb6:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    3bba:	00 97       	sbiw	r24, 0x00	; 0
    3bbc:	81 f4       	brne	.+32     	; 0x3bde <commandSetProgStep+0x238>
    programList[step].absRel = PROG_ABSOLUTE_MOVEMENT;
    3bbe:	81 2f       	mov	r24, r17
    3bc0:	90 e0       	ldi	r25, 0x00	; 0
    3bc2:	fc 01       	movw	r30, r24
    3bc4:	ee 0f       	add	r30, r30
    3bc6:	ff 1f       	adc	r31, r31
    3bc8:	ee 0f       	add	r30, r30
    3bca:	ff 1f       	adc	r31, r31
    3bcc:	ee 0f       	add	r30, r30
    3bce:	ff 1f       	adc	r31, r31
    3bd0:	88 0f       	add	r24, r24
    3bd2:	99 1f       	adc	r25, r25
    3bd4:	e8 0f       	add	r30, r24
    3bd6:	f9 1f       	adc	r31, r25
    3bd8:	ed 50       	subi	r30, 0x0D	; 13
    3bda:	fd 4f       	sbci	r31, 0xFD	; 253
    3bdc:	11 86       	std	Z+9, r1	; 0x09
  }
  if(strcmp(param5, "REL") == 0){
    3bde:	c7 01       	movw	r24, r14
    3be0:	6b e1       	ldi	r22, 0x1B	; 27
    3be2:	72 e0       	ldi	r23, 0x02	; 2
    3be4:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    3be8:	00 97       	sbiw	r24, 0x00	; 0
    3bea:	09 f0       	breq	.+2      	; 0x3bee <commandSetProgStep+0x248>
    3bec:	f5 ce       	rjmp	.-534    	; 0x39d8 <commandSetProgStep+0x32>
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
    3bee:	81 2f       	mov	r24, r17
    3bf0:	90 e0       	ldi	r25, 0x00	; 0
    3bf2:	fc 01       	movw	r30, r24
    3bf4:	ee 0f       	add	r30, r30
    3bf6:	ff 1f       	adc	r31, r31
    3bf8:	ee 0f       	add	r30, r30
    3bfa:	ff 1f       	adc	r31, r31
    3bfc:	ee 0f       	add	r30, r30
    3bfe:	ff 1f       	adc	r31, r31
    3c00:	88 0f       	add	r24, r24
    3c02:	99 1f       	adc	r25, r25
    3c04:	e8 0f       	add	r30, r24
    3c06:	f9 1f       	adc	r31, r25
    3c08:	ed 50       	subi	r30, 0x0D	; 13
    3c0a:	fd 4f       	sbci	r31, 0xFD	; 253
    3c0c:	81 e0       	ldi	r24, 0x01	; 1
    3c0e:	81 87       	std	Z+9, r24	; 0x09
    3c10:	e3 ce       	rjmp	.-570    	; 0x39d8 <commandSetProgStep+0x32>

00003c12 <commandGetMotorPosition>:

/* ---------------------------------------------------------------------
    returns the actual motor position as string
    the format depends on the given unit
 --------------------------------------------------------------------- */
char* commandGetMotorPosition(char* param0, char* param1){
    3c12:	0f 93       	push	r16
    3c14:	cf 93       	push	r28
    3c16:	df 93       	push	r29
    3c18:	eb 01       	movw	r28, r22

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    3c1a:	60 e0       	ldi	r22, 0x00	; 0
    3c1c:	70 e0       	ldi	r23, 0x00	; 0
    3c1e:	4a e0       	ldi	r20, 0x0A	; 10
    3c20:	50 e0       	ldi	r21, 0x00	; 0
    3c22:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    3c26:	06 2f       	mov	r16, r22

  if(i > MAX_MOTOR){
    3c28:	64 30       	cpi	r22, 0x04	; 4
    3c2a:	08 f0       	brcs	.+2      	; 0x3c2e <commandGetMotorPosition+0x1c>
    3c2c:	ac c0       	rjmp	.+344    	; 0x3d86 <commandGetMotorPosition+0x174>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(strcmp(param1, "steps") == 0){
    3c2e:	ce 01       	movw	r24, r28
    3c30:	6f e1       	ldi	r22, 0x1F	; 31
    3c32:	72 e0       	ldi	r23, 0x02	; 2
    3c34:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    3c38:	00 97       	sbiw	r24, 0x00	; 0
    3c3a:	59 f1       	breq	.+86     	; 0x3c92 <commandGetMotorPosition+0x80>
      sprintf(txString.buffer, "%d", motor[i].actualPosition);
    }
    else if(strcmp(param1, "deg") == 0){
    3c3c:	ce 01       	movw	r24, r28
    3c3e:	65 e2       	ldi	r22, 0x25	; 37
    3c40:	72 e0       	ldi	r23, 0x02	; 2
    3c42:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    3c46:	00 97       	sbiw	r24, 0x00	; 0
    3c48:	09 f4       	brne	.+2      	; 0x3c4c <commandGetMotorPosition+0x3a>
    3c4a:	60 c0       	rjmp	.+192    	; 0x3d0c <commandGetMotorPosition+0xfa>
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    }
    else if(strcmp(param1, "pi") == 0){
    3c4c:	ce 01       	movw	r24, r28
    3c4e:	69 e2       	ldi	r22, 0x29	; 41
    3c50:	72 e0       	ldi	r23, 0x02	; 2
    3c52:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    3c56:	00 97       	sbiw	r24, 0x00	; 0
    3c58:	09 f0       	breq	.+2      	; 0x3c5c <commandGetMotorPosition+0x4a>
    3c5a:	58 c0       	rjmp	.+176    	; 0x3d0c <commandGetMotorPosition+0xfa>
      sprintf(txString.buffer, "%f", stepsToRadian(i, motor[i].actualPosition));
    3c5c:	c0 91 e7 03 	lds	r28, 0x03E7
    3c60:	d0 91 e8 03 	lds	r29, 0x03E8
    3c64:	e0 2f       	mov	r30, r16
    3c66:	f0 e0       	ldi	r31, 0x00	; 0
    3c68:	ee 0f       	add	r30, r30
    3c6a:	ff 1f       	adc	r31, r31
    3c6c:	ee 0f       	add	r30, r30
    3c6e:	ff 1f       	adc	r31, r31
    3c70:	ee 0f       	add	r30, r30
    3c72:	ff 1f       	adc	r31, r31
    3c74:	cf 01       	movw	r24, r30
    3c76:	88 0f       	add	r24, r24
    3c78:	99 1f       	adc	r25, r25
    3c7a:	88 0f       	add	r24, r24
    3c7c:	99 1f       	adc	r25, r25
    3c7e:	e8 0f       	add	r30, r24
    3c80:	f9 1f       	adc	r31, r25
    3c82:	e0 51       	subi	r30, 0x10	; 16
    3c84:	fc 4f       	sbci	r31, 0xFC	; 252
    3c86:	60 81       	ld	r22, Z
    3c88:	71 81       	ldd	r23, Z+1	; 0x01
    3c8a:	80 2f       	mov	r24, r16
    3c8c:	0e 94 23 08 	call	0x1046	; 0x1046 <stepsToRadian>
    3c90:	57 c0       	rjmp	.+174    	; 0x3d40 <commandGetMotorPosition+0x12e>
  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(strcmp(param1, "steps") == 0){
      sprintf(txString.buffer, "%d", motor[i].actualPosition);
    3c92:	40 91 e7 03 	lds	r20, 0x03E7
    3c96:	50 91 e8 03 	lds	r21, 0x03E8
    3c9a:	e0 2f       	mov	r30, r16
    3c9c:	f0 e0       	ldi	r31, 0x00	; 0
    3c9e:	ee 0f       	add	r30, r30
    3ca0:	ff 1f       	adc	r31, r31
    3ca2:	ee 0f       	add	r30, r30
    3ca4:	ff 1f       	adc	r31, r31
    3ca6:	ee 0f       	add	r30, r30
    3ca8:	ff 1f       	adc	r31, r31
    3caa:	cf 01       	movw	r24, r30
    3cac:	88 0f       	add	r24, r24
    3cae:	99 1f       	adc	r25, r25
    3cb0:	88 0f       	add	r24, r24
    3cb2:	99 1f       	adc	r25, r25
    3cb4:	e8 0f       	add	r30, r24
    3cb6:	f9 1f       	adc	r31, r25
    3cb8:	e0 51       	subi	r30, 0x10	; 16
    3cba:	fc 4f       	sbci	r31, 0xFC	; 252
    3cbc:	20 81       	ld	r18, Z
    3cbe:	31 81       	ldd	r19, Z+1	; 0x01
    3cc0:	00 d0       	rcall	.+0      	; 0x3cc2 <commandGetMotorPosition+0xb0>
    3cc2:	00 d0       	rcall	.+0      	; 0x3cc4 <commandGetMotorPosition+0xb2>
    3cc4:	00 d0       	rcall	.+0      	; 0x3cc6 <commandGetMotorPosition+0xb4>
    3cc6:	ed b7       	in	r30, 0x3d	; 61
    3cc8:	fe b7       	in	r31, 0x3e	; 62
    3cca:	31 96       	adiw	r30, 0x01	; 1
    3ccc:	ad b7       	in	r26, 0x3d	; 61
    3cce:	be b7       	in	r27, 0x3e	; 62
    3cd0:	12 96       	adiw	r26, 0x02	; 2
    3cd2:	5c 93       	st	X, r21
    3cd4:	4e 93       	st	-X, r20
    3cd6:	11 97       	sbiw	r26, 0x01	; 1
    3cd8:	87 e1       	ldi	r24, 0x17	; 23
    3cda:	91 e0       	ldi	r25, 0x01	; 1
    3cdc:	93 83       	std	Z+3, r25	; 0x03
    3cde:	82 83       	std	Z+2, r24	; 0x02
    3ce0:	35 83       	std	Z+5, r19	; 0x05
    3ce2:	24 83       	std	Z+4, r18	; 0x04
    3ce4:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3ce8:	2d b7       	in	r18, 0x3d	; 61
    3cea:	3e b7       	in	r19, 0x3e	; 62
    3cec:	2a 5f       	subi	r18, 0xFA	; 250
    3cee:	3f 4f       	sbci	r19, 0xFF	; 255
    3cf0:	0f b6       	in	r0, 0x3f	; 63
    3cf2:	f8 94       	cli
    3cf4:	3e bf       	out	0x3e, r19	; 62
    3cf6:	0f be       	out	0x3f, r0	; 63
    3cf8:	2d bf       	out	0x3d, r18	; 61
      /* wrong unit argument returns in degree */
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    }
  }

  return txString.buffer;
    3cfa:	20 91 e7 03 	lds	r18, 0x03E7
    3cfe:	30 91 e8 03 	lds	r19, 0x03E8
}
    3d02:	c9 01       	movw	r24, r18
    3d04:	df 91       	pop	r29
    3d06:	cf 91       	pop	r28
    3d08:	0f 91       	pop	r16
    3d0a:	08 95       	ret
    else if(strcmp(param1, "pi") == 0){
      sprintf(txString.buffer, "%f", stepsToRadian(i, motor[i].actualPosition));
    }
    else{
      /* wrong unit argument returns in degree */
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    3d0c:	c0 91 e7 03 	lds	r28, 0x03E7
    3d10:	d0 91 e8 03 	lds	r29, 0x03E8
    3d14:	e0 2f       	mov	r30, r16
    3d16:	f0 e0       	ldi	r31, 0x00	; 0
    3d18:	ee 0f       	add	r30, r30
    3d1a:	ff 1f       	adc	r31, r31
    3d1c:	ee 0f       	add	r30, r30
    3d1e:	ff 1f       	adc	r31, r31
    3d20:	ee 0f       	add	r30, r30
    3d22:	ff 1f       	adc	r31, r31
    3d24:	cf 01       	movw	r24, r30
    3d26:	88 0f       	add	r24, r24
    3d28:	99 1f       	adc	r25, r25
    3d2a:	88 0f       	add	r24, r24
    3d2c:	99 1f       	adc	r25, r25
    3d2e:	e8 0f       	add	r30, r24
    3d30:	f9 1f       	adc	r31, r25
    3d32:	e0 51       	subi	r30, 0x10	; 16
    3d34:	fc 4f       	sbci	r31, 0xFC	; 252
    3d36:	60 81       	ld	r22, Z
    3d38:	71 81       	ldd	r23, Z+1	; 0x01
    3d3a:	80 2f       	mov	r24, r16
    3d3c:	0e 94 9e 07 	call	0xf3c	; 0xf3c <stepsToDegree>
    3d40:	ad b7       	in	r26, 0x3d	; 61
    3d42:	be b7       	in	r27, 0x3e	; 62
    3d44:	18 97       	sbiw	r26, 0x08	; 8
    3d46:	0f b6       	in	r0, 0x3f	; 63
    3d48:	f8 94       	cli
    3d4a:	be bf       	out	0x3e, r27	; 62
    3d4c:	0f be       	out	0x3f, r0	; 63
    3d4e:	ad bf       	out	0x3d, r26	; 61
    3d50:	ed b7       	in	r30, 0x3d	; 61
    3d52:	fe b7       	in	r31, 0x3e	; 62
    3d54:	31 96       	adiw	r30, 0x01	; 1
    3d56:	12 96       	adiw	r26, 0x02	; 2
    3d58:	dc 93       	st	X, r29
    3d5a:	ce 93       	st	-X, r28
    3d5c:	11 97       	sbiw	r26, 0x01	; 1
    3d5e:	2f e1       	ldi	r18, 0x1F	; 31
    3d60:	31 e0       	ldi	r19, 0x01	; 1
    3d62:	33 83       	std	Z+3, r19	; 0x03
    3d64:	22 83       	std	Z+2, r18	; 0x02
    3d66:	64 83       	std	Z+4, r22	; 0x04
    3d68:	75 83       	std	Z+5, r23	; 0x05
    3d6a:	86 83       	std	Z+6, r24	; 0x06
    3d6c:	97 83       	std	Z+7, r25	; 0x07
    3d6e:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3d72:	2d b7       	in	r18, 0x3d	; 61
    3d74:	3e b7       	in	r19, 0x3e	; 62
    3d76:	28 5f       	subi	r18, 0xF8	; 248
    3d78:	3f 4f       	sbci	r19, 0xFF	; 255
    3d7a:	0f b6       	in	r0, 0x3f	; 63
    3d7c:	f8 94       	cli
    3d7e:	3e bf       	out	0x3e, r19	; 62
    3d80:	0f be       	out	0x3f, r0	; 63
    3d82:	2d bf       	out	0x3d, r18	; 61
    3d84:	ba cf       	rjmp	.-140    	; 0x3cfa <commandGetMotorPosition+0xe8>
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    3d86:	80 91 e7 03 	lds	r24, 0x03E7
    3d8a:	90 91 e8 03 	lds	r25, 0x03E8
    3d8e:	00 d0       	rcall	.+0      	; 0x3d90 <commandGetMotorPosition+0x17e>
    3d90:	00 d0       	rcall	.+0      	; 0x3d92 <commandGetMotorPosition+0x180>
    3d92:	00 d0       	rcall	.+0      	; 0x3d94 <commandGetMotorPosition+0x182>
    3d94:	ed b7       	in	r30, 0x3d	; 61
    3d96:	fe b7       	in	r31, 0x3e	; 62
    3d98:	31 96       	adiw	r30, 0x01	; 1
    3d9a:	ad b7       	in	r26, 0x3d	; 61
    3d9c:	be b7       	in	r27, 0x3e	; 62
    3d9e:	12 96       	adiw	r26, 0x02	; 2
    3da0:	9c 93       	st	X, r25
    3da2:	8e 93       	st	-X, r24
    3da4:	11 97       	sbiw	r26, 0x01	; 1
    3da6:	80 e0       	ldi	r24, 0x00	; 0
    3da8:	91 e0       	ldi	r25, 0x01	; 1
    3daa:	93 83       	std	Z+3, r25	; 0x03
    3dac:	82 83       	std	Z+2, r24	; 0x02
    3dae:	04 83       	std	Z+4, r16	; 0x04
    3db0:	15 82       	std	Z+5, r1	; 0x05
    3db2:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    3db6:	2d b7       	in	r18, 0x3d	; 61
    3db8:	3e b7       	in	r19, 0x3e	; 62
    3dba:	2a 5f       	subi	r18, 0xFA	; 250
    3dbc:	3f 4f       	sbci	r19, 0xFF	; 255
    3dbe:	0f b6       	in	r0, 0x3f	; 63
    3dc0:	f8 94       	cli
    3dc2:	3e bf       	out	0x3e, r19	; 62
    3dc4:	0f be       	out	0x3f, r0	; 63
    3dc6:	2d bf       	out	0x3d, r18	; 61
    3dc8:	98 cf       	rjmp	.-208    	; 0x3cfa <commandGetMotorPosition+0xe8>

00003dca <changeDisplayMenu>:

  uint8_t j = 0;
  uint8_t k = 0;
  uint8_t sLen = 0;

  menuPtr  = (menuItem*)pgm_read_word(&menuList[i]);
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	88 0f       	add	r24, r24
    3dce:	99 1f       	adc	r25, r25
    3dd0:	8e 51       	subi	r24, 0x1E	; 30
    3dd2:	9b 4f       	sbci	r25, 0xFB	; 251
    3dd4:	fc 01       	movw	r30, r24
    3dd6:	25 91       	lpm	r18, Z+
    3dd8:	34 91       	lpm	r19, Z+
  menuText = (char*)pgm_read_word(&menuPtr->displayText);
    3dda:	f9 01       	movw	r30, r18
    3ddc:	65 91       	lpm	r22, Z+
    3dde:	74 91       	lpm	r23, Z+

  strcpy_P(displayBuffer, menuText);
    3de0:	80 91 eb 03 	lds	r24, 0x03EB
    3de4:	90 91 ec 03 	lds	r25, 0x03EC
    3de8:	0e 94 24 45 	call	0x8a48	; 0x8a48 <strcpy_P>

  displayBuffer = strtok(displayBuffer, "\n");
    3dec:	80 91 eb 03 	lds	r24, 0x03EB
    3df0:	90 91 ec 03 	lds	r25, 0x03EC
    3df4:	6c e2       	ldi	r22, 0x2C	; 44
    3df6:	72 e0       	ldi	r23, 0x02	; 2
    3df8:	0e 94 36 45 	call	0x8a6c	; 0x8a6c <strtok>
    3dfc:	bc 01       	movw	r22, r24
    3dfe:	90 93 ec 03 	sts	0x03EC, r25
    3e02:	80 93 eb 03 	sts	0x03EB, r24
  strcpy(menu.newMenuText[0], displayBuffer);
    3e06:	e0 91 ec 02 	lds	r30, 0x02EC
    3e0a:	f0 91 ed 02 	lds	r31, 0x02ED
    3e0e:	80 81       	ld	r24, Z
    3e10:	91 81       	ldd	r25, Z+1	; 0x01
    3e12:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
  displayBuffer = strtok(NULL, "\0");
    3e16:	80 e0       	ldi	r24, 0x00	; 0
    3e18:	90 e0       	ldi	r25, 0x00	; 0
    3e1a:	6e e2       	ldi	r22, 0x2E	; 46
    3e1c:	72 e0       	ldi	r23, 0x02	; 2
    3e1e:	0e 94 36 45 	call	0x8a6c	; 0x8a6c <strtok>
    3e22:	bc 01       	movw	r22, r24
    3e24:	90 93 ec 03 	sts	0x03EC, r25
    3e28:	80 93 eb 03 	sts	0x03EB, r24
  strcpy(menu.newMenuText[1], displayBuffer);
    3e2c:	e0 91 ec 02 	lds	r30, 0x02EC
    3e30:	f0 91 ed 02 	lds	r31, 0x02ED
    3e34:	82 81       	ldd	r24, Z+2	; 0x02
    3e36:	93 81       	ldd	r25, Z+3	; 0x03
    3e38:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
    3e3c:	20 e0       	ldi	r18, 0x00	; 0
    3e3e:	30 e0       	ldi	r19, 0x00	; 0

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
      menu.newMenuText[j][k] = ' ';
    3e40:	90 e2       	ldi	r25, 0x20	; 32
  displayBuffer = strtok(NULL, "\0");
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    3e42:	a0 91 ec 02 	lds	r26, 0x02EC
    3e46:	b0 91 ed 02 	lds	r27, 0x02ED
    3e4a:	a2 0f       	add	r26, r18
    3e4c:	b3 1f       	adc	r27, r19
    3e4e:	ec 91       	ld	r30, X
    3e50:	11 96       	adiw	r26, 0x01	; 1
    3e52:	fc 91       	ld	r31, X
    3e54:	df 01       	movw	r26, r30
    3e56:	0d 90       	ld	r0, X+
    3e58:	00 20       	and	r0, r0
    3e5a:	e9 f7       	brne	.-6      	; 0x3e56 <changeDisplayMenu+0x8c>
    3e5c:	11 97       	sbiw	r26, 0x01	; 1
    3e5e:	ae 1b       	sub	r26, r30
    3e60:	bf 0b       	sbc	r27, r31
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
    3e62:	a0 31       	cpi	r26, 0x10	; 16
    3e64:	80 f4       	brcc	.+32     	; 0x3e86 <changeDisplayMenu+0xbc>
    3e66:	8a 2f       	mov	r24, r26
      menu.newMenuText[j][k] = ' ';
    3e68:	e0 91 ec 02 	lds	r30, 0x02EC
    3e6c:	f0 91 ed 02 	lds	r31, 0x02ED
    3e70:	e2 0f       	add	r30, r18
    3e72:	f3 1f       	adc	r31, r19
    3e74:	01 90       	ld	r0, Z+
    3e76:	f0 81       	ld	r31, Z
    3e78:	e0 2d       	mov	r30, r0
    3e7a:	e8 0f       	add	r30, r24
    3e7c:	f1 1d       	adc	r31, r1
    3e7e:	90 83       	st	Z, r25
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
    3e80:	8f 5f       	subi	r24, 0xFF	; 255
    3e82:	80 31       	cpi	r24, 0x10	; 16
    3e84:	88 f3       	brcs	.-30     	; 0x3e68 <changeDisplayMenu+0x9e>
      menu.newMenuText[j][k] = ' ';
    }
    menu.newMenuText[j][DISPLAY_MENU_STRING_LENGTH-1] = '\0';
    3e86:	e0 91 ec 02 	lds	r30, 0x02EC
    3e8a:	f0 91 ed 02 	lds	r31, 0x02ED
    3e8e:	e2 0f       	add	r30, r18
    3e90:	f3 1f       	adc	r31, r19
    3e92:	01 90       	ld	r0, Z+
    3e94:	f0 81       	ld	r31, Z
    3e96:	e0 2d       	mov	r30, r0
    3e98:	10 8a       	std	Z+16, r1	; 0x10
    3e9a:	2e 5f       	subi	r18, 0xFE	; 254
    3e9c:	3f 4f       	sbci	r19, 0xFF	; 255
  strcpy(menu.newMenuText[0], displayBuffer);
  displayBuffer = strtok(NULL, "\0");
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    3e9e:	24 30       	cpi	r18, 0x04	; 4
    3ea0:	31 05       	cpc	r19, r1
    3ea2:	79 f6       	brne	.-98     	; 0x3e42 <changeDisplayMenu+0x78>
    }
    menu.newMenuText[j][DISPLAY_MENU_STRING_LENGTH-1] = '\0';
  }

  return;
}
    3ea4:	08 95       	ret

00003ea6 <parseCommand>:
}

/* ---------------------------------------------------------------------
    returns the command code and fills the parameter list
 --------------------------------------------------------------------- */
uint8_t parseCommand(void){
    3ea6:	af 92       	push	r10
    3ea8:	bf 92       	push	r11
    3eaa:	cf 92       	push	r12
    3eac:	df 92       	push	r13
    3eae:	ef 92       	push	r14
    3eb0:	ff 92       	push	r15
    3eb2:	0f 93       	push	r16
    3eb4:	1f 93       	push	r17
    3eb6:	cf 93       	push	r28
    3eb8:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    3eba:	f8 94       	cli
  //uint8_t j = 0;
  command *cmdPtr;
  char *token;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
    3ebc:	80 91 92 04 	lds	r24, 0x0492
    3ec0:	88 23       	and	r24, r24
    3ec2:	79 f4       	brne	.+30     	; 0x3ee2 <parseCommand+0x3c>
    3ec4:	b0 e8       	ldi	r27, 0x80	; 128
    3ec6:	ab 2e       	mov	r10, r27
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    3ec8:	78 94       	sei
      commandString.readyToProcess = 0;
    }
  }

  return commandCode;
}
    3eca:	8a 2d       	mov	r24, r10
    3ecc:	df 91       	pop	r29
    3ece:	cf 91       	pop	r28
    3ed0:	1f 91       	pop	r17
    3ed2:	0f 91       	pop	r16
    3ed4:	ff 90       	pop	r15
    3ed6:	ef 90       	pop	r14
    3ed8:	df 90       	pop	r13
    3eda:	cf 90       	pop	r12
    3edc:	bf 90       	pop	r11
    3ede:	af 90       	pop	r10
    3ee0:	08 95       	ret
  char *token;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
      /* extract command and get cmdCode */
      token = strtok(commandString.buffer, ALLOWED_CMD_DELIMITERS);
    3ee2:	80 91 90 04 	lds	r24, 0x0490
    3ee6:	90 91 91 04 	lds	r25, 0x0491
    3eea:	60 e3       	ldi	r22, 0x30	; 48
    3eec:	72 e0       	ldi	r23, 0x02	; 2
    3eee:	0e 94 36 45 	call	0x8a6c	; 0x8a6c <strtok>
    3ef2:	6c 01       	movw	r12, r24
    3ef4:	0a e0       	ldi	r16, 0x0A	; 10
    3ef6:	13 e0       	ldi	r17, 0x03	; 3
    3ef8:	a0 e8       	ldi	r26, 0x80	; 128
    3efa:	aa 2e       	mov	r10, r26
    3efc:	bb 24       	eor	r11, r11
    3efe:	e0 90 d6 02 	lds	r14, 0x02D6
    3f02:	f0 90 d7 02 	lds	r15, 0x02D7

      for(i = 0; i < TOTAL_NUMBER_OF_COMMANDS; i++){            /* loop over all commands */
        cmdPtr = (command*)pgm_read_word(&commandList[i]);      /* pointer to struct in flash */
    3f06:	f8 01       	movw	r30, r16
    3f08:	c5 91       	lpm	r28, Z+
    3f0a:	d4 91       	lpm	r29, Z+
        strcpy_P(commandParam[0], pgm_read_word(&cmdPtr->cmd)); /* contents of command code in flash */
    3f0c:	fe 01       	movw	r30, r28
    3f0e:	65 91       	lpm	r22, Z+
    3f10:	74 91       	lpm	r23, Z+
    3f12:	d7 01       	movw	r26, r14
    3f14:	8d 91       	ld	r24, X+
    3f16:	9c 91       	ld	r25, X
    3f18:	0e 94 24 45 	call	0x8a48	; 0x8a48 <strcpy_P>

        if(strcmp(token, commandParam[0]) == 0){
    3f1c:	e0 90 d6 02 	lds	r14, 0x02D6
    3f20:	f0 90 d7 02 	lds	r15, 0x02D7
    3f24:	f7 01       	movw	r30, r14
    3f26:	60 81       	ld	r22, Z
    3f28:	71 81       	ldd	r23, Z+1	; 0x01
    3f2a:	c6 01       	movw	r24, r12
    3f2c:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    3f30:	00 97       	sbiw	r24, 0x00	; 0
    3f32:	41 f4       	brne	.+16     	; 0x3f44 <parseCommand+0x9e>
          /* found a known command */
          commandCode = (uint8_t)pgm_read_byte(&cmdPtr->cmdCode);
    3f34:	23 96       	adiw	r28, 0x03	; 3
    3f36:	fe 01       	movw	r30, r28
    3f38:	94 91       	lpm	r25, Z+
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
    3f3a:	21 97       	sbiw	r28, 0x01	; 1
    3f3c:	fe 01       	movw	r30, r28
    3f3e:	84 91       	lpm	r24, Z+
    3f40:	a9 2e       	mov	r10, r25
    3f42:	b8 2e       	mov	r11, r24
    3f44:	0e 5f       	subi	r16, 0xFE	; 254
    3f46:	1f 4f       	sbci	r17, 0xFF	; 255
  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
      /* extract command and get cmdCode */
      token = strtok(commandString.buffer, ALLOWED_CMD_DELIMITERS);

      for(i = 0; i < TOTAL_NUMBER_OF_COMMANDS; i++){            /* loop over all commands */
    3f48:	f3 e0       	ldi	r31, 0x03	; 3
    3f4a:	04 35       	cpi	r16, 0x54	; 84
    3f4c:	1f 07       	cpc	r17, r31
    3f4e:	d9 f6       	brne	.-74     	; 0x3f06 <parseCommand+0x60>
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
        }
      }

      /* now parse the command parameters into tokens */
      for(i = 1; i <= noOfOpts; i++){
    3f50:	bb 20       	and	r11, r11
    3f52:	c9 f0       	breq	.+50     	; 0x3f86 <parseCommand+0xe0>
    3f54:	11 e0       	ldi	r17, 0x01	; 1
        token = strtok(NULL, ALLOWED_CMD_DELIMITERS);
    3f56:	80 e0       	ldi	r24, 0x00	; 0
    3f58:	90 e0       	ldi	r25, 0x00	; 0
    3f5a:	60 e3       	ldi	r22, 0x30	; 48
    3f5c:	72 e0       	ldi	r23, 0x02	; 2
    3f5e:	0e 94 36 45 	call	0x8a6c	; 0x8a6c <strtok>
    3f62:	bc 01       	movw	r22, r24
        strcpy(commandParam[i], token);
    3f64:	81 2f       	mov	r24, r17
    3f66:	90 e0       	ldi	r25, 0x00	; 0
    3f68:	88 0f       	add	r24, r24
    3f6a:	99 1f       	adc	r25, r25
    3f6c:	e0 91 d6 02 	lds	r30, 0x02D6
    3f70:	f0 91 d7 02 	lds	r31, 0x02D7
    3f74:	e8 0f       	add	r30, r24
    3f76:	f9 1f       	adc	r31, r25
    3f78:	80 81       	ld	r24, Z
    3f7a:	91 81       	ldd	r25, Z+1	; 0x01
    3f7c:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
        }
      }

      /* now parse the command parameters into tokens */
      for(i = 1; i <= noOfOpts; i++){
    3f80:	1f 5f       	subi	r17, 0xFF	; 255
    3f82:	b1 16       	cp	r11, r17
    3f84:	40 f7       	brcc	.-48     	; 0x3f56 <parseCommand+0xb0>
        token = strtok(NULL, ALLOWED_CMD_DELIMITERS);
        strcpy(commandParam[i], token);
      }

      memset(commandString.buffer, 0, SERIAL_BUFFERSIZE);
    3f86:	e0 91 90 04 	lds	r30, 0x0490
    3f8a:	f0 91 91 04 	lds	r31, 0x0491
    3f8e:	80 e4       	ldi	r24, 0x40	; 64
    3f90:	df 01       	movw	r26, r30
    3f92:	1d 92       	st	X+, r1
    3f94:	8a 95       	dec	r24
    3f96:	e9 f7       	brne	.-6      	; 0x3f92 <parseCommand+0xec>
      commandString.readyToProcess = 0;
    3f98:	10 92 92 04 	sts	0x0492, r1
    3f9c:	95 cf       	rjmp	.-214    	; 0x3ec8 <parseCommand+0x22>

00003f9e <sendText>:
}

/* ---------------------------------------------------------------------
    sends a terminated string via RS232
 --------------------------------------------------------------------- */
void sendText(char *c){
    3f9e:	fc 01       	movw	r30, r24

  while(*c){
    3fa0:	90 81       	ld	r25, Z
    3fa2:	99 23       	and	r25, r25
    3fa4:	51 f0       	breq	.+20     	; 0x3fba <sendText+0x1c>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    3fa6:	80 91 c0 00 	lds	r24, 0x00C0
    3faa:	85 ff       	sbrs	r24, 5
    3fac:	fc cf       	rjmp	.-8      	; 0x3fa6 <sendText+0x8>
    ;
  }

  UDR0 = c;
    3fae:	90 93 c6 00 	sts	0x00C6, r25
 --------------------------------------------------------------------- */
void sendText(char *c){

  while(*c){
    sendChar(*c);
    c++;
    3fb2:	31 96       	adiw	r30, 0x01	; 1
/* ---------------------------------------------------------------------
    sends a terminated string via RS232
 --------------------------------------------------------------------- */
void sendText(char *c){

  while(*c){
    3fb4:	90 81       	ld	r25, Z
    3fb6:	99 23       	and	r25, r25
    3fb8:	b1 f7       	brne	.-20     	; 0x3fa6 <sendText+0x8>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    3fba:	80 91 c0 00 	lds	r24, 0x00C0
    3fbe:	85 ff       	sbrs	r24, 5
    3fc0:	fc cf       	rjmp	.-8      	; 0x3fba <sendText+0x1c>
    ;
  }

  UDR0 = c;
    3fc2:	8a e0       	ldi	r24, 0x0A	; 10
    3fc4:	80 93 c6 00 	sts	0x00C6, r24
    c++;
  }
  /* send LF after finishing text sending */
  sendChar('\n');

  memset(txString.buffer, 0, SERIAL_BUFFERSIZE);
    3fc8:	e0 91 e7 03 	lds	r30, 0x03E7
    3fcc:	f0 91 e8 03 	lds	r31, 0x03E8
    3fd0:	80 e4       	ldi	r24, 0x40	; 64
    3fd2:	df 01       	movw	r26, r30
    3fd4:	1d 92       	st	X+, r1
    3fd6:	8a 95       	dec	r24
    3fd8:	e9 f7       	brne	.-6      	; 0x3fd4 <sendText+0x36>

  return;
}
    3fda:	08 95       	ret

00003fdc <commandLED>:


/* ---------------------------------------------------------------------
    debugging output for anything we'd like to know
 --------------------------------------------------------------------- */
void commandLED(char* param0, char* param1, char* param2){
    3fdc:	df 92       	push	r13
    3fde:	ef 92       	push	r14
    3fe0:	ff 92       	push	r15
    3fe2:	0f 93       	push	r16
    3fe4:	1f 93       	push	r17
    3fe6:	8b 01       	movw	r16, r22
    3fe8:	7a 01       	movw	r14, r20

  uint8_t a, b, c;

  a = (uint8_t)strtol(param0, (char **)NULL, 10);
    3fea:	60 e0       	ldi	r22, 0x00	; 0
    3fec:	70 e0       	ldi	r23, 0x00	; 0
    3fee:	4a e0       	ldi	r20, 0x0A	; 10
    3ff0:	50 e0       	ldi	r21, 0x00	; 0
    3ff2:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    3ff6:	d6 2e       	mov	r13, r22
  b = (uint8_t)strtol(param1, (char **)NULL, 10);
    3ff8:	c8 01       	movw	r24, r16
    3ffa:	60 e0       	ldi	r22, 0x00	; 0
    3ffc:	70 e0       	ldi	r23, 0x00	; 0
    3ffe:	4a e0       	ldi	r20, 0x0A	; 10
    4000:	50 e0       	ldi	r21, 0x00	; 0
    4002:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4006:	06 2f       	mov	r16, r22
  c = (uint8_t)strtol(param2, (char **)NULL, 16);
    4008:	c7 01       	movw	r24, r14
    400a:	60 e0       	ldi	r22, 0x00	; 0
    400c:	70 e0       	ldi	r23, 0x00	; 0
    400e:	40 e1       	ldi	r20, 0x10	; 16
    4010:	50 e0       	ldi	r21, 0x00	; 0
    4012:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4016:	16 2f       	mov	r17, r22
  
  sprintf(txString.buffer, "\na=%d\nb=%d\nc=%d", a, b, c);
    4018:	80 91 e7 03 	lds	r24, 0x03E7
    401c:	90 91 e8 03 	lds	r25, 0x03E8
    4020:	2d b7       	in	r18, 0x3d	; 61
    4022:	3e b7       	in	r19, 0x3e	; 62
    4024:	2a 50       	subi	r18, 0x0A	; 10
    4026:	30 40       	sbci	r19, 0x00	; 0
    4028:	0f b6       	in	r0, 0x3f	; 63
    402a:	f8 94       	cli
    402c:	3e bf       	out	0x3e, r19	; 62
    402e:	0f be       	out	0x3f, r0	; 63
    4030:	2d bf       	out	0x3d, r18	; 61
    4032:	ed b7       	in	r30, 0x3d	; 61
    4034:	fe b7       	in	r31, 0x3e	; 62
    4036:	31 96       	adiw	r30, 0x01	; 1
    4038:	ad b7       	in	r26, 0x3d	; 61
    403a:	be b7       	in	r27, 0x3e	; 62
    403c:	12 96       	adiw	r26, 0x02	; 2
    403e:	9c 93       	st	X, r25
    4040:	8e 93       	st	-X, r24
    4042:	11 97       	sbiw	r26, 0x01	; 1
    4044:	85 e3       	ldi	r24, 0x35	; 53
    4046:	92 e0       	ldi	r25, 0x02	; 2
    4048:	93 83       	std	Z+3, r25	; 0x03
    404a:	82 83       	std	Z+2, r24	; 0x02
    404c:	d4 82       	std	Z+4, r13	; 0x04
    404e:	15 82       	std	Z+5, r1	; 0x05
    4050:	06 83       	std	Z+6, r16	; 0x06
    4052:	17 82       	std	Z+7, r1	; 0x07
    4054:	10 87       	std	Z+8, r17	; 0x08
    4056:	11 86       	std	Z+9, r1	; 0x09
    4058:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
  sendText(txString.buffer);
    405c:	80 91 e7 03 	lds	r24, 0x03E7
    4060:	90 91 e8 03 	lds	r25, 0x03E8
    4064:	2d b7       	in	r18, 0x3d	; 61
    4066:	3e b7       	in	r19, 0x3e	; 62
    4068:	26 5f       	subi	r18, 0xF6	; 246
    406a:	3f 4f       	sbci	r19, 0xFF	; 255
    406c:	0f b6       	in	r0, 0x3f	; 63
    406e:	f8 94       	cli
    4070:	3e bf       	out	0x3e, r19	; 62
    4072:	0f be       	out	0x3f, r0	; 63
    4074:	2d bf       	out	0x3d, r18	; 61
    4076:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>

  changeButtonLED(a, b, c);
    407a:	8d 2d       	mov	r24, r13
    407c:	60 2f       	mov	r22, r16
    407e:	41 2f       	mov	r20, r17
    4080:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
  updateLEDs();
    4084:	0e 94 2c 07 	call	0xe58	; 0xe58 <updateLEDs>
  
  return;
}
    4088:	1f 91       	pop	r17
    408a:	0f 91       	pop	r16
    408c:	ff 90       	pop	r15
    408e:	ef 90       	pop	r14
    4090:	df 90       	pop	r13
    4092:	08 95       	ret

00004094 <commandDebugReadout>:
}

/* ---------------------------------------------------------------------
    debugging output for anything we'd like to know
 --------------------------------------------------------------------- */
void commandDebugReadout(){
    4094:	af 92       	push	r10
    4096:	bf 92       	push	r11
    4098:	cf 92       	push	r12
    409a:	df 92       	push	r13
    409c:	ef 92       	push	r14
    409e:	ff 92       	push	r15
    40a0:	0f 93       	push	r16
    40a2:	1f 93       	push	r17
    40a4:	cf 93       	push	r28
    40a6:	df 93       	push	r29
    40a8:	c0 e0       	ldi	r28, 0x00	; 0
    40aa:	d0 e0       	ldi	r29, 0x00	; 0
    40ac:	75 e4       	ldi	r23, 0x45	; 69
    40ae:	c7 2e       	mov	r12, r23
    40b0:	72 e0       	ldi	r23, 0x02	; 2
    40b2:	d7 2e       	mov	r13, r23

  uint8_t i = 0;

  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    sprintf(txString.buffer, "%d %d %d %d %d %d %d", i, programList[i].position[0],
    40b4:	e0 90 e7 03 	lds	r14, 0x03E7
    40b8:	f0 90 e8 03 	lds	r15, 0x03E8
    40bc:	ce 01       	movw	r24, r28
    40be:	fe 01       	movw	r30, r28
    40c0:	ee 0f       	add	r30, r30
    40c2:	ff 1f       	adc	r31, r31
    40c4:	ee 0f       	add	r30, r30
    40c6:	ff 1f       	adc	r31, r31
    40c8:	ee 0f       	add	r30, r30
    40ca:	ff 1f       	adc	r31, r31
    40cc:	88 0f       	add	r24, r24
    40ce:	99 1f       	adc	r25, r25
    40d0:	e8 0f       	add	r30, r24
    40d2:	f9 1f       	adc	r31, r25
    40d4:	ed 50       	subi	r30, 0x0D	; 13
    40d6:	fd 4f       	sbci	r31, 0xFD	; 253
    40d8:	01 81       	ldd	r16, Z+1	; 0x01
    40da:	12 81       	ldd	r17, Z+2	; 0x02
    40dc:	ce 01       	movw	r24, r28
    40de:	fe 01       	movw	r30, r28
    40e0:	ee 0f       	add	r30, r30
    40e2:	ff 1f       	adc	r31, r31
    40e4:	ee 0f       	add	r30, r30
    40e6:	ff 1f       	adc	r31, r31
    40e8:	ee 0f       	add	r30, r30
    40ea:	ff 1f       	adc	r31, r31
    40ec:	88 0f       	add	r24, r24
    40ee:	99 1f       	adc	r25, r25
    40f0:	e8 0f       	add	r30, r24
    40f2:	f9 1f       	adc	r31, r25
    40f4:	ed 50       	subi	r30, 0x0D	; 13
    40f6:	fd 4f       	sbci	r31, 0xFD	; 253
    40f8:	a3 80       	ldd	r10, Z+3	; 0x03
    40fa:	b4 80       	ldd	r11, Z+4	; 0x04
    40fc:	ce 01       	movw	r24, r28
    40fe:	fe 01       	movw	r30, r28
    4100:	ee 0f       	add	r30, r30
    4102:	ff 1f       	adc	r31, r31
    4104:	ee 0f       	add	r30, r30
    4106:	ff 1f       	adc	r31, r31
    4108:	ee 0f       	add	r30, r30
    410a:	ff 1f       	adc	r31, r31
    410c:	88 0f       	add	r24, r24
    410e:	99 1f       	adc	r25, r25
    4110:	e8 0f       	add	r30, r24
    4112:	f9 1f       	adc	r31, r25
    4114:	ed 50       	subi	r30, 0x0D	; 13
    4116:	fd 4f       	sbci	r31, 0xFD	; 253
    4118:	45 81       	ldd	r20, Z+5	; 0x05
    411a:	56 81       	ldd	r21, Z+6	; 0x06
    411c:	ce 01       	movw	r24, r28
    411e:	fe 01       	movw	r30, r28
    4120:	ee 0f       	add	r30, r30
    4122:	ff 1f       	adc	r31, r31
    4124:	ee 0f       	add	r30, r30
    4126:	ff 1f       	adc	r31, r31
    4128:	ee 0f       	add	r30, r30
    412a:	ff 1f       	adc	r31, r31
    412c:	88 0f       	add	r24, r24
    412e:	99 1f       	adc	r25, r25
    4130:	e8 0f       	add	r30, r24
    4132:	f9 1f       	adc	r31, r25
    4134:	ed 50       	subi	r30, 0x0D	; 13
    4136:	fd 4f       	sbci	r31, 0xFD	; 253
    4138:	27 81       	ldd	r18, Z+7	; 0x07
    413a:	30 85       	ldd	r19, Z+8	; 0x08
    413c:	ce 01       	movw	r24, r28
    413e:	fe 01       	movw	r30, r28
    4140:	ee 0f       	add	r30, r30
    4142:	ff 1f       	adc	r31, r31
    4144:	ee 0f       	add	r30, r30
    4146:	ff 1f       	adc	r31, r31
    4148:	ee 0f       	add	r30, r30
    414a:	ff 1f       	adc	r31, r31
    414c:	88 0f       	add	r24, r24
    414e:	99 1f       	adc	r25, r25
    4150:	e8 0f       	add	r30, r24
    4152:	f9 1f       	adc	r31, r25
    4154:	ed 50       	subi	r30, 0x0D	; 13
    4156:	fd 4f       	sbci	r31, 0xFD	; 253
    4158:	61 85       	ldd	r22, Z+9	; 0x09
    415a:	ce 01       	movw	r24, r28
    415c:	fe 01       	movw	r30, r28
    415e:	ee 0f       	add	r30, r30
    4160:	ff 1f       	adc	r31, r31
    4162:	ee 0f       	add	r30, r30
    4164:	ff 1f       	adc	r31, r31
    4166:	ee 0f       	add	r30, r30
    4168:	ff 1f       	adc	r31, r31
    416a:	88 0f       	add	r24, r24
    416c:	99 1f       	adc	r25, r25
    416e:	e8 0f       	add	r30, r24
    4170:	f9 1f       	adc	r31, r25
    4172:	ed 50       	subi	r30, 0x0D	; 13
    4174:	fd 4f       	sbci	r31, 0xFD	; 253
    4176:	80 81       	ld	r24, Z
    4178:	ad b7       	in	r26, 0x3d	; 61
    417a:	be b7       	in	r27, 0x3e	; 62
    417c:	52 97       	sbiw	r26, 0x12	; 18
    417e:	0f b6       	in	r0, 0x3f	; 63
    4180:	f8 94       	cli
    4182:	be bf       	out	0x3e, r27	; 62
    4184:	0f be       	out	0x3f, r0	; 63
    4186:	ad bf       	out	0x3d, r26	; 61
    4188:	ed b7       	in	r30, 0x3d	; 61
    418a:	fe b7       	in	r31, 0x3e	; 62
    418c:	31 96       	adiw	r30, 0x01	; 1
    418e:	12 96       	adiw	r26, 0x02	; 2
    4190:	fc 92       	st	X, r15
    4192:	ee 92       	st	-X, r14
    4194:	11 97       	sbiw	r26, 0x01	; 1
    4196:	d3 82       	std	Z+3, r13	; 0x03
    4198:	c2 82       	std	Z+2, r12	; 0x02
    419a:	c4 83       	std	Z+4, r28	; 0x04
    419c:	d5 83       	std	Z+5, r29	; 0x05
    419e:	17 83       	std	Z+7, r17	; 0x07
    41a0:	06 83       	std	Z+6, r16	; 0x06
    41a2:	b1 86       	std	Z+9, r11	; 0x09
    41a4:	a0 86       	std	Z+8, r10	; 0x08
    41a6:	53 87       	std	Z+11, r21	; 0x0b
    41a8:	42 87       	std	Z+10, r20	; 0x0a
    41aa:	35 87       	std	Z+13, r19	; 0x0d
    41ac:	24 87       	std	Z+12, r18	; 0x0c
    41ae:	66 87       	std	Z+14, r22	; 0x0e
    41b0:	17 86       	std	Z+15, r1	; 0x0f
    41b2:	80 8b       	std	Z+16, r24	; 0x10
    41b4:	11 8a       	std	Z+17, r1	; 0x11
    41b6:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
                                                        programList[i].position[1],
                                                        programList[i].position[2],
                                                        programList[i].position[3],
                                                        programList[i].absRel,
                                                        programList[i].isActive);
    sendText(txString.buffer);
    41ba:	80 91 e7 03 	lds	r24, 0x03E7
    41be:	90 91 e8 03 	lds	r25, 0x03E8
    41c2:	ed b7       	in	r30, 0x3d	; 61
    41c4:	fe b7       	in	r31, 0x3e	; 62
    41c6:	72 96       	adiw	r30, 0x12	; 18
    41c8:	0f b6       	in	r0, 0x3f	; 63
    41ca:	f8 94       	cli
    41cc:	fe bf       	out	0x3e, r31	; 62
    41ce:	0f be       	out	0x3f, r0	; 63
    41d0:	ed bf       	out	0x3d, r30	; 61
    41d2:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    41d6:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void commandDebugReadout(){

  uint8_t i = 0;

  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    41d8:	c0 31       	cpi	r28, 0x10	; 16
    41da:	d1 05       	cpc	r29, r1
    41dc:	09 f0       	breq	.+2      	; 0x41e0 <__stack+0xe1>
    41de:	6a cf       	rjmp	.-300    	; 0x40b4 <commandDebugReadout+0x20>
                                                        programList[i].isActive);
    sendText(txString.buffer);
  }

  return;
}
    41e0:	df 91       	pop	r29
    41e2:	cf 91       	pop	r28
    41e4:	1f 91       	pop	r17
    41e6:	0f 91       	pop	r16
    41e8:	ff 90       	pop	r15
    41ea:	ef 90       	pop	r14
    41ec:	df 90       	pop	r13
    41ee:	cf 90       	pop	r12
    41f0:	bf 90       	pop	r11
    41f2:	af 90       	pop	r10
    41f4:	08 95       	ret

000041f6 <commandGetMotorState>:
void commandGetMotorState(char* param0){

  uint8_t i = 0;
  //uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    41f6:	60 e0       	ldi	r22, 0x00	; 0
    41f8:	70 e0       	ldi	r23, 0x00	; 0
    41fa:	4a e0       	ldi	r20, 0x0A	; 10
    41fc:	50 e0       	ldi	r21, 0x00	; 0
    41fe:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    4202:	64 30       	cpi	r22, 0x04	; 4
    4204:	90 f5       	brcc	.+100    	; 0x426a <commandGetMotorState+0x74>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    if(motor[i].isTurnedOn){
    4206:	e6 2f       	mov	r30, r22
    4208:	f0 e0       	ldi	r31, 0x00	; 0
    420a:	ee 0f       	add	r30, r30
    420c:	ff 1f       	adc	r31, r31
    420e:	ee 0f       	add	r30, r30
    4210:	ff 1f       	adc	r31, r31
    4212:	ee 0f       	add	r30, r30
    4214:	ff 1f       	adc	r31, r31
    4216:	cf 01       	movw	r24, r30
    4218:	88 0f       	add	r24, r24
    421a:	99 1f       	adc	r25, r25
    421c:	88 0f       	add	r24, r24
    421e:	99 1f       	adc	r25, r25
    4220:	e8 0f       	add	r30, r24
    4222:	f9 1f       	adc	r31, r25
    4224:	e0 51       	subi	r30, 0x10	; 16
    4226:	fc 4f       	sbci	r31, 0xFC	; 252
    4228:	83 85       	ldd	r24, Z+11	; 0x0b
    422a:	88 23       	and	r24, r24
    422c:	79 f4       	brne	.+30     	; 0x424c <commandGetMotorState+0x56>
      sprintf(txString.buffer, "1");
    }
    else{
      sprintf(txString.buffer, "0");
    422e:	e0 91 e7 03 	lds	r30, 0x03E7
    4232:	f0 91 e8 03 	lds	r31, 0x03E8
    4236:	80 e3       	ldi	r24, 0x30	; 48
    4238:	90 e0       	ldi	r25, 0x00	; 0
    423a:	91 83       	std	Z+1, r25	; 0x01
    423c:	80 83       	st	Z, r24
    }

    sendText(txString.buffer);
    423e:	80 91 e7 03 	lds	r24, 0x03E7
    4242:	90 91 e8 03 	lds	r25, 0x03E8
    4246:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    424a:	08 95       	ret
    sendText(txString.buffer);
    return;
  }
  else{
    if(motor[i].isTurnedOn){
      sprintf(txString.buffer, "1");
    424c:	e0 91 e7 03 	lds	r30, 0x03E7
    4250:	f0 91 e8 03 	lds	r31, 0x03E8
    4254:	81 e3       	ldi	r24, 0x31	; 49
    4256:	90 e0       	ldi	r25, 0x00	; 0
    4258:	91 83       	std	Z+1, r25	; 0x01
    425a:	80 83       	st	Z, r24
    }
    else{
      sprintf(txString.buffer, "0");
    }

    sendText(txString.buffer);
    425c:	80 91 e7 03 	lds	r24, 0x03E7
    4260:	90 91 e8 03 	lds	r25, 0x03E8
    4264:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    4268:	08 95       	ret
  //uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    426a:	a0 91 e7 03 	lds	r26, 0x03E7
    426e:	b0 91 e8 03 	lds	r27, 0x03E8
    4272:	ea e5       	ldi	r30, 0x5A	; 90
    4274:	f2 e0       	ldi	r31, 0x02	; 2
    4276:	83 e1       	ldi	r24, 0x13	; 19
    4278:	01 90       	ld	r0, Z+
    427a:	0d 92       	st	X+, r0
    427c:	81 50       	subi	r24, 0x01	; 1
    427e:	e1 f7       	brne	.-8      	; 0x4278 <commandGetMotorState+0x82>
    4280:	de cf       	rjmp	.-68     	; 0x423e <commandGetMotorState+0x48>

00004282 <commandEnableForbiddenZone>:
}

/* ---------------------------------------------------------------------
    enable/disable forbidden zone
 --------------------------------------------------------------------- */
void commandEnableForbiddenZone(char* param0, char* param1){
    4282:	1f 93       	push	r17
    4284:	cf 93       	push	r28
    4286:	df 93       	push	r29
    4288:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    428a:	60 e0       	ldi	r22, 0x00	; 0
    428c:	70 e0       	ldi	r23, 0x00	; 0
    428e:	4a e0       	ldi	r20, 0x0A	; 10
    4290:	50 e0       	ldi	r21, 0x00	; 0
    4292:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4296:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4298:	64 30       	cpi	r22, 0x04	; 4
    429a:	b8 f4       	brcc	.+46     	; 0x42ca <commandEnableForbiddenZone+0x48>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    val = (uint8_t)strtol(param1, (char **)NULL, 10);
    429c:	ce 01       	movw	r24, r28
    429e:	60 e0       	ldi	r22, 0x00	; 0
    42a0:	70 e0       	ldi	r23, 0x00	; 0
    42a2:	4a e0       	ldi	r20, 0x0A	; 10
    42a4:	50 e0       	ldi	r21, 0x00	; 0
    42a6:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    forbiddenZone[i].active = val;
    42aa:	81 2f       	mov	r24, r17
    42ac:	90 e0       	ldi	r25, 0x00	; 0
    42ae:	fc 01       	movw	r30, r24
    42b0:	ee 0f       	add	r30, r30
    42b2:	ff 1f       	adc	r31, r31
    42b4:	ee 0f       	add	r30, r30
    42b6:	ff 1f       	adc	r31, r31
    42b8:	e8 0f       	add	r30, r24
    42ba:	f9 1f       	adc	r31, r25
    42bc:	ed 52       	subi	r30, 0x2D	; 45
    42be:	fc 4f       	sbci	r31, 0xFC	; 252
    42c0:	64 83       	std	Z+4, r22	; 0x04
  }

  return;
}
    42c2:	df 91       	pop	r29
    42c4:	cf 91       	pop	r28
    42c6:	1f 91       	pop	r17
    42c8:	08 95       	ret
  uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    42ca:	a0 91 e7 03 	lds	r26, 0x03E7
    42ce:	b0 91 e8 03 	lds	r27, 0x03E8
    42d2:	ea e5       	ldi	r30, 0x5A	; 90
    42d4:	f2 e0       	ldi	r31, 0x02	; 2
    42d6:	83 e1       	ldi	r24, 0x13	; 19
    42d8:	01 90       	ld	r0, Z+
    42da:	0d 92       	st	X+, r0
    42dc:	81 50       	subi	r24, 0x01	; 1
    42de:	e1 f7       	brne	.-8      	; 0x42d8 <commandEnableForbiddenZone+0x56>
    sendText(txString.buffer);
    42e0:	80 91 e7 03 	lds	r24, 0x03E7
    42e4:	90 91 e8 03 	lds	r25, 0x03E8
    42e8:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    42ec:	ea cf       	rjmp	.-44     	; 0x42c2 <commandEnableForbiddenZone+0x40>

000042ee <commandSetForbiddenZone>:
}

/* ---------------------------------------------------------------------
    defines forbidden zone
 --------------------------------------------------------------------- */
void commandSetForbiddenZone(char* param0, char* param1, char* param2){
    42ee:	ff 92       	push	r15
    42f0:	0f 93       	push	r16
    42f2:	1f 93       	push	r17
    42f4:	cf 93       	push	r28
    42f6:	df 93       	push	r29
    42f8:	eb 01       	movw	r28, r22
    42fa:	8a 01       	movw	r16, r20
  uint8_t i = 0;
  int16_t start = 0;
  int16_t stop  = 0;
  int16_t swap = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    42fc:	60 e0       	ldi	r22, 0x00	; 0
    42fe:	70 e0       	ldi	r23, 0x00	; 0
    4300:	4a e0       	ldi	r20, 0x0A	; 10
    4302:	50 e0       	ldi	r21, 0x00	; 0
    4304:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4308:	f6 2e       	mov	r15, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    430a:	83 e0       	ldi	r24, 0x03	; 3
    430c:	8f 15       	cp	r24, r15
    430e:	28 f1       	brcs	.+74     	; 0x435a <commandSetForbiddenZone+0x6c>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    start = (int16_t)atoi(param1);
    4310:	ce 01       	movw	r24, r28
    4312:	0e 94 26 44 	call	0x884c	; 0x884c <atoi>
    4316:	ec 01       	movw	r28, r24
    stop  = (int16_t)atoi(param2);
    4318:	c8 01       	movw	r24, r16
    431a:	0e 94 26 44 	call	0x884c	; 0x884c <atoi>
    431e:	ac 01       	movw	r20, r24

    if(start == stop){
    4320:	c8 17       	cp	r28, r24
    4322:	d9 07       	cpc	r29, r25
    4324:	79 f1       	breq	.+94     	; 0x4384 <commandSetForbiddenZone+0x96>
      forbiddenZone[i].stop   = 0;
      forbiddenZone[i].active = 0;
      return;
    }

    if(start > stop){
    4326:	8c 17       	cp	r24, r28
    4328:	9d 07       	cpc	r25, r29
    432a:	4c f1       	brlt	.+82     	; 0x437e <commandSetForbiddenZone+0x90>
      swap = stop;
      stop = start;
      start = swap;
    }

    forbiddenZone[i].start  = start;
    432c:	8f 2d       	mov	r24, r15
    432e:	90 e0       	ldi	r25, 0x00	; 0
    4330:	fc 01       	movw	r30, r24
    4332:	ee 0f       	add	r30, r30
    4334:	ff 1f       	adc	r31, r31
    4336:	ee 0f       	add	r30, r30
    4338:	ff 1f       	adc	r31, r31
    433a:	e8 0f       	add	r30, r24
    433c:	f9 1f       	adc	r31, r25
    433e:	ed 52       	subi	r30, 0x2D	; 45
    4340:	fc 4f       	sbci	r31, 0xFC	; 252
    4342:	d1 83       	std	Z+1, r29	; 0x01
    4344:	c0 83       	st	Z, r28
    forbiddenZone[i].stop   = stop;
    4346:	53 83       	std	Z+3, r21	; 0x03
    4348:	42 83       	std	Z+2, r20	; 0x02
    forbiddenZone[i].active = 1;
    434a:	81 e0       	ldi	r24, 0x01	; 1
    434c:	84 83       	std	Z+4, r24	; 0x04
  }

  return;
}
    434e:	df 91       	pop	r29
    4350:	cf 91       	pop	r28
    4352:	1f 91       	pop	r17
    4354:	0f 91       	pop	r16
    4356:	ff 90       	pop	r15
    4358:	08 95       	ret
  int16_t swap = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    435a:	a0 91 e7 03 	lds	r26, 0x03E7
    435e:	b0 91 e8 03 	lds	r27, 0x03E8
    4362:	ea e5       	ldi	r30, 0x5A	; 90
    4364:	f2 e0       	ldi	r31, 0x02	; 2
    4366:	83 e1       	ldi	r24, 0x13	; 19
    4368:	01 90       	ld	r0, Z+
    436a:	0d 92       	st	X+, r0
    436c:	81 50       	subi	r24, 0x01	; 1
    436e:	e1 f7       	brne	.-8      	; 0x4368 <commandSetForbiddenZone+0x7a>
    sendText(txString.buffer);
    4370:	80 91 e7 03 	lds	r24, 0x03E7
    4374:	90 91 e8 03 	lds	r25, 0x03E8
    4378:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    437c:	e8 cf       	rjmp	.-48     	; 0x434e <commandSetForbiddenZone+0x60>
      forbiddenZone[i].stop   = 0;
      forbiddenZone[i].active = 0;
      return;
    }

    if(start > stop){
    437e:	ae 01       	movw	r20, r28
    4380:	ec 01       	movw	r28, r24
    4382:	d4 cf       	rjmp	.-88     	; 0x432c <commandSetForbiddenZone+0x3e>
  else{
    start = (int16_t)atoi(param1);
    stop  = (int16_t)atoi(param2);

    if(start == stop){
      forbiddenZone[i].start  = 0;
    4384:	8f 2d       	mov	r24, r15
    4386:	90 e0       	ldi	r25, 0x00	; 0
    4388:	fc 01       	movw	r30, r24
    438a:	ee 0f       	add	r30, r30
    438c:	ff 1f       	adc	r31, r31
    438e:	ee 0f       	add	r30, r30
    4390:	ff 1f       	adc	r31, r31
    4392:	e8 0f       	add	r30, r24
    4394:	f9 1f       	adc	r31, r25
    4396:	ed 52       	subi	r30, 0x2D	; 45
    4398:	fc 4f       	sbci	r31, 0xFC	; 252
    439a:	11 82       	std	Z+1, r1	; 0x01
    439c:	10 82       	st	Z, r1
      forbiddenZone[i].stop   = 0;
    439e:	13 82       	std	Z+3, r1	; 0x03
    43a0:	12 82       	std	Z+2, r1	; 0x02
      forbiddenZone[i].active = 0;
    43a2:	14 82       	std	Z+4, r1	; 0x04
    forbiddenZone[i].stop   = stop;
    forbiddenZone[i].active = 1;
  }

  return;
}
    43a4:	df 91       	pop	r29
    43a6:	cf 91       	pop	r28
    43a8:	1f 91       	pop	r17
    43aa:	0f 91       	pop	r16
    43ac:	ff 90       	pop	r15
    43ae:	08 95       	ret

000043b0 <commandSetConstSpeed>:
}

/* ---------------------------------------------------------------------
    sets the infinite moving mode
 --------------------------------------------------------------------- */
void commandSetConstSpeed(char* param0, char* param1, char* param2){
    43b0:	2f 92       	push	r2
    43b2:	3f 92       	push	r3
    43b4:	4f 92       	push	r4
    43b6:	5f 92       	push	r5
    43b8:	6f 92       	push	r6
    43ba:	7f 92       	push	r7
    43bc:	8f 92       	push	r8
    43be:	9f 92       	push	r9
    43c0:	af 92       	push	r10
    43c2:	bf 92       	push	r11
    43c4:	cf 92       	push	r12
    43c6:	df 92       	push	r13
    43c8:	ef 92       	push	r14
    43ca:	ff 92       	push	r15
    43cc:	0f 93       	push	r16
    43ce:	1f 93       	push	r17
    43d0:	df 93       	push	r29
    43d2:	cf 93       	push	r28
    43d4:	00 d0       	rcall	.+0      	; 0x43d6 <commandSetConstSpeed+0x26>
    43d6:	00 d0       	rcall	.+0      	; 0x43d8 <commandSetConstSpeed+0x28>
    43d8:	00 d0       	rcall	.+0      	; 0x43da <commandSetConstSpeed+0x2a>
    43da:	cd b7       	in	r28, 0x3d	; 61
    43dc:	de b7       	in	r29, 0x3e	; 62
    43de:	7a 83       	std	Y+2, r23	; 0x02
    43e0:	69 83       	std	Y+1, r22	; 0x01
    43e2:	8a 01       	movw	r16, r20

  uint8_t i = 0;
  double val = 0.0;
  uint16_t waitTime = 1;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    43e4:	60 e0       	ldi	r22, 0x00	; 0
    43e6:	70 e0       	ldi	r23, 0x00	; 0
    43e8:	4a e0       	ldi	r20, 0x0A	; 10
    43ea:	50 e0       	ldi	r21, 0x00	; 0
    43ec:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    43f0:	64 30       	cpi	r22, 0x04	; 4
    43f2:	08 f0       	brcs	.+2      	; 0x43f6 <commandSetConstSpeed+0x46>
    43f4:	62 c0       	rjmp	.+196    	; 0x44ba <commandSetConstSpeed+0x10a>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    if(forbiddenZone[i].active){
    43f6:	e6 2e       	mov	r14, r22
    43f8:	ff 24       	eor	r15, r15
    43fa:	97 01       	movw	r18, r14
    43fc:	22 0f       	add	r18, r18
    43fe:	33 1f       	adc	r19, r19
    4400:	22 0f       	add	r18, r18
    4402:	33 1f       	adc	r19, r19
    4404:	3c 83       	std	Y+4, r19	; 0x04
    4406:	2b 83       	std	Y+3, r18	; 0x03
    4408:	f9 01       	movw	r30, r18
    440a:	ee 0d       	add	r30, r14
    440c:	ff 1d       	adc	r31, r15
    440e:	ed 52       	subi	r30, 0x2D	; 45
    4410:	fc 4f       	sbci	r31, 0xFC	; 252
    4412:	84 81       	ldd	r24, Z+4	; 0x04
    4414:	88 23       	and	r24, r24
    4416:	c9 f0       	breq	.+50     	; 0x444a <commandSetConstSpeed+0x9a>
      motor[i].desiredPosition += -1;
    }
  }

  return;
}
    4418:	26 96       	adiw	r28, 0x06	; 6
    441a:	0f b6       	in	r0, 0x3f	; 63
    441c:	f8 94       	cli
    441e:	de bf       	out	0x3e, r29	; 62
    4420:	0f be       	out	0x3f, r0	; 63
    4422:	cd bf       	out	0x3d, r28	; 61
    4424:	cf 91       	pop	r28
    4426:	df 91       	pop	r29
    4428:	1f 91       	pop	r17
    442a:	0f 91       	pop	r16
    442c:	ff 90       	pop	r15
    442e:	ef 90       	pop	r14
    4430:	df 90       	pop	r13
    4432:	cf 90       	pop	r12
    4434:	bf 90       	pop	r11
    4436:	af 90       	pop	r10
    4438:	9f 90       	pop	r9
    443a:	8f 90       	pop	r8
    443c:	7f 90       	pop	r7
    443e:	6f 90       	pop	r6
    4440:	5f 90       	pop	r5
    4442:	4f 90       	pop	r4
    4444:	3f 90       	pop	r3
    4446:	2f 90       	pop	r2
    4448:	08 95       	ret
      /* command not allowed if forbidden zone is set */
      return;
    }

    /* this is the wait-time for a full rotation in seconds */
    val = atof(param2);
    444a:	c8 01       	movw	r24, r16
    444c:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    4450:	3b 01       	movw	r6, r22
    4452:	4c 01       	movw	r8, r24

    if(strcmp(param1, "STOP") == 0){
    4454:	89 81       	ldd	r24, Y+1	; 0x01
    4456:	9a 81       	ldd	r25, Y+2	; 0x02
    4458:	6d e6       	ldi	r22, 0x6D	; 109
    445a:	72 e0       	ldi	r23, 0x02	; 2
    445c:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4460:	00 97       	sbiw	r24, 0x00	; 0
    4462:	09 f0       	breq	.+2      	; 0x4466 <commandSetConstSpeed+0xb6>
    4464:	3c c0       	rjmp	.+120    	; 0x44de <commandSetConstSpeed+0x12e>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4466:	f8 94       	cli
      ATOMIC_BLOCK(ATOMIC_FORCEON){
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    4468:	c7 01       	movw	r24, r14
    446a:	88 0f       	add	r24, r24
    446c:	99 1f       	adc	r25, r25
    446e:	88 0f       	add	r24, r24
    4470:	99 1f       	adc	r25, r25
    4472:	88 0f       	add	r24, r24
    4474:	99 1f       	adc	r25, r25
    4476:	fc 01       	movw	r30, r24
    4478:	ee 0f       	add	r30, r30
    447a:	ff 1f       	adc	r31, r31
    447c:	ee 0f       	add	r30, r30
    447e:	ff 1f       	adc	r31, r31
    4480:	e8 0f       	add	r30, r24
    4482:	f9 1f       	adc	r31, r25
    4484:	e0 51       	subi	r30, 0x10	; 16
    4486:	fc 4f       	sbci	r31, 0xFC	; 252
    4488:	14 86       	std	Z+12, r1	; 0x0c
        motor[i].waitBetweenSteps = 3;
    448a:	83 e0       	ldi	r24, 0x03	; 3
    448c:	90 e0       	ldi	r25, 0x00	; 0
    448e:	97 8f       	std	Z+31, r25	; 0x1f
    4490:	86 8f       	std	Z+30, r24	; 0x1e
        motor[i].desiredPosition  = motor[i].actualPosition;
    4492:	80 81       	ld	r24, Z
    4494:	91 81       	ldd	r25, Z+1	; 0x01
    4496:	eb 81       	ldd	r30, Y+3	; 0x03
    4498:	fc 81       	ldd	r31, Y+4	; 0x04
    449a:	ee 0f       	add	r30, r30
    449c:	ff 1f       	adc	r31, r31
    449e:	ee 0f       	add	r30, r30
    44a0:	ff 1f       	adc	r31, r31
    44a2:	ab 81       	ldd	r26, Y+3	; 0x03
    44a4:	bc 81       	ldd	r27, Y+4	; 0x04
    44a6:	ea 0f       	add	r30, r26
    44a8:	fb 1f       	adc	r31, r27
    44aa:	ee 0f       	add	r30, r30
    44ac:	ff 1f       	adc	r31, r31
    44ae:	ee 50       	subi	r30, 0x0E	; 14
    44b0:	fc 4f       	sbci	r31, 0xFC	; 252
    44b2:	91 83       	std	Z+1, r25	; 0x01
    44b4:	80 83       	st	Z, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    44b6:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    44b8:	af cf       	rjmp	.-162    	; 0x4418 <commandSetConstSpeed+0x68>
  uint16_t waitTime = 1;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    44ba:	a0 91 e7 03 	lds	r26, 0x03E7
    44be:	b0 91 e8 03 	lds	r27, 0x03E8
    44c2:	ea e5       	ldi	r30, 0x5A	; 90
    44c4:	f2 e0       	ldi	r31, 0x02	; 2
    44c6:	83 e1       	ldi	r24, 0x13	; 19
    44c8:	01 90       	ld	r0, Z+
    44ca:	0d 92       	st	X+, r0
    44cc:	81 50       	subi	r24, 0x01	; 1
    44ce:	e1 f7       	brne	.-8      	; 0x44c8 <commandSetConstSpeed+0x118>
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
    44d0:	80 91 e7 03 	lds	r24, 0x03E7
    44d4:	90 91 e8 03 	lds	r25, 0x03E8
    44d8:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    44dc:	9d cf       	rjmp	.-198    	; 0x4418 <commandSetConstSpeed+0x68>
      }
      return;
    }

    /* now calculate wait time between two steps in ms */
    waitTime = (uint16_t)round((fabs(val)*1000.0f) / ( motor[i].gearRatio
    44de:	f7 01       	movw	r30, r14
    44e0:	ee 0f       	add	r30, r30
    44e2:	ff 1f       	adc	r31, r31
    44e4:	ee 0f       	add	r30, r30
    44e6:	ff 1f       	adc	r31, r31
    44e8:	ee 0f       	add	r30, r30
    44ea:	ff 1f       	adc	r31, r31
    44ec:	fe 83       	std	Y+6, r31	; 0x06
    44ee:	ed 83       	std	Y+5, r30	; 0x05
    44f0:	ee 0f       	add	r30, r30
    44f2:	ff 1f       	adc	r31, r31
    44f4:	ee 0f       	add	r30, r30
    44f6:	ff 1f       	adc	r31, r31
    44f8:	2d 81       	ldd	r18, Y+5	; 0x05
    44fa:	3e 81       	ldd	r19, Y+6	; 0x06
    44fc:	e2 0f       	add	r30, r18
    44fe:	f3 1f       	adc	r31, r19
    4500:	e0 51       	subi	r30, 0x10	; 16
    4502:	fc 4f       	sbci	r31, 0xFC	; 252
    4504:	e5 84       	ldd	r14, Z+13	; 0x0d
    4506:	f6 84       	ldd	r15, Z+14	; 0x0e
    4508:	07 85       	ldd	r16, Z+15	; 0x0f
    450a:	10 89       	ldd	r17, Z+16	; 0x10
    450c:	a1 88       	ldd	r10, Z+17	; 0x11
    450e:	b2 88       	ldd	r11, Z+18	; 0x12
    4510:	c3 88       	ldd	r12, Z+19	; 0x13
    4512:	d4 88       	ldd	r13, Z+20	; 0x14
    4514:	25 88       	ldd	r2, Z+21	; 0x15
    4516:	36 88       	ldd	r3, Z+22	; 0x16
    4518:	47 88       	ldd	r4, Z+23	; 0x17
    451a:	50 8c       	ldd	r5, Z+24	; 0x18
    451c:	c4 01       	movw	r24, r8
    451e:	b3 01       	movw	r22, r6
    4520:	9f 77       	andi	r25, 0x7F	; 127
    4522:	20 e0       	ldi	r18, 0x00	; 0
    4524:	30 e0       	ldi	r19, 0x00	; 0
    4526:	4a e7       	ldi	r20, 0x7A	; 122
    4528:	54 e4       	ldi	r21, 0x44	; 68
    452a:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    452e:	3b 01       	movw	r6, r22
    4530:	4c 01       	movw	r8, r24
    4532:	c8 01       	movw	r24, r16
    4534:	b7 01       	movw	r22, r14
    4536:	a6 01       	movw	r20, r12
    4538:	95 01       	movw	r18, r10
    453a:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    453e:	a2 01       	movw	r20, r4
    4540:	91 01       	movw	r18, r2
    4542:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    4546:	9b 01       	movw	r18, r22
    4548:	ac 01       	movw	r20, r24
    454a:	c4 01       	movw	r24, r8
    454c:	b3 01       	movw	r22, r6
    454e:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>
    4552:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    4556:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
    455a:	8b 01       	movw	r16, r22
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
    455c:	67 2b       	or	r22, r23
    455e:	09 f4       	brne	.+2      	; 0x4562 <commandSetConstSpeed+0x1b2>
    4560:	77 c0       	rjmp	.+238    	; 0x4650 <commandSetConstSpeed+0x2a0>
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
      return;
    }
    if(waitTime > 9999){
    4562:	37 e2       	ldi	r19, 0x27	; 39
    4564:	60 31       	cpi	r22, 0x10	; 16
    4566:	73 07       	cpc	r23, r19
    4568:	08 f0       	brcs	.+2      	; 0x456c <commandSetConstSpeed+0x1bc>
    456a:	60 c0       	rjmp	.+192    	; 0x462c <commandSetConstSpeed+0x27c>
    sprintf(txString.buffer, "err: time too long");
    sendText(txString.buffer);
    }

    if(strcmp(param1, "CW")  == 0){
    456c:	89 81       	ldd	r24, Y+1	; 0x01
    456e:	9a 81       	ldd	r25, Y+2	; 0x02
    4570:	69 e9       	ldi	r22, 0x99	; 153
    4572:	72 e0       	ldi	r23, 0x02	; 2
    4574:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4578:	00 97       	sbiw	r24, 0x00	; 0
    457a:	39 f5       	brne	.+78     	; 0x45ca <commandSetConstSpeed+0x21a>
      motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CW;
    457c:	ed 81       	ldd	r30, Y+5	; 0x05
    457e:	fe 81       	ldd	r31, Y+6	; 0x06
    4580:	ee 0f       	add	r30, r30
    4582:	ff 1f       	adc	r31, r31
    4584:	ee 0f       	add	r30, r30
    4586:	ff 1f       	adc	r31, r31
    4588:	8d 81       	ldd	r24, Y+5	; 0x05
    458a:	9e 81       	ldd	r25, Y+6	; 0x06
    458c:	e8 0f       	add	r30, r24
    458e:	f9 1f       	adc	r31, r25
    4590:	e0 51       	subi	r30, 0x10	; 16
    4592:	fc 4f       	sbci	r31, 0xFC	; 252
    4594:	81 e0       	ldi	r24, 0x01	; 1
    4596:	84 87       	std	Z+12, r24	; 0x0c
      motor[i].waitBetweenSteps = waitTime;
    4598:	17 8f       	std	Z+31, r17	; 0x1f
    459a:	06 8f       	std	Z+30, r16	; 0x1e
      motor[i].desiredPosition  = motor[i].actualPosition;
    459c:	80 81       	ld	r24, Z
    459e:	91 81       	ldd	r25, Z+1	; 0x01
    45a0:	eb 81       	ldd	r30, Y+3	; 0x03
    45a2:	fc 81       	ldd	r31, Y+4	; 0x04
    45a4:	ee 0f       	add	r30, r30
    45a6:	ff 1f       	adc	r31, r31
    45a8:	ee 0f       	add	r30, r30
    45aa:	ff 1f       	adc	r31, r31
    45ac:	ab 81       	ldd	r26, Y+3	; 0x03
    45ae:	bc 81       	ldd	r27, Y+4	; 0x04
    45b0:	ea 0f       	add	r30, r26
    45b2:	fb 1f       	adc	r31, r27
    45b4:	ee 0f       	add	r30, r30
    45b6:	ff 1f       	adc	r31, r31
    45b8:	ee 50       	subi	r30, 0x0E	; 14
    45ba:	fc 4f       	sbci	r31, 0xFC	; 252
    45bc:	91 83       	std	Z+1, r25	; 0x01
    45be:	80 83       	st	Z, r24
      motor[i].desiredPosition += 1;
    45c0:	80 81       	ld	r24, Z
    45c2:	91 81       	ldd	r25, Z+1	; 0x01
    45c4:	01 96       	adiw	r24, 0x01	; 1
    45c6:	91 83       	std	Z+1, r25	; 0x01
    45c8:	80 83       	st	Z, r24
    }
    if(strcmp(param1, "CCW") == 0){
    45ca:	89 81       	ldd	r24, Y+1	; 0x01
    45cc:	9a 81       	ldd	r25, Y+2	; 0x02
    45ce:	6c e9       	ldi	r22, 0x9C	; 156
    45d0:	72 e0       	ldi	r23, 0x02	; 2
    45d2:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    45d6:	00 97       	sbiw	r24, 0x00	; 0
    45d8:	09 f0       	breq	.+2      	; 0x45dc <commandSetConstSpeed+0x22c>
    45da:	1e cf       	rjmp	.-452    	; 0x4418 <commandSetConstSpeed+0x68>
      motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
    45dc:	ed 81       	ldd	r30, Y+5	; 0x05
    45de:	fe 81       	ldd	r31, Y+6	; 0x06
    45e0:	ee 0f       	add	r30, r30
    45e2:	ff 1f       	adc	r31, r31
    45e4:	ee 0f       	add	r30, r30
    45e6:	ff 1f       	adc	r31, r31
    45e8:	2d 81       	ldd	r18, Y+5	; 0x05
    45ea:	3e 81       	ldd	r19, Y+6	; 0x06
    45ec:	e2 0f       	add	r30, r18
    45ee:	f3 1f       	adc	r31, r19
    45f0:	e0 51       	subi	r30, 0x10	; 16
    45f2:	fc 4f       	sbci	r31, 0xFC	; 252
    45f4:	82 e0       	ldi	r24, 0x02	; 2
    45f6:	84 87       	std	Z+12, r24	; 0x0c
      motor[i].waitBetweenSteps = waitTime;
    45f8:	17 8f       	std	Z+31, r17	; 0x1f
    45fa:	06 8f       	std	Z+30, r16	; 0x1e
      motor[i].desiredPosition  = motor[i].actualPosition;
    45fc:	80 81       	ld	r24, Z
    45fe:	91 81       	ldd	r25, Z+1	; 0x01
    4600:	eb 81       	ldd	r30, Y+3	; 0x03
    4602:	fc 81       	ldd	r31, Y+4	; 0x04
    4604:	ee 0f       	add	r30, r30
    4606:	ff 1f       	adc	r31, r31
    4608:	ee 0f       	add	r30, r30
    460a:	ff 1f       	adc	r31, r31
    460c:	ab 81       	ldd	r26, Y+3	; 0x03
    460e:	bc 81       	ldd	r27, Y+4	; 0x04
    4610:	ea 0f       	add	r30, r26
    4612:	fb 1f       	adc	r31, r27
    4614:	ee 0f       	add	r30, r30
    4616:	ff 1f       	adc	r31, r31
    4618:	ee 50       	subi	r30, 0x0E	; 14
    461a:	fc 4f       	sbci	r31, 0xFC	; 252
    461c:	91 83       	std	Z+1, r25	; 0x01
    461e:	80 83       	st	Z, r24
      motor[i].desiredPosition += -1;
    4620:	80 81       	ld	r24, Z
    4622:	91 81       	ldd	r25, Z+1	; 0x01
    4624:	01 97       	sbiw	r24, 0x01	; 1
    4626:	91 83       	std	Z+1, r25	; 0x01
    4628:	80 83       	st	Z, r24
    462a:	f6 ce       	rjmp	.-532    	; 0x4418 <commandSetConstSpeed+0x68>
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
      return;
    }
    if(waitTime > 9999){
    sprintf(txString.buffer, "err: time too long");
    462c:	a0 91 e7 03 	lds	r26, 0x03E7
    4630:	b0 91 e8 03 	lds	r27, 0x03E8
    4634:	e6 e8       	ldi	r30, 0x86	; 134
    4636:	f2 e0       	ldi	r31, 0x02	; 2
    4638:	83 e1       	ldi	r24, 0x13	; 19
    463a:	01 90       	ld	r0, Z+
    463c:	0d 92       	st	X+, r0
    463e:	81 50       	subi	r24, 0x01	; 1
    4640:	e1 f7       	brne	.-8      	; 0x463a <commandSetConstSpeed+0x28a>
    sendText(txString.buffer);
    4642:	80 91 e7 03 	lds	r24, 0x03E7
    4646:	90 91 e8 03 	lds	r25, 0x03E8
    464a:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    464e:	8e cf       	rjmp	.-228    	; 0x456c <commandSetConstSpeed+0x1bc>
    waitTime = (uint16_t)round((fabs(val)*1000.0f) / ( motor[i].gearRatio
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
      sprintf(txString.buffer, "err: time too short");
    4650:	a0 91 e7 03 	lds	r26, 0x03E7
    4654:	b0 91 e8 03 	lds	r27, 0x03E8
    4658:	e2 e7       	ldi	r30, 0x72	; 114
    465a:	f2 e0       	ldi	r31, 0x02	; 2
    465c:	84 e1       	ldi	r24, 0x14	; 20
    465e:	01 90       	ld	r0, Z+
    4660:	0d 92       	st	X+, r0
    4662:	81 50       	subi	r24, 0x01	; 1
    4664:	e1 f7       	brne	.-8      	; 0x465e <commandSetConstSpeed+0x2ae>
    4666:	34 cf       	rjmp	.-408    	; 0x44d0 <commandSetConstSpeed+0x120>

00004668 <commandSetWaitTime>:
}

/* ---------------------------------------------------------------------
    sets the wait time between two single steps
 --------------------------------------------------------------------- */
void commandSetWaitTime(char* param0, char* param1){
    4668:	1f 93       	push	r17
    466a:	cf 93       	push	r28
    466c:	df 93       	push	r29
    466e:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4670:	60 e0       	ldi	r22, 0x00	; 0
    4672:	70 e0       	ldi	r23, 0x00	; 0
    4674:	4a e0       	ldi	r20, 0x0A	; 10
    4676:	50 e0       	ldi	r21, 0x00	; 0
    4678:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    467c:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    467e:	64 30       	cpi	r22, 0x04	; 4
    4680:	d8 f4       	brcc	.+54     	; 0x46b8 <commandSetWaitTime+0x50>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    val = (uint16_t)atoi(param1);
    4682:	ce 01       	movw	r24, r28
    4684:	0e 94 26 44 	call	0x884c	; 0x884c <atoi>
    4688:	9c 01       	movw	r18, r24
    motor[i].waitBetweenSteps = val;
    468a:	e1 2f       	mov	r30, r17
    468c:	f0 e0       	ldi	r31, 0x00	; 0
    468e:	ee 0f       	add	r30, r30
    4690:	ff 1f       	adc	r31, r31
    4692:	ee 0f       	add	r30, r30
    4694:	ff 1f       	adc	r31, r31
    4696:	ee 0f       	add	r30, r30
    4698:	ff 1f       	adc	r31, r31
    469a:	cf 01       	movw	r24, r30
    469c:	88 0f       	add	r24, r24
    469e:	99 1f       	adc	r25, r25
    46a0:	88 0f       	add	r24, r24
    46a2:	99 1f       	adc	r25, r25
    46a4:	e8 0f       	add	r30, r24
    46a6:	f9 1f       	adc	r31, r25
    46a8:	e0 51       	subi	r30, 0x10	; 16
    46aa:	fc 4f       	sbci	r31, 0xFC	; 252
    46ac:	37 8f       	std	Z+31, r19	; 0x1f
    46ae:	26 8f       	std	Z+30, r18	; 0x1e
  }

  return;
}
    46b0:	df 91       	pop	r29
    46b2:	cf 91       	pop	r28
    46b4:	1f 91       	pop	r17
    46b6:	08 95       	ret
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    46b8:	a0 91 e7 03 	lds	r26, 0x03E7
    46bc:	b0 91 e8 03 	lds	r27, 0x03E8
    46c0:	ea e5       	ldi	r30, 0x5A	; 90
    46c2:	f2 e0       	ldi	r31, 0x02	; 2
    46c4:	83 e1       	ldi	r24, 0x13	; 19
    46c6:	01 90       	ld	r0, Z+
    46c8:	0d 92       	st	X+, r0
    46ca:	81 50       	subi	r24, 0x01	; 1
    46cc:	e1 f7       	brne	.-8      	; 0x46c6 <commandSetWaitTime+0x5e>
    sendText(txString.buffer);
    46ce:	80 91 e7 03 	lds	r24, 0x03E7
    46d2:	90 91 e8 03 	lds	r25, 0x03E8
    46d6:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    46da:	ea cf       	rjmp	.-44     	; 0x46b0 <commandSetWaitTime+0x48>

000046dc <commandSetFullRotation>:
}

/* ---------------------------------------------------------------------
    sets the steps per full rotation w/o substeps
 --------------------------------------------------------------------- */
void commandSetFullRotation(char* param0, char* param1){
    46dc:	1f 93       	push	r17
    46de:	cf 93       	push	r28
    46e0:	df 93       	push	r29
    46e2:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    46e4:	60 e0       	ldi	r22, 0x00	; 0
    46e6:	70 e0       	ldi	r23, 0x00	; 0
    46e8:	4a e0       	ldi	r20, 0x0A	; 10
    46ea:	50 e0       	ldi	r21, 0x00	; 0
    46ec:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    46f0:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    46f2:	64 30       	cpi	r22, 0x04	; 4
    46f4:	e0 f4       	brcc	.+56     	; 0x472e <commandSetFullRotation+0x52>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    46f6:	ce 01       	movw	r24, r28
    46f8:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    motor[i].stepsPerFullRotation = val;
    46fc:	e1 2f       	mov	r30, r17
    46fe:	f0 e0       	ldi	r31, 0x00	; 0
    4700:	ee 0f       	add	r30, r30
    4702:	ff 1f       	adc	r31, r31
    4704:	ee 0f       	add	r30, r30
    4706:	ff 1f       	adc	r31, r31
    4708:	ee 0f       	add	r30, r30
    470a:	ff 1f       	adc	r31, r31
    470c:	9f 01       	movw	r18, r30
    470e:	22 0f       	add	r18, r18
    4710:	33 1f       	adc	r19, r19
    4712:	22 0f       	add	r18, r18
    4714:	33 1f       	adc	r19, r19
    4716:	e2 0f       	add	r30, r18
    4718:	f3 1f       	adc	r31, r19
    471a:	e0 51       	subi	r30, 0x10	; 16
    471c:	fc 4f       	sbci	r31, 0xFC	; 252
    471e:	61 8b       	std	Z+17, r22	; 0x11
    4720:	72 8b       	std	Z+18, r23	; 0x12
    4722:	83 8b       	std	Z+19, r24	; 0x13
    4724:	94 8b       	std	Z+20, r25	; 0x14
  }

  return;
}
    4726:	df 91       	pop	r29
    4728:	cf 91       	pop	r28
    472a:	1f 91       	pop	r17
    472c:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    472e:	80 91 e7 03 	lds	r24, 0x03E7
    4732:	90 91 e8 03 	lds	r25, 0x03E8
    4736:	00 d0       	rcall	.+0      	; 0x4738 <commandSetFullRotation+0x5c>
    4738:	00 d0       	rcall	.+0      	; 0x473a <commandSetFullRotation+0x5e>
    473a:	00 d0       	rcall	.+0      	; 0x473c <commandSetFullRotation+0x60>
    473c:	ed b7       	in	r30, 0x3d	; 61
    473e:	fe b7       	in	r31, 0x3e	; 62
    4740:	31 96       	adiw	r30, 0x01	; 1
    4742:	ad b7       	in	r26, 0x3d	; 61
    4744:	be b7       	in	r27, 0x3e	; 62
    4746:	12 96       	adiw	r26, 0x02	; 2
    4748:	9c 93       	st	X, r25
    474a:	8e 93       	st	-X, r24
    474c:	11 97       	sbiw	r26, 0x01	; 1
    474e:	80 e0       	ldi	r24, 0x00	; 0
    4750:	91 e0       	ldi	r25, 0x01	; 1
    4752:	93 83       	std	Z+3, r25	; 0x03
    4754:	82 83       	std	Z+2, r24	; 0x02
    4756:	14 83       	std	Z+4, r17	; 0x04
    4758:	15 82       	std	Z+5, r1	; 0x05
    475a:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    sendText(txString.buffer);
    475e:	80 91 e7 03 	lds	r24, 0x03E7
    4762:	90 91 e8 03 	lds	r25, 0x03E8
    4766:	2d b7       	in	r18, 0x3d	; 61
    4768:	3e b7       	in	r19, 0x3e	; 62
    476a:	2a 5f       	subi	r18, 0xFA	; 250
    476c:	3f 4f       	sbci	r19, 0xFF	; 255
    476e:	0f b6       	in	r0, 0x3f	; 63
    4770:	f8 94       	cli
    4772:	3e bf       	out	0x3e, r19	; 62
    4774:	0f be       	out	0x3f, r0	; 63
    4776:	2d bf       	out	0x3d, r18	; 61
    4778:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    val = (double)atof(param1);
    motor[i].stepsPerFullRotation = val;
  }

  return;
}
    477c:	df 91       	pop	r29
    477e:	cf 91       	pop	r28
    4780:	1f 91       	pop	r17
    4782:	08 95       	ret

00004784 <commandSetGearRatio>:
}

/* ---------------------------------------------------------------------
    sets the mechanical gear ratio
 --------------------------------------------------------------------- */
void commandSetGearRatio(char* param0, char* param1){
    4784:	1f 93       	push	r17
    4786:	cf 93       	push	r28
    4788:	df 93       	push	r29
    478a:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    478c:	60 e0       	ldi	r22, 0x00	; 0
    478e:	70 e0       	ldi	r23, 0x00	; 0
    4790:	4a e0       	ldi	r20, 0x0A	; 10
    4792:	50 e0       	ldi	r21, 0x00	; 0
    4794:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4798:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    479a:	64 30       	cpi	r22, 0x04	; 4
    479c:	e0 f4       	brcc	.+56     	; 0x47d6 <commandSetGearRatio+0x52>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    479e:	ce 01       	movw	r24, r28
    47a0:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    motor[i].gearRatio = val;
    47a4:	e1 2f       	mov	r30, r17
    47a6:	f0 e0       	ldi	r31, 0x00	; 0
    47a8:	ee 0f       	add	r30, r30
    47aa:	ff 1f       	adc	r31, r31
    47ac:	ee 0f       	add	r30, r30
    47ae:	ff 1f       	adc	r31, r31
    47b0:	ee 0f       	add	r30, r30
    47b2:	ff 1f       	adc	r31, r31
    47b4:	9f 01       	movw	r18, r30
    47b6:	22 0f       	add	r18, r18
    47b8:	33 1f       	adc	r19, r19
    47ba:	22 0f       	add	r18, r18
    47bc:	33 1f       	adc	r19, r19
    47be:	e2 0f       	add	r30, r18
    47c0:	f3 1f       	adc	r31, r19
    47c2:	e0 51       	subi	r30, 0x10	; 16
    47c4:	fc 4f       	sbci	r31, 0xFC	; 252
    47c6:	65 87       	std	Z+13, r22	; 0x0d
    47c8:	76 87       	std	Z+14, r23	; 0x0e
    47ca:	87 87       	std	Z+15, r24	; 0x0f
    47cc:	90 8b       	std	Z+16, r25	; 0x10
  }

  return;
}
    47ce:	df 91       	pop	r29
    47d0:	cf 91       	pop	r28
    47d2:	1f 91       	pop	r17
    47d4:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    47d6:	80 91 e7 03 	lds	r24, 0x03E7
    47da:	90 91 e8 03 	lds	r25, 0x03E8
    47de:	00 d0       	rcall	.+0      	; 0x47e0 <commandSetGearRatio+0x5c>
    47e0:	00 d0       	rcall	.+0      	; 0x47e2 <commandSetGearRatio+0x5e>
    47e2:	00 d0       	rcall	.+0      	; 0x47e4 <commandSetGearRatio+0x60>
    47e4:	ed b7       	in	r30, 0x3d	; 61
    47e6:	fe b7       	in	r31, 0x3e	; 62
    47e8:	31 96       	adiw	r30, 0x01	; 1
    47ea:	ad b7       	in	r26, 0x3d	; 61
    47ec:	be b7       	in	r27, 0x3e	; 62
    47ee:	12 96       	adiw	r26, 0x02	; 2
    47f0:	9c 93       	st	X, r25
    47f2:	8e 93       	st	-X, r24
    47f4:	11 97       	sbiw	r26, 0x01	; 1
    47f6:	80 e0       	ldi	r24, 0x00	; 0
    47f8:	91 e0       	ldi	r25, 0x01	; 1
    47fa:	93 83       	std	Z+3, r25	; 0x03
    47fc:	82 83       	std	Z+2, r24	; 0x02
    47fe:	14 83       	std	Z+4, r17	; 0x04
    4800:	15 82       	std	Z+5, r1	; 0x05
    4802:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    sendText(txString.buffer);
    4806:	80 91 e7 03 	lds	r24, 0x03E7
    480a:	90 91 e8 03 	lds	r25, 0x03E8
    480e:	2d b7       	in	r18, 0x3d	; 61
    4810:	3e b7       	in	r19, 0x3e	; 62
    4812:	2a 5f       	subi	r18, 0xFA	; 250
    4814:	3f 4f       	sbci	r19, 0xFF	; 255
    4816:	0f b6       	in	r0, 0x3f	; 63
    4818:	f8 94       	cli
    481a:	3e bf       	out	0x3e, r19	; 62
    481c:	0f be       	out	0x3f, r0	; 63
    481e:	2d bf       	out	0x3d, r18	; 61
    4820:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    val = (double)atof(param1);
    motor[i].gearRatio = val;
  }

  return;
}
    4824:	df 91       	pop	r29
    4826:	cf 91       	pop	r28
    4828:	1f 91       	pop	r17
    482a:	08 95       	ret

0000482c <commandSetOptZeroPos>:

/* ---------------------------------------------------------------------
    sets the optical zero position
    as offset from magnetic zero position
 --------------------------------------------------------------------- */
void commandSetOptZeroPos(char* param0, char* param1){
    482c:	1f 93       	push	r17
    482e:	cf 93       	push	r28
    4830:	df 93       	push	r29
    4832:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  int16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4834:	60 e0       	ldi	r22, 0x00	; 0
    4836:	70 e0       	ldi	r23, 0x00	; 0
    4838:	4a e0       	ldi	r20, 0x0A	; 10
    483a:	50 e0       	ldi	r21, 0x00	; 0
    483c:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4840:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4842:	64 30       	cpi	r22, 0x04	; 4
    4844:	00 f5       	brcc	.+64     	; 0x4886 <commandSetOptZeroPos+0x5a>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (int16_t)strtol(param1, (char **)NULL, 10);
    4846:	ce 01       	movw	r24, r28
    4848:	60 e0       	ldi	r22, 0x00	; 0
    484a:	70 e0       	ldi	r23, 0x00	; 0
    484c:	4a e0       	ldi	r20, 0x0A	; 10
    484e:	50 e0       	ldi	r21, 0x00	; 0
    4850:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    motor[i].opticalZeroPosition = val;
    4854:	21 2f       	mov	r18, r17
    4856:	30 e0       	ldi	r19, 0x00	; 0
    4858:	f9 01       	movw	r30, r18
    485a:	ee 0f       	add	r30, r30
    485c:	ff 1f       	adc	r31, r31
    485e:	ee 0f       	add	r30, r30
    4860:	ff 1f       	adc	r31, r31
    4862:	ee 0f       	add	r30, r30
    4864:	ff 1f       	adc	r31, r31
    4866:	22 0f       	add	r18, r18
    4868:	33 1f       	adc	r19, r19
    486a:	e2 0f       	add	r30, r18
    486c:	f3 1f       	adc	r31, r19
    486e:	ee 0f       	add	r30, r30
    4870:	ff 1f       	adc	r31, r31
    4872:	ee 0f       	add	r30, r30
    4874:	ff 1f       	adc	r31, r31
    4876:	ec 50       	subi	r30, 0x0C	; 12
    4878:	fc 4f       	sbci	r31, 0xFC	; 252
    487a:	71 83       	std	Z+1, r23	; 0x01
    487c:	60 83       	st	Z, r22
  }

  return;
}
    487e:	df 91       	pop	r29
    4880:	cf 91       	pop	r28
    4882:	1f 91       	pop	r17
    4884:	08 95       	ret
  int16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4886:	80 91 e7 03 	lds	r24, 0x03E7
    488a:	90 91 e8 03 	lds	r25, 0x03E8
    488e:	00 d0       	rcall	.+0      	; 0x4890 <commandSetOptZeroPos+0x64>
    4890:	00 d0       	rcall	.+0      	; 0x4892 <commandSetOptZeroPos+0x66>
    4892:	00 d0       	rcall	.+0      	; 0x4894 <commandSetOptZeroPos+0x68>
    4894:	ed b7       	in	r30, 0x3d	; 61
    4896:	fe b7       	in	r31, 0x3e	; 62
    4898:	31 96       	adiw	r30, 0x01	; 1
    489a:	ad b7       	in	r26, 0x3d	; 61
    489c:	be b7       	in	r27, 0x3e	; 62
    489e:	12 96       	adiw	r26, 0x02	; 2
    48a0:	9c 93       	st	X, r25
    48a2:	8e 93       	st	-X, r24
    48a4:	11 97       	sbiw	r26, 0x01	; 1
    48a6:	80 e0       	ldi	r24, 0x00	; 0
    48a8:	91 e0       	ldi	r25, 0x01	; 1
    48aa:	93 83       	std	Z+3, r25	; 0x03
    48ac:	82 83       	std	Z+2, r24	; 0x02
    48ae:	14 83       	std	Z+4, r17	; 0x04
    48b0:	15 82       	std	Z+5, r1	; 0x05
    48b2:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    sendText(txString.buffer);
    48b6:	80 91 e7 03 	lds	r24, 0x03E7
    48ba:	90 91 e8 03 	lds	r25, 0x03E8
    48be:	2d b7       	in	r18, 0x3d	; 61
    48c0:	3e b7       	in	r19, 0x3e	; 62
    48c2:	2a 5f       	subi	r18, 0xFA	; 250
    48c4:	3f 4f       	sbci	r19, 0xFF	; 255
    48c6:	0f b6       	in	r0, 0x3f	; 63
    48c8:	f8 94       	cli
    48ca:	3e bf       	out	0x3e, r19	; 62
    48cc:	0f be       	out	0x3f, r0	; 63
    48ce:	2d bf       	out	0x3d, r18	; 61
    48d0:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    val = (int16_t)strtol(param1, (char **)NULL, 10);
    motor[i].opticalZeroPosition = val;
  }

  return;
}
    48d4:	df 91       	pop	r29
    48d6:	cf 91       	pop	r28
    48d8:	1f 91       	pop	r17
    48da:	08 95       	ret

000048dc <commandMoveRel>:
}

/* ---------------------------------------------------------------------
    moves the motor relative to the actual position
 --------------------------------------------------------------------- */
void commandMoveRel(char* param0, char* param1, char* param2){
    48dc:	ff 92       	push	r15
    48de:	0f 93       	push	r16
    48e0:	1f 93       	push	r17
    48e2:	cf 93       	push	r28
    48e4:	df 93       	push	r29
    48e6:	eb 01       	movw	r28, r22
    48e8:	8a 01       	movw	r16, r20

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    48ea:	60 e0       	ldi	r22, 0x00	; 0
    48ec:	70 e0       	ldi	r23, 0x00	; 0
    48ee:	4a e0       	ldi	r20, 0x0A	; 10
    48f0:	50 e0       	ldi	r21, 0x00	; 0
    48f2:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    48f6:	f6 2e       	mov	r15, r22

  if(i > MAX_MOTOR){
    48f8:	83 e0       	ldi	r24, 0x03	; 3
    48fa:	8f 15       	cp	r24, r15
    48fc:	30 f4       	brcc	.+12     	; 0x490a <commandMoveRel+0x2e>
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    48fe:	df 91       	pop	r29
    4900:	cf 91       	pop	r28
    4902:	1f 91       	pop	r17
    4904:	0f 91       	pop	r16
    4906:	ff 90       	pop	r15
    4908:	08 95       	ret

  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    490a:	c8 01       	movw	r24, r16
    490c:	6f e1       	ldi	r22, 0x1F	; 31
    490e:	72 e0       	ldi	r23, 0x02	; 2
    4910:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4914:	00 97       	sbiw	r24, 0x00	; 0
    4916:	a9 f0       	breq	.+42     	; 0x4942 <commandMoveRel+0x66>
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    4918:	c8 01       	movw	r24, r16
    491a:	65 e2       	ldi	r22, 0x25	; 37
    491c:	72 e0       	ldi	r23, 0x02	; 2
    491e:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4922:	00 97       	sbiw	r24, 0x00	; 0
    4924:	09 f4       	brne	.+2      	; 0x4928 <commandMoveRel+0x4c>
    4926:	42 c0       	rjmp	.+132    	; 0x49ac <commandMoveRel+0xd0>
    degreeToSteps(i, atof(param1), 1.0f);
  }
  else if(strcmp(param2, "pi") == 0){
    4928:	c8 01       	movw	r24, r16
    492a:	69 e2       	ldi	r22, 0x29	; 41
    492c:	72 e0       	ldi	r23, 0x02	; 2
    492e:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4932:	00 97       	sbiw	r24, 0x00	; 0
    4934:	09 f4       	brne	.+2      	; 0x4938 <commandMoveRel+0x5c>
    4936:	47 c0       	rjmp	.+142    	; 0x49c6 <commandMoveRel+0xea>
    radiansToSteps(i, atof(param1), 1.0f);
  }
  else{
    sendText("ERROR: unknown unit");
    4938:	80 ea       	ldi	r24, 0xA0	; 160
    493a:	92 e0       	ldi	r25, 0x02	; 2
    493c:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    4940:	de cf       	rjmp	.-68     	; 0x48fe <commandMoveRel+0x22>
  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
    4942:	ef 2d       	mov	r30, r15
    4944:	f0 e0       	ldi	r31, 0x00	; 0
    4946:	ee 0f       	add	r30, r30
    4948:	ff 1f       	adc	r31, r31
    494a:	ee 0f       	add	r30, r30
    494c:	ff 1f       	adc	r31, r31
    494e:	cf 01       	movw	r24, r30
    4950:	88 0f       	add	r24, r24
    4952:	99 1f       	adc	r25, r25
    4954:	88 0f       	add	r24, r24
    4956:	99 1f       	adc	r25, r25
    4958:	e8 0f       	add	r30, r24
    495a:	f9 1f       	adc	r31, r25
    495c:	ee 0f       	add	r30, r30
    495e:	ff 1f       	adc	r31, r31
    4960:	ee 50       	subi	r30, 0x0E	; 14
    4962:	fc 4f       	sbci	r31, 0xFC	; 252
    4964:	00 81       	ld	r16, Z
    4966:	11 81       	ldd	r17, Z+1	; 0x01
    4968:	ce 01       	movw	r24, r28
    496a:	60 e0       	ldi	r22, 0x00	; 0
    496c:	70 e0       	ldi	r23, 0x00	; 0
    496e:	4a e0       	ldi	r20, 0x0A	; 10
    4970:	50 e0       	ldi	r21, 0x00	; 0
    4972:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4976:	06 0f       	add	r16, r22
    4978:	17 1f       	adc	r17, r23
    497a:	ef 2d       	mov	r30, r15
    497c:	f0 e0       	ldi	r31, 0x00	; 0
    497e:	ee 0f       	add	r30, r30
    4980:	ff 1f       	adc	r31, r31
    4982:	ee 0f       	add	r30, r30
    4984:	ff 1f       	adc	r31, r31
    4986:	cf 01       	movw	r24, r30
    4988:	88 0f       	add	r24, r24
    498a:	99 1f       	adc	r25, r25
    498c:	88 0f       	add	r24, r24
    498e:	99 1f       	adc	r25, r25
    4990:	e8 0f       	add	r30, r24
    4992:	f9 1f       	adc	r31, r25
    4994:	ee 0f       	add	r30, r30
    4996:	ff 1f       	adc	r31, r31
    4998:	ee 50       	subi	r30, 0x0E	; 14
    499a:	fc 4f       	sbci	r31, 0xFC	; 252
    499c:	11 83       	std	Z+1, r17	; 0x01
    499e:	00 83       	st	Z, r16
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    49a0:	df 91       	pop	r29
    49a2:	cf 91       	pop	r28
    49a4:	1f 91       	pop	r17
    49a6:	0f 91       	pop	r16
    49a8:	ff 90       	pop	r15
    49aa:	08 95       	ret

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    degreeToSteps(i, atof(param1), 1.0f);
    49ac:	ce 01       	movw	r24, r28
    49ae:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    49b2:	ab 01       	movw	r20, r22
    49b4:	bc 01       	movw	r22, r24
    49b6:	8f 2d       	mov	r24, r15
    49b8:	00 e0       	ldi	r16, 0x00	; 0
    49ba:	10 e0       	ldi	r17, 0x00	; 0
    49bc:	20 e8       	ldi	r18, 0x80	; 128
    49be:	3f e3       	ldi	r19, 0x3F	; 63
    49c0:	0e 94 13 11 	call	0x2226	; 0x2226 <degreeToSteps>
    49c4:	9c cf       	rjmp	.-200    	; 0x48fe <commandMoveRel+0x22>
  }
  else if(strcmp(param2, "pi") == 0){
    radiansToSteps(i, atof(param1), 1.0f);
    49c6:	ce 01       	movw	r24, r28
    49c8:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    49cc:	ab 01       	movw	r20, r22
    49ce:	bc 01       	movw	r22, r24
    49d0:	8f 2d       	mov	r24, r15
    49d2:	00 e0       	ldi	r16, 0x00	; 0
    49d4:	10 e0       	ldi	r17, 0x00	; 0
    49d6:	20 e8       	ldi	r18, 0x80	; 128
    49d8:	3f e3       	ldi	r19, 0x3F	; 63
    49da:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <radiansToSteps>
    49de:	8f cf       	rjmp	.-226    	; 0x48fe <commandMoveRel+0x22>

000049e0 <commandMoveAbs>:
}

/* ---------------------------------------------------------------------
    moves the motor to an absolute position
 --------------------------------------------------------------------- */
void commandMoveAbs(char* param0, char* param1, char* param2){
    49e0:	df 92       	push	r13
    49e2:	ef 92       	push	r14
    49e4:	ff 92       	push	r15
    49e6:	0f 93       	push	r16
    49e8:	1f 93       	push	r17
    49ea:	cf 93       	push	r28
    49ec:	df 93       	push	r29
    49ee:	eb 01       	movw	r28, r22
    49f0:	8a 01       	movw	r16, r20

  uint8_t i = 0;
  double actMotorPos = 0.0f;
  double posDiff = 0.0f;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    49f2:	60 e0       	ldi	r22, 0x00	; 0
    49f4:	70 e0       	ldi	r23, 0x00	; 0
    49f6:	4a e0       	ldi	r20, 0x0A	; 10
    49f8:	50 e0       	ldi	r21, 0x00	; 0
    49fa:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    49fe:	d6 2e       	mov	r13, r22

  if(i > MAX_MOTOR){
    4a00:	83 e0       	ldi	r24, 0x03	; 3
    4a02:	8d 15       	cp	r24, r13
    4a04:	40 f4       	brcc	.+16     	; 0x4a16 <commandMoveAbs+0x36>
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    4a06:	df 91       	pop	r29
    4a08:	cf 91       	pop	r28
    4a0a:	1f 91       	pop	r17
    4a0c:	0f 91       	pop	r16
    4a0e:	ff 90       	pop	r15
    4a10:	ef 90       	pop	r14
    4a12:	df 90       	pop	r13
    4a14:	08 95       	ret

  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    4a16:	c8 01       	movw	r24, r16
    4a18:	6f e1       	ldi	r22, 0x1F	; 31
    4a1a:	72 e0       	ldi	r23, 0x02	; 2
    4a1c:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4a20:	00 97       	sbiw	r24, 0x00	; 0
    4a22:	a1 f0       	breq	.+40     	; 0x4a4c <commandMoveAbs+0x6c>
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    4a24:	c8 01       	movw	r24, r16
    4a26:	65 e2       	ldi	r22, 0x25	; 37
    4a28:	72 e0       	ldi	r23, 0x02	; 2
    4a2a:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4a2e:	00 97       	sbiw	r24, 0x00	; 0
    4a30:	79 f1       	breq	.+94     	; 0x4a90 <commandMoveAbs+0xb0>
    actMotorPos = stepsToDegree(i, motor[i].actualPosition);
    posDiff = atof(param1) - actMotorPos;
    degreeToSteps(i, posDiff, 1.0);
  }
  else if(strcmp(param2, "pi") == 0){
    4a32:	c8 01       	movw	r24, r16
    4a34:	69 e2       	ldi	r22, 0x29	; 41
    4a36:	72 e0       	ldi	r23, 0x02	; 2
    4a38:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    4a3c:	00 97       	sbiw	r24, 0x00	; 0
    4a3e:	09 f4       	brne	.+2      	; 0x4a42 <commandMoveAbs+0x62>
    4a40:	50 c0       	rjmp	.+160    	; 0x4ae2 <commandMoveAbs+0x102>
    actMotorPos = stepsToRadian(i, motor[i].actualPosition);
    posDiff = atof(param1) - actMotorPos;
    radiansToSteps(i, posDiff, 1.0);
  }
  else{
    sendText("ERROR: unknown unit");
    4a42:	80 ea       	ldi	r24, 0xA0	; 160
    4a44:	92 e0       	ldi	r25, 0x02	; 2
    4a46:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    4a4a:	dd cf       	rjmp	.-70     	; 0x4a06 <commandMoveAbs+0x26>
  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
    4a4c:	ce 01       	movw	r24, r28
    4a4e:	60 e0       	ldi	r22, 0x00	; 0
    4a50:	70 e0       	ldi	r23, 0x00	; 0
    4a52:	4a e0       	ldi	r20, 0x0A	; 10
    4a54:	50 e0       	ldi	r21, 0x00	; 0
    4a56:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4a5a:	ed 2d       	mov	r30, r13
    4a5c:	f0 e0       	ldi	r31, 0x00	; 0
    4a5e:	ee 0f       	add	r30, r30
    4a60:	ff 1f       	adc	r31, r31
    4a62:	ee 0f       	add	r30, r30
    4a64:	ff 1f       	adc	r31, r31
    4a66:	9f 01       	movw	r18, r30
    4a68:	22 0f       	add	r18, r18
    4a6a:	33 1f       	adc	r19, r19
    4a6c:	22 0f       	add	r18, r18
    4a6e:	33 1f       	adc	r19, r19
    4a70:	e2 0f       	add	r30, r18
    4a72:	f3 1f       	adc	r31, r19
    4a74:	ee 0f       	add	r30, r30
    4a76:	ff 1f       	adc	r31, r31
    4a78:	ee 50       	subi	r30, 0x0E	; 14
    4a7a:	fc 4f       	sbci	r31, 0xFC	; 252
    4a7c:	71 83       	std	Z+1, r23	; 0x01
    4a7e:	60 83       	st	Z, r22
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    4a80:	df 91       	pop	r29
    4a82:	cf 91       	pop	r28
    4a84:	1f 91       	pop	r17
    4a86:	0f 91       	pop	r16
    4a88:	ff 90       	pop	r15
    4a8a:	ef 90       	pop	r14
    4a8c:	df 90       	pop	r13
    4a8e:	08 95       	ret

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    actMotorPos = stepsToDegree(i, motor[i].actualPosition);
    4a90:	ed 2d       	mov	r30, r13
    4a92:	f0 e0       	ldi	r31, 0x00	; 0
    4a94:	ee 0f       	add	r30, r30
    4a96:	ff 1f       	adc	r31, r31
    4a98:	ee 0f       	add	r30, r30
    4a9a:	ff 1f       	adc	r31, r31
    4a9c:	ee 0f       	add	r30, r30
    4a9e:	ff 1f       	adc	r31, r31
    4aa0:	cf 01       	movw	r24, r30
    4aa2:	88 0f       	add	r24, r24
    4aa4:	99 1f       	adc	r25, r25
    4aa6:	88 0f       	add	r24, r24
    4aa8:	99 1f       	adc	r25, r25
    4aaa:	e8 0f       	add	r30, r24
    4aac:	f9 1f       	adc	r31, r25
    4aae:	e0 51       	subi	r30, 0x10	; 16
    4ab0:	fc 4f       	sbci	r31, 0xFC	; 252
    4ab2:	60 81       	ld	r22, Z
    4ab4:	71 81       	ldd	r23, Z+1	; 0x01
    4ab6:	8d 2d       	mov	r24, r13
    4ab8:	0e 94 9e 07 	call	0xf3c	; 0xf3c <stepsToDegree>
    4abc:	7b 01       	movw	r14, r22
    4abe:	8c 01       	movw	r16, r24
    posDiff = atof(param1) - actMotorPos;
    4ac0:	ce 01       	movw	r24, r28
    4ac2:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    degreeToSteps(i, posDiff, 1.0);
    4ac6:	a8 01       	movw	r20, r16
    4ac8:	97 01       	movw	r18, r14
    4aca:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__subsf3>
    4ace:	ab 01       	movw	r20, r22
    4ad0:	bc 01       	movw	r22, r24
    4ad2:	8d 2d       	mov	r24, r13
    4ad4:	00 e0       	ldi	r16, 0x00	; 0
    4ad6:	10 e0       	ldi	r17, 0x00	; 0
    4ad8:	20 e8       	ldi	r18, 0x80	; 128
    4ada:	3f e3       	ldi	r19, 0x3F	; 63
    4adc:	0e 94 13 11 	call	0x2226	; 0x2226 <degreeToSteps>
    4ae0:	92 cf       	rjmp	.-220    	; 0x4a06 <commandMoveAbs+0x26>
  }
  else if(strcmp(param2, "pi") == 0){
    actMotorPos = stepsToRadian(i, motor[i].actualPosition);
    4ae2:	ed 2d       	mov	r30, r13
    4ae4:	f0 e0       	ldi	r31, 0x00	; 0
    4ae6:	ee 0f       	add	r30, r30
    4ae8:	ff 1f       	adc	r31, r31
    4aea:	ee 0f       	add	r30, r30
    4aec:	ff 1f       	adc	r31, r31
    4aee:	ee 0f       	add	r30, r30
    4af0:	ff 1f       	adc	r31, r31
    4af2:	cf 01       	movw	r24, r30
    4af4:	88 0f       	add	r24, r24
    4af6:	99 1f       	adc	r25, r25
    4af8:	88 0f       	add	r24, r24
    4afa:	99 1f       	adc	r25, r25
    4afc:	e8 0f       	add	r30, r24
    4afe:	f9 1f       	adc	r31, r25
    4b00:	e0 51       	subi	r30, 0x10	; 16
    4b02:	fc 4f       	sbci	r31, 0xFC	; 252
    4b04:	60 81       	ld	r22, Z
    4b06:	71 81       	ldd	r23, Z+1	; 0x01
    4b08:	8d 2d       	mov	r24, r13
    4b0a:	0e 94 23 08 	call	0x1046	; 0x1046 <stepsToRadian>
    4b0e:	7b 01       	movw	r14, r22
    4b10:	8c 01       	movw	r16, r24
    posDiff = atof(param1) - actMotorPos;
    4b12:	ce 01       	movw	r24, r28
    4b14:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    radiansToSteps(i, posDiff, 1.0);
    4b18:	a8 01       	movw	r20, r16
    4b1a:	97 01       	movw	r18, r14
    4b1c:	0e 94 39 3f 	call	0x7e72	; 0x7e72 <__subsf3>
    4b20:	ab 01       	movw	r20, r22
    4b22:	bc 01       	movw	r22, r24
    4b24:	8d 2d       	mov	r24, r13
    4b26:	00 e0       	ldi	r16, 0x00	; 0
    4b28:	10 e0       	ldi	r17, 0x00	; 0
    4b2a:	20 e8       	ldi	r18, 0x80	; 128
    4b2c:	3f e3       	ldi	r19, 0x3F	; 63
    4b2e:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <radiansToSteps>
    4b32:	69 cf       	rjmp	.-302    	; 0x4a06 <commandMoveAbs+0x26>

00004b34 <initBuffers>:

  uint8_t i,j;

  /* command parameters */
  for(j = 0; j < PARAMETER_LENGTH; j++){
    commandParam[i][j] = 0;
    4b34:	20 e0       	ldi	r18, 0x00	; 0
    4b36:	30 e0       	ldi	r19, 0x00	; 0
    4b38:	80 e0       	ldi	r24, 0x00	; 0
    4b3a:	90 e0       	ldi	r25, 0x00	; 0
    4b3c:	e0 91 d6 02 	lds	r30, 0x02D6
    4b40:	f0 91 d7 02 	lds	r31, 0x02D7
    4b44:	01 90       	ld	r0, Z+
    4b46:	f0 81       	ld	r31, Z
    4b48:	e0 2d       	mov	r30, r0
    4b4a:	e8 0f       	add	r30, r24
    4b4c:	f9 1f       	adc	r31, r25
    4b4e:	10 82       	st	Z, r1
    4b50:	01 96       	adiw	r24, 0x01	; 1
void initBuffers(void){

  uint8_t i,j;

  /* command parameters */
  for(j = 0; j < PARAMETER_LENGTH; j++){
    4b52:	84 31       	cpi	r24, 0x14	; 20
    4b54:	91 05       	cpc	r25, r1
    4b56:	91 f7       	brne	.-28     	; 0x4b3c <initBuffers+0x8>
    4b58:	80 e0       	ldi	r24, 0x00	; 0
    4b5a:	90 e0       	ldi	r25, 0x00	; 0
    commandParam[i][j] = 0;
  }

  /* buffers for the display */
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    menu.currentDisplayValue[i][j] = 0;
    4b5c:	e0 91 e6 02 	lds	r30, 0x02E6
    4b60:	f0 91 e7 02 	lds	r31, 0x02E7
    4b64:	e2 0f       	add	r30, r18
    4b66:	f3 1f       	adc	r31, r19
    4b68:	01 90       	ld	r0, Z+
    4b6a:	f0 81       	ld	r31, Z
    4b6c:	e0 2d       	mov	r30, r0
    4b6e:	e8 0f       	add	r30, r24
    4b70:	f9 1f       	adc	r31, r25
    4b72:	10 82       	st	Z, r1
    menu.newDisplayValue[i][j]     = 0;
    4b74:	e0 91 e8 02 	lds	r30, 0x02E8
    4b78:	f0 91 e9 02 	lds	r31, 0x02E9
    4b7c:	e2 0f       	add	r30, r18
    4b7e:	f3 1f       	adc	r31, r19
    4b80:	01 90       	ld	r0, Z+
    4b82:	f0 81       	ld	r31, Z
    4b84:	e0 2d       	mov	r30, r0
    4b86:	e8 0f       	add	r30, r24
    4b88:	f9 1f       	adc	r31, r25
    4b8a:	10 82       	st	Z, r1
    4b8c:	01 96       	adiw	r24, 0x01	; 1
  for(j = 0; j < PARAMETER_LENGTH; j++){
    commandParam[i][j] = 0;
  }

  /* buffers for the display */
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    4b8e:	89 30       	cpi	r24, 0x09	; 9
    4b90:	91 05       	cpc	r25, r1
    4b92:	21 f7       	brne	.-56     	; 0x4b5c <initBuffers+0x28>
    4b94:	80 e0       	ldi	r24, 0x00	; 0
    4b96:	90 e0       	ldi	r25, 0x00	; 0
    menu.currentDisplayValue[i][j] = 0;
    menu.newDisplayValue[i][j]     = 0;
  }

  for(j = 0; j < DISPLAY_MENU_STRING_LENGTH; j++){
    menu.currentMenuText[i][j] = 0;
    4b98:	e0 91 ea 02 	lds	r30, 0x02EA
    4b9c:	f0 91 eb 02 	lds	r31, 0x02EB
    4ba0:	e2 0f       	add	r30, r18
    4ba2:	f3 1f       	adc	r31, r19
    4ba4:	01 90       	ld	r0, Z+
    4ba6:	f0 81       	ld	r31, Z
    4ba8:	e0 2d       	mov	r30, r0
    4baa:	e8 0f       	add	r30, r24
    4bac:	f9 1f       	adc	r31, r25
    4bae:	10 82       	st	Z, r1
    menu.newMenuText[i][j]     = 0;
    4bb0:	e0 91 ec 02 	lds	r30, 0x02EC
    4bb4:	f0 91 ed 02 	lds	r31, 0x02ED
    4bb8:	e2 0f       	add	r30, r18
    4bba:	f3 1f       	adc	r31, r19
    4bbc:	01 90       	ld	r0, Z+
    4bbe:	f0 81       	ld	r31, Z
    4bc0:	e0 2d       	mov	r30, r0
    4bc2:	e8 0f       	add	r30, r24
    4bc4:	f9 1f       	adc	r31, r25
    4bc6:	10 82       	st	Z, r1
    4bc8:	01 96       	adiw	r24, 0x01	; 1
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    menu.currentDisplayValue[i][j] = 0;
    menu.newDisplayValue[i][j]     = 0;
  }

  for(j = 0; j < DISPLAY_MENU_STRING_LENGTH; j++){
    4bca:	81 31       	cpi	r24, 0x11	; 17
    4bcc:	91 05       	cpc	r25, r1
    4bce:	21 f7       	brne	.-56     	; 0x4b98 <initBuffers+0x64>
    menu.currentMenuText[i][j] = 0;
    menu.newMenuText[i][j]     = 0;
  }

  memset(rxString.buffer, 0, SERIAL_BUFFERSIZE);
    4bd0:	e0 91 ee 02 	lds	r30, 0x02EE
    4bd4:	f0 91 ef 02 	lds	r31, 0x02EF
    4bd8:	80 e4       	ldi	r24, 0x40	; 64
    4bda:	df 01       	movw	r26, r30
    4bdc:	98 2f       	mov	r25, r24
    4bde:	1d 92       	st	X+, r1
    4be0:	9a 95       	dec	r25
    4be2:	e9 f7       	brne	.-6      	; 0x4bde <initBuffers+0xaa>
  memset(txString.buffer, 0, SERIAL_BUFFERSIZE);
    4be4:	e0 91 e7 03 	lds	r30, 0x03E7
    4be8:	f0 91 e8 03 	lds	r31, 0x03E8
    4bec:	df 01       	movw	r26, r30
    4bee:	98 2f       	mov	r25, r24
    4bf0:	1d 92       	st	X+, r1
    4bf2:	9a 95       	dec	r25
    4bf4:	e9 f7       	brne	.-6      	; 0x4bf0 <initBuffers+0xbc>
  memset(commandString.buffer, 0, SERIAL_BUFFERSIZE);
    4bf6:	e0 91 90 04 	lds	r30, 0x0490
    4bfa:	f0 91 91 04 	lds	r31, 0x0491
    4bfe:	df 01       	movw	r26, r30
    4c00:	1d 92       	st	X+, r1
    4c02:	8a 95       	dec	r24
    4c04:	e9 f7       	brne	.-6      	; 0x4c00 <initBuffers+0xcc>
  memset(displayBuffer, 0, DISPLAY_BUFFER_SIZE);
    4c06:	e0 91 eb 03 	lds	r30, 0x03EB
    4c0a:	f0 91 ec 03 	lds	r31, 0x03EC
    4c0e:	88 e2       	ldi	r24, 0x28	; 40
    4c10:	df 01       	movw	r26, r30
    4c12:	1d 92       	st	X+, r1
    4c14:	8a 95       	dec	r24
    4c16:	e9 f7       	brne	.-6      	; 0x4c12 <initBuffers+0xde>

  return;
}
    4c18:	08 95       	ret

00004c1a <copyRXstring>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4c1a:	f8 94       	cli
    copy command to internal buffer
 --------------------------------------------------------------------- */
void copyRXstring(void){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    memcpy(commandString.buffer, rxString.buffer, SERIAL_BUFFERSIZE);
    4c1c:	80 91 90 04 	lds	r24, 0x0490
    4c20:	90 91 91 04 	lds	r25, 0x0491
    4c24:	20 91 ee 02 	lds	r18, 0x02EE
    4c28:	30 91 ef 02 	lds	r19, 0x02EF
    4c2c:	dc 01       	movw	r26, r24
    4c2e:	f9 01       	movw	r30, r18
    4c30:	80 e4       	ldi	r24, 0x40	; 64
    4c32:	01 90       	ld	r0, Z+
    4c34:	0d 92       	st	X+, r0
    4c36:	81 50       	subi	r24, 0x01	; 1
    4c38:	e1 f7       	brne	.-8      	; 0x4c32 <copyRXstring+0x18>
    commandString.readyToProcess = 1;
    4c3a:	81 e0       	ldi	r24, 0x01	; 1
    4c3c:	80 93 92 04 	sts	0x0492, r24

    memset(rxString.buffer, 0, SERIAL_BUFFERSIZE);
    4c40:	e0 91 ee 02 	lds	r30, 0x02EE
    4c44:	f0 91 ef 02 	lds	r31, 0x02EF
    4c48:	80 e4       	ldi	r24, 0x40	; 64
    4c4a:	df 01       	movw	r26, r30
    4c4c:	1d 92       	st	X+, r1
    4c4e:	8a 95       	dec	r24
    4c50:	e9 f7       	brne	.-6      	; 0x4c4c <copyRXstring+0x32>
    rxString.charCount = 0;
    4c52:	10 92 f1 02 	sts	0x02F1, r1
    rxString.readyToProcess = 0;
    4c56:	10 92 f0 02 	sts	0x02F0, r1
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4c5a:	78 94       	sei
  }

  return;
}
    4c5c:	08 95       	ret

00004c5e <getMotorCurrent>:
  float curr = 0.0;
  uint8_t addr = 0;
  uint16_t data = 0;
  uint8_t val = 0;

  addr = getDACAddress(mot);
    4c5e:	0e 94 9b 09 	call	0x1336	; 0x1336 <getDACAddress>

  IICread(addr, IIC.data, 2);
    4c62:	60 91 ed 03 	lds	r22, 0x03ED
    4c66:	70 91 ee 03 	lds	r23, 0x03EE
    4c6a:	42 e0       	ldi	r20, 0x02	; 2
    4c6c:	0e 94 48 3b 	call	0x7690	; 0x7690 <IICread>

  data |= (uint16_t)((IIC.data[0] << 8) & 0xFF00);  /* high byte */
    4c70:	e0 91 ed 03 	lds	r30, 0x03ED
    4c74:	f0 91 ee 03 	lds	r31, 0x03EE
  data |= (uint16_t)((IIC.data[1]) & 0x00FF);       /* low byte  */
    4c78:	a0 91 ed 03 	lds	r26, 0x03ED
    4c7c:	b0 91 ee 03 	lds	r27, 0x03EE
    4c80:	70 81       	ld	r23, Z
    4c82:	60 e0       	ldi	r22, 0x00	; 0
    4c84:	11 96       	adiw	r26, 0x01	; 1
    4c86:	2c 91       	ld	r18, X
    4c88:	30 e0       	ldi	r19, 0x00	; 0
    4c8a:	62 2b       	or	r22, r18
    4c8c:	73 2b       	or	r23, r19
    4c8e:	72 95       	swap	r23
    4c90:	62 95       	swap	r22
    4c92:	6f 70       	andi	r22, 0x0F	; 15
    4c94:	67 27       	eor	r22, r23
    4c96:	7f 70       	andi	r23, 0x0F	; 15
    4c98:	67 27       	eor	r22, r23
    4c9a:	70 e0       	ldi	r23, 0x00	; 0
    4c9c:	80 e0       	ldi	r24, 0x00	; 0
    4c9e:	90 e0       	ldi	r25, 0x00	; 0
    4ca0:	0e 94 3b 40 	call	0x8076	; 0x8076 <__floatunsisf>
    4ca4:	26 e6       	ldi	r18, 0x66	; 102
    4ca6:	36 e6       	ldi	r19, 0x66	; 102
    4ca8:	4a e9       	ldi	r20, 0x9A	; 154
    4caa:	52 e4       	ldi	r21, 0x42	; 66
    4cac:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>

  /* according to setMotorCurrent() max(val) = 193 */
  curr = ((float)val) / 77.2;

  return curr;
}
    4cb0:	08 95       	ret

00004cb2 <commandGetMotorCurrent>:
char* commandGetMotorCurrent(char* param0){

  uint8_t i = 0;
  double curr = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4cb2:	60 e0       	ldi	r22, 0x00	; 0
    4cb4:	70 e0       	ldi	r23, 0x00	; 0
    4cb6:	4a e0       	ldi	r20, 0x0A	; 10
    4cb8:	50 e0       	ldi	r21, 0x00	; 0
    4cba:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    4cbe:	64 30       	cpi	r22, 0x04	; 4
    4cc0:	78 f5       	brcc	.+94     	; 0x4d20 <commandGetMotorCurrent+0x6e>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    curr = getMotorCurrent(i);
    4cc2:	86 2f       	mov	r24, r22
    4cc4:	0e 94 2f 26 	call	0x4c5e	; 0x4c5e <getMotorCurrent>
    sprintf(txString.buffer, "%f", curr);
    4cc8:	20 91 e7 03 	lds	r18, 0x03E7
    4ccc:	30 91 e8 03 	lds	r19, 0x03E8
    4cd0:	ad b7       	in	r26, 0x3d	; 61
    4cd2:	be b7       	in	r27, 0x3e	; 62
    4cd4:	18 97       	sbiw	r26, 0x08	; 8
    4cd6:	0f b6       	in	r0, 0x3f	; 63
    4cd8:	f8 94       	cli
    4cda:	be bf       	out	0x3e, r27	; 62
    4cdc:	0f be       	out	0x3f, r0	; 63
    4cde:	ad bf       	out	0x3d, r26	; 61
    4ce0:	ed b7       	in	r30, 0x3d	; 61
    4ce2:	fe b7       	in	r31, 0x3e	; 62
    4ce4:	31 96       	adiw	r30, 0x01	; 1
    4ce6:	12 96       	adiw	r26, 0x02	; 2
    4ce8:	3c 93       	st	X, r19
    4cea:	2e 93       	st	-X, r18
    4cec:	11 97       	sbiw	r26, 0x01	; 1
    4cee:	2f e1       	ldi	r18, 0x1F	; 31
    4cf0:	31 e0       	ldi	r19, 0x01	; 1
    4cf2:	33 83       	std	Z+3, r19	; 0x03
    4cf4:	22 83       	std	Z+2, r18	; 0x02
    4cf6:	64 83       	std	Z+4, r22	; 0x04
    4cf8:	75 83       	std	Z+5, r23	; 0x05
    4cfa:	86 83       	std	Z+6, r24	; 0x06
    4cfc:	97 83       	std	Z+7, r25	; 0x07
    4cfe:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    4d02:	4d b7       	in	r20, 0x3d	; 61
    4d04:	5e b7       	in	r21, 0x3e	; 62
    4d06:	48 5f       	subi	r20, 0xF8	; 248
    4d08:	5f 4f       	sbci	r21, 0xFF	; 255
    4d0a:	0f b6       	in	r0, 0x3f	; 63
    4d0c:	f8 94       	cli
    4d0e:	5e bf       	out	0x3e, r21	; 62
    4d10:	0f be       	out	0x3f, r0	; 63
    4d12:	4d bf       	out	0x3d, r20	; 61
  }
  
  return txString.buffer;
    4d14:	20 91 e7 03 	lds	r18, 0x03E7
    4d18:	30 91 e8 03 	lds	r19, 0x03E8
}
    4d1c:	c9 01       	movw	r24, r18
    4d1e:	08 95       	ret
  double curr = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4d20:	80 91 e7 03 	lds	r24, 0x03E7
    4d24:	90 91 e8 03 	lds	r25, 0x03E8
    4d28:	00 d0       	rcall	.+0      	; 0x4d2a <commandGetMotorCurrent+0x78>
    4d2a:	00 d0       	rcall	.+0      	; 0x4d2c <commandGetMotorCurrent+0x7a>
    4d2c:	00 d0       	rcall	.+0      	; 0x4d2e <commandGetMotorCurrent+0x7c>
    4d2e:	ed b7       	in	r30, 0x3d	; 61
    4d30:	fe b7       	in	r31, 0x3e	; 62
    4d32:	31 96       	adiw	r30, 0x01	; 1
    4d34:	ad b7       	in	r26, 0x3d	; 61
    4d36:	be b7       	in	r27, 0x3e	; 62
    4d38:	12 96       	adiw	r26, 0x02	; 2
    4d3a:	9c 93       	st	X, r25
    4d3c:	8e 93       	st	-X, r24
    4d3e:	11 97       	sbiw	r26, 0x01	; 1
    4d40:	80 e0       	ldi	r24, 0x00	; 0
    4d42:	91 e0       	ldi	r25, 0x01	; 1
    4d44:	93 83       	std	Z+3, r25	; 0x03
    4d46:	82 83       	std	Z+2, r24	; 0x02
    4d48:	64 83       	std	Z+4, r22	; 0x04
    4d4a:	15 82       	std	Z+5, r1	; 0x05
    4d4c:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    4d50:	4d b7       	in	r20, 0x3d	; 61
    4d52:	5e b7       	in	r21, 0x3e	; 62
    4d54:	4a 5f       	subi	r20, 0xFA	; 250
    4d56:	5f 4f       	sbci	r21, 0xFF	; 255
    4d58:	0f b6       	in	r0, 0x3f	; 63
    4d5a:	f8 94       	cli
    4d5c:	5e bf       	out	0x3e, r21	; 62
    4d5e:	0f be       	out	0x3f, r0	; 63
    4d60:	4d bf       	out	0x3d, r20	; 61
  else{
    curr = getMotorCurrent(i);
    sprintf(txString.buffer, "%f", curr);
  }
  
  return txString.buffer;
    4d62:	20 91 e7 03 	lds	r18, 0x03E7
    4d66:	30 91 e8 03 	lds	r19, 0x03E8
}
    4d6a:	c9 01       	movw	r24, r18
    4d6c:	08 95       	ret

00004d6e <setMotorCurrent>:
}

/* ---------------------------------------------------------------------
   sets the motor current for DRV8825
 --------------------------------------------------------------------- */
void setMotorCurrent(uint8_t mot, float curr){
    4d6e:	df 92       	push	r13
    4d70:	ef 92       	push	r14
    4d72:	ff 92       	push	r15
    4d74:	0f 93       	push	r16
    4d76:	1f 93       	push	r17
    4d78:	d8 2e       	mov	r13, r24
    4d7a:	7a 01       	movw	r14, r20
    4d7c:	8b 01       	movw	r16, r22

  uint8_t addr = 0;
  uint8_t val = 0;
  //uint16_t reg = 0;

  if(curr < 0.0){
    4d7e:	cb 01       	movw	r24, r22
    4d80:	ba 01       	movw	r22, r20
    4d82:	20 e0       	ldi	r18, 0x00	; 0
    4d84:	30 e0       	ldi	r19, 0x00	; 0
    4d86:	40 e0       	ldi	r20, 0x00	; 0
    4d88:	50 e0       	ldi	r21, 0x00	; 0
    4d8a:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <__cmpsf2>
    4d8e:	88 23       	and	r24, r24
    4d90:	34 f1       	brlt	.+76     	; 0x4dde <setMotorCurrent+0x70>
    curr = 0.0;
  }

  if(curr > 2.5){ /* maximum for DRV8825: 2.5 Ampere */
    4d92:	c8 01       	movw	r24, r16
    4d94:	b7 01       	movw	r22, r14
    4d96:	20 e0       	ldi	r18, 0x00	; 0
    4d98:	30 e0       	ldi	r19, 0x00	; 0
    4d9a:	40 e2       	ldi	r20, 0x20	; 32
    4d9c:	50 e4       	ldi	r21, 0x40	; 64
    4d9e:	0e 94 40 41 	call	0x8280	; 0x8280 <__gesf2>
    4da2:	18 16       	cp	r1, r24
    4da4:	fc f4       	brge	.+62     	; 0x4de4 <setMotorCurrent+0x76>
    4da6:	0c e0       	ldi	r16, 0x0C	; 12
    4da8:	10 e1       	ldi	r17, 0x10	; 16
    curr = 2.5;
  }

  addr = getDACAddress(mot);
    4daa:	8d 2d       	mov	r24, r13
    4dac:	0e 94 9b 09 	call	0x1336	; 0x1336 <getDACAddress>
  /* 255 / 3.3V * 2.5A = 193 */
  /* 193 <=> 2.5 A, 193/2.5 = 77.2 */

  val = (uint8_t)floor(77.2 * curr);

  IIC.data[0] = (val & 0xF0) >> 4;
    4db0:	e0 91 ed 03 	lds	r30, 0x03ED
    4db4:	f0 91 ee 03 	lds	r31, 0x03EE
    4db8:	00 83       	st	Z, r16
  IIC.data[1] = (val & 0x0F) << 4;
    4dba:	e0 91 ed 03 	lds	r30, 0x03ED
    4dbe:	f0 91 ee 03 	lds	r31, 0x03EE
    4dc2:	11 83       	std	Z+1, r17	; 0x01

  IICwrite(addr, IIC.data, 2);
    4dc4:	60 91 ed 03 	lds	r22, 0x03ED
    4dc8:	70 91 ee 03 	lds	r23, 0x03EE
    4dcc:	42 e0       	ldi	r20, 0x02	; 2
    4dce:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>

  return;
}
    4dd2:	1f 91       	pop	r17
    4dd4:	0f 91       	pop	r16
    4dd6:	ff 90       	pop	r15
    4dd8:	ef 90       	pop	r14
    4dda:	df 90       	pop	r13
    4ddc:	08 95       	ret

  uint8_t addr = 0;
  uint8_t val = 0;
  //uint16_t reg = 0;

  if(curr < 0.0){
    4dde:	00 e0       	ldi	r16, 0x00	; 0
    4de0:	10 e0       	ldi	r17, 0x00	; 0
    4de2:	e3 cf       	rjmp	.-58     	; 0x4daa <setMotorCurrent+0x3c>
}

/* ---------------------------------------------------------------------
   sets the motor current for DRV8825
 --------------------------------------------------------------------- */
void setMotorCurrent(uint8_t mot, float curr){
    4de4:	c8 01       	movw	r24, r16
    4de6:	b7 01       	movw	r22, r14
    4de8:	26 e6       	ldi	r18, 0x66	; 102
    4dea:	36 e6       	ldi	r19, 0x66	; 102
    4dec:	4a e9       	ldi	r20, 0x9A	; 154
    4dee:	52 e4       	ldi	r21, 0x42	; 66
    4df0:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    4df4:	0e 94 78 40 	call	0x80f0	; 0x80f0 <floor>
    4df8:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
    4dfc:	06 2f       	mov	r16, r22
    4dfe:	02 95       	swap	r16
    4e00:	0f 70       	andi	r16, 0x0F	; 15
    4e02:	16 2f       	mov	r17, r22
    4e04:	12 95       	swap	r17
    4e06:	10 7f       	andi	r17, 0xF0	; 240
    4e08:	d0 cf       	rjmp	.-96     	; 0x4daa <setMotorCurrent+0x3c>

00004e0a <commandSetMotorCurrent>:
}

/* ---------------------------------------------------------------------
    sets the desired motor current
 --------------------------------------------------------------------- */
void commandSetMotorCurrent(char* param0, char* param1){
    4e0a:	1f 93       	push	r17
    4e0c:	cf 93       	push	r28
    4e0e:	df 93       	push	r29
    4e10:	eb 01       	movw	r28, r22
  
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4e12:	60 e0       	ldi	r22, 0x00	; 0
    4e14:	70 e0       	ldi	r23, 0x00	; 0
    4e16:	4a e0       	ldi	r20, 0x0A	; 10
    4e18:	50 e0       	ldi	r21, 0x00	; 0
    4e1a:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    4e1e:	16 2f       	mov	r17, r22
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    4e20:	64 30       	cpi	r22, 0x04	; 4
    4e22:	a0 f5       	brcc	.+104    	; 0x4e8c <commandSetMotorCurrent+0x82>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
  }
  else{
    motor[i].current = atof(param1);
    4e24:	ce 01       	movw	r24, r28
    4e26:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    4e2a:	e1 2f       	mov	r30, r17
    4e2c:	f0 e0       	ldi	r31, 0x00	; 0
    4e2e:	ee 0f       	add	r30, r30
    4e30:	ff 1f       	adc	r31, r31
    4e32:	ee 0f       	add	r30, r30
    4e34:	ff 1f       	adc	r31, r31
    4e36:	ee 0f       	add	r30, r30
    4e38:	ff 1f       	adc	r31, r31
    4e3a:	9f 01       	movw	r18, r30
    4e3c:	22 0f       	add	r18, r18
    4e3e:	33 1f       	adc	r19, r19
    4e40:	22 0f       	add	r18, r18
    4e42:	33 1f       	adc	r19, r19
    4e44:	e2 0f       	add	r30, r18
    4e46:	f3 1f       	adc	r31, r19
    4e48:	e0 51       	subi	r30, 0x10	; 16
    4e4a:	fc 4f       	sbci	r31, 0xFC	; 252
    4e4c:	63 a3       	std	Z+35, r22	; 0x23
    4e4e:	74 a3       	std	Z+36, r23	; 0x24
    4e50:	85 a3       	std	Z+37, r24	; 0x25
    4e52:	96 a3       	std	Z+38, r25	; 0x26
    setMotorCurrent(i, motor[i].current);
    4e54:	e1 2f       	mov	r30, r17
    4e56:	f0 e0       	ldi	r31, 0x00	; 0
    4e58:	ee 0f       	add	r30, r30
    4e5a:	ff 1f       	adc	r31, r31
    4e5c:	ee 0f       	add	r30, r30
    4e5e:	ff 1f       	adc	r31, r31
    4e60:	ee 0f       	add	r30, r30
    4e62:	ff 1f       	adc	r31, r31
    4e64:	cf 01       	movw	r24, r30
    4e66:	88 0f       	add	r24, r24
    4e68:	99 1f       	adc	r25, r25
    4e6a:	88 0f       	add	r24, r24
    4e6c:	99 1f       	adc	r25, r25
    4e6e:	e8 0f       	add	r30, r24
    4e70:	f9 1f       	adc	r31, r25
    4e72:	e0 51       	subi	r30, 0x10	; 16
    4e74:	fc 4f       	sbci	r31, 0xFC	; 252
    4e76:	43 a1       	ldd	r20, Z+35	; 0x23
    4e78:	54 a1       	ldd	r21, Z+36	; 0x24
    4e7a:	65 a1       	ldd	r22, Z+37	; 0x25
    4e7c:	76 a1       	ldd	r23, Z+38	; 0x26
    4e7e:	81 2f       	mov	r24, r17
    4e80:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <setMotorCurrent>
  }

  return;
}
    4e84:	df 91       	pop	r29
    4e86:	cf 91       	pop	r28
    4e88:	1f 91       	pop	r17
    4e8a:	08 95       	ret
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4e8c:	80 91 e7 03 	lds	r24, 0x03E7
    4e90:	90 91 e8 03 	lds	r25, 0x03E8
    4e94:	00 d0       	rcall	.+0      	; 0x4e96 <commandSetMotorCurrent+0x8c>
    4e96:	00 d0       	rcall	.+0      	; 0x4e98 <commandSetMotorCurrent+0x8e>
    4e98:	00 d0       	rcall	.+0      	; 0x4e9a <commandSetMotorCurrent+0x90>
    4e9a:	ed b7       	in	r30, 0x3d	; 61
    4e9c:	fe b7       	in	r31, 0x3e	; 62
    4e9e:	31 96       	adiw	r30, 0x01	; 1
    4ea0:	ad b7       	in	r26, 0x3d	; 61
    4ea2:	be b7       	in	r27, 0x3e	; 62
    4ea4:	12 96       	adiw	r26, 0x02	; 2
    4ea6:	9c 93       	st	X, r25
    4ea8:	8e 93       	st	-X, r24
    4eaa:	11 97       	sbiw	r26, 0x01	; 1
    4eac:	80 e0       	ldi	r24, 0x00	; 0
    4eae:	91 e0       	ldi	r25, 0x01	; 1
    4eb0:	93 83       	std	Z+3, r25	; 0x03
    4eb2:	82 83       	std	Z+2, r24	; 0x02
    4eb4:	14 83       	std	Z+4, r17	; 0x04
    4eb6:	15 82       	std	Z+5, r1	; 0x05
    4eb8:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    sendText(txString.buffer);
    4ebc:	80 91 e7 03 	lds	r24, 0x03E7
    4ec0:	90 91 e8 03 	lds	r25, 0x03E8
    4ec4:	2d b7       	in	r18, 0x3d	; 61
    4ec6:	3e b7       	in	r19, 0x3e	; 62
    4ec8:	2a 5f       	subi	r18, 0xFA	; 250
    4eca:	3f 4f       	sbci	r19, 0xFF	; 255
    4ecc:	0f b6       	in	r0, 0x3f	; 63
    4ece:	f8 94       	cli
    4ed0:	3e bf       	out	0x3e, r19	; 62
    4ed2:	0f be       	out	0x3f, r0	; 63
    4ed4:	2d bf       	out	0x3d, r18	; 61
    4ed6:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    motor[i].current = atof(param1);
    setMotorCurrent(i, motor[i].current);
  }

  return;
}
    4eda:	df 91       	pop	r29
    4edc:	cf 91       	pop	r28
    4ede:	1f 91       	pop	r17
    4ee0:	08 95       	ret

00004ee2 <initDAC>:
 --------------------------------------------------------------------- */
void initDAC(uint8_t mot){

  uint8_t addr = 0;

  addr = getDACAddress(mot);
    4ee2:	0e 94 9b 09 	call	0x1336	; 0x1336 <getDACAddress>
  IIC.data[0] = 0x00; IIC.data[1] = 0x00;
    4ee6:	e0 91 ed 03 	lds	r30, 0x03ED
    4eea:	f0 91 ee 03 	lds	r31, 0x03EE
    4eee:	10 82       	st	Z, r1
    4ef0:	e0 91 ed 03 	lds	r30, 0x03ED
    4ef4:	f0 91 ee 03 	lds	r31, 0x03EE
    4ef8:	11 82       	std	Z+1, r1	; 0x01
  IICwrite(addr, IIC.data, 2);
    4efa:	60 91 ed 03 	lds	r22, 0x03ED
    4efe:	70 91 ee 03 	lds	r23, 0x03EE
    4f02:	42 e0       	ldi	r20, 0x02	; 2
    4f04:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>

  return;
}
    4f08:	08 95       	ret

00004f0a <writePortExpanderRegister>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4f0a:	f8 94       	cli
   write port expander register
 --------------------------------------------------------------------- */
void writePortExpanderRegister(uint8_t addr, uint8_t reg, uint8_t val){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    IIC.data[0] = reg; IIC.data[1] = val;
    4f0c:	e0 91 ed 03 	lds	r30, 0x03ED
    4f10:	f0 91 ee 03 	lds	r31, 0x03EE
    4f14:	60 83       	st	Z, r22
    4f16:	e0 91 ed 03 	lds	r30, 0x03ED
    4f1a:	f0 91 ee 03 	lds	r31, 0x03EE
    4f1e:	41 83       	std	Z+1, r20	; 0x01
    IICwrite(addr, IIC.data, 2);
    4f20:	60 91 ed 03 	lds	r22, 0x03ED
    4f24:	70 91 ee 03 	lds	r23, 0x03EE
    4f28:	42 e0       	ldi	r20, 0x02	; 2
    4f2a:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4f2e:	78 94       	sei
  }

  return;
}
    4f30:	08 95       	ret

00004f32 <initPortExpander>:
====================================================================== */

/* ---------------------------------------------------------------------
   initialize I2C port expanders in byte mode
 --------------------------------------------------------------------- */
void initPortExpander(uint8_t addr){
    4f32:	0f 93       	push	r16
    4f34:	1f 93       	push	r17
    4f36:	18 2f       	mov	r17, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4f38:	f8 94       	cli

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    /*  register addr  |  register value   |       send it        */
    IIC.data[0] = IOCONA; IIC.data[1] = 0x20; IICwrite(addr, IIC.data, 2);
    4f3a:	e0 91 ed 03 	lds	r30, 0x03ED
    4f3e:	f0 91 ee 03 	lds	r31, 0x03EE
    4f42:	8a e0       	ldi	r24, 0x0A	; 10
    4f44:	80 83       	st	Z, r24
    4f46:	e0 91 ed 03 	lds	r30, 0x03ED
    4f4a:	f0 91 ee 03 	lds	r31, 0x03EE
    4f4e:	80 e2       	ldi	r24, 0x20	; 32
    4f50:	81 83       	std	Z+1, r24	; 0x01
    4f52:	60 91 ed 03 	lds	r22, 0x03ED
    4f56:	70 91 ee 03 	lds	r23, 0x03EE
    4f5a:	81 2f       	mov	r24, r17
    4f5c:	42 e0       	ldi	r20, 0x02	; 2
    4f5e:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>

    IIC.data[0] = IODIRA; IIC.data[1] = 0x00; IICwrite(addr, IIC.data, 2);
    4f62:	e0 91 ed 03 	lds	r30, 0x03ED
    4f66:	f0 91 ee 03 	lds	r31, 0x03EE
    4f6a:	10 82       	st	Z, r1
    4f6c:	e0 91 ed 03 	lds	r30, 0x03ED
    4f70:	f0 91 ee 03 	lds	r31, 0x03EE
    4f74:	11 82       	std	Z+1, r1	; 0x01
    4f76:	60 91 ed 03 	lds	r22, 0x03ED
    4f7a:	70 91 ee 03 	lds	r23, 0x03EE
    4f7e:	81 2f       	mov	r24, r17
    4f80:	42 e0       	ldi	r20, 0x02	; 2
    4f82:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>
    IIC.data[0] = IODIRB; IIC.data[1] = 0xFF; IICwrite(addr, IIC.data, 2);
    4f86:	e0 91 ed 03 	lds	r30, 0x03ED
    4f8a:	f0 91 ee 03 	lds	r31, 0x03EE
    4f8e:	81 e0       	ldi	r24, 0x01	; 1
    4f90:	80 83       	st	Z, r24
    4f92:	e0 91 ed 03 	lds	r30, 0x03ED
    4f96:	f0 91 ee 03 	lds	r31, 0x03EE
    4f9a:	8f ef       	ldi	r24, 0xFF	; 255
    4f9c:	81 83       	std	Z+1, r24	; 0x01
    4f9e:	60 91 ed 03 	lds	r22, 0x03ED
    4fa2:	70 91 ee 03 	lds	r23, 0x03EE
    4fa6:	81 2f       	mov	r24, r17
    4fa8:	42 e0       	ldi	r20, 0x02	; 2
    4faa:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>
    IIC.data[0] = GPINTENB; IIC.data[1] = 0x1D; IICwrite(addr, IIC.data, 2);
    4fae:	e0 91 ed 03 	lds	r30, 0x03ED
    4fb2:	f0 91 ee 03 	lds	r31, 0x03EE
    4fb6:	85 e0       	ldi	r24, 0x05	; 5
    4fb8:	80 83       	st	Z, r24
    4fba:	e0 91 ed 03 	lds	r30, 0x03ED
    4fbe:	f0 91 ee 03 	lds	r31, 0x03EE
    4fc2:	8d e1       	ldi	r24, 0x1D	; 29
    4fc4:	81 83       	std	Z+1, r24	; 0x01
    4fc6:	60 91 ed 03 	lds	r22, 0x03ED
    4fca:	70 91 ee 03 	lds	r23, 0x03EE
    4fce:	81 2f       	mov	r24, r17
    4fd0:	42 e0       	ldi	r20, 0x02	; 2
    4fd2:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>
    IIC.data[0] = DEFVALB; IIC.data[1] = 0x03; IICwrite(addr, IIC.data, 2);
    4fd6:	e0 91 ed 03 	lds	r30, 0x03ED
    4fda:	f0 91 ee 03 	lds	r31, 0x03EE
    4fde:	87 e0       	ldi	r24, 0x07	; 7
    4fe0:	80 83       	st	Z, r24
    4fe2:	e0 91 ed 03 	lds	r30, 0x03ED
    4fe6:	f0 91 ee 03 	lds	r31, 0x03EE
    4fea:	03 e0       	ldi	r16, 0x03	; 3
    4fec:	01 83       	std	Z+1, r16	; 0x01
    4fee:	60 91 ed 03 	lds	r22, 0x03ED
    4ff2:	70 91 ee 03 	lds	r23, 0x03EE
    4ff6:	81 2f       	mov	r24, r17
    4ff8:	42 e0       	ldi	r20, 0x02	; 2
    4ffa:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>
    IIC.data[0] = INTCONB; IIC.data[1] = 0x03; IICwrite(addr, IIC.data, 2);
    4ffe:	e0 91 ed 03 	lds	r30, 0x03ED
    5002:	f0 91 ee 03 	lds	r31, 0x03EE
    5006:	89 e0       	ldi	r24, 0x09	; 9
    5008:	80 83       	st	Z, r24
    500a:	e0 91 ed 03 	lds	r30, 0x03ED
    500e:	f0 91 ee 03 	lds	r31, 0x03EE
    5012:	01 83       	std	Z+1, r16	; 0x01
    5014:	60 91 ed 03 	lds	r22, 0x03ED
    5018:	70 91 ee 03 	lds	r23, 0x03EE
    501c:	81 2f       	mov	r24, r17
    501e:	42 e0       	ldi	r20, 0x02	; 2
    5020:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>
    IIC.data[0] = GPIOA; IIC.data[1] = 0x78; IICwrite(addr, IIC.data, 2);
    5024:	e0 91 ed 03 	lds	r30, 0x03ED
    5028:	f0 91 ee 03 	lds	r31, 0x03EE
    502c:	82 e1       	ldi	r24, 0x12	; 18
    502e:	80 83       	st	Z, r24
    5030:	e0 91 ed 03 	lds	r30, 0x03ED
    5034:	f0 91 ee 03 	lds	r31, 0x03EE
    5038:	88 e7       	ldi	r24, 0x78	; 120
    503a:	81 83       	std	Z+1, r24	; 0x01
    503c:	60 91 ed 03 	lds	r22, 0x03ED
    5040:	70 91 ee 03 	lds	r23, 0x03EE
    5044:	81 2f       	mov	r24, r17
    5046:	42 e0       	ldi	r20, 0x02	; 2
    5048:	0e 94 1b 3b 	call	0x7636	; 0x7636 <IICwrite>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    504c:	78 94       	sei
  }

  return;
}
    504e:	1f 91       	pop	r17
    5050:	0f 91       	pop	r16
    5052:	08 95       	ret

00005054 <readPortExpanderRegister>:
}

/* ---------------------------------------------------------------------
   read port expander register
 --------------------------------------------------------------------- */
uint8_t readPortExpanderRegister(uint8_t addr, uint8_t reg){
    5054:	0f 93       	push	r16
    5056:	1f 93       	push	r17
    5058:	08 2f       	mov	r16, r24
    505a:	16 2f       	mov	r17, r22
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    505c:	f8 94       	cli

  uint8_t val = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    IICstart();
    505e:	0e 94 ed 3a 	call	0x75da	; 0x75da <IICstart>
    if(IICgetStatus() != TW_START){
    5062:	0e 94 17 3b 	call	0x762e	; 0x762e <IICgetStatus>
      /* error handling */
    }

    IICsendByte(addr | TW_WRITE);
    5066:	80 2f       	mov	r24, r16
    5068:	0e 94 f9 3a 	call	0x75f2	; 0x75f2 <IICsendByte>
    if(IICgetStatus() !=  TW_MR_SLA_ACK){
    506c:	0e 94 17 3b 	call	0x762e	; 0x762e <IICgetStatus>
      /* error handling */
    }

    IICsendByte(reg);
    5070:	81 2f       	mov	r24, r17
    5072:	0e 94 f9 3a 	call	0x75f2	; 0x75f2 <IICsendByte>
    if(IICgetStatus() !=  TW_MR_SLA_ACK){
    5076:	0e 94 17 3b 	call	0x762e	; 0x762e <IICgetStatus>
      /* error handling */
    }

    IICstart();
    507a:	0e 94 ed 3a 	call	0x75da	; 0x75da <IICstart>
    if(IICgetStatus() != TW_START){
    507e:	0e 94 17 3b 	call	0x762e	; 0x762e <IICgetStatus>
      /* error handling */
    }

    IICsendByte(addr | TW_READ);
    5082:	80 2f       	mov	r24, r16
    5084:	81 60       	ori	r24, 0x01	; 1
    5086:	0e 94 f9 3a 	call	0x75f2	; 0x75f2 <IICsendByte>
    if(IICgetStatus() !=  TW_MR_SLA_ACK){
    508a:	0e 94 17 3b 	call	0x762e	; 0x762e <IICgetStatus>
      /* error handling */
    }

    val = IICreadNACK();
    508e:	0e 94 0d 3b 	call	0x761a	; 0x761a <IICreadNACK>
    5092:	18 2f       	mov	r17, r24
    if(IICgetStatus() !=  TW_MR_DATA_NACK){
    5094:	0e 94 17 3b 	call	0x762e	; 0x762e <IICgetStatus>
      /* error handling */
    }

    IICstop();
    5098:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <IICstop>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    509c:	78 94       	sei
  }

  return val;
}
    509e:	81 2f       	mov	r24, r17
    50a0:	1f 91       	pop	r17
    50a2:	0f 91       	pop	r16
    50a4:	08 95       	ret

000050a6 <__vector_1>:
}

/* ---------------------------------------------------------------------
    a button seems to be pressed ;-)
 --------------------------------------------------------------------- */
ISR(INT0_vect){
    50a6:	1f 92       	push	r1
    50a8:	0f 92       	push	r0
    50aa:	0f b6       	in	r0, 0x3f	; 63
    50ac:	0f 92       	push	r0
    50ae:	0b b6       	in	r0, 0x3b	; 59
    50b0:	0f 92       	push	r0
    50b2:	11 24       	eor	r1, r1
    50b4:	2f 93       	push	r18
    50b6:	3f 93       	push	r19
    50b8:	4f 93       	push	r20
    50ba:	5f 93       	push	r21
    50bc:	6f 93       	push	r22
    50be:	7f 93       	push	r23
    50c0:	8f 93       	push	r24
    50c2:	9f 93       	push	r25
    50c4:	af 93       	push	r26
    50c6:	bf 93       	push	r27
    50c8:	ef 93       	push	r30
    50ca:	ff 93       	push	r31
   
  //sendText("INT0");
  
  uint8_t regVal = 0;
  
  regVal = readPortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, INTCAP);
    50cc:	80 e4       	ldi	r24, 0x40	; 64
    50ce:	68 e0       	ldi	r22, 0x08	; 8
    50d0:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>
    50d4:	98 2f       	mov	r25, r24
  
  /* check if a button is actually in process */
  if(buttonState.readyToProcess){
    50d6:	80 91 de 02 	lds	r24, 0x02DE
    50da:	88 23       	and	r24, r24
    50dc:	29 f4       	brne	.+10     	; 0x50e8 <__vector_1+0x42>
    return;
  }
  else{
    buttonState.inputRegister = regVal;
    50de:	90 93 dc 02 	sts	0x02DC, r25
    buttonState.readyToProcess = 1;
    50e2:	81 e0       	ldi	r24, 0x01	; 1
    50e4:	80 93 de 02 	sts	0x02DE, r24
  }

}
    50e8:	ff 91       	pop	r31
    50ea:	ef 91       	pop	r30
    50ec:	bf 91       	pop	r27
    50ee:	af 91       	pop	r26
    50f0:	9f 91       	pop	r25
    50f2:	8f 91       	pop	r24
    50f4:	7f 91       	pop	r23
    50f6:	6f 91       	pop	r22
    50f8:	5f 91       	pop	r21
    50fa:	4f 91       	pop	r20
    50fc:	3f 91       	pop	r19
    50fe:	2f 91       	pop	r18
    5100:	0f 90       	pop	r0
    5102:	0b be       	out	0x3b, r0	; 59
    5104:	0f 90       	pop	r0
    5106:	0f be       	out	0x3f, r0	; 63
    5108:	0f 90       	pop	r0
    510a:	1f 90       	pop	r1
    510c:	18 95       	reti

0000510e <initManualOperatingButtons>:
   initializes all buttons and turns on the required interrupts
 --------------------------------------------------------------------- */
void initManualOperatingButtons(void){

  /* only for rotary encoder + its button */
  PORTC |= (1<<PC5)|(1<<PC4)|(1<<PC3);   /* set internal pull-ups */
    510e:	88 b1       	in	r24, 0x08	; 8
    5110:	88 63       	ori	r24, 0x38	; 56
    5112:	88 b9       	out	0x08, r24	; 8
  /* init port expander for buttons
   *
   * http://www.gammon.com.au/forum/?id=10945
   *
   */
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IOCON, 0x22);
    5114:	80 e4       	ldi	r24, 0x40	; 64
    5116:	65 e0       	ldi	r22, 0x05	; 5
    5118:	42 e2       	ldi	r20, 0x22	; 34
    511a:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IODIR, 0xFF);
    511e:	80 e4       	ldi	r24, 0x40	; 64
    5120:	60 e0       	ldi	r22, 0x00	; 0
    5122:	4f ef       	ldi	r20, 0xFF	; 255
    5124:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IPOL, 0xFF);
    5128:	80 e4       	ldi	r24, 0x40	; 64
    512a:	61 e0       	ldi	r22, 0x01	; 1
    512c:	4f ef       	ldi	r20, 0xFF	; 255
    512e:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPINTEN, 0xF8);
    5132:	80 e4       	ldi	r24, 0x40	; 64
    5134:	62 e0       	ldi	r22, 0x02	; 2
    5136:	48 ef       	ldi	r20, 0xF8	; 248
    5138:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, DEFVAL, 0x03);
    513c:	80 e4       	ldi	r24, 0x40	; 64
    513e:	63 e0       	ldi	r22, 0x03	; 3
    5140:	43 e0       	ldi	r20, 0x03	; 3
    5142:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, INTCON, 0x00);
    5146:	80 e4       	ldi	r24, 0x40	; 64
    5148:	64 e0       	ldi	r22, 0x04	; 4
    514a:	40 e0       	ldi	r20, 0x00	; 0
    514c:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPPU, 0xFF);
    5150:	80 e4       	ldi	r24, 0x40	; 64
    5152:	66 e0       	ldi	r22, 0x06	; 6
    5154:	4f ef       	ldi	r20, 0xFF	; 255
    5156:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  
  //read GPIO register to clear the interrupt
  uint8_t tmp = 0;
  tmp = readPortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPIO);
    515a:	80 e4       	ldi	r24, 0x40	; 64
    515c:	69 e0       	ldi	r22, 0x09	; 9
    515e:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>

  /* activate interrupt on INT0 (PD2) */
  EICRA |= (1<<ISC01)|(1<<ISC00);  /* rising edge causes interrupt */
    5162:	e9 e6       	ldi	r30, 0x69	; 105
    5164:	f0 e0       	ldi	r31, 0x00	; 0
    5166:	80 81       	ld	r24, Z
    5168:	83 60       	ori	r24, 0x03	; 3
    516a:	80 83       	st	Z, r24
  EIMSK |= (1<<INT0);   /* enable interrupt pin INT0 */
    516c:	e8 9a       	sbi	0x1d, 0	; 29

  /* set up a timer for button/rotary_encoder polling
   *
   * the 8-bit Timer/Counter0 is used for that
   */
  TCCR0A |= (1<<WGM01);   /* enable CTC */
    516e:	84 b5       	in	r24, 0x24	; 36
    5170:	82 60       	ori	r24, 0x02	; 2
    5172:	84 bd       	out	0x24, r24	; 36
  OCR0A   = 40;           /* 40 is an empirical value for best behavior of the rotEnc. */
    5174:	88 e2       	ldi	r24, 0x28	; 40
    5176:	87 bd       	out	0x27, r24	; 39
  TIMSK0 |= (1<<OCIE0A);  /* enable interrupt */
    5178:	ee e6       	ldi	r30, 0x6E	; 110
    517a:	f0 e0       	ldi	r31, 0x00	; 0
    517c:	80 81       	ld	r24, Z
    517e:	82 60       	ori	r24, 0x02	; 2
    5180:	80 83       	st	Z, r24
  TCNT0   = 0;
    5182:	16 bc       	out	0x26, r1	; 38

  /* start the timer/counter */
  TCCR0B |= (1<<CS02)|(1<<CS00);  /* prescaler = 1024 --> 51.2 us per cycle */
    5184:	85 b5       	in	r24, 0x25	; 37
    5186:	85 60       	ori	r24, 0x05	; 5
    5188:	85 bd       	out	0x25, r24	; 37

  return;
}
    518a:	08 95       	ret

0000518c <getMotorSens>:
}

/* ---------------------------------------------------------------------
     read motor port expander input pin
 --------------------------------------------------------------------- */
uint8_t getMotorSens(uint8_t mot, uint8_t sens){
    518c:	1f 93       	push	r17
    518e:	16 2f       	mov	r17, r22

  uint8_t addr = 0;
  uint8_t regval = 0;
  uint8_t state = 0;

  addr = getPortExpanderAddress(mot);
    5190:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
  regval = readPortExpanderRegister(addr, GPIOB);
    5194:	63 e1       	ldi	r22, 0x13	; 19
    5196:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>
    519a:	21 e0       	ldi	r18, 0x01	; 1
    519c:	30 e0       	ldi	r19, 0x00	; 0
    519e:	02 c0       	rjmp	.+4      	; 0x51a4 <getMotorSens+0x18>
    51a0:	22 0f       	add	r18, r18
    51a2:	33 1f       	adc	r19, r19
    51a4:	1a 95       	dec	r17
    51a6:	e2 f7       	brpl	.-8      	; 0x51a0 <getMotorSens+0x14>
    51a8:	82 23       	and	r24, r18
    51aa:	09 f0       	breq	.+2      	; 0x51ae <getMotorSens+0x22>
    51ac:	81 e0       	ldi	r24, 0x01	; 1
  else{
    state = 0;
  }

  return state;
}
    51ae:	1f 91       	pop	r17
    51b0:	08 95       	ret

000051b2 <commandIsConnected>:
}

/* ---------------------------------------------------------------------
    returns whether a motor is connected or not
 --------------------------------------------------------------------- */
char* commandIsConnected(char* param0){
    51b2:	1f 93       	push	r17

  uint8_t i = 0;
  //uint8_t mota = 0;
  //uint8_t motb = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    51b4:	60 e0       	ldi	r22, 0x00	; 0
    51b6:	70 e0       	ldi	r23, 0x00	; 0
    51b8:	4a e0       	ldi	r20, 0x0A	; 10
    51ba:	50 e0       	ldi	r21, 0x00	; 0
    51bc:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    51c0:	16 2f       	mov	r17, r22
  //motb = getMotorSens(i, PORTEXP_MOTOR_MOTB);
  
  //sprintf(txString.buffer, "\nmota=%d\nmotb=%d\n", mota, motb);
  //sendText(txString.buffer);

  if(i > MAX_MOTOR){
    51c2:	64 30       	cpi	r22, 0x04	; 4
    51c4:	20 f5       	brcc	.+72     	; 0x520e <commandIsConnected+0x5c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(getMotorSens(i, PORTEXP_MOTOR_MOTA) && getMotorSens(i, PORTEXP_MOTOR_MOTB)){
    51c6:	86 2f       	mov	r24, r22
    51c8:	65 e0       	ldi	r22, 0x05	; 5
    51ca:	0e 94 c6 28 	call	0x518c	; 0x518c <getMotorSens>
    51ce:	88 23       	and	r24, r24
    51d0:	79 f4       	brne	.+30     	; 0x51f0 <commandIsConnected+0x3e>
      sprintf(txString.buffer, "0"); //motor is not connected
    }
    else{
      sprintf(txString.buffer, "1"); //motor is connected
    51d2:	e0 91 e7 03 	lds	r30, 0x03E7
    51d6:	f0 91 e8 03 	lds	r31, 0x03E8
    51da:	81 e3       	ldi	r24, 0x31	; 49
    51dc:	90 e0       	ldi	r25, 0x00	; 0
    51de:	91 83       	std	Z+1, r25	; 0x01
    51e0:	80 83       	st	Z, r24
    }
  }

  return txString.buffer;
    51e2:	20 91 e7 03 	lds	r18, 0x03E7
    51e6:	30 91 e8 03 	lds	r19, 0x03E8
}
    51ea:	c9 01       	movw	r24, r18
    51ec:	1f 91       	pop	r17
    51ee:	08 95       	ret

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(getMotorSens(i, PORTEXP_MOTOR_MOTA) && getMotorSens(i, PORTEXP_MOTOR_MOTB)){
    51f0:	81 2f       	mov	r24, r17
    51f2:	66 e0       	ldi	r22, 0x06	; 6
    51f4:	0e 94 c6 28 	call	0x518c	; 0x518c <getMotorSens>
    51f8:	88 23       	and	r24, r24
    51fa:	59 f3       	breq	.-42     	; 0x51d2 <commandIsConnected+0x20>
      sprintf(txString.buffer, "0"); //motor is not connected
    51fc:	e0 91 e7 03 	lds	r30, 0x03E7
    5200:	f0 91 e8 03 	lds	r31, 0x03E8
    5204:	80 e3       	ldi	r24, 0x30	; 48
    5206:	90 e0       	ldi	r25, 0x00	; 0
    5208:	91 83       	std	Z+1, r25	; 0x01
    520a:	80 83       	st	Z, r24
    520c:	ea cf       	rjmp	.-44     	; 0x51e2 <commandIsConnected+0x30>
  
  //sprintf(txString.buffer, "\nmota=%d\nmotb=%d\n", mota, motb);
  //sendText(txString.buffer);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    520e:	80 91 e7 03 	lds	r24, 0x03E7
    5212:	90 91 e8 03 	lds	r25, 0x03E8
    5216:	00 d0       	rcall	.+0      	; 0x5218 <commandIsConnected+0x66>
    5218:	00 d0       	rcall	.+0      	; 0x521a <commandIsConnected+0x68>
    521a:	00 d0       	rcall	.+0      	; 0x521c <commandIsConnected+0x6a>
    521c:	ed b7       	in	r30, 0x3d	; 61
    521e:	fe b7       	in	r31, 0x3e	; 62
    5220:	31 96       	adiw	r30, 0x01	; 1
    5222:	ad b7       	in	r26, 0x3d	; 61
    5224:	be b7       	in	r27, 0x3e	; 62
    5226:	12 96       	adiw	r26, 0x02	; 2
    5228:	9c 93       	st	X, r25
    522a:	8e 93       	st	-X, r24
    522c:	11 97       	sbiw	r26, 0x01	; 1
    522e:	80 e0       	ldi	r24, 0x00	; 0
    5230:	91 e0       	ldi	r25, 0x01	; 1
    5232:	93 83       	std	Z+3, r25	; 0x03
    5234:	82 83       	std	Z+2, r24	; 0x02
    5236:	14 83       	std	Z+4, r17	; 0x04
    5238:	15 82       	std	Z+5, r1	; 0x05
    523a:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    523e:	8d b7       	in	r24, 0x3d	; 61
    5240:	9e b7       	in	r25, 0x3e	; 62
    5242:	06 96       	adiw	r24, 0x06	; 6
    5244:	0f b6       	in	r0, 0x3f	; 63
    5246:	f8 94       	cli
    5248:	9e bf       	out	0x3e, r25	; 62
    524a:	0f be       	out	0x3f, r0	; 63
    524c:	8d bf       	out	0x3d, r24	; 61
    else{
      sprintf(txString.buffer, "1"); //motor is connected
    }
  }

  return txString.buffer;
    524e:	20 91 e7 03 	lds	r18, 0x03E7
    5252:	30 91 e8 03 	lds	r19, 0x03E8
}
    5256:	c9 01       	movw	r24, r18
    5258:	1f 91       	pop	r17
    525a:	08 95       	ret

0000525c <wakeMotorUp>:
}

/* ---------------------------------------------------------------------
     get motor out of bed
 --------------------------------------------------------------------- */
void wakeMotorUp(uint8_t mot){
    525c:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    525e:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
    5262:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    5264:	62 e1       	ldi	r22, 0x12	; 18
    5266:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>

  regval |= (1<<PORTEXP_MOTOR_SLEEP);

  writePortExpanderRegister(addr, GPIOA, regval);
    526a:	48 2f       	mov	r20, r24
    526c:	40 62       	ori	r20, 0x20	; 32
    526e:	81 2f       	mov	r24, r17
    5270:	62 e1       	ldi	r22, 0x12	; 18
    5272:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5276:	80 e1       	ldi	r24, 0x10	; 16
    5278:	97 e2       	ldi	r25, 0x27	; 39
    527a:	01 97       	sbiw	r24, 0x01	; 1
    527c:	f1 f7       	brne	.-4      	; 0x527a <wakeMotorUp+0x1e>
  _delay_ms(2);

  return;
}
    527e:	1f 91       	pop	r17
    5280:	08 95       	ret

00005282 <setMotorSleep>:
}

/* ---------------------------------------------------------------------
     send motor to bed (active LOW)
 --------------------------------------------------------------------- */
void setMotorSleep(uint8_t mot){
    5282:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    5284:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
    5288:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    528a:	62 e1       	ldi	r22, 0x12	; 18
    528c:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>

  regval &= ~(1<<PORTEXP_MOTOR_SLEEP);

  writePortExpanderRegister(addr, GPIOA, regval);
    5290:	48 2f       	mov	r20, r24
    5292:	4f 7d       	andi	r20, 0xDF	; 223
    5294:	81 2f       	mov	r24, r17
    5296:	62 e1       	ldi	r22, 0x12	; 18
    5298:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>

  return;
}
    529c:	1f 91       	pop	r17
    529e:	08 95       	ret

000052a0 <resetMotorLogic>:
     resets the internal motor logic (active LOW):
     - step table
     - home position
     - disables H-bridges
 --------------------------------------------------------------------- */
void resetMotorLogic(uint8_t mot){
    52a0:	0f 93       	push	r16
    52a2:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    52a4:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
    52a8:	08 2f       	mov	r16, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    52aa:	62 e1       	ldi	r22, 0x12	; 18
    52ac:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>

  regval &= ~(1<<PORTEXP_MOTOR_RESET);
    52b0:	18 2f       	mov	r17, r24
    52b2:	1f 7b       	andi	r17, 0xBF	; 191
  writePortExpanderRegister(addr, GPIOA, regval);
    52b4:	80 2f       	mov	r24, r16
    52b6:	62 e1       	ldi	r22, 0x12	; 18
    52b8:	41 2f       	mov	r20, r17
    52ba:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  regval |= (1<<PORTEXP_MOTOR_RESET);
  writePortExpanderRegister(addr, GPIOA, regval);
    52be:	10 64       	ori	r17, 0x40	; 64
    52c0:	80 2f       	mov	r24, r16
    52c2:	62 e1       	ldi	r22, 0x12	; 18
    52c4:	41 2f       	mov	r20, r17
    52c6:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>

  return;
}
    52ca:	1f 91       	pop	r17
    52cc:	0f 91       	pop	r16
    52ce:	08 95       	ret

000052d0 <motorZeroRun>:
/* ---------------------------------------------------------------------
    zero run: position calibration for the motor.
    After zero run motor will have the fast axis position of any
    wave plate.
 --------------------------------------------------------------------- */
void motorZeroRun(uint8_t i){
    52d0:	2f 92       	push	r2
    52d2:	3f 92       	push	r3
    52d4:	4f 92       	push	r4
    52d6:	5f 92       	push	r5
    52d8:	6f 92       	push	r6
    52da:	7f 92       	push	r7
    52dc:	8f 92       	push	r8
    52de:	9f 92       	push	r9
    52e0:	bf 92       	push	r11
    52e2:	cf 92       	push	r12
    52e4:	df 92       	push	r13
    52e6:	ef 92       	push	r14
    52e8:	ff 92       	push	r15
    52ea:	0f 93       	push	r16
    52ec:	1f 93       	push	r17
    52ee:	cf 93       	push	r28
    52f0:	df 93       	push	r29
    52f2:	b8 2e       	mov	r11, r24
  uint16_t keepWaitTime = 0;
  double stepsPerRound = 0.0f;
  //uint16_t thres = 50;  /* threshold for the ADC reading of the Hall sensor */
  uint16_t j = 0;

  if(forbiddenZone[i].active){
    52f4:	88 2e       	mov	r8, r24
    52f6:	99 24       	eor	r9, r9
    52f8:	24 01       	movw	r4, r8
    52fa:	44 0c       	add	r4, r4
    52fc:	55 1c       	adc	r5, r5
    52fe:	44 0c       	add	r4, r4
    5300:	55 1c       	adc	r5, r5
    5302:	f2 01       	movw	r30, r4
    5304:	e8 0d       	add	r30, r8
    5306:	f9 1d       	adc	r31, r9
    5308:	ed 52       	subi	r30, 0x2D	; 45
    530a:	fc 4f       	sbci	r31, 0xFC	; 252
    530c:	84 81       	ldd	r24, Z+4	; 0x04
    530e:	88 23       	and	r24, r24
    5310:	09 f0       	breq	.+2      	; 0x5314 <motorZeroRun+0x44>
    5312:	c8 c0       	rjmp	.+400    	; 0x54a4 <motorZeroRun+0x1d4>
    /* zerorun not allowed if forbidden zone is active */
    return;
  }

  /* stop any motor movements (stop timer/counter2) */
  TCCR2B &= ~0x07;
    5314:	80 91 b1 00 	lds	r24, 0x00B1
    5318:	88 7f       	andi	r24, 0xF8	; 248
    531a:	80 93 b1 00 	sts	0x00B1, r24

  keepWaitTime = motor[i].waitBetweenSteps;
    531e:	34 01       	movw	r6, r8
    5320:	66 0c       	add	r6, r6
    5322:	77 1c       	adc	r7, r7
    5324:	66 0c       	add	r6, r6
    5326:	77 1c       	adc	r7, r7
    5328:	66 0c       	add	r6, r6
    532a:	77 1c       	adc	r7, r7
    532c:	83 01       	movw	r16, r6
    532e:	00 0f       	add	r16, r16
    5330:	11 1f       	adc	r17, r17
    5332:	00 0f       	add	r16, r16
    5334:	11 1f       	adc	r17, r17
    5336:	06 0d       	add	r16, r6
    5338:	17 1d       	adc	r17, r7
    533a:	00 51       	subi	r16, 0x10	; 16
    533c:	1c 4f       	sbci	r17, 0xFC	; 252
    533e:	f8 01       	movw	r30, r16
    5340:	26 8c       	ldd	r2, Z+30	; 0x1e
    5342:	37 8c       	ldd	r3, Z+31	; 0x1f

  stepsPerRound = motor[i].stepsPerFullRotation
    5344:	61 89       	ldd	r22, Z+17	; 0x11
    5346:	72 89       	ldd	r23, Z+18	; 0x12
    5348:	83 89       	ldd	r24, Z+19	; 0x13
    534a:	94 89       	ldd	r25, Z+20	; 0x14
    534c:	25 85       	ldd	r18, Z+13	; 0x0d
    534e:	36 85       	ldd	r19, Z+14	; 0x0e
    5350:	47 85       	ldd	r20, Z+15	; 0x0f
    5352:	50 89       	ldd	r21, Z+16	; 0x10
    5354:	c5 88       	ldd	r12, Z+21	; 0x15
    5356:	d6 88       	ldd	r13, Z+22	; 0x16
    5358:	e7 88       	ldd	r14, Z+23	; 0x17
    535a:	f0 8c       	ldd	r15, Z+24	; 0x18
    535c:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    5360:	a7 01       	movw	r20, r14
    5362:	96 01       	movw	r18, r12
    5364:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    5368:	6b 01       	movw	r12, r22
    536a:	7c 01       	movw	r14, r24
                  * motor[i].subSteps;

  /* fist step:
   * move 360 degree to find the roughly position of the magnetic zero point.
   * this will be done with fast moving */
  motor[i].waitBetweenSteps = 1;    /* set 1 ms for fast moving */
    536c:	81 e0       	ldi	r24, 0x01	; 1
    536e:	90 e0       	ldi	r25, 0x00	; 0
    5370:	f8 01       	movw	r30, r16
    5372:	97 8f       	std	Z+31, r25	; 0x1f
    5374:	86 8f       	std	Z+30, r24	; 0x1e
    5376:	05 c0       	rjmp	.+10     	; 0x5382 <motorZeroRun+0xb2>

  /* in case we are at any possible zero position: move out */
  //while(getADCvalue(i) < thres){
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, -200);
    5378:	8b 2d       	mov	r24, r11
    537a:	68 e3       	ldi	r22, 0x38	; 56
    537c:	7f ef       	ldi	r23, 0xFF	; 255
    537e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
   * this will be done with fast moving */
  motor[i].waitBetweenSteps = 1;    /* set 1 ms for fast moving */

  /* in case we are at any possible zero position: move out */
  //while(getADCvalue(i) < thres){
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    5382:	8b 2d       	mov	r24, r11
    5384:	64 e0       	ldi	r22, 0x04	; 4
    5386:	0e 94 c6 28 	call	0x518c	; 0x518c <getMotorSens>
    538a:	88 23       	and	r24, r24
    538c:	a9 f7       	brne	.-22     	; 0x5378 <motorZeroRun+0xa8>
/* ---------------------------------------------------------------------
    zero run: position calibration for the motor.
    After zero run motor will have the fast axis position of any
    wave plate.
 --------------------------------------------------------------------- */
void motorZeroRun(uint8_t i){
    538e:	c7 01       	movw	r24, r14
    5390:	b6 01       	movw	r22, r12
    5392:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    5396:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
    539a:	8b 01       	movw	r16, r22
    539c:	c0 e0       	ldi	r28, 0x00	; 0
    539e:	d0 e0       	ldi	r29, 0x00	; 0
    53a0:	0c c0       	rjmp	.+24     	; 0x53ba <motorZeroRun+0xea>
    moveMotorRelative(i, -200);
  }

  /* start first search for zero point */
  for(j = 0; j < (uint16_t)round(stepsPerRound); j++){
    moveMotorRelative(i, 1);
    53a2:	8b 2d       	mov	r24, r11
    53a4:	61 e0       	ldi	r22, 0x01	; 1
    53a6:	70 e0       	ldi	r23, 0x00	; 0
    53a8:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
    //if(getADCvalue(i) < thres){
	if(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    53ac:	8b 2d       	mov	r24, r11
    53ae:	64 e0       	ldi	r22, 0x04	; 4
    53b0:	0e 94 c6 28 	call	0x518c	; 0x518c <getMotorSens>
    53b4:	88 23       	and	r24, r24
    53b6:	21 f4       	brne	.+8      	; 0x53c0 <motorZeroRun+0xf0>
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, -200);
  }

  /* start first search for zero point */
  for(j = 0; j < (uint16_t)round(stepsPerRound); j++){
    53b8:	21 96       	adiw	r28, 0x01	; 1
    53ba:	c0 17       	cp	r28, r16
    53bc:	d1 07       	cpc	r29, r17
    53be:	88 f3       	brcs	.-30     	; 0x53a2 <motorZeroRun+0xd2>
      break;
    }
  }

  /* move 90 degree forward */
  moveMotorRelative(i, (int16_t)round(0.25*stepsPerRound));
    53c0:	c7 01       	movw	r24, r14
    53c2:	b6 01       	movw	r22, r12
    53c4:	20 e0       	ldi	r18, 0x00	; 0
    53c6:	30 e0       	ldi	r19, 0x00	; 0
    53c8:	40 e8       	ldi	r20, 0x80	; 128
    53ca:	5e e3       	ldi	r21, 0x3E	; 62
    53cc:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    53d0:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    53d4:	0e 94 0a 40 	call	0x8014	; 0x8014 <__fixsfsi>
    53d8:	9b 01       	movw	r18, r22
    53da:	ac 01       	movw	r20, r24
    53dc:	8b 2d       	mov	r24, r11
    53de:	b9 01       	movw	r22, r18
    53e0:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
  /* second step:
   * move again to 200 steps before the former found zero position fast.
   * then move slowly to find the exact magnetic zero position. */

  /* now move till 200 steps before the zero-position */
  moveMotorRelative(i, (int16_t)round(0.75*stepsPerRound) - 200);
    53e4:	c7 01       	movw	r24, r14
    53e6:	b6 01       	movw	r22, r12
    53e8:	20 e0       	ldi	r18, 0x00	; 0
    53ea:	30 e0       	ldi	r19, 0x00	; 0
    53ec:	40 e4       	ldi	r20, 0x40	; 64
    53ee:	5f e3       	ldi	r21, 0x3F	; 63
    53f0:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    53f4:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    53f8:	0e 94 0a 40 	call	0x8014	; 0x8014 <__fixsfsi>
    53fc:	9b 01       	movw	r18, r22
    53fe:	ac 01       	movw	r20, r24
    5400:	28 5c       	subi	r18, 0xC8	; 200
    5402:	30 40       	sbci	r19, 0x00	; 0
    5404:	8b 2d       	mov	r24, r11
    5406:	b9 01       	movw	r22, r18
    5408:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>

  /* now get slow to find zero position precisely */
  motor[i].waitBetweenSteps = 5;
    540c:	f3 01       	movw	r30, r6
    540e:	ee 0f       	add	r30, r30
    5410:	ff 1f       	adc	r31, r31
    5412:	ee 0f       	add	r30, r30
    5414:	ff 1f       	adc	r31, r31
    5416:	e6 0d       	add	r30, r6
    5418:	f7 1d       	adc	r31, r7
    541a:	e0 51       	subi	r30, 0x10	; 16
    541c:	fc 4f       	sbci	r31, 0xFC	; 252
    541e:	85 e0       	ldi	r24, 0x05	; 5
    5420:	90 e0       	ldi	r25, 0x00	; 0
    5422:	97 8f       	std	Z+31, r25	; 0x1f
    5424:	86 8f       	std	Z+30, r24	; 0x1e
    5426:	05 c0       	rjmp	.+10     	; 0x5432 <motorZeroRun+0x162>

  /* and move till the threshold is reached */
  //while(getADCvalue(i) > thres){
  while(!getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, 1);
    5428:	8b 2d       	mov	r24, r11
    542a:	61 e0       	ldi	r22, 0x01	; 1
    542c:	70 e0       	ldi	r23, 0x00	; 0
    542e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
  /* now get slow to find zero position precisely */
  motor[i].waitBetweenSteps = 5;

  /* and move till the threshold is reached */
  //while(getADCvalue(i) > thres){
  while(!getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    5432:	8b 2d       	mov	r24, r11
    5434:	64 e0       	ldi	r22, 0x04	; 4
    5436:	0e 94 c6 28 	call	0x518c	; 0x518c <getMotorSens>
    543a:	88 23       	and	r24, r24
    543c:	a9 f3       	breq	.-22     	; 0x5428 <motorZeroRun+0x158>
  }
  /* and here we found our magnetic zero position :-) */

  /* third step:
   * go to the internal saved optical zero position */
  motor[i].waitBetweenSteps = keepWaitTime;
    543e:	83 01       	movw	r16, r6
    5440:	00 0f       	add	r16, r16
    5442:	11 1f       	adc	r17, r17
    5444:	00 0f       	add	r16, r16
    5446:	11 1f       	adc	r17, r17
    5448:	06 0d       	add	r16, r6
    544a:	17 1d       	adc	r17, r7
    544c:	00 51       	subi	r16, 0x10	; 16
    544e:	1c 4f       	sbci	r17, 0xFC	; 252
    5450:	f8 01       	movw	r30, r16
    5452:	37 8e       	std	Z+31, r3	; 0x1f
    5454:	26 8e       	std	Z+30, r2	; 0x1e
  moveMotorRelative(i, motor[i].opticalZeroPosition);
    5456:	88 0c       	add	r8, r8
    5458:	99 1c       	adc	r9, r9
    545a:	86 0c       	add	r8, r6
    545c:	97 1c       	adc	r9, r7
    545e:	88 0c       	add	r8, r8
    5460:	99 1c       	adc	r9, r9
    5462:	88 0c       	add	r8, r8
    5464:	99 1c       	adc	r9, r9
    5466:	84 ef       	ldi	r24, 0xF4	; 244
    5468:	93 e0       	ldi	r25, 0x03	; 3
    546a:	88 0e       	add	r8, r24
    546c:	99 1e       	adc	r9, r25
    546e:	f4 01       	movw	r30, r8
    5470:	60 81       	ld	r22, Z
    5472:	71 81       	ldd	r23, Z+1	; 0x01
    5474:	8b 2d       	mov	r24, r11
    5476:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>

  /* now set motor into a defined state */
  motor[i].actualPosition = 0;
    547a:	f8 01       	movw	r30, r16
    547c:	11 82       	std	Z+1, r1	; 0x01
    547e:	10 82       	st	Z, r1
  motor[i].desiredPosition = 0;
    5480:	f2 01       	movw	r30, r4
    5482:	ee 0f       	add	r30, r30
    5484:	ff 1f       	adc	r31, r31
    5486:	ee 0f       	add	r30, r30
    5488:	ff 1f       	adc	r31, r31
    548a:	e4 0d       	add	r30, r4
    548c:	f5 1d       	adc	r31, r5
    548e:	ee 0f       	add	r30, r30
    5490:	ff 1f       	adc	r31, r31
    5492:	ee 50       	subi	r30, 0x0E	; 14
    5494:	fc 4f       	sbci	r31, 0xFC	; 252
    5496:	11 82       	std	Z+1, r1	; 0x01
    5498:	10 82       	st	Z, r1

  resetMotorLogic(i);
    549a:	8b 2d       	mov	r24, r11
    549c:	0e 94 50 29 	call	0x52a0	; 0x52a0 <resetMotorLogic>

  /* allow motor movements again */
  initMotorDelayTimer();
    54a0:	0e 94 c3 05 	call	0xb86	; 0xb86 <initMotorDelayTimer>

  return;
}
    54a4:	df 91       	pop	r29
    54a6:	cf 91       	pop	r28
    54a8:	1f 91       	pop	r17
    54aa:	0f 91       	pop	r16
    54ac:	ff 90       	pop	r15
    54ae:	ef 90       	pop	r14
    54b0:	df 90       	pop	r13
    54b2:	cf 90       	pop	r12
    54b4:	bf 90       	pop	r11
    54b6:	9f 90       	pop	r9
    54b8:	8f 90       	pop	r8
    54ba:	7f 90       	pop	r7
    54bc:	6f 90       	pop	r6
    54be:	5f 90       	pop	r5
    54c0:	4f 90       	pop	r4
    54c2:	3f 90       	pop	r3
    54c4:	2f 90       	pop	r2
    54c6:	08 95       	ret

000054c8 <setMotorDecay>:
}

/* ---------------------------------------------------------------------
     sets the motor decay (SLOW = 0, FAST = 1, MIXED = 2)
 --------------------------------------------------------------------- */
void setMotorDecay(uint8_t mot, uint8_t state){
    54c8:	ff 92       	push	r15
    54ca:	0f 93       	push	r16
    54cc:	1f 93       	push	r17
    54ce:	f6 2e       	mov	r15, r22

  uint8_t addr = 0;
  uint8_t regval = 0;
  uint8_t iodir = 0;

  addr = getPortExpanderAddress(mot);
    54d0:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
    54d4:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    54d6:	62 e1       	ldi	r22, 0x12	; 18
    54d8:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>
    54dc:	08 2f       	mov	r16, r24
  iodir = readPortExpanderRegister(addr, IODIRA);
    54de:	81 2f       	mov	r24, r17
    54e0:	60 e0       	ldi	r22, 0x00	; 0
    54e2:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>

  if(state == 1){ //fast decay
    54e6:	91 e0       	ldi	r25, 0x01	; 1
    54e8:	f9 16       	cp	r15, r25
    54ea:	a9 f0       	breq	.+42     	; 0x5516 <setMotorDecay+0x4e>
    regval |= (1<<PORTEXP_MOTOR_DECAY);
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
  }
  else if(state == 2){ //mixed decay
    54ec:	92 e0       	ldi	r25, 0x02	; 2
    54ee:	f9 16       	cp	r15, r25
    54f0:	b9 f0       	breq	.+46     	; 0x5520 <setMotorDecay+0x58>
    iodir  |= (1<<PORTEXP_MOTOR_DECAY); //set as input so pin is "open"
  }
  else{ //slow decay
    regval &= ~(1<<PORTEXP_MOTOR_DECAY);
    54f2:	0f 7e       	andi	r16, 0xEF	; 239
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
    54f4:	3f ee       	ldi	r19, 0xEF	; 239
    54f6:	f3 2e       	mov	r15, r19
    54f8:	f8 22       	and	r15, r24
  }

  writePortExpanderRegister(addr, GPIOA, regval);
    54fa:	81 2f       	mov	r24, r17
    54fc:	62 e1       	ldi	r22, 0x12	; 18
    54fe:	40 2f       	mov	r20, r16
    5500:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  writePortExpanderRegister(addr, IODIRA, iodir);
    5504:	81 2f       	mov	r24, r17
    5506:	60 e0       	ldi	r22, 0x00	; 0
    5508:	4f 2d       	mov	r20, r15
    550a:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>

  return;
}
    550e:	1f 91       	pop	r17
    5510:	0f 91       	pop	r16
    5512:	ff 90       	pop	r15
    5514:	08 95       	ret
  addr = getPortExpanderAddress(mot);
  regval = readPortExpanderRegister(addr, GPIOA);
  iodir = readPortExpanderRegister(addr, IODIRA);

  if(state == 1){ //fast decay
    regval |= (1<<PORTEXP_MOTOR_DECAY);
    5516:	00 61       	ori	r16, 0x10	; 16
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
    5518:	5f ee       	ldi	r21, 0xEF	; 239
    551a:	f5 2e       	mov	r15, r21
    551c:	f8 22       	and	r15, r24
    551e:	ed cf       	rjmp	.-38     	; 0x54fa <setMotorDecay+0x32>
  }
  else if(state == 2){ //mixed decay
    iodir  |= (1<<PORTEXP_MOTOR_DECAY); //set as input so pin is "open"
    5520:	40 e1       	ldi	r20, 0x10	; 16
    5522:	f4 2e       	mov	r15, r20
    5524:	f8 2a       	or	r15, r24
    5526:	e9 cf       	rjmp	.-46     	; 0x54fa <setMotorDecay+0x32>

00005528 <commandSetMotorDecay>:
}

/* ---------------------------------------------------------------------
    sets the desired motor decay
 --------------------------------------------------------------------- */
void commandSetMotorDecay(char* param0, char* param1){
    5528:	1f 93       	push	r17
    552a:	cf 93       	push	r28
    552c:	df 93       	push	r29
    552e:	eb 01       	movw	r28, r22
  
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    5530:	60 e0       	ldi	r22, 0x00	; 0
    5532:	70 e0       	ldi	r23, 0x00	; 0
    5534:	4a e0       	ldi	r20, 0x0A	; 10
    5536:	50 e0       	ldi	r21, 0x00	; 0
    5538:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    553c:	16 2f       	mov	r17, r22
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    553e:	64 30       	cpi	r22, 0x04	; 4
    5540:	80 f5       	brcc	.+96     	; 0x55a2 <commandSetMotorDecay+0x7a>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
  }
  else{
    motor[i].decay = atof(param1);
    5542:	ce 01       	movw	r24, r28
    5544:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    5548:	0e 94 0a 40 	call	0x8014	; 0x8014 <__fixsfsi>
    554c:	e1 2f       	mov	r30, r17
    554e:	f0 e0       	ldi	r31, 0x00	; 0
    5550:	ee 0f       	add	r30, r30
    5552:	ff 1f       	adc	r31, r31
    5554:	ee 0f       	add	r30, r30
    5556:	ff 1f       	adc	r31, r31
    5558:	ee 0f       	add	r30, r30
    555a:	ff 1f       	adc	r31, r31
    555c:	9f 01       	movw	r18, r30
    555e:	22 0f       	add	r18, r18
    5560:	33 1f       	adc	r19, r19
    5562:	22 0f       	add	r18, r18
    5564:	33 1f       	adc	r19, r19
    5566:	e2 0f       	add	r30, r18
    5568:	f3 1f       	adc	r31, r19
    556a:	e0 51       	subi	r30, 0x10	; 16
    556c:	fc 4f       	sbci	r31, 0xFC	; 252
    556e:	67 a3       	std	Z+39, r22	; 0x27
    setMotorDecay(i, motor[i].decay);
    5570:	e1 2f       	mov	r30, r17
    5572:	f0 e0       	ldi	r31, 0x00	; 0
    5574:	ee 0f       	add	r30, r30
    5576:	ff 1f       	adc	r31, r31
    5578:	ee 0f       	add	r30, r30
    557a:	ff 1f       	adc	r31, r31
    557c:	ee 0f       	add	r30, r30
    557e:	ff 1f       	adc	r31, r31
    5580:	cf 01       	movw	r24, r30
    5582:	88 0f       	add	r24, r24
    5584:	99 1f       	adc	r25, r25
    5586:	88 0f       	add	r24, r24
    5588:	99 1f       	adc	r25, r25
    558a:	e8 0f       	add	r30, r24
    558c:	f9 1f       	adc	r31, r25
    558e:	e0 51       	subi	r30, 0x10	; 16
    5590:	fc 4f       	sbci	r31, 0xFC	; 252
    5592:	67 a1       	ldd	r22, Z+39	; 0x27
    5594:	81 2f       	mov	r24, r17
    5596:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <setMotorDecay>
  }

  return;
}
    559a:	df 91       	pop	r29
    559c:	cf 91       	pop	r28
    559e:	1f 91       	pop	r17
    55a0:	08 95       	ret
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    55a2:	80 91 e7 03 	lds	r24, 0x03E7
    55a6:	90 91 e8 03 	lds	r25, 0x03E8
    55aa:	00 d0       	rcall	.+0      	; 0x55ac <commandSetMotorDecay+0x84>
    55ac:	00 d0       	rcall	.+0      	; 0x55ae <commandSetMotorDecay+0x86>
    55ae:	00 d0       	rcall	.+0      	; 0x55b0 <commandSetMotorDecay+0x88>
    55b0:	ed b7       	in	r30, 0x3d	; 61
    55b2:	fe b7       	in	r31, 0x3e	; 62
    55b4:	31 96       	adiw	r30, 0x01	; 1
    55b6:	ad b7       	in	r26, 0x3d	; 61
    55b8:	be b7       	in	r27, 0x3e	; 62
    55ba:	12 96       	adiw	r26, 0x02	; 2
    55bc:	9c 93       	st	X, r25
    55be:	8e 93       	st	-X, r24
    55c0:	11 97       	sbiw	r26, 0x01	; 1
    55c2:	80 e0       	ldi	r24, 0x00	; 0
    55c4:	91 e0       	ldi	r25, 0x01	; 1
    55c6:	93 83       	std	Z+3, r25	; 0x03
    55c8:	82 83       	std	Z+2, r24	; 0x02
    55ca:	14 83       	std	Z+4, r17	; 0x04
    55cc:	15 82       	std	Z+5, r1	; 0x05
    55ce:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    sendText(txString.buffer);
    55d2:	80 91 e7 03 	lds	r24, 0x03E7
    55d6:	90 91 e8 03 	lds	r25, 0x03E8
    55da:	2d b7       	in	r18, 0x3d	; 61
    55dc:	3e b7       	in	r19, 0x3e	; 62
    55de:	2a 5f       	subi	r18, 0xFA	; 250
    55e0:	3f 4f       	sbci	r19, 0xFF	; 255
    55e2:	0f b6       	in	r0, 0x3f	; 63
    55e4:	f8 94       	cli
    55e6:	3e bf       	out	0x3e, r19	; 62
    55e8:	0f be       	out	0x3f, r0	; 63
    55ea:	2d bf       	out	0x3d, r18	; 61
    55ec:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    motor[i].decay = atof(param1);
    setMotorDecay(i, motor[i].decay);
  }

  return;
}
    55f0:	df 91       	pop	r29
    55f2:	cf 91       	pop	r28
    55f4:	1f 91       	pop	r17
    55f6:	08 95       	ret

000055f8 <setMotorState>:

/* ---------------------------------------------------------------------
    setMotorState: turns motor on/off
    nENBL: active low
 --------------------------------------------------------------------- */
void setMotorState(uint8_t mot, uint8_t state){
    55f8:	ff 92       	push	r15
    55fa:	0f 93       	push	r16
    55fc:	1f 93       	push	r17
    55fe:	08 2f       	mov	r16, r24
    5600:	f6 2e       	mov	r15, r22

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    5602:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
    5606:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    5608:	62 e1       	ldi	r22, 0x12	; 18
    560a:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>

  if(state){
    560e:	ff 20       	and	r15, r15
    5610:	e1 f4       	brne	.+56     	; 0x564a <setMotorState+0x52>
    regval &= ~(1<<PORTEXP_MOTOR_ENABLE);
  }
  else{
    regval |= (1<<PORTEXP_MOTOR_ENABLE);
    5612:	48 2f       	mov	r20, r24
    5614:	48 60       	ori	r20, 0x08	; 8
  }

  writePortExpanderRegister(addr, GPIOA, regval);
    5616:	81 2f       	mov	r24, r17
    5618:	62 e1       	ldi	r22, 0x12	; 18
    561a:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  motor[mot].isTurnedOn = state;
    561e:	e0 2f       	mov	r30, r16
    5620:	f0 e0       	ldi	r31, 0x00	; 0
    5622:	ee 0f       	add	r30, r30
    5624:	ff 1f       	adc	r31, r31
    5626:	ee 0f       	add	r30, r30
    5628:	ff 1f       	adc	r31, r31
    562a:	ee 0f       	add	r30, r30
    562c:	ff 1f       	adc	r31, r31
    562e:	cf 01       	movw	r24, r30
    5630:	88 0f       	add	r24, r24
    5632:	99 1f       	adc	r25, r25
    5634:	88 0f       	add	r24, r24
    5636:	99 1f       	adc	r25, r25
    5638:	e8 0f       	add	r30, r24
    563a:	f9 1f       	adc	r31, r25
    563c:	e0 51       	subi	r30, 0x10	; 16
    563e:	fc 4f       	sbci	r31, 0xFC	; 252
    5640:	f3 86       	std	Z+11, r15	; 0x0b

  return;
}
    5642:	1f 91       	pop	r17
    5644:	0f 91       	pop	r16
    5646:	ff 90       	pop	r15
    5648:	08 95       	ret

  addr = getPortExpanderAddress(mot);
  regval = readPortExpanderRegister(addr, GPIOA);

  if(state){
    regval &= ~(1<<PORTEXP_MOTOR_ENABLE);
    564a:	48 2f       	mov	r20, r24
    564c:	47 7f       	andi	r20, 0xF7	; 247
    564e:	e3 cf       	rjmp	.-58     	; 0x5616 <setMotorState+0x1e>

00005650 <commandEnable>:
}

/* ---------------------------------------------------------------------
    enables/disables a motor
 --------------------------------------------------------------------- */
void commandEnable(char* param0, char* param1){
    5650:	0f 93       	push	r16
    5652:	df 93       	push	r29
    5654:	cf 93       	push	r28
    5656:	00 d0       	rcall	.+0      	; 0x5658 <commandEnable+0x8>
    5658:	cd b7       	in	r28, 0x3d	; 61
    565a:	de b7       	in	r29, 0x3e	; 62
    565c:	7a 83       	std	Y+2, r23	; 0x02
    565e:	69 83       	std	Y+1, r22	; 0x01

  uint8_t i   = 0;
  uint8_t val = 0;

  i   = (uint8_t)strtol(param0, (char **)NULL, 10);
    5660:	60 e0       	ldi	r22, 0x00	; 0
    5662:	70 e0       	ldi	r23, 0x00	; 0
    5664:	4a e0       	ldi	r20, 0x0A	; 10
    5666:	50 e0       	ldi	r21, 0x00	; 0
    5668:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    566c:	06 2f       	mov	r16, r22
  val = (uint8_t)strtol(param1, (char **)NULL, 10);
    566e:	89 81       	ldd	r24, Y+1	; 0x01
    5670:	9a 81       	ldd	r25, Y+2	; 0x02
    5672:	60 e0       	ldi	r22, 0x00	; 0
    5674:	70 e0       	ldi	r23, 0x00	; 0
    5676:	4a e0       	ldi	r20, 0x0A	; 10
    5678:	50 e0       	ldi	r21, 0x00	; 0
    567a:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>



  if(i > MAX_MOTOR){
    567e:	04 30       	cpi	r16, 0x04	; 4
    5680:	30 f4       	brcc	.+12     	; 0x568e <commandEnable+0x3e>
    return;
  }
  else{
    if(val){
    5682:	66 23       	and	r22, r22
    5684:	51 f4       	brne	.+20     	; 0x569a <commandEnable+0x4a>
      setMotorState(i, ON);
    }
    else{
      setMotorState(i, OFF);
    5686:	80 2f       	mov	r24, r16
    5688:	60 e0       	ldi	r22, 0x00	; 0
    568a:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
      //sendChar('a');
    }
  }

  return;
}
    568e:	0f 90       	pop	r0
    5690:	0f 90       	pop	r0
    5692:	cf 91       	pop	r28
    5694:	df 91       	pop	r29
    5696:	0f 91       	pop	r16
    5698:	08 95       	ret
  if(i > MAX_MOTOR){
    return;
  }
  else{
    if(val){
      setMotorState(i, ON);
    569a:	80 2f       	mov	r24, r16
    569c:	61 e0       	ldi	r22, 0x01	; 1
    569e:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
      //sendChar('a');
    }
  }

  return;
}
    56a2:	0f 90       	pop	r0
    56a4:	0f 90       	pop	r0
    56a6:	cf 91       	pop	r28
    56a8:	df 91       	pop	r29
    56aa:	0f 91       	pop	r16
    56ac:	08 95       	ret

000056ae <prepareReset>:
  */

  /* turn off all available motors */
  uint8_t i;
  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorState(i, OFF);
    56ae:	80 e0       	ldi	r24, 0x00	; 0
    56b0:	60 e0       	ldi	r22, 0x00	; 0
    56b2:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
    56b6:	81 e0       	ldi	r24, 0x01	; 1
    56b8:	60 e0       	ldi	r22, 0x00	; 0
    56ba:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
    56be:	82 e0       	ldi	r24, 0x02	; 2
    56c0:	60 e0       	ldi	r22, 0x00	; 0
    56c2:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
    56c6:	83 e0       	ldi	r24, 0x03	; 3
    56c8:	60 e0       	ldi	r22, 0x00	; 0
    56ca:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
  }

  /* stop polling timer for manual operating system */
  TCCR0B = 0;
    56ce:	15 bc       	out	0x25, r1	; 37

  /* stop motor movement timer */
  TCCR2B = 0;
    56d0:	10 92 b1 00 	sts	0x00B1, r1

  return;
}
    56d4:	08 95       	ret

000056d6 <setSubSteps>:

/* ---------------------------------------------------------------------
   sets the desired motor substeps
   function takes a value 1...32   
 --------------------------------------------------------------------- */
void setSubSteps(uint8_t mot, uint8_t steps){
    56d6:	af 92       	push	r10
    56d8:	bf 92       	push	r11
    56da:	cf 92       	push	r12
    56dc:	df 92       	push	r13
    56de:	ef 92       	push	r14
    56e0:	ff 92       	push	r15
    56e2:	0f 93       	push	r16
    56e4:	1f 93       	push	r17
    56e6:	a8 2e       	mov	r10, r24
    56e8:	06 2f       	mov	r16, r22
  if(steps > 5){
    steps = 5;
  }
  */
  
  if(steps > 32){
    56ea:	61 32       	cpi	r22, 0x21	; 33
    56ec:	08 f4       	brcc	.+2      	; 0x56f0 <setSubSteps+0x1a>
    56ee:	49 c0       	rjmp	.+146    	; 0x5782 <setSubSteps+0xac>
    56f0:	80 e2       	ldi	r24, 0x20	; 32
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    56f2:	00 e0       	ldi	r16, 0x00	; 0
    tmp_steps = tmp_steps >> 1;
    56f4:	86 95       	lsr	r24
	steps++ ;
    56f6:	0f 5f       	subi	r16, 0xFF	; 255
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    56f8:	81 30       	cpi	r24, 0x01	; 1
    56fa:	e1 f7       	brne	.-8      	; 0x56f4 <setSubSteps+0x1e>
    56fc:	61 e0       	ldi	r22, 0x01	; 1
    56fe:	70 e0       	ldi	r23, 0x00	; 0
    5700:	00 2e       	mov	r0, r16
    5702:	02 c0       	rjmp	.+4      	; 0x5708 <setSubSteps+0x32>
    5704:	66 0f       	add	r22, r22
    5706:	77 1f       	adc	r23, r23
    5708:	0a 94       	dec	r0
    570a:	e2 f7       	brpl	.-8      	; 0x5704 <setSubSteps+0x2e>
    570c:	88 27       	eor	r24, r24
    570e:	77 fd       	sbrc	r23, 7
    5710:	80 95       	com	r24
    5712:	98 2f       	mov	r25, r24
    5714:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    5718:	6b 01       	movw	r12, r22
    571a:	7c 01       	movw	r14, r24
    tmp_steps = tmp_steps >> 1;
	steps++ ;
  }
  
  addr = getPortExpanderAddress(mot);
    571c:	8a 2d       	mov	r24, r10
    571e:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
    5722:	b8 2e       	mov	r11, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    5724:	62 e1       	ldi	r22, 0x12	; 18
    5726:	0e 94 2a 28 	call	0x5054	; 0x5054 <readPortExpanderRegister>
    572a:	18 2f       	mov	r17, r24

  regval &= 0xF8;

  regval |= (reverseBitOrder(steps) & 0xE0) >> 5;
    572c:	80 2f       	mov	r24, r16
    572e:	0e 94 ad 09 	call	0x135a	; 0x135a <reverseBitOrder>
    5732:	18 7f       	andi	r17, 0xF8	; 248
    5734:	82 95       	swap	r24
    5736:	86 95       	lsr	r24
    5738:	87 70       	andi	r24, 0x07	; 7
    573a:	18 2b       	or	r17, r24
  writePortExpanderRegister(addr, GPIOA, regval);
    573c:	8b 2d       	mov	r24, r11
    573e:	62 e1       	ldi	r22, 0x12	; 18
    5740:	41 2f       	mov	r20, r17
    5742:	0e 94 85 27 	call	0x4f0a	; 0x4f0a <writePortExpanderRegister>
  
  motor[mot].subSteps = (1<<steps);
    5746:	ea 2d       	mov	r30, r10
    5748:	f0 e0       	ldi	r31, 0x00	; 0
    574a:	ee 0f       	add	r30, r30
    574c:	ff 1f       	adc	r31, r31
    574e:	ee 0f       	add	r30, r30
    5750:	ff 1f       	adc	r31, r31
    5752:	ee 0f       	add	r30, r30
    5754:	ff 1f       	adc	r31, r31
    5756:	cf 01       	movw	r24, r30
    5758:	88 0f       	add	r24, r24
    575a:	99 1f       	adc	r25, r25
    575c:	88 0f       	add	r24, r24
    575e:	99 1f       	adc	r25, r25
    5760:	e8 0f       	add	r30, r24
    5762:	f9 1f       	adc	r31, r25
    5764:	e0 51       	subi	r30, 0x10	; 16
    5766:	fc 4f       	sbci	r31, 0xFC	; 252
    5768:	c5 8a       	std	Z+21, r12	; 0x15
    576a:	d6 8a       	std	Z+22, r13	; 0x16
    576c:	e7 8a       	std	Z+23, r14	; 0x17
    576e:	f0 8e       	std	Z+24, r15	; 0x18

  return;
}
    5770:	1f 91       	pop	r17
    5772:	0f 91       	pop	r16
    5774:	ff 90       	pop	r15
    5776:	ef 90       	pop	r14
    5778:	df 90       	pop	r13
    577a:	cf 90       	pop	r12
    577c:	bf 90       	pop	r11
    577e:	af 90       	pop	r10
    5780:	08 95       	ret
  */
  
  if(steps > 32){
    steps = 32;
  }
  if(steps < 1){
    5782:	66 23       	and	r22, r22
    5784:	59 f4       	brne	.+22     	; 0x579c <setSubSteps+0xc6>
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    5786:	0f 2e       	mov	r0, r31
    5788:	f0 e0       	ldi	r31, 0x00	; 0
    578a:	cf 2e       	mov	r12, r31
    578c:	f0 e0       	ldi	r31, 0x00	; 0
    578e:	df 2e       	mov	r13, r31
    5790:	f0 e8       	ldi	r31, 0x80	; 128
    5792:	ef 2e       	mov	r14, r31
    5794:	ff e3       	ldi	r31, 0x3F	; 63
    5796:	ff 2e       	mov	r15, r31
    5798:	f0 2d       	mov	r31, r0
    579a:	c0 cf       	rjmp	.-128    	; 0x571c <setSubSteps+0x46>
    579c:	61 30       	cpi	r22, 0x01	; 1
    579e:	11 f0       	breq	.+4      	; 0x57a4 <setSubSteps+0xce>
    57a0:	86 2f       	mov	r24, r22
    57a2:	a7 cf       	rjmp	.-178    	; 0x56f2 <setSubSteps+0x1c>
    57a4:	00 e0       	ldi	r16, 0x00	; 0
    57a6:	ef cf       	rjmp	.-34     	; 0x5786 <setSubSteps+0xb0>

000057a8 <commandSetSubSteps>:
}

/* ---------------------------------------------------------------------
    sets the desired substeps
 --------------------------------------------------------------------- */
void commandSetSubSteps(char* param0, char* param1){
    57a8:	1f 93       	push	r17
    57aa:	cf 93       	push	r28
    57ac:	df 93       	push	r29
    57ae:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    57b0:	60 e0       	ldi	r22, 0x00	; 0
    57b2:	70 e0       	ldi	r23, 0x00	; 0
    57b4:	4a e0       	ldi	r20, 0x0A	; 10
    57b6:	50 e0       	ldi	r21, 0x00	; 0
    57b8:	0e 94 f3 42 	call	0x85e6	; 0x85e6 <strtol>
    57bc:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    57be:	64 30       	cpi	r22, 0x04	; 4
    57c0:	88 f4       	brcc	.+34     	; 0x57e4 <commandSetSubSteps+0x3c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    57c2:	ce 01       	movw	r24, r28
    57c4:	0e 94 22 44 	call	0x8844	; 0x8844 <atof>
    //motor[i].subSteps = val;
    setSubSteps(i, (uint8_t)round(val));
    57c8:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    57cc:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
    57d0:	9b 01       	movw	r18, r22
    57d2:	ac 01       	movw	r20, r24
    57d4:	81 2f       	mov	r24, r17
    57d6:	62 2f       	mov	r22, r18
    57d8:	0e 94 6b 2b 	call	0x56d6	; 0x56d6 <setSubSteps>
  }

  return;
}
    57dc:	df 91       	pop	r29
    57de:	cf 91       	pop	r28
    57e0:	1f 91       	pop	r17
    57e2:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    57e4:	80 91 e7 03 	lds	r24, 0x03E7
    57e8:	90 91 e8 03 	lds	r25, 0x03E8
    57ec:	00 d0       	rcall	.+0      	; 0x57ee <commandSetSubSteps+0x46>
    57ee:	00 d0       	rcall	.+0      	; 0x57f0 <commandSetSubSteps+0x48>
    57f0:	00 d0       	rcall	.+0      	; 0x57f2 <commandSetSubSteps+0x4a>
    57f2:	ed b7       	in	r30, 0x3d	; 61
    57f4:	fe b7       	in	r31, 0x3e	; 62
    57f6:	31 96       	adiw	r30, 0x01	; 1
    57f8:	ad b7       	in	r26, 0x3d	; 61
    57fa:	be b7       	in	r27, 0x3e	; 62
    57fc:	12 96       	adiw	r26, 0x02	; 2
    57fe:	9c 93       	st	X, r25
    5800:	8e 93       	st	-X, r24
    5802:	11 97       	sbiw	r26, 0x01	; 1
    5804:	80 e0       	ldi	r24, 0x00	; 0
    5806:	91 e0       	ldi	r25, 0x01	; 1
    5808:	93 83       	std	Z+3, r25	; 0x03
    580a:	82 83       	std	Z+2, r24	; 0x02
    580c:	14 83       	std	Z+4, r17	; 0x04
    580e:	15 82       	std	Z+5, r1	; 0x05
    5810:	0e 94 b1 45 	call	0x8b62	; 0x8b62 <sprintf>
    sendText(txString.buffer);
    5814:	80 91 e7 03 	lds	r24, 0x03E7
    5818:	90 91 e8 03 	lds	r25, 0x03E8
    581c:	2d b7       	in	r18, 0x3d	; 61
    581e:	3e b7       	in	r19, 0x3e	; 62
    5820:	2a 5f       	subi	r18, 0xFA	; 250
    5822:	3f 4f       	sbci	r19, 0xFF	; 255
    5824:	0f b6       	in	r0, 0x3f	; 63
    5826:	f8 94       	cli
    5828:	3e bf       	out	0x3e, r19	; 62
    582a:	0f be       	out	0x3f, r0	; 63
    582c:	2d bf       	out	0x3d, r18	; 61
    582e:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    //motor[i].subSteps = val;
    setSubSteps(i, (uint8_t)round(val));
  }

  return;
}
    5832:	df 91       	pop	r29
    5834:	cf 91       	pop	r28
    5836:	1f 91       	pop	r17
    5838:	08 95       	ret

0000583a <updateIICvalues>:
}

/* ---------------------------------------------------------------------
   update IIC values for all motors
 --------------------------------------------------------------------- */
void updateIICvalues(void){
    583a:	cf 93       	push	r28
    583c:	df 93       	push	r29
    583e:	c0 e0       	ldi	r28, 0x00	; 0
    5840:	d0 e0       	ldi	r29, 0x00	; 0

  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorCurrent(i, motor[i].current);
    5842:	fe 01       	movw	r30, r28
    5844:	ee 0f       	add	r30, r30
    5846:	ff 1f       	adc	r31, r31
    5848:	ee 0f       	add	r30, r30
    584a:	ff 1f       	adc	r31, r31
    584c:	ee 0f       	add	r30, r30
    584e:	ff 1f       	adc	r31, r31
    5850:	cf 01       	movw	r24, r30
    5852:	88 0f       	add	r24, r24
    5854:	99 1f       	adc	r25, r25
    5856:	88 0f       	add	r24, r24
    5858:	99 1f       	adc	r25, r25
    585a:	e8 0f       	add	r30, r24
    585c:	f9 1f       	adc	r31, r25
    585e:	e0 51       	subi	r30, 0x10	; 16
    5860:	fc 4f       	sbci	r31, 0xFC	; 252
    5862:	43 a1       	ldd	r20, Z+35	; 0x23
    5864:	54 a1       	ldd	r21, Z+36	; 0x24
    5866:	65 a1       	ldd	r22, Z+37	; 0x25
    5868:	76 a1       	ldd	r23, Z+38	; 0x26
    586a:	8c 2f       	mov	r24, r28
    586c:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <setMotorCurrent>
    setMotorDecay(i, motor[i].decay);
    5870:	fe 01       	movw	r30, r28
    5872:	ee 0f       	add	r30, r30
    5874:	ff 1f       	adc	r31, r31
    5876:	ee 0f       	add	r30, r30
    5878:	ff 1f       	adc	r31, r31
    587a:	ee 0f       	add	r30, r30
    587c:	ff 1f       	adc	r31, r31
    587e:	cf 01       	movw	r24, r30
    5880:	88 0f       	add	r24, r24
    5882:	99 1f       	adc	r25, r25
    5884:	88 0f       	add	r24, r24
    5886:	99 1f       	adc	r25, r25
    5888:	e8 0f       	add	r30, r24
    588a:	f9 1f       	adc	r31, r25
    588c:	e0 51       	subi	r30, 0x10	; 16
    588e:	fc 4f       	sbci	r31, 0xFC	; 252
    5890:	67 a1       	ldd	r22, Z+39	; 0x27
    5892:	8c 2f       	mov	r24, r28
    5894:	0e 94 64 2a 	call	0x54c8	; 0x54c8 <setMotorDecay>
    setSubSteps(i, (uint8_t)round(motor[i].subSteps));
    5898:	fe 01       	movw	r30, r28
    589a:	ee 0f       	add	r30, r30
    589c:	ff 1f       	adc	r31, r31
    589e:	ee 0f       	add	r30, r30
    58a0:	ff 1f       	adc	r31, r31
    58a2:	ee 0f       	add	r30, r30
    58a4:	ff 1f       	adc	r31, r31
    58a6:	cf 01       	movw	r24, r30
    58a8:	88 0f       	add	r24, r24
    58aa:	99 1f       	adc	r25, r25
    58ac:	88 0f       	add	r24, r24
    58ae:	99 1f       	adc	r25, r25
    58b0:	e8 0f       	add	r30, r24
    58b2:	f9 1f       	adc	r31, r25
    58b4:	e0 51       	subi	r30, 0x10	; 16
    58b6:	fc 4f       	sbci	r31, 0xFC	; 252
    58b8:	65 89       	ldd	r22, Z+21	; 0x15
    58ba:	76 89       	ldd	r23, Z+22	; 0x16
    58bc:	87 89       	ldd	r24, Z+23	; 0x17
    58be:	90 8d       	ldd	r25, Z+24	; 0x18
    58c0:	0e 94 a7 41 	call	0x834e	; 0x834e <round>
    58c4:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
    58c8:	9b 01       	movw	r18, r22
    58ca:	ac 01       	movw	r20, r24
    58cc:	8c 2f       	mov	r24, r28
    58ce:	62 2f       	mov	r22, r18
    58d0:	0e 94 6b 2b 	call	0x56d6	; 0x56d6 <setSubSteps>
    58d4:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void updateIICvalues(void){

  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    58d6:	c4 30       	cpi	r28, 0x04	; 4
    58d8:	d1 05       	cpc	r29, r1
    58da:	09 f0       	breq	.+2      	; 0x58de <updateIICvalues+0xa4>
    58dc:	b2 cf       	rjmp	.-156    	; 0x5842 <updateIICvalues+0x8>
    setMotorDecay(i, motor[i].decay);
    setSubSteps(i, (uint8_t)round(motor[i].subSteps));
  }

  return;
}
    58de:	df 91       	pop	r29
    58e0:	cf 91       	pop	r28
    58e2:	08 95       	ret

000058e4 <updateDisplay>:
 --------------------------------------------------------------------- */
void updateDisplay(void){

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    58e4:	80 91 e4 02 	lds	r24, 0x02E4
    58e8:	82 30       	cpi	r24, 0x02	; 2
    58ea:	09 f4       	brne	.+2      	; 0x58ee <updateDisplay+0xa>
    58ec:	6f c0       	rjmp	.+222    	; 0x59cc <updateDisplay+0xe8>
    58ee:	83 30       	cpi	r24, 0x03	; 3
    58f0:	08 f4       	brcc	.+2      	; 0x58f4 <updateDisplay+0x10>
    58f2:	64 c0       	rjmp	.+200    	; 0x59bc <updateDisplay+0xd8>
    58f4:	83 30       	cpi	r24, 0x03	; 3
    58f6:	09 f4       	brne	.+2      	; 0x58fa <updateDisplay+0x16>
    58f8:	c6 c0       	rjmp	.+396    	; 0x5a86 <updateDisplay+0x1a2>
    58fa:	85 30       	cpi	r24, 0x05	; 5
    58fc:	09 f0       	breq	.+2      	; 0x5900 <updateDisplay+0x1c>
    58fe:	61 c0       	rjmp	.+194    	; 0x59c2 <updateDisplay+0xde>
        }
      }
      break;
      
    case MENU_SETTINGS_MODE:
      if(menu.currentDisplayedMenu != menu.newDisplayedMenu){
    5900:	90 91 e0 02 	lds	r25, 0x02E0
    5904:	80 91 df 02 	lds	r24, 0x02DF
    5908:	98 17       	cp	r25, r24
    590a:	09 f4       	brne	.+2      	; 0x590e <updateDisplay+0x2a>
    590c:	5a c0       	rjmp	.+180    	; 0x59c2 <updateDisplay+0xde>
        changeDisplayMenu(menu.newDisplayedMenu);
    590e:	80 91 df 02 	lds	r24, 0x02DF
    5912:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <changeDisplayMenu>
        //lcd_setcursor(0, 1);  /* line 1 */
        //lcd_string(menu.newMenuText[0]);
        OLEDsetCursor(0, 0);
    5916:	80 e0       	ldi	r24, 0x00	; 0
    5918:	60 e0       	ldi	r22, 0x00	; 0
    591a:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[0]);
    591e:	e0 91 ec 02 	lds	r30, 0x02EC
    5922:	f0 91 ed 02 	lds	r31, 0x02ED
    5926:	80 81       	ld	r24, Z
    5928:	91 81       	ldd	r25, Z+1	; 0x01
    592a:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentMenuText[0], menu.newMenuText[0]);
    592e:	a0 91 ea 02 	lds	r26, 0x02EA
    5932:	b0 91 eb 02 	lds	r27, 0x02EB
    5936:	e0 91 ec 02 	lds	r30, 0x02EC
    593a:	f0 91 ed 02 	lds	r31, 0x02ED
    593e:	60 81       	ld	r22, Z
    5940:	71 81       	ldd	r23, Z+1	; 0x01
    5942:	8d 91       	ld	r24, X+
    5944:	9c 91       	ld	r25, X
    5946:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
        //lcd_setcursor(0, 2);  /* line 2 */
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
    594a:	80 e0       	ldi	r24, 0x00	; 0
    594c:	61 e0       	ldi	r22, 0x01	; 1
    594e:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[1]);
    5952:	e0 91 ec 02 	lds	r30, 0x02EC
    5956:	f0 91 ed 02 	lds	r31, 0x02ED
    595a:	82 81       	ldd	r24, Z+2	; 0x02
    595c:	93 81       	ldd	r25, Z+3	; 0x03
    595e:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
    5962:	a0 91 ea 02 	lds	r26, 0x02EA
    5966:	b0 91 eb 02 	lds	r27, 0x02EB
    596a:	e0 91 ec 02 	lds	r30, 0x02EC
    596e:	f0 91 ed 02 	lds	r31, 0x02ED
    5972:	62 81       	ldd	r22, Z+2	; 0x02
    5974:	73 81       	ldd	r23, Z+3	; 0x03
    5976:	12 96       	adiw	r26, 0x02	; 2
    5978:	8d 91       	ld	r24, X+
    597a:	9c 91       	ld	r25, X
    597c:	13 97       	sbiw	r26, 0x03	; 3
    597e:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
    5982:	80 91 df 02 	lds	r24, 0x02DF
    5986:	80 93 e0 02 	sts	0x02E0, r24
    598a:	40 e0       	ldi	r20, 0x00	; 0
    598c:	50 e0       	ldi	r21, 0x00	; 0
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
          sprintf(menu.currentDisplayValue[j], "no text");
    598e:	e0 91 e6 02 	lds	r30, 0x02E6
    5992:	f0 91 e7 02 	lds	r31, 0x02E7
    5996:	e4 0f       	add	r30, r20
    5998:	f5 1f       	adc	r31, r21
    599a:	20 81       	ld	r18, Z
    599c:	31 81       	ldd	r19, Z+1	; 0x01
    599e:	c9 01       	movw	r24, r18
    59a0:	dc 01       	movw	r26, r24
    59a2:	e4 eb       	ldi	r30, 0xB4	; 180
    59a4:	f2 e0       	ldi	r31, 0x02	; 2
    59a6:	88 e0       	ldi	r24, 0x08	; 8
    59a8:	01 90       	ld	r0, Z+
    59aa:	0d 92       	st	X+, r0
    59ac:	81 50       	subi	r24, 0x01	; 1
    59ae:	e1 f7       	brne	.-8      	; 0x59a8 <updateDisplay+0xc4>
    59b0:	4e 5f       	subi	r20, 0xFE	; 254
    59b2:	5f 4f       	sbci	r21, 0xFF	; 255
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newMenuText[1]);
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
    59b4:	4a 30       	cpi	r20, 0x0A	; 10
    59b6:	51 05       	cpc	r21, r1
    59b8:	51 f7       	brne	.-44     	; 0x598e <updateDisplay+0xaa>
    59ba:	03 c0       	rjmp	.+6      	; 0x59c2 <updateDisplay+0xde>
 --------------------------------------------------------------------- */
void updateDisplay(void){

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    59bc:	81 30       	cpi	r24, 0x01	; 1
    59be:	09 f4       	brne	.+2      	; 0x59c2 <updateDisplay+0xde>
    59c0:	62 c0       	rjmp	.+196    	; 0x5a86 <updateDisplay+0x1a2>

    default:
      break;
  }

  menu.currentMenuMode = menu.newMenuMode;
    59c2:	80 91 e1 02 	lds	r24, 0x02E1
    59c6:	80 93 e4 02 	sts	0x02E4, r24

  return;
}
    59ca:	08 95       	ret

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    case MENU_SCROLL_MODE:
      if(menu.currentDisplayedMenu != menu.newDisplayedMenu){
    59cc:	90 91 e0 02 	lds	r25, 0x02E0
    59d0:	80 91 df 02 	lds	r24, 0x02DF
    59d4:	98 17       	cp	r25, r24
    59d6:	a9 f3       	breq	.-22     	; 0x59c2 <updateDisplay+0xde>
        changeDisplayMenu(menu.newDisplayedMenu);
    59d8:	80 91 df 02 	lds	r24, 0x02DF
    59dc:	0e 94 e5 1e 	call	0x3dca	; 0x3dca <changeDisplayMenu>
        //lcd_setcursor(0, 1);  /* line 1 */
        //lcd_string(menu.newMenuText[0]);
        OLEDsetCursor(0, 0);
    59e0:	80 e0       	ldi	r24, 0x00	; 0
    59e2:	60 e0       	ldi	r22, 0x00	; 0
    59e4:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[0]);
    59e8:	e0 91 ec 02 	lds	r30, 0x02EC
    59ec:	f0 91 ed 02 	lds	r31, 0x02ED
    59f0:	80 81       	ld	r24, Z
    59f2:	91 81       	ldd	r25, Z+1	; 0x01
    59f4:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentMenuText[0], menu.newMenuText[0]);
    59f8:	a0 91 ea 02 	lds	r26, 0x02EA
    59fc:	b0 91 eb 02 	lds	r27, 0x02EB
    5a00:	e0 91 ec 02 	lds	r30, 0x02EC
    5a04:	f0 91 ed 02 	lds	r31, 0x02ED
    5a08:	60 81       	ld	r22, Z
    5a0a:	71 81       	ldd	r23, Z+1	; 0x01
    5a0c:	8d 91       	ld	r24, X+
    5a0e:	9c 91       	ld	r25, X
    5a10:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
        //lcd_setcursor(0, 2);  /* line 2 */
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
    5a14:	80 e0       	ldi	r24, 0x00	; 0
    5a16:	61 e0       	ldi	r22, 0x01	; 1
    5a18:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[1]);
    5a1c:	e0 91 ec 02 	lds	r30, 0x02EC
    5a20:	f0 91 ed 02 	lds	r31, 0x02ED
    5a24:	82 81       	ldd	r24, Z+2	; 0x02
    5a26:	93 81       	ldd	r25, Z+3	; 0x03
    5a28:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
    5a2c:	a0 91 ea 02 	lds	r26, 0x02EA
    5a30:	b0 91 eb 02 	lds	r27, 0x02EB
    5a34:	e0 91 ec 02 	lds	r30, 0x02EC
    5a38:	f0 91 ed 02 	lds	r31, 0x02ED
    5a3c:	62 81       	ldd	r22, Z+2	; 0x02
    5a3e:	73 81       	ldd	r23, Z+3	; 0x03
    5a40:	12 96       	adiw	r26, 0x02	; 2
    5a42:	8d 91       	ld	r24, X+
    5a44:	9c 91       	ld	r25, X
    5a46:	13 97       	sbiw	r26, 0x03	; 3
    5a48:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
    5a4c:	80 91 df 02 	lds	r24, 0x02DF
    5a50:	80 93 e0 02 	sts	0x02E0, r24
    5a54:	40 e0       	ldi	r20, 0x00	; 0
    5a56:	50 e0       	ldi	r21, 0x00	; 0
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
          sprintf(menu.currentDisplayValue[j], "no text");
    5a58:	e0 91 e6 02 	lds	r30, 0x02E6
    5a5c:	f0 91 e7 02 	lds	r31, 0x02E7
    5a60:	e4 0f       	add	r30, r20
    5a62:	f5 1f       	adc	r31, r21
    5a64:	20 81       	ld	r18, Z
    5a66:	31 81       	ldd	r19, Z+1	; 0x01
    5a68:	c9 01       	movw	r24, r18
    5a6a:	dc 01       	movw	r26, r24
    5a6c:	e4 eb       	ldi	r30, 0xB4	; 180
    5a6e:	f2 e0       	ldi	r31, 0x02	; 2
    5a70:	88 e0       	ldi	r24, 0x08	; 8
    5a72:	01 90       	ld	r0, Z+
    5a74:	0d 92       	st	X+, r0
    5a76:	81 50       	subi	r24, 0x01	; 1
    5a78:	e1 f7       	brne	.-8      	; 0x5a72 <updateDisplay+0x18e>
    5a7a:	4e 5f       	subi	r20, 0xFE	; 254
    5a7c:	5f 4f       	sbci	r21, 0xFF	; 255
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newMenuText[1]);
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
    5a7e:	4a 30       	cpi	r20, 0x0A	; 10
    5a80:	51 05       	cpc	r21, r1
    5a82:	51 f7       	brne	.-44     	; 0x5a58 <updateDisplay+0x174>
    5a84:	9e cf       	rjmp	.-196    	; 0x59c2 <updateDisplay+0xde>
      }
      break;

    case MENU_CHANGE_MODE:
    case MENU_VALUE_CHANGE:
      updateDisplayChangeValues(menu.currentDisplayedMenu);
    5a86:	80 91 e0 02 	lds	r24, 0x02E0
    5a8a:	0e 94 ae 15 	call	0x2b5c	; 0x2b5c <updateDisplayChangeValues>
      if(strcmp(menu.currentDisplayValue[0], menu.newDisplayValue[0])){
    5a8e:	a0 91 e6 02 	lds	r26, 0x02E6
    5a92:	b0 91 e7 02 	lds	r27, 0x02E7
    5a96:	e0 91 e8 02 	lds	r30, 0x02E8
    5a9a:	f0 91 e9 02 	lds	r31, 0x02E9
    5a9e:	60 81       	ld	r22, Z
    5aa0:	71 81       	ldd	r23, Z+1	; 0x01
    5aa2:	8d 91       	ld	r24, X+
    5aa4:	9c 91       	ld	r25, X
    5aa6:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    5aaa:	00 97       	sbiw	r24, 0x00	; 0
    5aac:	09 f0       	breq	.+2      	; 0x5ab0 <updateDisplay+0x1cc>
    5aae:	8f c0       	rjmp	.+286    	; 0x5bce <updateDisplay+0x2ea>
        //lcd_string(menu.newDisplayValue[0]);
        OLEDsetCursor(0, 0);
        OLEDprintCC(menu.newDisplayValue[0]);
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
      }
      if(strcmp(menu.currentDisplayValue[1], menu.newDisplayValue[1])){
    5ab0:	a0 91 e6 02 	lds	r26, 0x02E6
    5ab4:	b0 91 e7 02 	lds	r27, 0x02E7
    5ab8:	e0 91 e8 02 	lds	r30, 0x02E8
    5abc:	f0 91 e9 02 	lds	r31, 0x02E9
    5ac0:	62 81       	ldd	r22, Z+2	; 0x02
    5ac2:	73 81       	ldd	r23, Z+3	; 0x03
    5ac4:	12 96       	adiw	r26, 0x02	; 2
    5ac6:	8d 91       	ld	r24, X+
    5ac8:	9c 91       	ld	r25, X
    5aca:	13 97       	sbiw	r26, 0x03	; 3
    5acc:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    5ad0:	00 97       	sbiw	r24, 0x00	; 0
    5ad2:	09 f0       	breq	.+2      	; 0x5ad6 <updateDisplay+0x1f2>
    5ad4:	5f c0       	rjmp	.+190    	; 0x5b94 <updateDisplay+0x2b0>
        //lcd_string(menu.newDisplayValue[1]);
        OLEDsetCursor(8, 0);
        OLEDprintCC(menu.newDisplayValue[1]);
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
      }
      if(strcmp(menu.currentDisplayValue[2], menu.newDisplayValue[2])){
    5ad6:	a0 91 e6 02 	lds	r26, 0x02E6
    5ada:	b0 91 e7 02 	lds	r27, 0x02E7
    5ade:	e0 91 e8 02 	lds	r30, 0x02E8
    5ae2:	f0 91 e9 02 	lds	r31, 0x02E9
    5ae6:	64 81       	ldd	r22, Z+4	; 0x04
    5ae8:	75 81       	ldd	r23, Z+5	; 0x05
    5aea:	14 96       	adiw	r26, 0x04	; 4
    5aec:	8d 91       	ld	r24, X+
    5aee:	9c 91       	ld	r25, X
    5af0:	15 97       	sbiw	r26, 0x05	; 5
    5af2:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    5af6:	00 97       	sbiw	r24, 0x00	; 0
    5af8:	81 f5       	brne	.+96     	; 0x5b5a <updateDisplay+0x276>
        //lcd_string(menu.newDisplayValue[2]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newDisplayValue[2]);
        strcpy(menu.currentDisplayValue[2], menu.newDisplayValue[2]);
      }
      if(strcmp(menu.currentDisplayValue[3], menu.newDisplayValue[3])){
    5afa:	a0 91 e6 02 	lds	r26, 0x02E6
    5afe:	b0 91 e7 02 	lds	r27, 0x02E7
    5b02:	e0 91 e8 02 	lds	r30, 0x02E8
    5b06:	f0 91 e9 02 	lds	r31, 0x02E9
    5b0a:	66 81       	ldd	r22, Z+6	; 0x06
    5b0c:	77 81       	ldd	r23, Z+7	; 0x07
    5b0e:	16 96       	adiw	r26, 0x06	; 6
    5b10:	8d 91       	ld	r24, X+
    5b12:	9c 91       	ld	r25, X
    5b14:	17 97       	sbiw	r26, 0x07	; 7
    5b16:	0e 94 3b 45 	call	0x8a76	; 0x8a76 <strcmp>
    5b1a:	00 97       	sbiw	r24, 0x00	; 0
    5b1c:	09 f4       	brne	.+2      	; 0x5b20 <updateDisplay+0x23c>
    5b1e:	51 cf       	rjmp	.-350    	; 0x59c2 <updateDisplay+0xde>
        //lcd_setcursor(8, 2);
        //lcd_string(menu.newDisplayValue[3]);
        OLEDsetCursor(8, 1);
    5b20:	88 e0       	ldi	r24, 0x08	; 8
    5b22:	61 e0       	ldi	r22, 0x01	; 1
    5b24:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[3]);
    5b28:	e0 91 e8 02 	lds	r30, 0x02E8
    5b2c:	f0 91 e9 02 	lds	r31, 0x02E9
    5b30:	86 81       	ldd	r24, Z+6	; 0x06
    5b32:	97 81       	ldd	r25, Z+7	; 0x07
    5b34:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentDisplayValue[3], menu.newDisplayValue[3]);
    5b38:	a0 91 e6 02 	lds	r26, 0x02E6
    5b3c:	b0 91 e7 02 	lds	r27, 0x02E7
    5b40:	e0 91 e8 02 	lds	r30, 0x02E8
    5b44:	f0 91 e9 02 	lds	r31, 0x02E9
    5b48:	66 81       	ldd	r22, Z+6	; 0x06
    5b4a:	77 81       	ldd	r23, Z+7	; 0x07
    5b4c:	16 96       	adiw	r26, 0x06	; 6
    5b4e:	8d 91       	ld	r24, X+
    5b50:	9c 91       	ld	r25, X
    5b52:	17 97       	sbiw	r26, 0x07	; 7
    5b54:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
    5b58:	34 cf       	rjmp	.-408    	; 0x59c2 <updateDisplay+0xde>
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
      }
      if(strcmp(menu.currentDisplayValue[2], menu.newDisplayValue[2])){
        //lcd_setcursor(0, 2);
        //lcd_string(menu.newDisplayValue[2]);
        OLEDsetCursor(0, 1);
    5b5a:	80 e0       	ldi	r24, 0x00	; 0
    5b5c:	61 e0       	ldi	r22, 0x01	; 1
    5b5e:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[2]);
    5b62:	e0 91 e8 02 	lds	r30, 0x02E8
    5b66:	f0 91 e9 02 	lds	r31, 0x02E9
    5b6a:	84 81       	ldd	r24, Z+4	; 0x04
    5b6c:	95 81       	ldd	r25, Z+5	; 0x05
    5b6e:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentDisplayValue[2], menu.newDisplayValue[2]);
    5b72:	a0 91 e6 02 	lds	r26, 0x02E6
    5b76:	b0 91 e7 02 	lds	r27, 0x02E7
    5b7a:	e0 91 e8 02 	lds	r30, 0x02E8
    5b7e:	f0 91 e9 02 	lds	r31, 0x02E9
    5b82:	64 81       	ldd	r22, Z+4	; 0x04
    5b84:	75 81       	ldd	r23, Z+5	; 0x05
    5b86:	14 96       	adiw	r26, 0x04	; 4
    5b88:	8d 91       	ld	r24, X+
    5b8a:	9c 91       	ld	r25, X
    5b8c:	15 97       	sbiw	r26, 0x05	; 5
    5b8e:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
    5b92:	b3 cf       	rjmp	.-154    	; 0x5afa <updateDisplay+0x216>
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
      }
      if(strcmp(menu.currentDisplayValue[1], menu.newDisplayValue[1])){
        //lcd_setcursor(8, 1);
        //lcd_string(menu.newDisplayValue[1]);
        OLEDsetCursor(8, 0);
    5b94:	88 e0       	ldi	r24, 0x08	; 8
    5b96:	60 e0       	ldi	r22, 0x00	; 0
    5b98:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[1]);
    5b9c:	e0 91 e8 02 	lds	r30, 0x02E8
    5ba0:	f0 91 e9 02 	lds	r31, 0x02E9
    5ba4:	82 81       	ldd	r24, Z+2	; 0x02
    5ba6:	93 81       	ldd	r25, Z+3	; 0x03
    5ba8:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
    5bac:	a0 91 e6 02 	lds	r26, 0x02E6
    5bb0:	b0 91 e7 02 	lds	r27, 0x02E7
    5bb4:	e0 91 e8 02 	lds	r30, 0x02E8
    5bb8:	f0 91 e9 02 	lds	r31, 0x02E9
    5bbc:	62 81       	ldd	r22, Z+2	; 0x02
    5bbe:	73 81       	ldd	r23, Z+3	; 0x03
    5bc0:	12 96       	adiw	r26, 0x02	; 2
    5bc2:	8d 91       	ld	r24, X+
    5bc4:	9c 91       	ld	r25, X
    5bc6:	13 97       	sbiw	r26, 0x03	; 3
    5bc8:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
    5bcc:	84 cf       	rjmp	.-248    	; 0x5ad6 <updateDisplay+0x1f2>
    case MENU_VALUE_CHANGE:
      updateDisplayChangeValues(menu.currentDisplayedMenu);
      if(strcmp(menu.currentDisplayValue[0], menu.newDisplayValue[0])){
        //lcd_setcursor(0, 1);
        //lcd_string(menu.newDisplayValue[0]);
        OLEDsetCursor(0, 0);
    5bce:	80 e0       	ldi	r24, 0x00	; 0
    5bd0:	60 e0       	ldi	r22, 0x00	; 0
    5bd2:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[0]);
    5bd6:	e0 91 e8 02 	lds	r30, 0x02E8
    5bda:	f0 91 e9 02 	lds	r31, 0x02E9
    5bde:	80 81       	ld	r24, Z
    5be0:	91 81       	ldd	r25, Z+1	; 0x01
    5be2:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
    5be6:	a0 91 e6 02 	lds	r26, 0x02E6
    5bea:	b0 91 e7 02 	lds	r27, 0x02E7
    5bee:	e0 91 e8 02 	lds	r30, 0x02E8
    5bf2:	f0 91 e9 02 	lds	r31, 0x02E9
    5bf6:	60 81       	ld	r22, Z
    5bf8:	71 81       	ldd	r23, Z+1	; 0x01
    5bfa:	8d 91       	ld	r24, X+
    5bfc:	9c 91       	ld	r25, X
    5bfe:	0e 94 44 45 	call	0x8a88	; 0x8a88 <strcpy>
    5c02:	56 cf       	rjmp	.-340    	; 0x5ab0 <updateDisplay+0x1cc>

00005c04 <updateMenu>:


/* ---------------------------------------------------------------------
   implementing the display state machine
 --------------------------------------------------------------------- */
void updateMenu(void){
    5c04:	6f 92       	push	r6
    5c06:	7f 92       	push	r7
    5c08:	8f 92       	push	r8
    5c0a:	9f 92       	push	r9
    5c0c:	af 92       	push	r10
    5c0e:	bf 92       	push	r11
    5c10:	cf 92       	push	r12
    5c12:	df 92       	push	r13
    5c14:	ef 92       	push	r14
    5c16:	ff 92       	push	r15
    5c18:	0f 93       	push	r16
    5c1a:	1f 93       	push	r17
    5c1c:	cf 93       	push	r28
    5c1e:	df 93       	push	r29

  uint8_t i = 0;
  uint8_t tmp = 0;

  /* first check if we have something to change at all */
  if(buttonState.readyToProcess == 0 && rotEnc.readyToProcess == 0){
    5c20:	80 91 de 02 	lds	r24, 0x02DE
    5c24:	88 23       	and	r24, r24
    5c26:	21 f4       	brne	.+8      	; 0x5c30 <updateMenu+0x2c>
    5c28:	80 91 d0 03 	lds	r24, 0x03D0
    5c2c:	88 23       	and	r24, r24
    5c2e:	a1 f0       	breq	.+40     	; 0x5c58 <updateMenu+0x54>
    /* nothing to be done */
    return;
  }

  /* now get information about the actual display prompt */
  menuPrompt = menu.currentDisplayedMenu;
    5c30:	00 91 e0 02 	lds	r16, 0x02E0
  menuState  = menu.currentMenuMode;
    5c34:	10 91 e4 02 	lds	r17, 0x02E4

  if(menuState == MENU_SCROLL_MODE){
    5c38:	12 30       	cpi	r17, 0x02	; 2
    5c3a:	09 f4       	brne	.+2      	; 0x5c3e <updateMenu+0x3a>
    5c3c:	b4 c0       	rjmp	.+360    	; 0x5da6 <updateMenu+0x1a2>
      menu.newMenuMode = MENU_SETTINGS_MODE;
      menu.newDisplayedMenu = MENU_CHANGE_SUBSTEPS;
    }
  }
  
  if(menuState == MENU_SETTINGS_MODE){
    5c3e:	15 30       	cpi	r17, 0x05	; 5
    5c40:	09 f4       	brne	.+2      	; 0x5c44 <updateMenu+0x40>
    5c42:	de c0       	rjmp	.+444    	; 0x5e00 <updateMenu+0x1fc>
      menu.newDisplayedMenu = MENU_SETTINGS;
    }
  }
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    5c44:	11 30       	cpi	r17, 0x01	; 1
    5c46:	b9 f0       	breq	.+46     	; 0x5c76 <updateMenu+0x72>
    5c48:	13 30       	cpi	r17, 0x03	; 3
    5c4a:	a9 f0       	breq	.+42     	; 0x5c76 <updateMenu+0x72>
          break;
      }
    }
  }

  buttonState.readyToProcess = 0;
    5c4c:	10 92 de 02 	sts	0x02DE, r1
  rotEnc.readyToProcess = 0;
    5c50:	10 92 d0 03 	sts	0x03D0, r1
  rotEnc.buttonPressed = 0;
    5c54:	10 92 d1 03 	sts	0x03D1, r1

  return;
}
    5c58:	df 91       	pop	r29
    5c5a:	cf 91       	pop	r28
    5c5c:	1f 91       	pop	r17
    5c5e:	0f 91       	pop	r16
    5c60:	ff 90       	pop	r15
    5c62:	ef 90       	pop	r14
    5c64:	df 90       	pop	r13
    5c66:	cf 90       	pop	r12
    5c68:	bf 90       	pop	r11
    5c6a:	af 90       	pop	r10
    5c6c:	9f 90       	pop	r9
    5c6e:	8f 90       	pop	r8
    5c70:	7f 90       	pop	r7
    5c72:	6f 90       	pop	r6
    5c74:	08 95       	ret
  }
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    5c76:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <getButtonEvent>
    switch(buttonVal){
    5c7a:	85 30       	cpi	r24, 0x05	; 5
    5c7c:	09 f4       	brne	.+2      	; 0x5c80 <updateMenu+0x7c>
    5c7e:	1d c1       	rjmp	.+570    	; 0x5eba <updateMenu+0x2b6>
    5c80:	86 30       	cpi	r24, 0x06	; 6
    5c82:	08 f0       	brcs	.+2      	; 0x5c86 <updateMenu+0x82>
    5c84:	7e c0       	rjmp	.+252    	; 0x5d82 <updateMenu+0x17e>
    5c86:	83 30       	cpi	r24, 0x03	; 3
    5c88:	09 f4       	brne	.+2      	; 0x5c8c <updateMenu+0x88>
    5c8a:	0a c1       	rjmp	.+532    	; 0x5ea0 <updateMenu+0x29c>
    5c8c:	84 30       	cpi	r24, 0x04	; 4
    5c8e:	09 f4       	brne	.+2      	; 0x5c92 <updateMenu+0x8e>
    5c90:	ff c0       	rjmp	.+510    	; 0x5e90 <updateMenu+0x28c>
      default:
        break;
    }
  }

  if(menuState == MENU_VALUE_CHANGE){
    5c92:	13 30       	cpi	r17, 0x03	; 3
    5c94:	d9 f6       	brne	.-74     	; 0x5c4c <updateMenu+0x48>
    /* here we have a motor selected and want to change any of its values */
    rotEncVal = getRotaryEncoderEvent();
    5c96:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <getRotaryEncoderEvent>
    5c9a:	18 2f       	mov	r17, r24
    if(rotEncVal != 0){
    5c9c:	88 23       	and	r24, r24
    5c9e:	b1 f2       	breq	.-84     	; 0x5c4c <updateMenu+0x48>
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
    5ca0:	80 91 e0 02 	lds	r24, 0x02E0
    5ca4:	90 e0       	ldi	r25, 0x00	; 0
    5ca6:	88 0f       	add	r24, r24
    5ca8:	99 1f       	adc	r25, r25
    5caa:	8e 51       	subi	r24, 0x1E	; 30
    5cac:	9b 4f       	sbci	r25, 0xFB	; 251
    5cae:	fc 01       	movw	r30, r24
    5cb0:	25 91       	lpm	r18, Z+
    5cb2:	34 91       	lpm	r19, Z+
      state = (uint8_t)pgm_read_byte(&menuPtr->state);
    5cb4:	2e 5f       	subi	r18, 0xFE	; 254
    5cb6:	3f 4f       	sbci	r19, 0xFF	; 255
    5cb8:	f9 01       	movw	r30, r18
    5cba:	84 91       	lpm	r24, Z+

      switch(state){
    5cbc:	87 30       	cpi	r24, 0x07	; 7
    5cbe:	09 f4       	brne	.+2      	; 0x5cc2 <updateMenu+0xbe>
    5cc0:	cc c0       	rjmp	.+408    	; 0x5e5a <updateMenu+0x256>
    5cc2:	88 30       	cpi	r24, 0x08	; 8
    5cc4:	08 f0       	brcs	.+2      	; 0x5cc8 <updateMenu+0xc4>
    5cc6:	2d c1       	rjmp	.+602    	; 0x5f22 <updateMenu+0x31e>
    5cc8:	83 30       	cpi	r24, 0x03	; 3
    5cca:	09 f4       	brne	.+2      	; 0x5cce <updateMenu+0xca>
    5ccc:	57 c2       	rjmp	.+1198   	; 0x617c <updateMenu+0x578>
    5cce:	84 30       	cpi	r24, 0x04	; 4
    5cd0:	08 f0       	brcs	.+2      	; 0x5cd4 <updateMenu+0xd0>
    5cd2:	c8 c1       	rjmp	.+912    	; 0x6064 <updateMenu+0x460>
    5cd4:	81 30       	cpi	r24, 0x01	; 1
    5cd6:	09 f4       	brne	.+2      	; 0x5cda <updateMenu+0xd6>
    5cd8:	16 c5       	rjmp	.+2604   	; 0x6706 <updateMenu+0xb02>
    5cda:	82 30       	cpi	r24, 0x02	; 2
    5cdc:	09 f0       	breq	.+2      	; 0x5ce0 <updateMenu+0xdc>
    5cde:	b6 cf       	rjmp	.-148    	; 0x5c4c <updateMenu+0x48>
            }
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    5ce0:	c0 e0       	ldi	r28, 0x00	; 0
    5ce2:	d0 e0       	ldi	r29, 0x00	; 0
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepMultiplier += (rotEncVal)/10.0;
    5ce4:	a1 2e       	mov	r10, r17
    5ce6:	bb 24       	eor	r11, r11
    5ce8:	a7 fc       	sbrc	r10, 7
    5cea:	b0 94       	com	r11
    5cec:	cb 2c       	mov	r12, r11
    5cee:	db 2c       	mov	r13, r11
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    5cf0:	80 91 e5 02 	lds	r24, 0x02E5
    5cf4:	90 e0       	ldi	r25, 0x00	; 0
    5cf6:	0c 2e       	mov	r0, r28
    5cf8:	02 c0       	rjmp	.+4      	; 0x5cfe <updateMenu+0xfa>
    5cfa:	95 95       	asr	r25
    5cfc:	87 95       	ror	r24
    5cfe:	0a 94       	dec	r0
    5d00:	e2 f7       	brpl	.-8      	; 0x5cfa <updateMenu+0xf6>
    5d02:	80 ff       	sbrs	r24, 0
    5d04:	38 c0       	rjmp	.+112    	; 0x5d76 <updateMenu+0x172>
              motor[i].stepMultiplier += (rotEncVal)/10.0;
    5d06:	fe 01       	movw	r30, r28
    5d08:	ee 0f       	add	r30, r30
    5d0a:	ff 1f       	adc	r31, r31
    5d0c:	ee 0f       	add	r30, r30
    5d0e:	ff 1f       	adc	r31, r31
    5d10:	ee 0f       	add	r30, r30
    5d12:	ff 1f       	adc	r31, r31
    5d14:	cf 01       	movw	r24, r30
    5d16:	88 0f       	add	r24, r24
    5d18:	99 1f       	adc	r25, r25
    5d1a:	88 0f       	add	r24, r24
    5d1c:	99 1f       	adc	r25, r25
    5d1e:	e8 0f       	add	r30, r24
    5d20:	f9 1f       	adc	r31, r25
    5d22:	e0 51       	subi	r30, 0x10	; 16
    5d24:	fc 4f       	sbci	r31, 0xFC	; 252
    5d26:	e2 8c       	ldd	r14, Z+26	; 0x1a
    5d28:	f3 8c       	ldd	r15, Z+27	; 0x1b
    5d2a:	04 8d       	ldd	r16, Z+28	; 0x1c
    5d2c:	15 8d       	ldd	r17, Z+29	; 0x1d
    5d2e:	c6 01       	movw	r24, r12
    5d30:	b5 01       	movw	r22, r10
    5d32:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    5d36:	20 e0       	ldi	r18, 0x00	; 0
    5d38:	30 e0       	ldi	r19, 0x00	; 0
    5d3a:	40 e2       	ldi	r20, 0x20	; 32
    5d3c:	51 e4       	ldi	r21, 0x41	; 65
    5d3e:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>
    5d42:	9b 01       	movw	r18, r22
    5d44:	ac 01       	movw	r20, r24
    5d46:	c8 01       	movw	r24, r16
    5d48:	b7 01       	movw	r22, r14
    5d4a:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <__addsf3>
    5d4e:	fe 01       	movw	r30, r28
    5d50:	ee 0f       	add	r30, r30
    5d52:	ff 1f       	adc	r31, r31
    5d54:	ee 0f       	add	r30, r30
    5d56:	ff 1f       	adc	r31, r31
    5d58:	ee 0f       	add	r30, r30
    5d5a:	ff 1f       	adc	r31, r31
    5d5c:	9f 01       	movw	r18, r30
    5d5e:	22 0f       	add	r18, r18
    5d60:	33 1f       	adc	r19, r19
    5d62:	22 0f       	add	r18, r18
    5d64:	33 1f       	adc	r19, r19
    5d66:	e2 0f       	add	r30, r18
    5d68:	f3 1f       	adc	r31, r19
    5d6a:	e0 51       	subi	r30, 0x10	; 16
    5d6c:	fc 4f       	sbci	r31, 0xFC	; 252
    5d6e:	62 8f       	std	Z+26, r22	; 0x1a
    5d70:	73 8f       	std	Z+27, r23	; 0x1b
    5d72:	84 8f       	std	Z+28, r24	; 0x1c
    5d74:	95 8f       	std	Z+29, r25	; 0x1d
    5d76:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    5d78:	c4 30       	cpi	r28, 0x04	; 4
    5d7a:	d1 05       	cpc	r29, r1
    5d7c:	09 f0       	breq	.+2      	; 0x5d80 <updateMenu+0x17c>
    5d7e:	b8 cf       	rjmp	.-144    	; 0x5cf0 <updateMenu+0xec>
    5d80:	65 cf       	rjmp	.-310    	; 0x5c4c <updateMenu+0x48>
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    switch(buttonVal){
    5d82:	87 30       	cpi	r24, 0x07	; 7
    5d84:	09 f4       	brne	.+2      	; 0x5d88 <updateMenu+0x184>
    5d86:	88 c0       	rjmp	.+272    	; 0x5e98 <updateMenu+0x294>
    5d88:	87 30       	cpi	r24, 0x07	; 7
    5d8a:	08 f0       	brcs	.+2      	; 0x5d8e <updateMenu+0x18a>
    5d8c:	5c c0       	rjmp	.+184    	; 0x5e46 <updateMenu+0x242>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR1:
        menu.selectedMotor ^= (1 << MOTOR1);
    5d8e:	80 91 e5 02 	lds	r24, 0x02E5
    5d92:	92 e0       	ldi	r25, 0x02	; 2
    5d94:	89 27       	eor	r24, r25
    5d96:	80 93 e5 02 	sts	0x02E5, r24
        menu.newMenuMode = MENU_VALUE_CHANGE;
    5d9a:	83 e0       	ldi	r24, 0x03	; 3
    5d9c:	80 93 e1 02 	sts	0x02E1, r24
        updateMotorButtonLEDs();
    5da0:	0e 94 7d 07 	call	0xefa	; 0xefa <updateMotorButtonLEDs>
    5da4:	76 cf       	rjmp	.-276    	; 0x5c92 <updateMenu+0x8e>
  menuState  = menu.currentMenuMode;

  if(menuState == MENU_SCROLL_MODE){
    /* so here we want to scroll through the menu */

    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    5da6:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <getRotaryEncoderEvent>
    menuPrompt = (menuPrompt+(int8_t)rotEncVal) % NUMBER_OF_DISPLAY_MENUS;
    5daa:	99 27       	eor	r25, r25
    5dac:	87 fd       	sbrc	r24, 7
    5dae:	90 95       	com	r25
    5db0:	20 2f       	mov	r18, r16
    5db2:	33 27       	eor	r19, r19
    5db4:	27 fd       	sbrc	r18, 7
    5db6:	30 95       	com	r19
    5db8:	82 0f       	add	r24, r18
    5dba:	93 1f       	adc	r25, r19
    5dbc:	69 e0       	ldi	r22, 0x09	; 9
    5dbe:	70 e0       	ldi	r23, 0x00	; 0
    5dc0:	0e 94 db 41 	call	0x83b6	; 0x83b6 <__divmodhi4>
    5dc4:	18 2f       	mov	r17, r24
    if(menuPrompt < 0){
    5dc6:	87 fd       	sbrc	r24, 7
    5dc8:	a0 c0       	rjmp	.+320    	; 0x5f0a <updateMenu+0x306>
      menuPrompt = NUMBER_OF_DISPLAY_MENUS - 1;
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    5dca:	80 93 df 02 	sts	0x02DF, r24
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    5dce:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <getButtonEvent>
    5dd2:	88 30       	cpi	r24, 0x08	; 8
    5dd4:	09 f4       	brne	.+2      	; 0x5dd8 <updateMenu+0x1d4>
    5dd6:	90 c0       	rjmp	.+288    	; 0x5ef8 <updateMenu+0x2f4>
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    5dd8:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <getButtonEvent>
    5ddc:	88 30       	cpi	r24, 0x08	; 8
    5dde:	09 f4       	brne	.+2      	; 0x5de2 <updateMenu+0x1de>
    5de0:	82 c0       	rjmp	.+260    	; 0x5ee6 <updateMenu+0x2e2>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    }
    
    //or enter MENU_SETTINGS_MODE
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menuPrompt == MENU_SETTINGS){
    5de2:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <getButtonEvent>
    5de6:	88 30       	cpi	r24, 0x08	; 8
    5de8:	09 f0       	breq	.+2      	; 0x5dec <updateMenu+0x1e8>
    5dea:	30 cf       	rjmp	.-416    	; 0x5c4c <updateMenu+0x48>
    5dec:	18 30       	cpi	r17, 0x08	; 8
    5dee:	09 f0       	breq	.+2      	; 0x5df2 <updateMenu+0x1ee>
    5df0:	2d cf       	rjmp	.-422    	; 0x5c4c <updateMenu+0x48>
      menu.newMenuMode = MENU_SETTINGS_MODE;
    5df2:	85 e0       	ldi	r24, 0x05	; 5
    5df4:	80 93 e1 02 	sts	0x02E1, r24
      menu.newDisplayedMenu = MENU_CHANGE_SUBSTEPS;
    5df8:	8a e0       	ldi	r24, 0x0A	; 10
    5dfa:	80 93 df 02 	sts	0x02DF, r24
    5dfe:	26 cf       	rjmp	.-436    	; 0x5c4c <updateMenu+0x48>
  }
  
  if(menuState == MENU_SETTINGS_MODE){
    /* so here we want to scroll through the settings menu */
          
    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    5e00:	0e 94 f3 09 	call	0x13e6	; 0x13e6 <getRotaryEncoderEvent>
    menuPrompt = (menuPrompt + (int8_t)rotEncVal);
    5e04:	28 2f       	mov	r18, r24
    5e06:	20 0f       	add	r18, r16
    if(menuPrompt > 9 + NUMBER_OF_SETTINGS_MENUS){
    5e08:	2f 30       	cpi	r18, 0x0F	; 15
    5e0a:	cc f0       	brlt	.+50     	; 0x5e3e <updateMenu+0x23a>
    5e0c:	2a e0       	ldi	r18, 0x0A	; 10
    }
    if(menuPrompt < 10){
      menuPrompt = 9 + NUMBER_OF_SETTINGS_MENUS;
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    5e0e:	20 93 df 02 	sts	0x02DF, r18

    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    5e12:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <getButtonEvent>
    5e16:	88 30       	cpi	r24, 0x08	; 8
    5e18:	09 f4       	brne	.+2      	; 0x5e1c <updateMenu+0x218>
    5e1a:	53 c0       	rjmp	.+166    	; 0x5ec2 <updateMenu+0x2be>
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    5e1c:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <getButtonEvent>
    5e20:	88 30       	cpi	r24, 0x08	; 8
    5e22:	09 f4       	brne	.+2      	; 0x5e26 <updateMenu+0x222>
    5e24:	57 c0       	rjmp	.+174    	; 0x5ed4 <updateMenu+0x2d0>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    }
    
    buttonVal = getButtonEvent();
    5e26:	0e 94 d1 09 	call	0x13a2	; 0x13a2 <getButtonEvent>
    if(buttonVal == BUTTON_MENUESCAPE){
    5e2a:	83 30       	cpi	r24, 0x03	; 3
    5e2c:	09 f0       	breq	.+2      	; 0x5e30 <updateMenu+0x22c>
    5e2e:	0e cf       	rjmp	.-484    	; 0x5c4c <updateMenu+0x48>
      /* get back to the MENU_SCROLL_MODE */
      menu.newMenuMode = MENU_SCROLL_MODE;
    5e30:	82 e0       	ldi	r24, 0x02	; 2
    5e32:	80 93 e1 02 	sts	0x02E1, r24
      menu.newDisplayedMenu = MENU_SETTINGS;
    5e36:	88 e0       	ldi	r24, 0x08	; 8
    5e38:	80 93 df 02 	sts	0x02DF, r24
    5e3c:	07 cf       	rjmp	.-498    	; 0x5c4c <updateMenu+0x48>
    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    menuPrompt = (menuPrompt + (int8_t)rotEncVal);
    if(menuPrompt > 9 + NUMBER_OF_SETTINGS_MENUS){
      menuPrompt = 10;
    }
    if(menuPrompt < 10){
    5e3e:	2a 30       	cpi	r18, 0x0A	; 10
    5e40:	34 f7       	brge	.-52     	; 0x5e0e <updateMenu+0x20a>
    5e42:	2e e0       	ldi	r18, 0x0E	; 14
    5e44:	e4 cf       	rjmp	.-56     	; 0x5e0e <updateMenu+0x20a>
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    switch(buttonVal){
    5e46:	88 30       	cpi	r24, 0x08	; 8
    5e48:	09 f0       	breq	.+2      	; 0x5e4c <updateMenu+0x248>
    5e4a:	23 cf       	rjmp	.-442    	; 0x5c92 <updateMenu+0x8e>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_ROT_ENC_PRESS:
        menu.fastMovingMode ^= 1;
    5e4c:	80 91 e2 02 	lds	r24, 0x02E2
    5e50:	91 e0       	ldi	r25, 0x01	; 1
    5e52:	89 27       	eor	r24, r25
    5e54:	80 93 e2 02 	sts	0x02E2, r24
    5e58:	1c cf       	rjmp	.-456    	; 0x5c92 <updateMenu+0x8e>
            }
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    5e5a:	c0 e0       	ldi	r28, 0x00	; 0
    5e5c:	d0 e0       	ldi	r29, 0x00	; 0

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motorZeroRun(i);
              menu.selectedMotor ^= (1 << i);
    5e5e:	e1 e0       	ldi	r30, 0x01	; 1
    5e60:	ce 2e       	mov	r12, r30
    5e62:	d1 2c       	mov	r13, r1
          }
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    5e64:	80 91 e5 02 	lds	r24, 0x02E5
    5e68:	90 e0       	ldi	r25, 0x00	; 0
    5e6a:	0c 2e       	mov	r0, r28
    5e6c:	02 c0       	rjmp	.+4      	; 0x5e72 <updateMenu+0x26e>
    5e6e:	95 95       	asr	r25
    5e70:	87 95       	ror	r24
    5e72:	0a 94       	dec	r0
    5e74:	e2 f7       	brpl	.-8      	; 0x5e6e <updateMenu+0x26a>
    5e76:	80 fd       	sbrc	r24, 0
    5e78:	6d c1       	rjmp	.+730    	; 0x6154 <updateMenu+0x550>
              motorZeroRun(i);
              menu.selectedMotor ^= (1 << i);
              updateDisplay();
              updateMotorButtonLEDs();
    5e7a:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    5e7c:	c4 30       	cpi	r28, 0x04	; 4
    5e7e:	d1 05       	cpc	r29, r1
    5e80:	89 f7       	brne	.-30     	; 0x5e64 <updateMenu+0x260>
              updateDisplay();
              updateMotorButtonLEDs();
            }
          }
          /* get back to the MENU_SCROLL_MODE when finished calibration*/
          menu.newMenuMode = MENU_SCROLL_MODE;
    5e82:	82 e0       	ldi	r24, 0x02	; 2
    5e84:	80 93 e1 02 	sts	0x02E1, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    5e88:	89 e0       	ldi	r24, 0x09	; 9
    5e8a:	80 93 e0 02 	sts	0x02E0, r24
    5e8e:	de ce       	rjmp	.-580    	; 0x5c4c <updateMenu+0x48>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR3:
        menu.selectedMotor ^= (1 << MOTOR3);
    5e90:	80 91 e5 02 	lds	r24, 0x02E5
    5e94:	98 e0       	ldi	r25, 0x08	; 8
    5e96:	7e cf       	rjmp	.-260    	; 0x5d94 <updateMenu+0x190>
    switch(buttonVal){
      case NO_BUTTON:
        break;

      case BUTTON_MOTOR0:
        menu.selectedMotor ^= (1 << MOTOR0);
    5e98:	80 91 e5 02 	lds	r24, 0x02E5
    5e9c:	91 e0       	ldi	r25, 0x01	; 1
    5e9e:	7a cf       	rjmp	.-268    	; 0x5d94 <updateMenu+0x190>
      case BUTTON_ROT_ENC_PRESS:
        menu.fastMovingMode ^= 1;
        break;

      case BUTTON_MENUESCAPE:
        if(menu.currentDisplayedMenu < 10){
    5ea0:	80 91 e0 02 	lds	r24, 0x02E0
    5ea4:	8a 30       	cpi	r24, 0x0A	; 10
    5ea6:	a0 f5       	brcc	.+104    	; 0x5f10 <updateMenu+0x30c>
          /* get back to the MENU_SCROLL_MODE */
          menu.newMenuMode = MENU_SCROLL_MODE;
    5ea8:	82 e0       	ldi	r24, 0x02	; 2
    5eaa:	80 93 e1 02 	sts	0x02E1, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    5eae:	89 e0       	ldi	r24, 0x09	; 9
    5eb0:	80 93 e0 02 	sts	0x02E0, r24
          menu.fastMovingMode = OFF;
    5eb4:	10 92 e2 02 	sts	0x02E2, r1
    5eb8:	ec ce       	rjmp	.-552    	; 0x5c92 <updateMenu+0x8e>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR2:
        menu.selectedMotor ^= (1 << MOTOR2);
    5eba:	80 91 e5 02 	lds	r24, 0x02E5
    5ebe:	94 e0       	ldi	r25, 0x04	; 4
    5ec0:	69 cf       	rjmp	.-302    	; 0x5d94 <updateMenu+0x190>
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;

    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    5ec2:	80 91 e5 02 	lds	r24, 0x02E5
    5ec6:	88 23       	and	r24, r24
    5ec8:	09 f0       	breq	.+2      	; 0x5ecc <updateMenu+0x2c8>
    5eca:	a8 cf       	rjmp	.-176    	; 0x5e1c <updateMenu+0x218>
      menu.newMenuMode = MENU_CHANGE_MODE;
    5ecc:	81 e0       	ldi	r24, 0x01	; 1
    5ece:	80 93 e1 02 	sts	0x02E1, r24
    5ed2:	a4 cf       	rjmp	.-184    	; 0x5e1c <updateMenu+0x218>
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    5ed4:	80 91 e5 02 	lds	r24, 0x02E5
    5ed8:	88 23       	and	r24, r24
    5eda:	09 f4       	brne	.+2      	; 0x5ede <updateMenu+0x2da>
    5edc:	a4 cf       	rjmp	.-184    	; 0x5e26 <updateMenu+0x222>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    5ede:	83 e0       	ldi	r24, 0x03	; 3
    5ee0:	80 93 e1 02 	sts	0x02E1, r24
    5ee4:	a0 cf       	rjmp	.-192    	; 0x5e26 <updateMenu+0x222>
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    5ee6:	80 91 e5 02 	lds	r24, 0x02E5
    5eea:	88 23       	and	r24, r24
    5eec:	09 f4       	brne	.+2      	; 0x5ef0 <updateMenu+0x2ec>
    5eee:	79 cf       	rjmp	.-270    	; 0x5de2 <updateMenu+0x1de>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    5ef0:	83 e0       	ldi	r24, 0x03	; 3
    5ef2:	80 93 e1 02 	sts	0x02E1, r24
    5ef6:	75 cf       	rjmp	.-278    	; 0x5de2 <updateMenu+0x1de>
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    5ef8:	80 91 e5 02 	lds	r24, 0x02E5
    5efc:	88 23       	and	r24, r24
    5efe:	09 f0       	breq	.+2      	; 0x5f02 <updateMenu+0x2fe>
    5f00:	6b cf       	rjmp	.-298    	; 0x5dd8 <updateMenu+0x1d4>
      menu.newMenuMode = MENU_CHANGE_MODE;
    5f02:	81 e0       	ldi	r24, 0x01	; 1
    5f04:	80 93 e1 02 	sts	0x02E1, r24
    5f08:	67 cf       	rjmp	.-306    	; 0x5dd8 <updateMenu+0x1d4>
  if(menuState == MENU_SCROLL_MODE){
    /* so here we want to scroll through the menu */

    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    menuPrompt = (menuPrompt+(int8_t)rotEncVal) % NUMBER_OF_DISPLAY_MENUS;
    if(menuPrompt < 0){
    5f0a:	18 e0       	ldi	r17, 0x08	; 8
    5f0c:	88 e0       	ldi	r24, 0x08	; 8
    5f0e:	5d cf       	rjmp	.-326    	; 0x5dca <updateMenu+0x1c6>
          menu.currentDisplayedMenu = MENU_DUMMY;
          menu.fastMovingMode = OFF;
        }
        else{
          /* get back to the MENU_SETTINGS_MODE */
          menu.newMenuMode = MENU_SETTINGS_MODE;
    5f10:	85 e0       	ldi	r24, 0x05	; 5
    5f12:	80 93 e1 02 	sts	0x02E1, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    5f16:	89 e0       	ldi	r24, 0x09	; 9
    5f18:	80 93 e0 02 	sts	0x02E0, r24
          menu.fastMovingMode = OFF;
    5f1c:	10 92 e2 02 	sts	0x02E2, r1
    5f20:	b8 ce       	rjmp	.-656    	; 0x5c92 <updateMenu+0x8e>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    5f22:	8b 30       	cpi	r24, 0x0B	; 11
    5f24:	09 f4       	brne	.+2      	; 0x5f28 <updateMenu+0x324>
    5f26:	30 c3       	rjmp	.+1632   	; 0x6588 <updateMenu+0x984>
    5f28:	8c 30       	cpi	r24, 0x0C	; 12
    5f2a:	08 f0       	brcs	.+2      	; 0x5f2e <updateMenu+0x32a>
    5f2c:	83 c0       	rjmp	.+262    	; 0x6034 <updateMenu+0x430>
    5f2e:	88 30       	cpi	r24, 0x08	; 8
    5f30:	09 f4       	brne	.+2      	; 0x5f34 <updateMenu+0x330>
    5f32:	1f c3       	rjmp	.+1598   	; 0x6572 <updateMenu+0x96e>
    5f34:	8a 30       	cpi	r24, 0x0A	; 10
    5f36:	09 f0       	breq	.+2      	; 0x5f3a <updateMenu+0x336>
    5f38:	89 ce       	rjmp	.-750    	; 0x5c4c <updateMenu+0x48>
          }
          /* get back to the MENU_SCROLL_MODE when finished calibration*/
          menu.newMenuMode = MENU_SCROLL_MODE;
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
          break;
    5f3a:	c0 e0       	ldi	r28, 0x00	; 0
    5f3c:	d0 e0       	ldi	r29, 0x00	; 0
    5f3e:	ec 2e       	mov	r14, r28

        case MENU_CHANGE_SUBSTEPS:   /* change motor substeps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    5f40:	80 91 e5 02 	lds	r24, 0x02E5
    5f44:	dc 2e       	mov	r13, r28
    5f46:	cd 2e       	mov	r12, r29
    5f48:	90 e0       	ldi	r25, 0x00	; 0
    5f4a:	0c 2e       	mov	r0, r28
    5f4c:	02 c0       	rjmp	.+4      	; 0x5f52 <updateMenu+0x34e>
    5f4e:	95 95       	asr	r25
    5f50:	87 95       	ror	r24
    5f52:	0a 94       	dec	r0
    5f54:	e2 f7       	brpl	.-8      	; 0x5f4e <updateMenu+0x34a>
    5f56:	80 ff       	sbrs	r24, 0
    5f58:	67 c0       	rjmp	.+206    	; 0x6028 <updateMenu+0x424>
              tmp = motor[i].subSteps;
    5f5a:	fe 01       	movw	r30, r28
    5f5c:	ee 0f       	add	r30, r30
    5f5e:	ff 1f       	adc	r31, r31
    5f60:	ee 0f       	add	r30, r30
    5f62:	ff 1f       	adc	r31, r31
    5f64:	ee 0f       	add	r30, r30
    5f66:	ff 1f       	adc	r31, r31
    5f68:	cf 01       	movw	r24, r30
    5f6a:	88 0f       	add	r24, r24
    5f6c:	99 1f       	adc	r25, r25
    5f6e:	88 0f       	add	r24, r24
    5f70:	99 1f       	adc	r25, r25
    5f72:	e8 0f       	add	r30, r24
    5f74:	f9 1f       	adc	r31, r25
    5f76:	e0 51       	subi	r30, 0x10	; 16
    5f78:	fc 4f       	sbci	r31, 0xFC	; 252
    5f7a:	65 89       	ldd	r22, Z+21	; 0x15
    5f7c:	76 89       	ldd	r23, Z+22	; 0x16
    5f7e:	87 89       	ldd	r24, Z+23	; 0x17
    5f80:	90 8d       	ldd	r25, Z+24	; 0x18
    5f82:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
              if(rotEncVal > 0){
    5f86:	11 16       	cp	r1, r17
    5f88:	0c f0       	brlt	.+2      	; 0x5f8c <updateMenu+0x388>
    5f8a:	69 c4       	rjmp	.+2258   	; 0x685e <updateMenu+0xc5a>
                //motor[i].subSteps *= 2.0;
                tmp *= 2.0;
    5f8c:	70 e0       	ldi	r23, 0x00	; 0
    5f8e:	88 27       	eor	r24, r24
    5f90:	77 fd       	sbrc	r23, 7
    5f92:	80 95       	com	r24
    5f94:	98 2f       	mov	r25, r24
    5f96:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    5f9a:	9b 01       	movw	r18, r22
    5f9c:	ac 01       	movw	r20, r24
    5f9e:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <__addsf3>
    5fa2:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
    5fa6:	06 2f       	mov	r16, r22
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
              }
              if(motor[i].subSteps < 1){
    5fa8:	ed 2d       	mov	r30, r13
    5faa:	fc 2d       	mov	r31, r12
    5fac:	ee 0f       	add	r30, r30
    5fae:	ff 1f       	adc	r31, r31
    5fb0:	ee 0f       	add	r30, r30
    5fb2:	ff 1f       	adc	r31, r31
    5fb4:	ee 0f       	add	r30, r30
    5fb6:	ff 1f       	adc	r31, r31
    5fb8:	cf 01       	movw	r24, r30
    5fba:	88 0f       	add	r24, r24
    5fbc:	99 1f       	adc	r25, r25
    5fbe:	88 0f       	add	r24, r24
    5fc0:	99 1f       	adc	r25, r25
    5fc2:	e8 0f       	add	r30, r24
    5fc4:	f9 1f       	adc	r31, r25
    5fc6:	e0 51       	subi	r30, 0x10	; 16
    5fc8:	fc 4f       	sbci	r31, 0xFC	; 252
    5fca:	65 89       	ldd	r22, Z+21	; 0x15
    5fcc:	76 89       	ldd	r23, Z+22	; 0x16
    5fce:	87 89       	ldd	r24, Z+23	; 0x17
    5fd0:	90 8d       	ldd	r25, Z+24	; 0x18
    5fd2:	20 e0       	ldi	r18, 0x00	; 0
    5fd4:	30 e0       	ldi	r19, 0x00	; 0
    5fd6:	40 e8       	ldi	r20, 0x80	; 128
    5fd8:	5f e3       	ldi	r21, 0x3F	; 63
    5fda:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <__cmpsf2>
    5fde:	88 23       	and	r24, r24
    5fe0:	0c f4       	brge	.+2      	; 0x5fe4 <updateMenu+0x3e0>
    5fe2:	3b c4       	rjmp	.+2166   	; 0x685a <updateMenu+0xc56>
                //motor[i].subSteps = 1;
                tmp = 1;
              }
              if(motor[i].subSteps > 32){
    5fe4:	ed 2d       	mov	r30, r13
    5fe6:	fc 2d       	mov	r31, r12
    5fe8:	ee 0f       	add	r30, r30
    5fea:	ff 1f       	adc	r31, r31
    5fec:	ee 0f       	add	r30, r30
    5fee:	ff 1f       	adc	r31, r31
    5ff0:	ee 0f       	add	r30, r30
    5ff2:	ff 1f       	adc	r31, r31
    5ff4:	cf 01       	movw	r24, r30
    5ff6:	88 0f       	add	r24, r24
    5ff8:	99 1f       	adc	r25, r25
    5ffa:	88 0f       	add	r24, r24
    5ffc:	99 1f       	adc	r25, r25
    5ffe:	e8 0f       	add	r30, r24
    6000:	f9 1f       	adc	r31, r25
    6002:	e0 51       	subi	r30, 0x10	; 16
    6004:	fc 4f       	sbci	r31, 0xFC	; 252
    6006:	65 89       	ldd	r22, Z+21	; 0x15
    6008:	76 89       	ldd	r23, Z+22	; 0x16
    600a:	87 89       	ldd	r24, Z+23	; 0x17
    600c:	90 8d       	ldd	r25, Z+24	; 0x18
    600e:	20 e0       	ldi	r18, 0x00	; 0
    6010:	30 e0       	ldi	r19, 0x00	; 0
    6012:	40 e0       	ldi	r20, 0x00	; 0
    6014:	52 e4       	ldi	r21, 0x42	; 66
    6016:	0e 94 40 41 	call	0x8280	; 0x8280 <__gesf2>
    601a:	18 16       	cp	r1, r24
    601c:	0c f4       	brge	.+2      	; 0x6020 <updateMenu+0x41c>
    601e:	00 e2       	ldi	r16, 0x20	; 32
                //motor[i].subSteps = 32;
                tmp = 32;
              }
              setSubSteps(i,tmp);
    6020:	8e 2d       	mov	r24, r14
    6022:	60 2f       	mov	r22, r16
    6024:	0e 94 6b 2b 	call	0x56d6	; 0x56d6 <setSubSteps>
    6028:	21 96       	adiw	r28, 0x01	; 1
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
          break;

        case MENU_CHANGE_SUBSTEPS:   /* change motor substeps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    602a:	c4 30       	cpi	r28, 0x04	; 4
    602c:	d1 05       	cpc	r29, r1
    602e:	09 f0       	breq	.+2      	; 0x6032 <updateMenu+0x42e>
    6030:	86 cf       	rjmp	.-244    	; 0x5f3e <updateMenu+0x33a>
    6032:	0c ce       	rjmp	.-1000   	; 0x5c4c <updateMenu+0x48>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    6034:	8d 30       	cpi	r24, 0x0D	; 13
    6036:	09 f4       	brne	.+2      	; 0x603a <updateMenu+0x436>
    6038:	a3 c1       	rjmp	.+838    	; 0x6380 <updateMenu+0x77c>
    603a:	8d 30       	cpi	r24, 0x0D	; 13
    603c:	08 f4       	brcc	.+2      	; 0x6040 <updateMenu+0x43c>
    603e:	11 c1       	rjmp	.+546    	; 0x6262 <updateMenu+0x65e>
    6040:	8e 30       	cpi	r24, 0x0E	; 14
    6042:	09 f0       	breq	.+2      	; 0x6046 <updateMenu+0x442>
    6044:	03 ce       	rjmp	.-1018   	; 0x5c4c <updateMenu+0x48>
          OLEDsetCursor(0, 0);
          OLEDprintCC("saved");
          break;

        case MENU_LOAD_CONFIG:   /* load last configuration */
          loadConfigFromEEPROM();
    6046:	0e 94 a3 0a 	call	0x1546	; 0x1546 <loadConfigFromEEPROM>
          updateIICvalues();
    604a:	0e 94 1d 2c 	call	0x583a	; 0x583a <updateIICvalues>
          //lcd_clear();
          //lcd_string("loaded");
          OLEDclear();
    604e:	0e 94 07 3a 	call	0x740e	; 0x740e <OLEDclear>
          OLEDsetCursor(0, 0);
    6052:	80 e0       	ldi	r24, 0x00	; 0
    6054:	60 e0       	ldi	r22, 0x00	; 0
    6056:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
          OLEDprintCC("loaded");
    605a:	82 ec       	ldi	r24, 0xC2	; 194
    605c:	92 e0       	ldi	r25, 0x02	; 2
    605e:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
    6062:	f4 cd       	rjmp	.-1048   	; 0x5c4c <updateMenu+0x48>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    6064:	85 30       	cpi	r24, 0x05	; 5
    6066:	09 f4       	brne	.+2      	; 0x606a <updateMenu+0x466>
    6068:	32 c2       	rjmp	.+1124   	; 0x64ce <updateMenu+0x8ca>
    606a:	86 30       	cpi	r24, 0x06	; 6
    606c:	08 f4       	brcc	.+2      	; 0x6070 <updateMenu+0x46c>
    606e:	95 c1       	rjmp	.+810    	; 0x639a <updateMenu+0x796>

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                defineOpticalZeroPosition(i, rotEncVal*100);
    6070:	61 2f       	mov	r22, r17
    6072:	77 27       	eor	r23, r23
    6074:	67 fd       	sbrc	r22, 7
    6076:	70 95       	com	r23
    6078:	84 e6       	ldi	r24, 0x64	; 100
    607a:	90 e0       	ldi	r25, 0x00	; 0
    607c:	68 9f       	mul	r22, r24
    607e:	d0 01       	movw	r26, r0
    6080:	69 9f       	mul	r22, r25
    6082:	b0 0d       	add	r27, r0
    6084:	78 9f       	mul	r23, r24
    6086:	b0 0d       	add	r27, r0
    6088:	11 24       	eor	r1, r1
    608a:	40 e0       	ldi	r20, 0x00	; 0
    608c:	50 e0       	ldi	r21, 0x00	; 0
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    608e:	80 91 e5 02 	lds	r24, 0x02E5
    6092:	90 e0       	ldi	r25, 0x00	; 0
    6094:	04 2e       	mov	r0, r20
    6096:	02 c0       	rjmp	.+4      	; 0x609c <updateMenu+0x498>
    6098:	95 95       	asr	r25
    609a:	87 95       	ror	r24
    609c:	0a 94       	dec	r0
    609e:	e2 f7       	brpl	.-8      	; 0x6098 <updateMenu+0x494>
    60a0:	80 ff       	sbrs	r24, 0
    60a2:	51 c0       	rjmp	.+162    	; 0x6146 <updateMenu+0x542>
              if(menu.fastMovingMode){
    60a4:	80 91 e2 02 	lds	r24, 0x02E2
    60a8:	88 23       	and	r24, r24
    60aa:	09 f4       	brne	.+2      	; 0x60ae <updateMenu+0x4aa>
    60ac:	96 c3       	rjmp	.+1836   	; 0x67da <updateMenu+0xbd6>
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
    60ae:	fa 01       	movw	r30, r20
    60b0:	ee 0f       	add	r30, r30
    60b2:	ff 1f       	adc	r31, r31
    60b4:	ee 0f       	add	r30, r30
    60b6:	ff 1f       	adc	r31, r31
    60b8:	ee 0f       	add	r30, r30
    60ba:	ff 1f       	adc	r31, r31
    60bc:	cf 01       	movw	r24, r30
    60be:	88 0f       	add	r24, r24
    60c0:	99 1f       	adc	r25, r25
    60c2:	88 0f       	add	r24, r24
    60c4:	99 1f       	adc	r25, r25
    60c6:	e8 0f       	add	r30, r24
    60c8:	f9 1f       	adc	r31, r25
    60ca:	e0 51       	subi	r30, 0x10	; 16
    60cc:	fc 4f       	sbci	r31, 0xFC	; 252
    60ce:	20 81       	ld	r18, Z
    60d0:	31 81       	ldd	r19, Z+1	; 0x01
    60d2:	2a 0f       	add	r18, r26
    60d4:	3b 1f       	adc	r19, r27
    60d6:	fa 01       	movw	r30, r20
    60d8:	ee 0f       	add	r30, r30
    60da:	ff 1f       	adc	r31, r31
    60dc:	ee 0f       	add	r30, r30
    60de:	ff 1f       	adc	r31, r31
    60e0:	cf 01       	movw	r24, r30
    60e2:	88 0f       	add	r24, r24
    60e4:	99 1f       	adc	r25, r25
    60e6:	88 0f       	add	r24, r24
    60e8:	99 1f       	adc	r25, r25
    60ea:	e8 0f       	add	r30, r24
    60ec:	f9 1f       	adc	r31, r25
    60ee:	ee 0f       	add	r30, r30
    60f0:	ff 1f       	adc	r31, r31
    60f2:	ee 50       	subi	r30, 0x0E	; 14
    60f4:	fc 4f       	sbci	r31, 0xFC	; 252
    60f6:	31 83       	std	Z+1, r19	; 0x01
    60f8:	20 83       	st	Z, r18
  motor[i].opticalZeroPosition = motor[i].desiredPosition;
    60fa:	fa 01       	movw	r30, r20
    60fc:	ee 0f       	add	r30, r30
    60fe:	ff 1f       	adc	r31, r31
    6100:	ee 0f       	add	r30, r30
    6102:	ff 1f       	adc	r31, r31
    6104:	cf 01       	movw	r24, r30
    6106:	88 0f       	add	r24, r24
    6108:	99 1f       	adc	r25, r25
    610a:	88 0f       	add	r24, r24
    610c:	99 1f       	adc	r25, r25
    610e:	e8 0f       	add	r30, r24
    6110:	f9 1f       	adc	r31, r25
    6112:	ee 0f       	add	r30, r30
    6114:	ff 1f       	adc	r31, r31
    6116:	ee 50       	subi	r30, 0x0E	; 14
    6118:	fc 4f       	sbci	r31, 0xFC	; 252
    611a:	20 81       	ld	r18, Z
    611c:	31 81       	ldd	r19, Z+1	; 0x01
    611e:	ca 01       	movw	r24, r20
    6120:	fa 01       	movw	r30, r20
    6122:	ee 0f       	add	r30, r30
    6124:	ff 1f       	adc	r31, r31
    6126:	ee 0f       	add	r30, r30
    6128:	ff 1f       	adc	r31, r31
    612a:	ee 0f       	add	r30, r30
    612c:	ff 1f       	adc	r31, r31
    612e:	88 0f       	add	r24, r24
    6130:	99 1f       	adc	r25, r25
    6132:	e8 0f       	add	r30, r24
    6134:	f9 1f       	adc	r31, r25
    6136:	ee 0f       	add	r30, r30
    6138:	ff 1f       	adc	r31, r31
    613a:	ee 0f       	add	r30, r30
    613c:	ff 1f       	adc	r31, r31
    613e:	ec 50       	subi	r30, 0x0C	; 12
    6140:	fc 4f       	sbci	r31, 0xFC	; 252
    6142:	31 83       	std	Z+1, r19	; 0x01
    6144:	20 83       	st	Z, r18
    6146:	4f 5f       	subi	r20, 0xFF	; 255
    6148:	5f 4f       	sbci	r21, 0xFF	; 255
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    614a:	44 30       	cpi	r20, 0x04	; 4
    614c:	51 05       	cpc	r21, r1
    614e:	09 f0       	breq	.+2      	; 0x6152 <updateMenu+0x54e>
    6150:	9e cf       	rjmp	.-196    	; 0x608e <updateMenu+0x48a>
    6152:	7c cd       	rjmp	.-1288   	; 0x5c4c <updateMenu+0x48>
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motorZeroRun(i);
    6154:	8c 2f       	mov	r24, r28
    6156:	0e 94 68 29 	call	0x52d0	; 0x52d0 <motorZeroRun>
              menu.selectedMotor ^= (1 << i);
    615a:	20 91 e5 02 	lds	r18, 0x02E5
    615e:	c6 01       	movw	r24, r12
    6160:	0c 2e       	mov	r0, r28
    6162:	02 c0       	rjmp	.+4      	; 0x6168 <updateMenu+0x564>
    6164:	88 0f       	add	r24, r24
    6166:	99 1f       	adc	r25, r25
    6168:	0a 94       	dec	r0
    616a:	e2 f7       	brpl	.-8      	; 0x6164 <updateMenu+0x560>
    616c:	28 27       	eor	r18, r24
    616e:	20 93 e5 02 	sts	0x02E5, r18
              updateDisplay();
    6172:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <updateDisplay>
              updateMotorButtonLEDs();
    6176:	0e 94 7d 07 	call	0xefa	; 0xefa <updateMotorButtonLEDs>
    617a:	7f ce       	rjmp	.-770    	; 0x5e7a <updateMenu+0x276>
      switch(state){
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    617c:	40 e0       	ldi	r20, 0x00	; 0
    617e:	50 e0       	ldi	r21, 0x00	; 0
        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepUnit += rotEncVal;
              if(motor[i].stepUnit < 0){
                motor[i].stepUnit = 2;
    6180:	72 e0       	ldi	r23, 0x02	; 2
          }
          break;

        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6182:	80 91 e5 02 	lds	r24, 0x02E5
    6186:	34 2f       	mov	r19, r20
    6188:	65 2f       	mov	r22, r21
    618a:	90 e0       	ldi	r25, 0x00	; 0
    618c:	04 2e       	mov	r0, r20
    618e:	02 c0       	rjmp	.+4      	; 0x6194 <updateMenu+0x590>
    6190:	95 95       	asr	r25
    6192:	87 95       	ror	r24
    6194:	0a 94       	dec	r0
    6196:	e2 f7       	brpl	.-8      	; 0x6190 <updateMenu+0x58c>
    6198:	80 ff       	sbrs	r24, 0
    619a:	5c c0       	rjmp	.+184    	; 0x6254 <updateMenu+0x650>
              motor[i].stepUnit += rotEncVal;
    619c:	fa 01       	movw	r30, r20
    619e:	ee 0f       	add	r30, r30
    61a0:	ff 1f       	adc	r31, r31
    61a2:	ee 0f       	add	r30, r30
    61a4:	ff 1f       	adc	r31, r31
    61a6:	ee 0f       	add	r30, r30
    61a8:	ff 1f       	adc	r31, r31
    61aa:	cf 01       	movw	r24, r30
    61ac:	88 0f       	add	r24, r24
    61ae:	99 1f       	adc	r25, r25
    61b0:	88 0f       	add	r24, r24
    61b2:	99 1f       	adc	r25, r25
    61b4:	e8 0f       	add	r30, r24
    61b6:	f9 1f       	adc	r31, r25
    61b8:	e0 51       	subi	r30, 0x10	; 16
    61ba:	fc 4f       	sbci	r31, 0xFC	; 252
    61bc:	21 8d       	ldd	r18, Z+25	; 0x19
    61be:	21 0f       	add	r18, r17
    61c0:	fa 01       	movw	r30, r20
    61c2:	ee 0f       	add	r30, r30
    61c4:	ff 1f       	adc	r31, r31
    61c6:	ee 0f       	add	r30, r30
    61c8:	ff 1f       	adc	r31, r31
    61ca:	ee 0f       	add	r30, r30
    61cc:	ff 1f       	adc	r31, r31
    61ce:	cf 01       	movw	r24, r30
    61d0:	88 0f       	add	r24, r24
    61d2:	99 1f       	adc	r25, r25
    61d4:	88 0f       	add	r24, r24
    61d6:	99 1f       	adc	r25, r25
    61d8:	e8 0f       	add	r30, r24
    61da:	f9 1f       	adc	r31, r25
    61dc:	e0 51       	subi	r30, 0x10	; 16
    61de:	fc 4f       	sbci	r31, 0xFC	; 252
    61e0:	21 8f       	std	Z+25, r18	; 0x19
              if(motor[i].stepUnit < 0){
    61e2:	fa 01       	movw	r30, r20
    61e4:	ee 0f       	add	r30, r30
    61e6:	ff 1f       	adc	r31, r31
    61e8:	ee 0f       	add	r30, r30
    61ea:	ff 1f       	adc	r31, r31
    61ec:	ee 0f       	add	r30, r30
    61ee:	ff 1f       	adc	r31, r31
    61f0:	cf 01       	movw	r24, r30
    61f2:	88 0f       	add	r24, r24
    61f4:	99 1f       	adc	r25, r25
    61f6:	88 0f       	add	r24, r24
    61f8:	99 1f       	adc	r25, r25
    61fa:	e8 0f       	add	r30, r24
    61fc:	f9 1f       	adc	r31, r25
    61fe:	e0 51       	subi	r30, 0x10	; 16
    6200:	fc 4f       	sbci	r31, 0xFC	; 252
    6202:	81 8d       	ldd	r24, Z+25	; 0x19
    6204:	87 fd       	sbrc	r24, 7
    6206:	17 c3       	rjmp	.+1582   	; 0x6836 <updateMenu+0xc32>
                motor[i].stepUnit = 2;
              }
              if(motor[i].stepUnit > 2){
    6208:	e3 2f       	mov	r30, r19
    620a:	f6 2f       	mov	r31, r22
    620c:	ee 0f       	add	r30, r30
    620e:	ff 1f       	adc	r31, r31
    6210:	ee 0f       	add	r30, r30
    6212:	ff 1f       	adc	r31, r31
    6214:	ee 0f       	add	r30, r30
    6216:	ff 1f       	adc	r31, r31
    6218:	cf 01       	movw	r24, r30
    621a:	88 0f       	add	r24, r24
    621c:	99 1f       	adc	r25, r25
    621e:	88 0f       	add	r24, r24
    6220:	99 1f       	adc	r25, r25
    6222:	e8 0f       	add	r30, r24
    6224:	f9 1f       	adc	r31, r25
    6226:	e0 51       	subi	r30, 0x10	; 16
    6228:	fc 4f       	sbci	r31, 0xFC	; 252
    622a:	81 8d       	ldd	r24, Z+25	; 0x19
    622c:	83 30       	cpi	r24, 0x03	; 3
    622e:	94 f0       	brlt	.+36     	; 0x6254 <updateMenu+0x650>
                motor[i].stepUnit = 0;
    6230:	e3 2f       	mov	r30, r19
    6232:	f6 2f       	mov	r31, r22
    6234:	ee 0f       	add	r30, r30
    6236:	ff 1f       	adc	r31, r31
    6238:	ee 0f       	add	r30, r30
    623a:	ff 1f       	adc	r31, r31
    623c:	ee 0f       	add	r30, r30
    623e:	ff 1f       	adc	r31, r31
    6240:	cf 01       	movw	r24, r30
    6242:	88 0f       	add	r24, r24
    6244:	99 1f       	adc	r25, r25
    6246:	88 0f       	add	r24, r24
    6248:	99 1f       	adc	r25, r25
    624a:	e8 0f       	add	r30, r24
    624c:	f9 1f       	adc	r31, r25
    624e:	e0 51       	subi	r30, 0x10	; 16
    6250:	fc 4f       	sbci	r31, 0xFC	; 252
    6252:	11 8e       	std	Z+25, r1	; 0x19
    6254:	4f 5f       	subi	r20, 0xFF	; 255
    6256:	5f 4f       	sbci	r21, 0xFF	; 255
            }
          }
          break;

        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6258:	44 30       	cpi	r20, 0x04	; 4
    625a:	51 05       	cpc	r21, r1
    625c:	09 f0       	breq	.+2      	; 0x6260 <updateMenu+0x65c>
    625e:	91 cf       	rjmp	.-222    	; 0x6182 <updateMenu+0x57e>
    6260:	f5 cc       	rjmp	.-1558   	; 0x5c4c <updateMenu+0x48>
    6262:	40 e0       	ldi	r20, 0x00	; 0
    6264:	50 e0       	ldi	r21, 0x00	; 0
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].waitBetweenSteps += rotEncVal;
    6266:	61 2f       	mov	r22, r17
    6268:	77 27       	eor	r23, r23
    626a:	67 fd       	sbrc	r22, 7
    626c:	70 95       	com	r23
              if(motor[i].waitBetweenSteps < 1){
                /* wait time is at least 1 ms */
                motor[i].waitBetweenSteps = 1;
    626e:	c1 e0       	ldi	r28, 0x01	; 1
    6270:	d0 e0       	ldi	r29, 0x00	; 0
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6272:	80 91 e5 02 	lds	r24, 0x02E5
    6276:	da 01       	movw	r26, r20
    6278:	90 e0       	ldi	r25, 0x00	; 0
    627a:	04 2e       	mov	r0, r20
    627c:	02 c0       	rjmp	.+4      	; 0x6282 <updateMenu+0x67e>
    627e:	95 95       	asr	r25
    6280:	87 95       	ror	r24
    6282:	0a 94       	dec	r0
    6284:	e2 f7       	brpl	.-8      	; 0x627e <updateMenu+0x67a>
    6286:	80 ff       	sbrs	r24, 0
    6288:	74 c0       	rjmp	.+232    	; 0x6372 <updateMenu+0x76e>
              motor[i].waitBetweenSteps += rotEncVal;
    628a:	fa 01       	movw	r30, r20
    628c:	ee 0f       	add	r30, r30
    628e:	ff 1f       	adc	r31, r31
    6290:	ee 0f       	add	r30, r30
    6292:	ff 1f       	adc	r31, r31
    6294:	ee 0f       	add	r30, r30
    6296:	ff 1f       	adc	r31, r31
    6298:	cf 01       	movw	r24, r30
    629a:	88 0f       	add	r24, r24
    629c:	99 1f       	adc	r25, r25
    629e:	88 0f       	add	r24, r24
    62a0:	99 1f       	adc	r25, r25
    62a2:	e8 0f       	add	r30, r24
    62a4:	f9 1f       	adc	r31, r25
    62a6:	e0 51       	subi	r30, 0x10	; 16
    62a8:	fc 4f       	sbci	r31, 0xFC	; 252
    62aa:	26 8d       	ldd	r18, Z+30	; 0x1e
    62ac:	37 8d       	ldd	r19, Z+31	; 0x1f
    62ae:	26 0f       	add	r18, r22
    62b0:	37 1f       	adc	r19, r23
    62b2:	fa 01       	movw	r30, r20
    62b4:	ee 0f       	add	r30, r30
    62b6:	ff 1f       	adc	r31, r31
    62b8:	ee 0f       	add	r30, r30
    62ba:	ff 1f       	adc	r31, r31
    62bc:	ee 0f       	add	r30, r30
    62be:	ff 1f       	adc	r31, r31
    62c0:	cf 01       	movw	r24, r30
    62c2:	88 0f       	add	r24, r24
    62c4:	99 1f       	adc	r25, r25
    62c6:	88 0f       	add	r24, r24
    62c8:	99 1f       	adc	r25, r25
    62ca:	e8 0f       	add	r30, r24
    62cc:	f9 1f       	adc	r31, r25
    62ce:	e0 51       	subi	r30, 0x10	; 16
    62d0:	fc 4f       	sbci	r31, 0xFC	; 252
    62d2:	37 8f       	std	Z+31, r19	; 0x1f
    62d4:	26 8f       	std	Z+30, r18	; 0x1e
              if(motor[i].waitBetweenSteps < 1){
    62d6:	fa 01       	movw	r30, r20
    62d8:	ee 0f       	add	r30, r30
    62da:	ff 1f       	adc	r31, r31
    62dc:	ee 0f       	add	r30, r30
    62de:	ff 1f       	adc	r31, r31
    62e0:	ee 0f       	add	r30, r30
    62e2:	ff 1f       	adc	r31, r31
    62e4:	cf 01       	movw	r24, r30
    62e6:	88 0f       	add	r24, r24
    62e8:	99 1f       	adc	r25, r25
    62ea:	88 0f       	add	r24, r24
    62ec:	99 1f       	adc	r25, r25
    62ee:	e8 0f       	add	r30, r24
    62f0:	f9 1f       	adc	r31, r25
    62f2:	e0 51       	subi	r30, 0x10	; 16
    62f4:	fc 4f       	sbci	r31, 0xFC	; 252
    62f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    62f8:	97 8d       	ldd	r25, Z+31	; 0x1f
    62fa:	89 2b       	or	r24, r25
    62fc:	91 f4       	brne	.+36     	; 0x6322 <updateMenu+0x71e>
                /* wait time is at least 1 ms */
                motor[i].waitBetweenSteps = 1;
    62fe:	fa 01       	movw	r30, r20
    6300:	ee 0f       	add	r30, r30
    6302:	ff 1f       	adc	r31, r31
    6304:	ee 0f       	add	r30, r30
    6306:	ff 1f       	adc	r31, r31
    6308:	ee 0f       	add	r30, r30
    630a:	ff 1f       	adc	r31, r31
    630c:	cf 01       	movw	r24, r30
    630e:	88 0f       	add	r24, r24
    6310:	99 1f       	adc	r25, r25
    6312:	88 0f       	add	r24, r24
    6314:	99 1f       	adc	r25, r25
    6316:	e8 0f       	add	r30, r24
    6318:	f9 1f       	adc	r31, r25
    631a:	e0 51       	subi	r30, 0x10	; 16
    631c:	fc 4f       	sbci	r31, 0xFC	; 252
    631e:	d7 8f       	std	Z+31, r29	; 0x1f
    6320:	c6 8f       	std	Z+30, r28	; 0x1e
              }
              motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    6322:	fd 01       	movw	r30, r26
    6324:	ee 0f       	add	r30, r30
    6326:	ff 1f       	adc	r31, r31
    6328:	ee 0f       	add	r30, r30
    632a:	ff 1f       	adc	r31, r31
    632c:	ee 0f       	add	r30, r30
    632e:	ff 1f       	adc	r31, r31
    6330:	cf 01       	movw	r24, r30
    6332:	88 0f       	add	r24, r24
    6334:	99 1f       	adc	r25, r25
    6336:	88 0f       	add	r24, r24
    6338:	99 1f       	adc	r25, r25
    633a:	e8 0f       	add	r30, r24
    633c:	f9 1f       	adc	r31, r25
    633e:	e0 51       	subi	r30, 0x10	; 16
    6340:	fc 4f       	sbci	r31, 0xFC	; 252
    6342:	26 8d       	ldd	r18, Z+30	; 0x1e
    6344:	37 8d       	ldd	r19, Z+31	; 0x1f
    6346:	22 0f       	add	r18, r18
    6348:	33 1f       	adc	r19, r19
    634a:	21 50       	subi	r18, 0x01	; 1
    634c:	30 40       	sbci	r19, 0x00	; 0
    634e:	fd 01       	movw	r30, r26
    6350:	ee 0f       	add	r30, r30
    6352:	ff 1f       	adc	r31, r31
    6354:	ee 0f       	add	r30, r30
    6356:	ff 1f       	adc	r31, r31
    6358:	ee 0f       	add	r30, r30
    635a:	ff 1f       	adc	r31, r31
    635c:	cf 01       	movw	r24, r30
    635e:	88 0f       	add	r24, r24
    6360:	99 1f       	adc	r25, r25
    6362:	88 0f       	add	r24, r24
    6364:	99 1f       	adc	r25, r25
    6366:	e8 0f       	add	r30, r24
    6368:	f9 1f       	adc	r31, r25
    636a:	e0 51       	subi	r30, 0x10	; 16
    636c:	fc 4f       	sbci	r31, 0xFC	; 252
    636e:	31 a3       	std	Z+33, r19	; 0x21
    6370:	20 a3       	std	Z+32, r18	; 0x20
    6372:	4f 5f       	subi	r20, 0xFF	; 255
    6374:	5f 4f       	sbci	r21, 0xFF	; 255
            }
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6376:	44 30       	cpi	r20, 0x04	; 4
    6378:	51 05       	cpc	r21, r1
    637a:	09 f0       	breq	.+2      	; 0x637e <updateMenu+0x77a>
    637c:	7a cf       	rjmp	.-268    	; 0x6272 <updateMenu+0x66e>
    637e:	66 cc       	rjmp	.-1844   	; 0x5c4c <updateMenu+0x48>
            }
          }
          break;

        case MENU_SAVE_CONFIG:   /* save current configuration */
          saveConfigToEEPROM();
    6380:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <saveConfigToEEPROM>
          //lcd_clear();
          //lcd_string("saved");
          OLEDclear();
    6384:	0e 94 07 3a 	call	0x740e	; 0x740e <OLEDclear>
          OLEDsetCursor(0, 0);
    6388:	80 e0       	ldi	r24, 0x00	; 0
    638a:	60 e0       	ldi	r22, 0x00	; 0
    638c:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
          OLEDprintCC("saved");
    6390:	8c eb       	ldi	r24, 0xBC	; 188
    6392:	92 e0       	ldi	r25, 0x02	; 2
    6394:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
    6398:	59 cc       	rjmp	.-1870   	; 0x5c4c <updateMenu+0x48>
            }
          }
          break;

        case MENU_RUN_PROGRAM:  /* run an internal program defined by CLI */
          if(rotEncVal > 0){
    639a:	11 16       	cp	r1, r17
    639c:	0c f0       	brlt	.+2      	; 0x63a0 <updateMenu+0x79c>
    639e:	1b c3       	rjmp	.+1590   	; 0x69d6 <updateMenu+0xdd2>
            do{
              /* find the next active program step */
              menu.currentProgramStep += 1;
    63a0:	80 91 e3 02 	lds	r24, 0x02E3
    63a4:	8f 5f       	subi	r24, 0xFF	; 255
    63a6:	80 93 e3 02 	sts	0x02E3, r24
              if(menu.currentProgramStep >= MAX_PROGRAM_STEPS){
    63aa:	80 91 e3 02 	lds	r24, 0x02E3
    63ae:	80 31       	cpi	r24, 0x10	; 16
    63b0:	14 f0       	brlt	.+4      	; 0x63b6 <updateMenu+0x7b2>
                menu.currentProgramStep = 0;
    63b2:	10 92 e3 02 	sts	0x02E3, r1
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
    63b6:	80 91 e3 02 	lds	r24, 0x02E3
    63ba:	99 27       	eor	r25, r25
    63bc:	87 fd       	sbrc	r24, 7
    63be:	90 95       	com	r25
    63c0:	fc 01       	movw	r30, r24
    63c2:	ee 0f       	add	r30, r30
    63c4:	ff 1f       	adc	r31, r31
    63c6:	ee 0f       	add	r30, r30
    63c8:	ff 1f       	adc	r31, r31
    63ca:	ee 0f       	add	r30, r30
    63cc:	ff 1f       	adc	r31, r31
    63ce:	88 0f       	add	r24, r24
    63d0:	99 1f       	adc	r25, r25
    63d2:	e8 0f       	add	r30, r24
    63d4:	f9 1f       	adc	r31, r25
    63d6:	ed 50       	subi	r30, 0x0D	; 13
    63d8:	fd 4f       	sbci	r31, 0xFD	; 253
    63da:	80 81       	ld	r24, Z
    63dc:	88 23       	and	r24, r24
    63de:	01 f3       	breq	.-64     	; 0x63a0 <updateMenu+0x79c>
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
          }

          if(programList[menu.currentProgramStep].absRel == PROG_ABSOLUTE_MOVEMENT){
    63e0:	80 91 e3 02 	lds	r24, 0x02E3
    63e4:	99 27       	eor	r25, r25
    63e6:	87 fd       	sbrc	r24, 7
    63e8:	90 95       	com	r25
    63ea:	fc 01       	movw	r30, r24
    63ec:	ee 0f       	add	r30, r30
    63ee:	ff 1f       	adc	r31, r31
    63f0:	ee 0f       	add	r30, r30
    63f2:	ff 1f       	adc	r31, r31
    63f4:	ee 0f       	add	r30, r30
    63f6:	ff 1f       	adc	r31, r31
    63f8:	88 0f       	add	r24, r24
    63fa:	99 1f       	adc	r25, r25
    63fc:	e8 0f       	add	r30, r24
    63fe:	f9 1f       	adc	r31, r25
    6400:	ed 50       	subi	r30, 0x0D	; 13
    6402:	fd 4f       	sbci	r31, 0xFD	; 253
    6404:	81 85       	ldd	r24, Z+9	; 0x09
    6406:	88 23       	and	r24, r24
    6408:	09 f0       	breq	.+2      	; 0x640c <updateMenu+0x808>
    640a:	3c c2       	rjmp	.+1144   	; 0x6884 <updateMenu+0xc80>
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
    640c:	80 91 e3 02 	lds	r24, 0x02E3
    6410:	99 27       	eor	r25, r25
    6412:	87 fd       	sbrc	r24, 7
    6414:	90 95       	com	r25
    6416:	fc 01       	movw	r30, r24
    6418:	ee 0f       	add	r30, r30
    641a:	ff 1f       	adc	r31, r31
    641c:	ee 0f       	add	r30, r30
    641e:	ff 1f       	adc	r31, r31
    6420:	ee 0f       	add	r30, r30
    6422:	ff 1f       	adc	r31, r31
    6424:	88 0f       	add	r24, r24
    6426:	99 1f       	adc	r25, r25
    6428:	e8 0f       	add	r30, r24
    642a:	f9 1f       	adc	r31, r25
    642c:	ed 50       	subi	r30, 0x0D	; 13
    642e:	fd 4f       	sbci	r31, 0xFD	; 253
    6430:	81 81       	ldd	r24, Z+1	; 0x01
    6432:	92 81       	ldd	r25, Z+2	; 0x02
    6434:	90 93 f3 03 	sts	0x03F3, r25
    6438:	80 93 f2 03 	sts	0x03F2, r24
    643c:	80 91 e3 02 	lds	r24, 0x02E3
    6440:	99 27       	eor	r25, r25
    6442:	87 fd       	sbrc	r24, 7
    6444:	90 95       	com	r25
    6446:	fc 01       	movw	r30, r24
    6448:	ee 0f       	add	r30, r30
    644a:	ff 1f       	adc	r31, r31
    644c:	ee 0f       	add	r30, r30
    644e:	ff 1f       	adc	r31, r31
    6450:	ee 0f       	add	r30, r30
    6452:	ff 1f       	adc	r31, r31
    6454:	88 0f       	add	r24, r24
    6456:	99 1f       	adc	r25, r25
    6458:	e8 0f       	add	r30, r24
    645a:	f9 1f       	adc	r31, r25
    645c:	ed 50       	subi	r30, 0x0D	; 13
    645e:	fd 4f       	sbci	r31, 0xFD	; 253
    6460:	83 81       	ldd	r24, Z+3	; 0x03
    6462:	94 81       	ldd	r25, Z+4	; 0x04
    6464:	90 93 1b 04 	sts	0x041B, r25
    6468:	80 93 1a 04 	sts	0x041A, r24
    646c:	80 91 e3 02 	lds	r24, 0x02E3
    6470:	99 27       	eor	r25, r25
    6472:	87 fd       	sbrc	r24, 7
    6474:	90 95       	com	r25
    6476:	fc 01       	movw	r30, r24
    6478:	ee 0f       	add	r30, r30
    647a:	ff 1f       	adc	r31, r31
    647c:	ee 0f       	add	r30, r30
    647e:	ff 1f       	adc	r31, r31
    6480:	ee 0f       	add	r30, r30
    6482:	ff 1f       	adc	r31, r31
    6484:	88 0f       	add	r24, r24
    6486:	99 1f       	adc	r25, r25
    6488:	e8 0f       	add	r30, r24
    648a:	f9 1f       	adc	r31, r25
    648c:	ed 50       	subi	r30, 0x0D	; 13
    648e:	fd 4f       	sbci	r31, 0xFD	; 253
    6490:	85 81       	ldd	r24, Z+5	; 0x05
    6492:	96 81       	ldd	r25, Z+6	; 0x06
    6494:	90 93 43 04 	sts	0x0443, r25
    6498:	80 93 42 04 	sts	0x0442, r24
    649c:	80 91 e3 02 	lds	r24, 0x02E3
    64a0:	99 27       	eor	r25, r25
    64a2:	87 fd       	sbrc	r24, 7
    64a4:	90 95       	com	r25
    64a6:	fc 01       	movw	r30, r24
    64a8:	ee 0f       	add	r30, r30
    64aa:	ff 1f       	adc	r31, r31
    64ac:	ee 0f       	add	r30, r30
    64ae:	ff 1f       	adc	r31, r31
    64b0:	ee 0f       	add	r30, r30
    64b2:	ff 1f       	adc	r31, r31
    64b4:	88 0f       	add	r24, r24
    64b6:	99 1f       	adc	r25, r25
    64b8:	e8 0f       	add	r30, r24
    64ba:	f9 1f       	adc	r31, r25
    64bc:	ed 50       	subi	r30, 0x0D	; 13
    64be:	fd 4f       	sbci	r31, 0xFD	; 253
    64c0:	87 81       	ldd	r24, Z+7	; 0x07
    64c2:	90 85       	ldd	r25, Z+8	; 0x08
    64c4:	90 93 6b 04 	sts	0x046B, r25
    64c8:	80 93 6a 04 	sts	0x046A, r24
    64cc:	bf cb       	rjmp	.-2178   	; 0x5c4c <updateMenu+0x48>
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    64ce:	c0 e0       	ldi	r28, 0x00	; 0
    64d0:	d0 e0       	ldi	r29, 0x00	; 0
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
              if(motor[i].angularVelocity < 0){
                motor[i].angularVelocity = 2;
    64d2:	02 e0       	ldi	r16, 0x02	; 2
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    64d4:	4c 2f       	mov	r20, r28
          }
          break;

        case MENU_CONST_ANGULAR_SPEED:  /* enter constant moving mode */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    64d6:	80 91 e5 02 	lds	r24, 0x02E5
    64da:	90 e0       	ldi	r25, 0x00	; 0
    64dc:	0c 2e       	mov	r0, r28
    64de:	02 c0       	rjmp	.+4      	; 0x64e4 <updateMenu+0x8e0>
    64e0:	95 95       	asr	r25
    64e2:	87 95       	ror	r24
    64e4:	0a 94       	dec	r0
    64e6:	e2 f7       	brpl	.-8      	; 0x64e0 <updateMenu+0x8dc>
    64e8:	80 ff       	sbrs	r24, 0
    64ea:	3d c0       	rjmp	.+122    	; 0x6566 <updateMenu+0x962>
              if(forbiddenZone[i].active){
    64ec:	fe 01       	movw	r30, r28
    64ee:	ee 0f       	add	r30, r30
    64f0:	ff 1f       	adc	r31, r31
    64f2:	ee 0f       	add	r30, r30
    64f4:	ff 1f       	adc	r31, r31
    64f6:	ec 0f       	add	r30, r28
    64f8:	fd 1f       	adc	r31, r29
    64fa:	ed 52       	subi	r30, 0x2D	; 45
    64fc:	fc 4f       	sbci	r31, 0xFC	; 252
    64fe:	84 81       	ldd	r24, Z+4	; 0x04
    6500:	88 23       	and	r24, r24
    6502:	09 f0       	breq	.+2      	; 0x6506 <updateMenu+0x902>
    6504:	a3 cb       	rjmp	.-2234   	; 0x5c4c <updateMenu+0x48>
                /* const angular speed not allowed if
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
    6506:	9e 01       	movw	r18, r28
    6508:	22 0f       	add	r18, r18
    650a:	33 1f       	adc	r19, r19
    650c:	22 0f       	add	r18, r18
    650e:	33 1f       	adc	r19, r19
    6510:	22 0f       	add	r18, r18
    6512:	33 1f       	adc	r19, r19
    6514:	f9 01       	movw	r30, r18
    6516:	ee 0f       	add	r30, r30
    6518:	ff 1f       	adc	r31, r31
    651a:	ee 0f       	add	r30, r30
    651c:	ff 1f       	adc	r31, r31
    651e:	e2 0f       	add	r30, r18
    6520:	f3 1f       	adc	r31, r19
    6522:	e0 51       	subi	r30, 0x10	; 16
    6524:	fc 4f       	sbci	r31, 0xFC	; 252
    6526:	82 a1       	ldd	r24, Z+34	; 0x22
    6528:	81 0f       	add	r24, r17
    652a:	82 a3       	std	Z+34, r24	; 0x22
              if(motor[i].angularVelocity < 0){
    652c:	82 a1       	ldd	r24, Z+34	; 0x22
    652e:	87 fd       	sbrc	r24, 7
    6530:	a7 c1       	rjmp	.+846    	; 0x6880 <updateMenu+0xc7c>
                motor[i].angularVelocity = 2;
              }
              if(motor[i].angularVelocity > 2){
    6532:	f9 01       	movw	r30, r18
    6534:	ee 0f       	add	r30, r30
    6536:	ff 1f       	adc	r31, r31
    6538:	ee 0f       	add	r30, r30
    653a:	ff 1f       	adc	r31, r31
    653c:	e2 0f       	add	r30, r18
    653e:	f3 1f       	adc	r31, r19
    6540:	e0 51       	subi	r30, 0x10	; 16
    6542:	fc 4f       	sbci	r31, 0xFC	; 252
    6544:	82 a1       	ldd	r24, Z+34	; 0x22
    6546:	83 30       	cpi	r24, 0x03	; 3
    6548:	0c f0       	brlt	.+2      	; 0x654c <updateMenu+0x948>
                motor[i].angularVelocity = 0;
    654a:	12 a2       	std	Z+34, r1	; 0x22
              }
              setConstSpeed(i, motor[i].angularVelocity);
    654c:	f9 01       	movw	r30, r18
    654e:	ee 0f       	add	r30, r30
    6550:	ff 1f       	adc	r31, r31
    6552:	ee 0f       	add	r30, r30
    6554:	ff 1f       	adc	r31, r31
    6556:	e2 0f       	add	r30, r18
    6558:	f3 1f       	adc	r31, r19
    655a:	e0 51       	subi	r30, 0x10	; 16
    655c:	fc 4f       	sbci	r31, 0xFC	; 252
    655e:	62 a1       	ldd	r22, Z+34	; 0x22
    6560:	84 2f       	mov	r24, r20
    6562:	0e 94 a8 08 	call	0x1150	; 0x1150 <setConstSpeed>
    6566:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_CONST_ANGULAR_SPEED:  /* enter constant moving mode */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6568:	c4 30       	cpi	r28, 0x04	; 4
    656a:	d1 05       	cpc	r29, r1
    656c:	09 f0       	breq	.+2      	; 0x6570 <updateMenu+0x96c>
    656e:	b2 cf       	rjmp	.-156    	; 0x64d4 <updateMenu+0x8d0>
    6570:	6d cb       	rjmp	.-2342   	; 0x5c4c <updateMenu+0x48>
            }
          }
          break;
          
        case MENU_SETTINGS:        
          OLEDclear();
    6572:	0e 94 07 3a 	call	0x740e	; 0x740e <OLEDclear>
          OLEDsetCursor(0, 0);
    6576:	80 e0       	ldi	r24, 0x00	; 0
    6578:	60 e0       	ldi	r22, 0x00	; 0
    657a:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
          OLEDprintCC("hello"); //should never show up
    657e:	89 ec       	ldi	r24, 0xC9	; 201
    6580:	92 e0       	ldi	r25, 0x02	; 2
    6582:	0e 94 38 39 	call	0x7270	; 0x7270 <OLEDprintCC>
    6586:	62 cb       	rjmp	.-2364   	; 0x5c4c <updateMenu+0x48>
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    6588:	c0 e0       	ldi	r28, 0x00	; 0
    658a:	d0 e0       	ldi	r29, 0x00	; 0
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].current += (rotEncVal)/10.0;
    658c:	61 2e       	mov	r6, r17
    658e:	77 24       	eor	r7, r7
    6590:	67 fc       	sbrc	r6, 7
    6592:	70 94       	com	r7
    6594:	87 2c       	mov	r8, r7
    6596:	97 2c       	mov	r9, r7
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    6598:	bc 2e       	mov	r11, r28
          }
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    659a:	80 91 e5 02 	lds	r24, 0x02E5
    659e:	dc 2e       	mov	r13, r28
    65a0:	cd 2e       	mov	r12, r29
    65a2:	90 e0       	ldi	r25, 0x00	; 0
    65a4:	0c 2e       	mov	r0, r28
    65a6:	02 c0       	rjmp	.+4      	; 0x65ac <updateMenu+0x9a8>
    65a8:	95 95       	asr	r25
    65aa:	87 95       	ror	r24
    65ac:	0a 94       	dec	r0
    65ae:	e2 f7       	brpl	.-8      	; 0x65a8 <updateMenu+0x9a4>
    65b0:	80 ff       	sbrs	r24, 0
    65b2:	a3 c0       	rjmp	.+326    	; 0x66fa <updateMenu+0xaf6>
              motor[i].current += (rotEncVal)/10.0;
    65b4:	fe 01       	movw	r30, r28
    65b6:	ee 0f       	add	r30, r30
    65b8:	ff 1f       	adc	r31, r31
    65ba:	ee 0f       	add	r30, r30
    65bc:	ff 1f       	adc	r31, r31
    65be:	ee 0f       	add	r30, r30
    65c0:	ff 1f       	adc	r31, r31
    65c2:	cf 01       	movw	r24, r30
    65c4:	88 0f       	add	r24, r24
    65c6:	99 1f       	adc	r25, r25
    65c8:	88 0f       	add	r24, r24
    65ca:	99 1f       	adc	r25, r25
    65cc:	e8 0f       	add	r30, r24
    65ce:	f9 1f       	adc	r31, r25
    65d0:	e0 51       	subi	r30, 0x10	; 16
    65d2:	fc 4f       	sbci	r31, 0xFC	; 252
    65d4:	e3 a0       	ldd	r14, Z+35	; 0x23
    65d6:	f4 a0       	ldd	r15, Z+36	; 0x24
    65d8:	05 a1       	ldd	r16, Z+37	; 0x25
    65da:	16 a1       	ldd	r17, Z+38	; 0x26
    65dc:	c4 01       	movw	r24, r8
    65de:	b3 01       	movw	r22, r6
    65e0:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    65e4:	20 e0       	ldi	r18, 0x00	; 0
    65e6:	30 e0       	ldi	r19, 0x00	; 0
    65e8:	40 e2       	ldi	r20, 0x20	; 32
    65ea:	51 e4       	ldi	r21, 0x41	; 65
    65ec:	0e 94 a2 3f 	call	0x7f44	; 0x7f44 <__divsf3>
    65f0:	9b 01       	movw	r18, r22
    65f2:	ac 01       	movw	r20, r24
    65f4:	c8 01       	movw	r24, r16
    65f6:	b7 01       	movw	r22, r14
    65f8:	0e 94 3a 3f 	call	0x7e74	; 0x7e74 <__addsf3>
    65fc:	fe 01       	movw	r30, r28
    65fe:	ee 0f       	add	r30, r30
    6600:	ff 1f       	adc	r31, r31
    6602:	ee 0f       	add	r30, r30
    6604:	ff 1f       	adc	r31, r31
    6606:	ee 0f       	add	r30, r30
    6608:	ff 1f       	adc	r31, r31
    660a:	9f 01       	movw	r18, r30
    660c:	22 0f       	add	r18, r18
    660e:	33 1f       	adc	r19, r19
    6610:	22 0f       	add	r18, r18
    6612:	33 1f       	adc	r19, r19
    6614:	e2 0f       	add	r30, r18
    6616:	f3 1f       	adc	r31, r19
    6618:	e0 51       	subi	r30, 0x10	; 16
    661a:	fc 4f       	sbci	r31, 0xFC	; 252
    661c:	63 a3       	std	Z+35, r22	; 0x23
    661e:	74 a3       	std	Z+36, r23	; 0x24
    6620:	85 a3       	std	Z+37, r24	; 0x25
    6622:	96 a3       	std	Z+38, r25	; 0x26
              if(motor[i].current < 0){
    6624:	fe 01       	movw	r30, r28
    6626:	ee 0f       	add	r30, r30
    6628:	ff 1f       	adc	r31, r31
    662a:	ee 0f       	add	r30, r30
    662c:	ff 1f       	adc	r31, r31
    662e:	ee 0f       	add	r30, r30
    6630:	ff 1f       	adc	r31, r31
    6632:	cf 01       	movw	r24, r30
    6634:	88 0f       	add	r24, r24
    6636:	99 1f       	adc	r25, r25
    6638:	88 0f       	add	r24, r24
    663a:	99 1f       	adc	r25, r25
    663c:	e8 0f       	add	r30, r24
    663e:	f9 1f       	adc	r31, r25
    6640:	e0 51       	subi	r30, 0x10	; 16
    6642:	fc 4f       	sbci	r31, 0xFC	; 252
    6644:	63 a1       	ldd	r22, Z+35	; 0x23
    6646:	74 a1       	ldd	r23, Z+36	; 0x24
    6648:	85 a1       	ldd	r24, Z+37	; 0x25
    664a:	96 a1       	ldd	r25, Z+38	; 0x26
    664c:	20 e0       	ldi	r18, 0x00	; 0
    664e:	30 e0       	ldi	r19, 0x00	; 0
    6650:	40 e0       	ldi	r20, 0x00	; 0
    6652:	50 e0       	ldi	r21, 0x00	; 0
    6654:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <__cmpsf2>
    6658:	88 23       	and	r24, r24
    665a:	0c f4       	brge	.+2      	; 0x665e <updateMenu+0xa5a>
    665c:	d3 c0       	rjmp	.+422    	; 0x6804 <updateMenu+0xc00>
                motor[i].current = 0;
              }
              if(motor[i].current > 2.5){
    665e:	ed 2d       	mov	r30, r13
    6660:	fc 2d       	mov	r31, r12
    6662:	ee 0f       	add	r30, r30
    6664:	ff 1f       	adc	r31, r31
    6666:	ee 0f       	add	r30, r30
    6668:	ff 1f       	adc	r31, r31
    666a:	ee 0f       	add	r30, r30
    666c:	ff 1f       	adc	r31, r31
    666e:	cf 01       	movw	r24, r30
    6670:	88 0f       	add	r24, r24
    6672:	99 1f       	adc	r25, r25
    6674:	88 0f       	add	r24, r24
    6676:	99 1f       	adc	r25, r25
    6678:	e8 0f       	add	r30, r24
    667a:	f9 1f       	adc	r31, r25
    667c:	e0 51       	subi	r30, 0x10	; 16
    667e:	fc 4f       	sbci	r31, 0xFC	; 252
    6680:	63 a1       	ldd	r22, Z+35	; 0x23
    6682:	74 a1       	ldd	r23, Z+36	; 0x24
    6684:	85 a1       	ldd	r24, Z+37	; 0x25
    6686:	96 a1       	ldd	r25, Z+38	; 0x26
    6688:	20 e0       	ldi	r18, 0x00	; 0
    668a:	30 e0       	ldi	r19, 0x00	; 0
    668c:	40 e2       	ldi	r20, 0x20	; 32
    668e:	50 e4       	ldi	r21, 0x40	; 64
    6690:	0e 94 40 41 	call	0x8280	; 0x8280 <__gesf2>
    6694:	18 16       	cp	r1, r24
    6696:	cc f4       	brge	.+50     	; 0x66ca <updateMenu+0xac6>
                motor[i].current = 2.5;
    6698:	ed 2d       	mov	r30, r13
    669a:	fc 2d       	mov	r31, r12
    669c:	ee 0f       	add	r30, r30
    669e:	ff 1f       	adc	r31, r31
    66a0:	ee 0f       	add	r30, r30
    66a2:	ff 1f       	adc	r31, r31
    66a4:	ee 0f       	add	r30, r30
    66a6:	ff 1f       	adc	r31, r31
    66a8:	cf 01       	movw	r24, r30
    66aa:	88 0f       	add	r24, r24
    66ac:	99 1f       	adc	r25, r25
    66ae:	88 0f       	add	r24, r24
    66b0:	99 1f       	adc	r25, r25
    66b2:	e8 0f       	add	r30, r24
    66b4:	f9 1f       	adc	r31, r25
    66b6:	e0 51       	subi	r30, 0x10	; 16
    66b8:	fc 4f       	sbci	r31, 0xFC	; 252
    66ba:	80 e0       	ldi	r24, 0x00	; 0
    66bc:	90 e0       	ldi	r25, 0x00	; 0
    66be:	a0 e2       	ldi	r26, 0x20	; 32
    66c0:	b0 e4       	ldi	r27, 0x40	; 64
    66c2:	83 a3       	std	Z+35, r24	; 0x23
    66c4:	94 a3       	std	Z+36, r25	; 0x24
    66c6:	a5 a3       	std	Z+37, r26	; 0x25
    66c8:	b6 a3       	std	Z+38, r27	; 0x26
              }
              setMotorCurrent(i, motor[i].current);
    66ca:	ed 2d       	mov	r30, r13
    66cc:	fc 2d       	mov	r31, r12
    66ce:	ee 0f       	add	r30, r30
    66d0:	ff 1f       	adc	r31, r31
    66d2:	ee 0f       	add	r30, r30
    66d4:	ff 1f       	adc	r31, r31
    66d6:	ee 0f       	add	r30, r30
    66d8:	ff 1f       	adc	r31, r31
    66da:	cf 01       	movw	r24, r30
    66dc:	88 0f       	add	r24, r24
    66de:	99 1f       	adc	r25, r25
    66e0:	88 0f       	add	r24, r24
    66e2:	99 1f       	adc	r25, r25
    66e4:	e8 0f       	add	r30, r24
    66e6:	f9 1f       	adc	r31, r25
    66e8:	e0 51       	subi	r30, 0x10	; 16
    66ea:	fc 4f       	sbci	r31, 0xFC	; 252
    66ec:	43 a1       	ldd	r20, Z+35	; 0x23
    66ee:	54 a1       	ldd	r21, Z+36	; 0x24
    66f0:	65 a1       	ldd	r22, Z+37	; 0x25
    66f2:	76 a1       	ldd	r23, Z+38	; 0x26
    66f4:	8b 2d       	mov	r24, r11
    66f6:	0e 94 b7 26 	call	0x4d6e	; 0x4d6e <setMotorCurrent>
    66fa:	21 96       	adiw	r28, 0x01	; 1
            ;
          }
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    66fc:	c4 30       	cpi	r28, 0x04	; 4
    66fe:	d1 05       	cpc	r29, r1
    6700:	09 f0       	breq	.+2      	; 0x6704 <updateMenu+0xb00>
    6702:	4a cf       	rjmp	.-364    	; 0x6598 <updateMenu+0x994>
    6704:	a3 ca       	rjmp	.-2746   	; 0x5c4c <updateMenu+0x48>
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              switch(motor[i].stepUnit){
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
    6706:	81 2e       	mov	r8, r17
    6708:	99 24       	eor	r9, r9
    670a:	87 fc       	sbrc	r8, 7
    670c:	90 94       	com	r9
    670e:	84 e6       	ldi	r24, 0x64	; 100
    6710:	90 e0       	ldi	r25, 0x00	; 0
    6712:	88 9e       	mul	r8, r24
    6714:	30 01       	movw	r6, r0
    6716:	89 9e       	mul	r8, r25
    6718:	70 0c       	add	r7, r0
    671a:	98 9e       	mul	r9, r24
    671c:	70 0c       	add	r7, r0
    671e:	11 24       	eor	r1, r1
    6720:	c0 e0       	ldi	r28, 0x00	; 0
    6722:	d0 e0       	ldi	r29, 0x00	; 0
                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
                  }
                  else{
                    degreeToSteps(i, rotEncVal, motor[i].stepMultiplier);
    6724:	a1 2e       	mov	r10, r17
    6726:	bb 24       	eor	r11, r11
    6728:	a7 fc       	sbrc	r10, 7
    672a:	b0 94       	com	r11
    672c:	cb 2c       	mov	r12, r11
    672e:	db 2c       	mov	r13, r11
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6730:	80 91 e5 02 	lds	r24, 0x02E5
    6734:	90 e0       	ldi	r25, 0x00	; 0
    6736:	0c 2e       	mov	r0, r28
    6738:	02 c0       	rjmp	.+4      	; 0x673e <updateMenu+0xb3a>
    673a:	95 95       	asr	r25
    673c:	87 95       	ror	r24
    673e:	0a 94       	dec	r0
    6740:	e2 f7       	brpl	.-8      	; 0x673a <updateMenu+0xb36>
    6742:	80 ff       	sbrs	r24, 0
    6744:	44 c0       	rjmp	.+136    	; 0x67ce <updateMenu+0xbca>
              switch(motor[i].stepUnit){
    6746:	fe 01       	movw	r30, r28
    6748:	ee 0f       	add	r30, r30
    674a:	ff 1f       	adc	r31, r31
    674c:	ee 0f       	add	r30, r30
    674e:	ff 1f       	adc	r31, r31
    6750:	ee 0f       	add	r30, r30
    6752:	ff 1f       	adc	r31, r31
    6754:	cf 01       	movw	r24, r30
    6756:	88 0f       	add	r24, r24
    6758:	99 1f       	adc	r25, r25
    675a:	88 0f       	add	r24, r24
    675c:	99 1f       	adc	r25, r25
    675e:	e8 0f       	add	r30, r24
    6760:	f9 1f       	adc	r31, r25
    6762:	e0 51       	subi	r30, 0x10	; 16
    6764:	fc 4f       	sbci	r31, 0xFC	; 252
    6766:	81 8d       	ldd	r24, Z+25	; 0x19
    6768:	81 30       	cpi	r24, 0x01	; 1
    676a:	09 f4       	brne	.+2      	; 0x676e <updateMenu+0xb6a>
    676c:	09 c1       	rjmp	.+530    	; 0x6980 <updateMenu+0xd7c>
    676e:	82 30       	cpi	r24, 0x02	; 2
    6770:	09 f4       	brne	.+2      	; 0x6774 <updateMenu+0xb70>
    6772:	e0 c0       	rjmp	.+448    	; 0x6934 <updateMenu+0xd30>
    6774:	88 23       	and	r24, r24
    6776:	59 f5       	brne	.+86     	; 0x67ce <updateMenu+0xbca>
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
    6778:	80 91 e2 02 	lds	r24, 0x02E2
    677c:	88 23       	and	r24, r24
    677e:	09 f4       	brne	.+2      	; 0x6782 <updateMenu+0xb7e>
    6780:	4e c1       	rjmp	.+668    	; 0x6a1e <updateMenu+0xe1a>
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
    6782:	fe 01       	movw	r30, r28
    6784:	ee 0f       	add	r30, r30
    6786:	ff 1f       	adc	r31, r31
    6788:	ee 0f       	add	r30, r30
    678a:	ff 1f       	adc	r31, r31
    678c:	cf 01       	movw	r24, r30
    678e:	88 0f       	add	r24, r24
    6790:	99 1f       	adc	r25, r25
    6792:	88 0f       	add	r24, r24
    6794:	99 1f       	adc	r25, r25
    6796:	e8 0f       	add	r30, r24
    6798:	f9 1f       	adc	r31, r25
    679a:	ee 0f       	add	r30, r30
    679c:	ff 1f       	adc	r31, r31
    679e:	ee 50       	subi	r30, 0x0E	; 14
    67a0:	fc 4f       	sbci	r31, 0xFC	; 252
    67a2:	20 81       	ld	r18, Z
    67a4:	31 81       	ldd	r19, Z+1	; 0x01
    67a6:	26 0d       	add	r18, r6
    67a8:	37 1d       	adc	r19, r7
                  }
                  else{
                    motor[i].desiredPosition += (int16_t)rotEncVal;
    67aa:	fe 01       	movw	r30, r28
    67ac:	ee 0f       	add	r30, r30
    67ae:	ff 1f       	adc	r31, r31
    67b0:	ee 0f       	add	r30, r30
    67b2:	ff 1f       	adc	r31, r31
    67b4:	cf 01       	movw	r24, r30
    67b6:	88 0f       	add	r24, r24
    67b8:	99 1f       	adc	r25, r25
    67ba:	88 0f       	add	r24, r24
    67bc:	99 1f       	adc	r25, r25
    67be:	e8 0f       	add	r30, r24
    67c0:	f9 1f       	adc	r31, r25
    67c2:	ee 0f       	add	r30, r30
    67c4:	ff 1f       	adc	r31, r31
    67c6:	ee 50       	subi	r30, 0x0E	; 14
    67c8:	fc 4f       	sbci	r31, 0xFC	; 252
    67ca:	31 83       	std	Z+1, r19	; 0x01
    67cc:	20 83       	st	Z, r18
                  break;

                case MOTOR_STEP_UNIT_RADIAN:
                  /* default step is pi/8 */
                  /* pi/8 is far enough, so no fast moving mode here */
                  radiansToSteps(i, (rotEncVal)*0.125, motor[i].stepMultiplier);
    67ce:	21 96       	adiw	r28, 0x01	; 1
      switch(state){
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    67d0:	c4 30       	cpi	r28, 0x04	; 4
    67d2:	d1 05       	cpc	r29, r1
    67d4:	09 f0       	breq	.+2      	; 0x67d8 <updateMenu+0xbd4>
    67d6:	ac cf       	rjmp	.-168    	; 0x6730 <updateMenu+0xb2c>
    67d8:	39 ca       	rjmp	.-2958   	; 0x5c4c <updateMenu+0x48>
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
    67da:	fa 01       	movw	r30, r20
    67dc:	ee 0f       	add	r30, r30
    67de:	ff 1f       	adc	r31, r31
    67e0:	ee 0f       	add	r30, r30
    67e2:	ff 1f       	adc	r31, r31
    67e4:	ee 0f       	add	r30, r30
    67e6:	ff 1f       	adc	r31, r31
    67e8:	cf 01       	movw	r24, r30
    67ea:	88 0f       	add	r24, r24
    67ec:	99 1f       	adc	r25, r25
    67ee:	88 0f       	add	r24, r24
    67f0:	99 1f       	adc	r25, r25
    67f2:	e8 0f       	add	r30, r24
    67f4:	f9 1f       	adc	r31, r25
    67f6:	e0 51       	subi	r30, 0x10	; 16
    67f8:	fc 4f       	sbci	r31, 0xFC	; 252
    67fa:	20 81       	ld	r18, Z
    67fc:	31 81       	ldd	r19, Z+1	; 0x01
    67fe:	26 0f       	add	r18, r22
    6800:	37 1f       	adc	r19, r23
    6802:	69 cc       	rjmp	.-1838   	; 0x60d6 <updateMenu+0x4d2>
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].current += (rotEncVal)/10.0;
              if(motor[i].current < 0){
                motor[i].current = 0;
    6804:	fe 01       	movw	r30, r28
    6806:	ee 0f       	add	r30, r30
    6808:	ff 1f       	adc	r31, r31
    680a:	ee 0f       	add	r30, r30
    680c:	ff 1f       	adc	r31, r31
    680e:	ee 0f       	add	r30, r30
    6810:	ff 1f       	adc	r31, r31
    6812:	cf 01       	movw	r24, r30
    6814:	88 0f       	add	r24, r24
    6816:	99 1f       	adc	r25, r25
    6818:	88 0f       	add	r24, r24
    681a:	99 1f       	adc	r25, r25
    681c:	e8 0f       	add	r30, r24
    681e:	f9 1f       	adc	r31, r25
    6820:	e0 51       	subi	r30, 0x10	; 16
    6822:	fc 4f       	sbci	r31, 0xFC	; 252
    6824:	80 e0       	ldi	r24, 0x00	; 0
    6826:	90 e0       	ldi	r25, 0x00	; 0
    6828:	a0 e0       	ldi	r26, 0x00	; 0
    682a:	b0 e0       	ldi	r27, 0x00	; 0
    682c:	83 a3       	std	Z+35, r24	; 0x23
    682e:	94 a3       	std	Z+36, r25	; 0x24
    6830:	a5 a3       	std	Z+37, r26	; 0x25
    6832:	b6 a3       	std	Z+38, r27	; 0x26
    6834:	14 cf       	rjmp	.-472    	; 0x665e <updateMenu+0xa5a>
        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepUnit += rotEncVal;
              if(motor[i].stepUnit < 0){
                motor[i].stepUnit = 2;
    6836:	fa 01       	movw	r30, r20
    6838:	ee 0f       	add	r30, r30
    683a:	ff 1f       	adc	r31, r31
    683c:	ee 0f       	add	r30, r30
    683e:	ff 1f       	adc	r31, r31
    6840:	ee 0f       	add	r30, r30
    6842:	ff 1f       	adc	r31, r31
    6844:	cf 01       	movw	r24, r30
    6846:	88 0f       	add	r24, r24
    6848:	99 1f       	adc	r25, r25
    684a:	88 0f       	add	r24, r24
    684c:	99 1f       	adc	r25, r25
    684e:	e8 0f       	add	r30, r24
    6850:	f9 1f       	adc	r31, r25
    6852:	e0 51       	subi	r30, 0x10	; 16
    6854:	fc 4f       	sbci	r31, 0xFC	; 252
    6856:	71 8f       	std	Z+25, r23	; 0x19
    6858:	d7 cc       	rjmp	.-1618   	; 0x6208 <updateMenu+0x604>
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
              }
              if(motor[i].subSteps < 1){
    685a:	01 e0       	ldi	r16, 0x01	; 1
    685c:	c3 cb       	rjmp	.-2170   	; 0x5fe4 <updateMenu+0x3e0>
                //motor[i].subSteps *= 2.0;
                tmp *= 2.0;
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
    685e:	70 e0       	ldi	r23, 0x00	; 0
    6860:	88 27       	eor	r24, r24
    6862:	77 fd       	sbrc	r23, 7
    6864:	80 95       	com	r24
    6866:	98 2f       	mov	r25, r24
    6868:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    686c:	20 e0       	ldi	r18, 0x00	; 0
    686e:	30 e0       	ldi	r19, 0x00	; 0
    6870:	40 e0       	ldi	r20, 0x00	; 0
    6872:	5f e3       	ldi	r21, 0x3F	; 63
    6874:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    6878:	0e 94 0f 40 	call	0x801e	; 0x801e <__fixunssfsi>
    687c:	06 2f       	mov	r16, r22
    687e:	94 cb       	rjmp	.-2264   	; 0x5fa8 <updateMenu+0x3a4>
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
              if(motor[i].angularVelocity < 0){
                motor[i].angularVelocity = 2;
    6880:	02 a3       	std	Z+34, r16	; 0x22
    6882:	57 ce       	rjmp	.-850    	; 0x6532 <updateMenu+0x92e>
          if(programList[menu.currentProgramStep].absRel == PROG_ABSOLUTE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
    6884:	80 91 e3 02 	lds	r24, 0x02E3
    6888:	99 27       	eor	r25, r25
    688a:	87 fd       	sbrc	r24, 7
    688c:	90 95       	com	r25
    688e:	fc 01       	movw	r30, r24
    6890:	ee 0f       	add	r30, r30
    6892:	ff 1f       	adc	r31, r31
    6894:	ee 0f       	add	r30, r30
    6896:	ff 1f       	adc	r31, r31
    6898:	ee 0f       	add	r30, r30
    689a:	ff 1f       	adc	r31, r31
    689c:	88 0f       	add	r24, r24
    689e:	99 1f       	adc	r25, r25
    68a0:	e8 0f       	add	r30, r24
    68a2:	f9 1f       	adc	r31, r25
    68a4:	ed 50       	subi	r30, 0x0D	; 13
    68a6:	fd 4f       	sbci	r31, 0xFD	; 253
    68a8:	81 85       	ldd	r24, Z+9	; 0x09
    68aa:	81 30       	cpi	r24, 0x01	; 1
    68ac:	09 f0       	breq	.+2      	; 0x68b0 <updateMenu+0xcac>
    68ae:	ce c9       	rjmp	.-3172   	; 0x5c4c <updateMenu+0x48>
    68b0:	60 e0       	ldi	r22, 0x00	; 0
    68b2:	70 e0       	ldi	r23, 0x00	; 0
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = motor[i].actualPosition
    68b4:	fb 01       	movw	r30, r22
    68b6:	ee 0f       	add	r30, r30
    68b8:	ff 1f       	adc	r31, r31
    68ba:	ee 0f       	add	r30, r30
    68bc:	ff 1f       	adc	r31, r31
    68be:	ee 0f       	add	r30, r30
    68c0:	ff 1f       	adc	r31, r31
    68c2:	cf 01       	movw	r24, r30
    68c4:	88 0f       	add	r24, r24
    68c6:	99 1f       	adc	r25, r25
    68c8:	88 0f       	add	r24, r24
    68ca:	99 1f       	adc	r25, r25
    68cc:	e8 0f       	add	r30, r24
    68ce:	f9 1f       	adc	r31, r25
    68d0:	e0 51       	subi	r30, 0x10	; 16
    68d2:	fc 4f       	sbci	r31, 0xFC	; 252
    68d4:	40 81       	ld	r20, Z
    68d6:	51 81       	ldd	r21, Z+1	; 0x01
    68d8:	80 91 e3 02 	lds	r24, 0x02E3
    68dc:	99 27       	eor	r25, r25
    68de:	87 fd       	sbrc	r24, 7
    68e0:	90 95       	com	r25
    68e2:	fc 01       	movw	r30, r24
    68e4:	ee 0f       	add	r30, r30
    68e6:	ff 1f       	adc	r31, r31
    68e8:	ee 0f       	add	r30, r30
    68ea:	ff 1f       	adc	r31, r31
    68ec:	e8 0f       	add	r30, r24
    68ee:	f9 1f       	adc	r31, r25
    68f0:	e6 0f       	add	r30, r22
    68f2:	f7 1f       	adc	r31, r23
    68f4:	ee 0f       	add	r30, r30
    68f6:	ff 1f       	adc	r31, r31
    68f8:	ed 50       	subi	r30, 0x0D	; 13
    68fa:	fd 4f       	sbci	r31, 0xFD	; 253
    68fc:	21 81       	ldd	r18, Z+1	; 0x01
    68fe:	32 81       	ldd	r19, Z+2	; 0x02
    6900:	24 0f       	add	r18, r20
    6902:	35 1f       	adc	r19, r21
    6904:	fb 01       	movw	r30, r22
    6906:	ee 0f       	add	r30, r30
    6908:	ff 1f       	adc	r31, r31
    690a:	ee 0f       	add	r30, r30
    690c:	ff 1f       	adc	r31, r31
    690e:	cf 01       	movw	r24, r30
    6910:	88 0f       	add	r24, r24
    6912:	99 1f       	adc	r25, r25
    6914:	88 0f       	add	r24, r24
    6916:	99 1f       	adc	r25, r25
    6918:	e8 0f       	add	r30, r24
    691a:	f9 1f       	adc	r31, r25
    691c:	ee 0f       	add	r30, r30
    691e:	ff 1f       	adc	r31, r31
    6920:	ee 50       	subi	r30, 0x0E	; 14
    6922:	fc 4f       	sbci	r31, 0xFC	; 252
    6924:	31 83       	std	Z+1, r19	; 0x01
    6926:	20 83       	st	Z, r18
    6928:	6f 5f       	subi	r22, 0xFF	; 255
    692a:	7f 4f       	sbci	r23, 0xFF	; 255
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    692c:	64 30       	cpi	r22, 0x04	; 4
    692e:	71 05       	cpc	r23, r1
    6930:	09 f6       	brne	.-126    	; 0x68b4 <updateMenu+0xcb0>
    6932:	8c c9       	rjmp	.-3304   	; 0x5c4c <updateMenu+0x48>
                  break;

                case MOTOR_STEP_UNIT_RADIAN:
                  /* default step is pi/8 */
                  /* pi/8 is far enough, so no fast moving mode here */
                  radiansToSteps(i, (rotEncVal)*0.125, motor[i].stepMultiplier);
    6934:	fe 01       	movw	r30, r28
    6936:	ee 0f       	add	r30, r30
    6938:	ff 1f       	adc	r31, r31
    693a:	ee 0f       	add	r30, r30
    693c:	ff 1f       	adc	r31, r31
    693e:	ee 0f       	add	r30, r30
    6940:	ff 1f       	adc	r31, r31
    6942:	cf 01       	movw	r24, r30
    6944:	88 0f       	add	r24, r24
    6946:	99 1f       	adc	r25, r25
    6948:	88 0f       	add	r24, r24
    694a:	99 1f       	adc	r25, r25
    694c:	e8 0f       	add	r30, r24
    694e:	f9 1f       	adc	r31, r25
    6950:	e0 51       	subi	r30, 0x10	; 16
    6952:	fc 4f       	sbci	r31, 0xFC	; 252
    6954:	e2 8c       	ldd	r14, Z+26	; 0x1a
    6956:	f3 8c       	ldd	r15, Z+27	; 0x1b
    6958:	04 8d       	ldd	r16, Z+28	; 0x1c
    695a:	15 8d       	ldd	r17, Z+29	; 0x1d
    695c:	c6 01       	movw	r24, r12
    695e:	b5 01       	movw	r22, r10
    6960:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    6964:	20 e0       	ldi	r18, 0x00	; 0
    6966:	30 e0       	ldi	r19, 0x00	; 0
    6968:	40 e0       	ldi	r20, 0x00	; 0
    696a:	5e e3       	ldi	r21, 0x3E	; 62
    696c:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    6970:	ab 01       	movw	r20, r22
    6972:	bc 01       	movw	r22, r24
    6974:	8c 2f       	mov	r24, r28
    6976:	98 01       	movw	r18, r16
    6978:	87 01       	movw	r16, r14
    697a:	0e 94 cc 0f 	call	0x1f98	; 0x1f98 <radiansToSteps>
    697e:	27 cf       	rjmp	.-434    	; 0x67ce <updateMenu+0xbca>
                    motor[i].desiredPosition += (int16_t)rotEncVal;
                  }
                  break;

                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
    6980:	80 91 e2 02 	lds	r24, 0x02E2
    6984:	88 23       	and	r24, r24
    6986:	09 f4       	brne	.+2      	; 0x698a <updateMenu+0xd86>
    6988:	5f c0       	rjmp	.+190    	; 0x6a48 <updateMenu+0xe44>
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
    698a:	fe 01       	movw	r30, r28
    698c:	ee 0f       	add	r30, r30
    698e:	ff 1f       	adc	r31, r31
    6990:	ee 0f       	add	r30, r30
    6992:	ff 1f       	adc	r31, r31
    6994:	ee 0f       	add	r30, r30
    6996:	ff 1f       	adc	r31, r31
    6998:	cf 01       	movw	r24, r30
    699a:	88 0f       	add	r24, r24
    699c:	99 1f       	adc	r25, r25
    699e:	88 0f       	add	r24, r24
    69a0:	99 1f       	adc	r25, r25
    69a2:	e8 0f       	add	r30, r24
    69a4:	f9 1f       	adc	r31, r25
    69a6:	e0 51       	subi	r30, 0x10	; 16
    69a8:	fc 4f       	sbci	r31, 0xFC	; 252
    69aa:	e2 8c       	ldd	r14, Z+26	; 0x1a
    69ac:	f3 8c       	ldd	r15, Z+27	; 0x1b
    69ae:	04 8d       	ldd	r16, Z+28	; 0x1c
    69b0:	15 8d       	ldd	r17, Z+29	; 0x1d
    69b2:	c6 01       	movw	r24, r12
    69b4:	b5 01       	movw	r22, r10
    69b6:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    69ba:	20 e0       	ldi	r18, 0x00	; 0
    69bc:	30 e0       	ldi	r19, 0x00	; 0
    69be:	40 e2       	ldi	r20, 0x20	; 32
    69c0:	51 e4       	ldi	r21, 0x41	; 65
    69c2:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    69c6:	ab 01       	movw	r20, r22
    69c8:	bc 01       	movw	r22, r24
    69ca:	8c 2f       	mov	r24, r28
    69cc:	98 01       	movw	r18, r16
    69ce:	87 01       	movw	r16, r14
    69d0:	0e 94 13 11 	call	0x2226	; 0x2226 <degreeToSteps>
    69d4:	fc ce       	rjmp	.-520    	; 0x67ce <updateMenu+0xbca>
          if(rotEncVal < 0){
            do{
              /* find the next active program step */
              menu.currentProgramStep += -1;
              if(menu.currentProgramStep < 0){
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
    69d6:	2f e0       	ldi	r18, 0x0F	; 15
    69d8:	16 c0       	rjmp	.+44     	; 0x6a06 <updateMenu+0xe02>
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
    69da:	80 91 e3 02 	lds	r24, 0x02E3
    69de:	99 27       	eor	r25, r25
    69e0:	87 fd       	sbrc	r24, 7
    69e2:	90 95       	com	r25
    69e4:	fc 01       	movw	r30, r24
    69e6:	ee 0f       	add	r30, r30
    69e8:	ff 1f       	adc	r31, r31
    69ea:	ee 0f       	add	r30, r30
    69ec:	ff 1f       	adc	r31, r31
    69ee:	ee 0f       	add	r30, r30
    69f0:	ff 1f       	adc	r31, r31
    69f2:	88 0f       	add	r24, r24
    69f4:	99 1f       	adc	r25, r25
    69f6:	e8 0f       	add	r30, r24
    69f8:	f9 1f       	adc	r31, r25
    69fa:	ed 50       	subi	r30, 0x0D	; 13
    69fc:	fd 4f       	sbci	r31, 0xFD	; 253
    69fe:	80 81       	ld	r24, Z
    6a00:	88 23       	and	r24, r24
    6a02:	09 f0       	breq	.+2      	; 0x6a06 <updateMenu+0xe02>
    6a04:	ed cc       	rjmp	.-1574   	; 0x63e0 <updateMenu+0x7dc>
          }

          if(rotEncVal < 0){
            do{
              /* find the next active program step */
              menu.currentProgramStep += -1;
    6a06:	80 91 e3 02 	lds	r24, 0x02E3
    6a0a:	81 50       	subi	r24, 0x01	; 1
    6a0c:	80 93 e3 02 	sts	0x02E3, r24
              if(menu.currentProgramStep < 0){
    6a10:	80 91 e3 02 	lds	r24, 0x02E3
    6a14:	87 ff       	sbrs	r24, 7
    6a16:	e1 cf       	rjmp	.-62     	; 0x69da <updateMenu+0xdd6>
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
    6a18:	20 93 e3 02 	sts	0x02E3, r18
    6a1c:	de cf       	rjmp	.-68     	; 0x69da <updateMenu+0xdd6>
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
                  }
                  else{
                    motor[i].desiredPosition += (int16_t)rotEncVal;
    6a1e:	fe 01       	movw	r30, r28
    6a20:	ee 0f       	add	r30, r30
    6a22:	ff 1f       	adc	r31, r31
    6a24:	ee 0f       	add	r30, r30
    6a26:	ff 1f       	adc	r31, r31
    6a28:	cf 01       	movw	r24, r30
    6a2a:	88 0f       	add	r24, r24
    6a2c:	99 1f       	adc	r25, r25
    6a2e:	88 0f       	add	r24, r24
    6a30:	99 1f       	adc	r25, r25
    6a32:	e8 0f       	add	r30, r24
    6a34:	f9 1f       	adc	r31, r25
    6a36:	ee 0f       	add	r30, r30
    6a38:	ff 1f       	adc	r31, r31
    6a3a:	ee 50       	subi	r30, 0x0E	; 14
    6a3c:	fc 4f       	sbci	r31, 0xFC	; 252
    6a3e:	20 81       	ld	r18, Z
    6a40:	31 81       	ldd	r19, Z+1	; 0x01
    6a42:	28 0d       	add	r18, r8
    6a44:	39 1d       	adc	r19, r9
    6a46:	b1 ce       	rjmp	.-670    	; 0x67aa <updateMenu+0xba6>
                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
                  }
                  else{
                    degreeToSteps(i, rotEncVal, motor[i].stepMultiplier);
    6a48:	fe 01       	movw	r30, r28
    6a4a:	ee 0f       	add	r30, r30
    6a4c:	ff 1f       	adc	r31, r31
    6a4e:	ee 0f       	add	r30, r30
    6a50:	ff 1f       	adc	r31, r31
    6a52:	ee 0f       	add	r30, r30
    6a54:	ff 1f       	adc	r31, r31
    6a56:	cf 01       	movw	r24, r30
    6a58:	88 0f       	add	r24, r24
    6a5a:	99 1f       	adc	r25, r25
    6a5c:	88 0f       	add	r24, r24
    6a5e:	99 1f       	adc	r25, r25
    6a60:	e8 0f       	add	r30, r24
    6a62:	f9 1f       	adc	r31, r25
    6a64:	e0 51       	subi	r30, 0x10	; 16
    6a66:	fc 4f       	sbci	r31, 0xFC	; 252
    6a68:	e2 8c       	ldd	r14, Z+26	; 0x1a
    6a6a:	f3 8c       	ldd	r15, Z+27	; 0x1b
    6a6c:	04 8d       	ldd	r16, Z+28	; 0x1c
    6a6e:	15 8d       	ldd	r17, Z+29	; 0x1d
    6a70:	c6 01       	movw	r24, r12
    6a72:	b5 01       	movw	r22, r10
    6a74:	0e 94 3d 40 	call	0x807a	; 0x807a <__floatsisf>
    6a78:	ab 01       	movw	r20, r22
    6a7a:	bc 01       	movw	r22, r24
    6a7c:	8c 2f       	mov	r24, r28
    6a7e:	98 01       	movw	r18, r16
    6a80:	87 01       	movw	r16, r14
    6a82:	0e 94 13 11 	call	0x2226	; 0x2226 <degreeToSteps>
    6a86:	a3 ce       	rjmp	.-698    	; 0x67ce <updateMenu+0xbca>

00006a88 <main>:


/* =====================================================================
    main loop
====================================================================== */
int main(void){
    6a88:	ef 92       	push	r14
    6a8a:	ff 92       	push	r15
    6a8c:	0f 93       	push	r16
    6a8e:	1f 93       	push	r17
    6a90:	cf 93       	push	r28
    6a92:	df 93       	push	r29

  uint8_t i;
  uint8_t commandCode;

  /* initialize command parameter list */
  commandParam = (char**)malloc(NUMBER_OF_PARAMETERS * sizeof(char*));
    6a94:	84 e1       	ldi	r24, 0x14	; 20
    6a96:	90 e0       	ldi	r25, 0x00	; 0
    6a98:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6a9c:	80 93 d6 02 	sts	0x02D6, r24
    6aa0:	90 93 d7 02 	sts	0x02D7, r25
    6aa4:	c0 e0       	ldi	r28, 0x00	; 0
    6aa6:	d0 e0       	ldi	r29, 0x00	; 0
  for(i = 0; i < NUMBER_OF_PARAMETERS; i++){
    commandParam[i] = (char*)malloc(PARAMETER_LENGTH * sizeof(char));
    6aa8:	00 91 d6 02 	lds	r16, 0x02D6
    6aac:	10 91 d7 02 	lds	r17, 0x02D7
    6ab0:	0c 0f       	add	r16, r28
    6ab2:	1d 1f       	adc	r17, r29
    6ab4:	84 e1       	ldi	r24, 0x14	; 20
    6ab6:	90 e0       	ldi	r25, 0x00	; 0
    6ab8:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6abc:	f8 01       	movw	r30, r16
    6abe:	80 83       	st	Z, r24
    6ac0:	91 83       	std	Z+1, r25	; 0x01
    6ac2:	22 96       	adiw	r28, 0x02	; 2
  uint8_t i;
  uint8_t commandCode;

  /* initialize command parameter list */
  commandParam = (char**)malloc(NUMBER_OF_PARAMETERS * sizeof(char*));
  for(i = 0; i < NUMBER_OF_PARAMETERS; i++){
    6ac4:	c4 31       	cpi	r28, 0x14	; 20
    6ac6:	d1 05       	cpc	r29, r1
    6ac8:	79 f7       	brne	.-34     	; 0x6aa8 <main+0x20>
    commandParam[i] = (char*)malloc(PARAMETER_LENGTH * sizeof(char));
  }

  /* initialize menu strings */
  menu.currentDisplayValue = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
    6aca:	88 e0       	ldi	r24, 0x08	; 8
    6acc:	90 e0       	ldi	r25, 0x00	; 0
    6ace:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6ad2:	90 93 e7 02 	sts	0x02E7, r25
    6ad6:	80 93 e6 02 	sts	0x02E6, r24
  menu.newDisplayValue     = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
    6ada:	88 e0       	ldi	r24, 0x08	; 8
    6adc:	90 e0       	ldi	r25, 0x00	; 0
    6ade:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6ae2:	90 93 e9 02 	sts	0x02E9, r25
    6ae6:	80 93 e8 02 	sts	0x02E8, r24
    6aea:	c0 e0       	ldi	r28, 0x00	; 0
    6aec:	d0 e0       	ldi	r29, 0x00	; 0
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    menu.currentDisplayValue[i] = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    6aee:	00 91 e6 02 	lds	r16, 0x02E6
    6af2:	10 91 e7 02 	lds	r17, 0x02E7
    6af6:	89 e0       	ldi	r24, 0x09	; 9
    6af8:	90 e0       	ldi	r25, 0x00	; 0
    6afa:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6afe:	0c 0f       	add	r16, r28
    6b00:	1d 1f       	adc	r17, r29
    6b02:	f8 01       	movw	r30, r16
    6b04:	80 83       	st	Z, r24
    6b06:	91 83       	std	Z+1, r25	; 0x01
    menu.newDisplayValue[i]     = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    6b08:	00 91 e8 02 	lds	r16, 0x02E8
    6b0c:	10 91 e9 02 	lds	r17, 0x02E9
    6b10:	89 e0       	ldi	r24, 0x09	; 9
    6b12:	90 e0       	ldi	r25, 0x00	; 0
    6b14:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6b18:	0c 0f       	add	r16, r28
    6b1a:	1d 1f       	adc	r17, r29
    6b1c:	f8 01       	movw	r30, r16
    6b1e:	80 83       	st	Z, r24
    6b20:	91 83       	std	Z+1, r25	; 0x01
    6b22:	22 96       	adiw	r28, 0x02	; 2
  }

  /* initialize menu strings */
  menu.currentDisplayValue = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
  menu.newDisplayValue     = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    6b24:	c8 30       	cpi	r28, 0x08	; 8
    6b26:	d1 05       	cpc	r29, r1
    6b28:	11 f7       	brne	.-60     	; 0x6aee <main+0x66>
    menu.currentDisplayValue[i] = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    menu.newDisplayValue[i]     = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
  }

  menu.currentMenuText     = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
    6b2a:	84 e0       	ldi	r24, 0x04	; 4
    6b2c:	90 e0       	ldi	r25, 0x00	; 0
    6b2e:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6b32:	90 93 eb 02 	sts	0x02EB, r25
    6b36:	80 93 ea 02 	sts	0x02EA, r24
  menu.newMenuText         = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
    6b3a:	84 e0       	ldi	r24, 0x04	; 4
    6b3c:	90 e0       	ldi	r25, 0x00	; 0
    6b3e:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6b42:	90 93 ed 02 	sts	0x02ED, r25
    6b46:	80 93 ec 02 	sts	0x02EC, r24
  for(i = 0; i < NUMBER_DISPLAY_MENU_STRINGS; i++){
    menu.currentMenuText[i] = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6b4a:	00 91 ea 02 	lds	r16, 0x02EA
    6b4e:	10 91 eb 02 	lds	r17, 0x02EB
    6b52:	81 e1       	ldi	r24, 0x11	; 17
    6b54:	90 e0       	ldi	r25, 0x00	; 0
    6b56:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6b5a:	f8 01       	movw	r30, r16
    6b5c:	80 83       	st	Z, r24
    6b5e:	91 83       	std	Z+1, r25	; 0x01
    menu.newMenuText[i]     = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6b60:	00 91 ec 02 	lds	r16, 0x02EC
    6b64:	10 91 ed 02 	lds	r17, 0x02ED
    6b68:	81 e1       	ldi	r24, 0x11	; 17
    6b6a:	90 e0       	ldi	r25, 0x00	; 0
    6b6c:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6b70:	f8 01       	movw	r30, r16
    6b72:	80 83       	st	Z, r24
    6b74:	91 83       	std	Z+1, r25	; 0x01
  }

  menu.currentMenuText     = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
  menu.newMenuText         = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
  for(i = 0; i < NUMBER_DISPLAY_MENU_STRINGS; i++){
    menu.currentMenuText[i] = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6b76:	00 91 ea 02 	lds	r16, 0x02EA
    6b7a:	10 91 eb 02 	lds	r17, 0x02EB
    6b7e:	81 e1       	ldi	r24, 0x11	; 17
    6b80:	90 e0       	ldi	r25, 0x00	; 0
    6b82:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6b86:	f8 01       	movw	r30, r16
    6b88:	82 83       	std	Z+2, r24	; 0x02
    6b8a:	93 83       	std	Z+3, r25	; 0x03
    menu.newMenuText[i]     = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6b8c:	00 91 ec 02 	lds	r16, 0x02EC
    6b90:	10 91 ed 02 	lds	r17, 0x02ED
    6b94:	81 e1       	ldi	r24, 0x11	; 17
    6b96:	90 e0       	ldi	r25, 0x00	; 0
    6b98:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6b9c:	f8 01       	movw	r30, r16
    6b9e:	82 83       	std	Z+2, r24	; 0x02
    6ba0:	93 83       	std	Z+3, r25	; 0x03
  }

  /* initialize TX and RX buffers for USART serial interface */
  rxString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    6ba2:	80 e4       	ldi	r24, 0x40	; 64
    6ba4:	90 e0       	ldi	r25, 0x00	; 0
    6ba6:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6baa:	90 93 ef 02 	sts	0x02EF, r25
    6bae:	80 93 ee 02 	sts	0x02EE, r24
  txString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    6bb2:	80 e4       	ldi	r24, 0x40	; 64
    6bb4:	90 e0       	ldi	r25, 0x00	; 0
    6bb6:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6bba:	90 93 e8 03 	sts	0x03E8, r25
    6bbe:	80 93 e7 03 	sts	0x03E7, r24
  commandString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    6bc2:	80 e4       	ldi	r24, 0x40	; 64
    6bc4:	90 e0       	ldi	r25, 0x00	; 0
    6bc6:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6bca:	90 93 91 04 	sts	0x0491, r25
    6bce:	80 93 90 04 	sts	0x0490, r24

  /* initialize IIC data buffer */
  IIC.data = (char*)malloc(21 * sizeof(char));
    6bd2:	85 e1       	ldi	r24, 0x15	; 21
    6bd4:	90 e0       	ldi	r25, 0x00	; 0
    6bd6:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6bda:	90 93 ee 03 	sts	0x03EE, r25
    6bde:	80 93 ed 03 	sts	0x03ED, r24

  /* initialize displayBuffer */
  displayBuffer = (char*)malloc(DISPLAY_BUFFER_SIZE * sizeof(char));
    6be2:	88 e2       	ldi	r24, 0x28	; 40
    6be4:	90 e0       	ldi	r25, 0x00	; 0
    6be6:	0e 94 ee 41 	call	0x83dc	; 0x83dc <malloc>
    6bea:	80 93 eb 03 	sts	0x03EB, r24
    6bee:	90 93 ec 03 	sts	0x03EC, r25
    6bf2:	80 e0       	ldi	r24, 0x00	; 0
    6bf4:	90 e0       	ldi	r25, 0x00	; 0

  /* initialize data for LEDs and WS2803 output pins */
  for(i = 0; i < BUTT_LED_CHANNELS; i++){
    buttLedData[i] = 0;
    6bf6:	fc 01       	movw	r30, r24
    6bf8:	eb 56       	subi	r30, 0x6B	; 107
    6bfa:	fc 4f       	sbci	r31, 0xFC	; 252
    6bfc:	10 82       	st	Z, r1
    6bfe:	01 96       	adiw	r24, 0x01	; 1

  /* initialize displayBuffer */
  displayBuffer = (char*)malloc(DISPLAY_BUFFER_SIZE * sizeof(char));

  /* initialize data for LEDs and WS2803 output pins */
  for(i = 0; i < BUTT_LED_CHANNELS; i++){
    6c00:	80 33       	cpi	r24, 0x30	; 48
    6c02:	91 05       	cpc	r25, r1
    6c04:	c1 f7       	brne	.-16     	; 0x6bf6 <main+0x16e>
    buttLedData[i] = 0;
  }
  DDRC |= (1 << WS2803_CKI) | (1 << WS2803_SDI);
    6c06:	87 b1       	in	r24, 0x07	; 7
    6c08:	80 6c       	ori	r24, 0xC0	; 192
    6c0a:	87 b9       	out	0x07, r24	; 7
  PORTC |= (1 << WS2803_CKI) | (1 << WS2803_SDI);
    6c0c:	88 b1       	in	r24, 0x08	; 8
    6c0e:	80 6c       	ori	r24, 0xC0	; 192
    6c10:	88 b9       	out	0x08, r24	; 8

  /* initialize PORTA as output for motor Step/Direction */
  DDRA  = 0xFF;
    6c12:	8f ef       	ldi	r24, 0xFF	; 255
    6c14:	81 b9       	out	0x01, r24	; 1
  PORTA = 0;
    6c16:	12 b8       	out	0x02, r1	; 2

  //lcd_init();
  //lcd_home();

  /* OLED setup */
  OLEDinit(OLED_V2);
    6c18:	82 e0       	ldi	r24, 0x02	; 2
    6c1a:	0e 94 b9 3a 	call	0x7572	; 0x7572 <OLEDinit>
    6c1e:	28 e8       	ldi	r18, 0x88	; 136
    6c20:	33 e1       	ldi	r19, 0x13	; 19
    6c22:	44 ef       	ldi	r20, 0xF4	; 244
    6c24:	51 e0       	ldi	r21, 0x01	; 1
    6c26:	ca 01       	movw	r24, r20
    6c28:	01 97       	sbiw	r24, 0x01	; 1
    6c2a:	f1 f7       	brne	.-4      	; 0x6c28 <main+0x1a0>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6c2c:	21 50       	subi	r18, 0x01	; 1
    6c2e:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6c30:	d1 f7       	brne	.-12     	; 0x6c26 <main+0x19e>
  _delay_ms(500);
  OLEDclear();
    6c32:	0e 94 07 3a 	call	0x740e	; 0x740e <OLEDclear>
  OLEDsetCursor(0, 0);
    6c36:	80 e0       	ldi	r24, 0x00	; 0
    6c38:	60 e0       	ldi	r22, 0x00	; 0
    6c3a:	0e 94 a6 39 	call	0x734c	; 0x734c <OLEDsetCursor>
   - 8 bit character size
   - no flow control
  */

  /* set baud rate registers */
  UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
    6c3e:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = (uint8_t)(UBRR_VALUE & 0xFF);
    6c42:	85 e1       	ldi	r24, 0x15	; 21
    6c44:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B |= (1<<TXEN0) | (1<<RXEN0)        /* enable RX and TX */
    6c48:	80 91 c1 00 	lds	r24, 0x00C1
    6c4c:	88 69       	ori	r24, 0x98	; 152
    6c4e:	80 93 c1 00 	sts	0x00C1, r24
  OLEDclear();
  OLEDsetCursor(0, 0);

  initUSART();

  initDataStructs();  /* must be the first function after reset! */
    6c52:	0e 94 40 03 	call	0x680	; 0x680 <initDataStructs>
  initBuffers();
    6c56:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <initBuffers>
  //initADC();
  initIIC();
    6c5a:	0e 94 e1 3a 	call	0x75c2	; 0x75c2 <initIIC>
  
RESET:
  initDataStructs();  /* must be the first function after reset! */ 
    6c5e:	0e 94 40 03 	call	0x680	; 0x680 <initDataStructs>
  initMotorDelayTimer();
    6c62:	0e 94 c3 05 	call	0xb86	; 0xb86 <initMotorDelayTimer>
  initManualOperatingButtons();
    6c66:	0e 94 87 28 	call	0x510e	; 0x510e <initManualOperatingButtons>
  
  /* TODO: detect motors if connected */
  
  loadConfigFromEEPROM();
    6c6a:	0e 94 a3 0a 	call	0x1546	; 0x1546 <loadConfigFromEEPROM>
    6c6e:	10 e0       	ldi	r17, 0x00	; 0

  /* init all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    initPortExpander(getPortExpanderAddress(i));
    6c70:	81 2f       	mov	r24, r17
    6c72:	0e 94 89 09 	call	0x1312	; 0x1312 <getPortExpanderAddress>
    6c76:	0e 94 99 27 	call	0x4f32	; 0x4f32 <initPortExpander>
    initDAC(i);
    6c7a:	81 2f       	mov	r24, r17
    6c7c:	0e 94 71 27 	call	0x4ee2	; 0x4ee2 <initDAC>
  /* TODO: detect motors if connected */
  
  loadConfigFromEEPROM();

  /* init all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    6c80:	1f 5f       	subi	r17, 0xFF	; 255
    6c82:	14 30       	cpi	r17, 0x04	; 4
    6c84:	a9 f7       	brne	.-22     	; 0x6c70 <main+0x1e8>
    initPortExpander(getPortExpanderAddress(i));
    initDAC(i);
  }
  
  updateIICvalues();
    6c86:	0e 94 1d 2c 	call	0x583a	; 0x583a <updateIICvalues>
  
  /* turn on all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorState(i, ON);
    6c8a:	80 e0       	ldi	r24, 0x00	; 0
    6c8c:	61 e0       	ldi	r22, 0x01	; 1
    6c8e:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
    6c92:	81 e0       	ldi	r24, 0x01	; 1
    6c94:	61 e0       	ldi	r22, 0x01	; 1
    6c96:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
    6c9a:	82 e0       	ldi	r24, 0x02	; 2
    6c9c:	61 e0       	ldi	r22, 0x01	; 1
    6c9e:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
    6ca2:	83 e0       	ldi	r24, 0x03	; 3
    6ca4:	61 e0       	ldi	r22, 0x01	; 1
    6ca6:	0e 94 fc 2a 	call	0x55f8	; 0x55f8 <setMotorState>
  }

  updateMenu();
    6caa:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <updateMenu>
  
  updateDisplay();
    6cae:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <updateDisplay>
  /*
  for(i = 0; i < 4; i++){
    changeButtonLED(i, GREEN, 0x0F);
  }
  */
  changeButtonLED(LED_MESC, RED, 0x0F);
    6cb2:	84 e0       	ldi	r24, 0x04	; 4
    6cb4:	62 e0       	ldi	r22, 0x02	; 2
    6cb6:	4f e0       	ldi	r20, 0x0F	; 15
    6cb8:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
  //updateLEDs();
  updateMotorButtonLEDs();
    6cbc:	0e 94 7d 07 	call	0xefa	; 0xefa <updateMotorButtonLEDs>
  
  commandCode = 0x80;

  sei();  /* turn on interrupts */
    6cc0:	78 94       	sei

  /* start the never ending story */
  for(;;){

    /* check for manual done changes */
    updateMenu();
    6cc2:	0e 94 02 2e 	call	0x5c04	; 0x5c04 <updateMenu>

    /* check for changed values and update them on the display */
    updateDisplay();
    6cc6:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <updateDisplay>
    
    //updateMotorButtonLEDs();

    /* check for new received command */
    if(rxString.readyToProcess){
    6cca:	80 91 f0 02 	lds	r24, 0x02F0
    6cce:	88 23       	and	r24, r24
    6cd0:	c1 f3       	breq	.-16     	; 0x6cc2 <main+0x23a>
      copyRXstring();
    6cd2:	0e 94 0d 26 	call	0x4c1a	; 0x4c1a <copyRXstring>
      commandCode = parseCommand();
    6cd6:	0e 94 53 1f 	call	0x3ea6	; 0x3ea6 <parseCommand>
    }

    switch(commandCode){
    6cda:	90 e0       	ldi	r25, 0x00	; 0
    6cdc:	fc 01       	movw	r30, r24
    6cde:	e1 58       	subi	r30, 0x81	; 129
    6ce0:	f0 40       	sbci	r31, 0x00	; 0
    6ce2:	e4 32       	cpi	r30, 0x24	; 36
    6ce4:	f1 05       	cpc	r31, r1
    6ce6:	68 f7       	brcc	.-38     	; 0x6cc2 <main+0x23a>
    6ce8:	ea 5b       	subi	r30, 0xBA	; 186
    6cea:	ff 4f       	sbci	r31, 0xFF	; 255
    6cec:	ee 0f       	add	r30, r30
    6cee:	ff 1f       	adc	r31, r31
    6cf0:	05 90       	lpm	r0, Z+
    6cf2:	f4 91       	lpm	r31, Z+
    6cf4:	e0 2d       	mov	r30, r0
    6cf6:	09 94       	ijmp
      case 0xA2:    /* GETDECAY */
        sendText(commandGetMotorDecay(commandParam[1]));
        break;

      case 0xA3:    /* SETDECAY */
        commandSetMotorDecay(commandParam[1], commandParam[2]);
    6cf8:	e0 91 d6 02 	lds	r30, 0x02D6
    6cfc:	f0 91 d7 02 	lds	r31, 0x02D7
    6d00:	64 81       	ldd	r22, Z+4	; 0x04
    6d02:	75 81       	ldd	r23, Z+5	; 0x05
    6d04:	82 81       	ldd	r24, Z+2	; 0x02
    6d06:	93 81       	ldd	r25, Z+3	; 0x03
    6d08:	0e 94 94 2a 	call	0x5528	; 0x5528 <commandSetMotorDecay>
    6d0c:	da cf       	rjmp	.-76     	; 0x6cc2 <main+0x23a>
      case 0xA1:    /* SETCURR */
        commandSetMotorCurrent(commandParam[1], commandParam[2]);
        break;
        
      case 0xA2:    /* GETDECAY */
        sendText(commandGetMotorDecay(commandParam[1]));
    6d0e:	e0 91 d6 02 	lds	r30, 0x02D6
    6d12:	f0 91 d7 02 	lds	r31, 0x02D7
    6d16:	82 81       	ldd	r24, Z+2	; 0x02
    6d18:	93 81       	ldd	r25, Z+3	; 0x03
    6d1a:	0e 94 5a 12 	call	0x24b4	; 0x24b4 <commandGetMotorDecay>
    6d1e:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6d22:	cf cf       	rjmp	.-98     	; 0x6cc2 <main+0x23a>
      case 0xA0:    /* GETCURR */
        sendText(commandGetMotorCurrent(commandParam[1]));
        break;

      case 0xA1:    /* SETCURR */
        commandSetMotorCurrent(commandParam[1], commandParam[2]);
    6d24:	e0 91 d6 02 	lds	r30, 0x02D6
    6d28:	f0 91 d7 02 	lds	r31, 0x02D7
    6d2c:	64 81       	ldd	r22, Z+4	; 0x04
    6d2e:	75 81       	ldd	r23, Z+5	; 0x05
    6d30:	82 81       	ldd	r24, Z+2	; 0x02
    6d32:	93 81       	ldd	r25, Z+3	; 0x03
    6d34:	0e 94 05 27 	call	0x4e0a	; 0x4e0a <commandSetMotorCurrent>
    6d38:	c4 cf       	rjmp	.-120    	; 0x6cc2 <main+0x23a>
      case 0x9F:    /* LED */
        commandLED(commandParam[1], commandParam[2], commandParam[3]);
        break;
		
      case 0xA0:    /* GETCURR */
        sendText(commandGetMotorCurrent(commandParam[1]));
    6d3a:	e0 91 d6 02 	lds	r30, 0x02D6
    6d3e:	f0 91 d7 02 	lds	r31, 0x02D7
    6d42:	82 81       	ldd	r24, Z+2	; 0x02
    6d44:	93 81       	ldd	r25, Z+3	; 0x03
    6d46:	0e 94 59 26 	call	0x4cb2	; 0x4cb2 <commandGetMotorCurrent>
    6d4a:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6d4e:	b9 cf       	rjmp	.-142    	; 0x6cc2 <main+0x23a>
      case 0x9E:
        commandDebugReadout();
        break;

      case 0x9F:    /* LED */
        commandLED(commandParam[1], commandParam[2], commandParam[3]);
    6d50:	e0 91 d6 02 	lds	r30, 0x02D6
    6d54:	f0 91 d7 02 	lds	r31, 0x02D7
    6d58:	64 81       	ldd	r22, Z+4	; 0x04
    6d5a:	75 81       	ldd	r23, Z+5	; 0x05
    6d5c:	46 81       	ldd	r20, Z+6	; 0x06
    6d5e:	57 81       	ldd	r21, Z+7	; 0x07
    6d60:	82 81       	ldd	r24, Z+2	; 0x02
    6d62:	93 81       	ldd	r25, Z+3	; 0x03
    6d64:	0e 94 ee 1f 	call	0x3fdc	; 0x3fdc <commandLED>
    6d68:	ac cf       	rjmp	.-168    	; 0x6cc2 <main+0x23a>
      case 0x9D:    /* GETMOTSTATE */
        commandGetMotorState(commandParam[1]);
        break;

      case 0x9E:
        commandDebugReadout();
    6d6a:	0e 94 4a 20 	call	0x4094	; 0x4094 <commandDebugReadout>
    6d6e:	a9 cf       	rjmp	.-174    	; 0x6cc2 <main+0x23a>
        commandSetProgStep(commandParam[1], commandParam[2], commandParam[3],
                           commandParam[4], commandParam[5], commandParam[6]);
        break;

      case 0x9D:    /* GETMOTSTATE */
        commandGetMotorState(commandParam[1]);
    6d70:	e0 91 d6 02 	lds	r30, 0x02D6
    6d74:	f0 91 d7 02 	lds	r31, 0x02D7
    6d78:	82 81       	ldd	r24, Z+2	; 0x02
    6d7a:	93 81       	ldd	r25, Z+3	; 0x03
    6d7c:	0e 94 fb 20 	call	0x41f6	; 0x41f6 <commandGetMotorState>
    6d80:	a0 cf       	rjmp	.-192    	; 0x6cc2 <main+0x23a>
      case 0x9B:    /* ENABFORBZONE */
        commandEnableForbiddenZone(commandParam[1], commandParam[2]);
        break;

      case 0x9C:    /* SETPROGSTEP */
        commandSetProgStep(commandParam[1], commandParam[2], commandParam[3],
    6d82:	e0 91 d6 02 	lds	r30, 0x02D6
    6d86:	f0 91 d7 02 	lds	r31, 0x02D7
    6d8a:	64 81       	ldd	r22, Z+4	; 0x04
    6d8c:	75 81       	ldd	r23, Z+5	; 0x05
    6d8e:	46 81       	ldd	r20, Z+6	; 0x06
    6d90:	57 81       	ldd	r21, Z+7	; 0x07
    6d92:	20 85       	ldd	r18, Z+8	; 0x08
    6d94:	31 85       	ldd	r19, Z+9	; 0x09
    6d96:	02 85       	ldd	r16, Z+10	; 0x0a
    6d98:	13 85       	ldd	r17, Z+11	; 0x0b
    6d9a:	e4 84       	ldd	r14, Z+12	; 0x0c
    6d9c:	f5 84       	ldd	r15, Z+13	; 0x0d
    6d9e:	82 81       	ldd	r24, Z+2	; 0x02
    6da0:	93 81       	ldd	r25, Z+3	; 0x03
    6da2:	0e 94 d3 1c 	call	0x39a6	; 0x39a6 <commandSetProgStep>
    6da6:	8d cf       	rjmp	.-230    	; 0x6cc2 <main+0x23a>
      case 0x9A:    /* SETFORBZONE */
        commandSetForbiddenZone(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x9B:    /* ENABFORBZONE */
        commandEnableForbiddenZone(commandParam[1], commandParam[2]);
    6da8:	e0 91 d6 02 	lds	r30, 0x02D6
    6dac:	f0 91 d7 02 	lds	r31, 0x02D7
    6db0:	64 81       	ldd	r22, Z+4	; 0x04
    6db2:	75 81       	ldd	r23, Z+5	; 0x05
    6db4:	82 81       	ldd	r24, Z+2	; 0x02
    6db6:	93 81       	ldd	r25, Z+3	; 0x03
    6db8:	0e 94 41 21 	call	0x4282	; 0x4282 <commandEnableForbiddenZone>
    6dbc:	82 cf       	rjmp	.-252    	; 0x6cc2 <main+0x23a>
          }
        }
        break;

      case 0x9A:    /* SETFORBZONE */
        commandSetForbiddenZone(commandParam[1], commandParam[2], commandParam[3]);
    6dbe:	e0 91 d6 02 	lds	r30, 0x02D6
    6dc2:	f0 91 d7 02 	lds	r31, 0x02D7
    6dc6:	64 81       	ldd	r22, Z+4	; 0x04
    6dc8:	75 81       	ldd	r23, Z+5	; 0x05
    6dca:	46 81       	ldd	r20, Z+6	; 0x06
    6dcc:	57 81       	ldd	r21, Z+7	; 0x07
    6dce:	82 81       	ldd	r24, Z+2	; 0x02
    6dd0:	93 81       	ldd	r25, Z+3	; 0x03
    6dd2:	0e 94 77 21 	call	0x42ee	; 0x42ee <commandSetForbiddenZone>
    6dd6:	75 cf       	rjmp	.-278    	; 0x6cc2 <main+0x23a>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    6dd8:	f8 94       	cli
    6dda:	40 e0       	ldi	r20, 0x00	; 0
    6ddc:	50 e0       	ldi	r21, 0x00	; 0
        break;

      case 0x99:    /* STOPALL */
        ATOMIC_BLOCK(ATOMIC_FORCEON){
          for(i = 0; i <= MAX_MOTOR; i++){
            motor[i].desiredPosition = motor[i].actualPosition;
    6dde:	fa 01       	movw	r30, r20
    6de0:	ee 0f       	add	r30, r30
    6de2:	ff 1f       	adc	r31, r31
    6de4:	ee 0f       	add	r30, r30
    6de6:	ff 1f       	adc	r31, r31
    6de8:	ee 0f       	add	r30, r30
    6dea:	ff 1f       	adc	r31, r31
    6dec:	cf 01       	movw	r24, r30
    6dee:	88 0f       	add	r24, r24
    6df0:	99 1f       	adc	r25, r25
    6df2:	88 0f       	add	r24, r24
    6df4:	99 1f       	adc	r25, r25
    6df6:	e8 0f       	add	r30, r24
    6df8:	f9 1f       	adc	r31, r25
    6dfa:	e0 51       	subi	r30, 0x10	; 16
    6dfc:	fc 4f       	sbci	r31, 0xFC	; 252
    6dfe:	20 81       	ld	r18, Z
    6e00:	31 81       	ldd	r19, Z+1	; 0x01
    6e02:	fa 01       	movw	r30, r20
    6e04:	ee 0f       	add	r30, r30
    6e06:	ff 1f       	adc	r31, r31
    6e08:	ee 0f       	add	r30, r30
    6e0a:	ff 1f       	adc	r31, r31
    6e0c:	cf 01       	movw	r24, r30
    6e0e:	88 0f       	add	r24, r24
    6e10:	99 1f       	adc	r25, r25
    6e12:	88 0f       	add	r24, r24
    6e14:	99 1f       	adc	r25, r25
    6e16:	e8 0f       	add	r30, r24
    6e18:	f9 1f       	adc	r31, r25
    6e1a:	ee 0f       	add	r30, r30
    6e1c:	ff 1f       	adc	r31, r31
    6e1e:	ee 50       	subi	r30, 0x0E	; 14
    6e20:	fc 4f       	sbci	r31, 0xFC	; 252
    6e22:	31 83       	std	Z+1, r19	; 0x01
    6e24:	20 83       	st	Z, r18
            motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    6e26:	fa 01       	movw	r30, r20
    6e28:	ee 0f       	add	r30, r30
    6e2a:	ff 1f       	adc	r31, r31
    6e2c:	ee 0f       	add	r30, r30
    6e2e:	ff 1f       	adc	r31, r31
    6e30:	ee 0f       	add	r30, r30
    6e32:	ff 1f       	adc	r31, r31
    6e34:	cf 01       	movw	r24, r30
    6e36:	88 0f       	add	r24, r24
    6e38:	99 1f       	adc	r25, r25
    6e3a:	88 0f       	add	r24, r24
    6e3c:	99 1f       	adc	r25, r25
    6e3e:	e8 0f       	add	r30, r24
    6e40:	f9 1f       	adc	r31, r25
    6e42:	e0 51       	subi	r30, 0x10	; 16
    6e44:	fc 4f       	sbci	r31, 0xFC	; 252
    6e46:	14 86       	std	Z+12, r1	; 0x0c
    6e48:	4f 5f       	subi	r20, 0xFF	; 255
    6e4a:	5f 4f       	sbci	r21, 0xFF	; 255
        goto RESET;
        break;

      case 0x99:    /* STOPALL */
        ATOMIC_BLOCK(ATOMIC_FORCEON){
          for(i = 0; i <= MAX_MOTOR; i++){
    6e4c:	44 30       	cpi	r20, 0x04	; 4
    6e4e:	51 05       	cpc	r21, r1
    6e50:	31 f6       	brne	.-116    	; 0x6dde <main+0x356>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    6e52:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    6e54:	36 cf       	rjmp	.-404    	; 0x6cc2 <main+0x23a>
      case 0x97:    /* SETCONSTSPEED */
        commandSetConstSpeed(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x98:    /* FACTORYRESET */
        commandFactoryReset();
    6e56:	0e 94 41 0c 	call	0x1882	; 0x1882 <commandFactoryReset>
        cli();
    6e5a:	f8 94       	cli
        prepareReset();
    6e5c:	0e 94 57 2b 	call	0x56ae	; 0x56ae <prepareReset>
    6e60:	fe ce       	rjmp	.-516    	; 0x6c5e <main+0x1d6>
      case 0x96:    /* SETWAITTIME */
        commandSetWaitTime(commandParam[1], commandParam[2]);
        break;

      case 0x97:    /* SETCONSTSPEED */
        commandSetConstSpeed(commandParam[1], commandParam[2], commandParam[3]);
    6e62:	e0 91 d6 02 	lds	r30, 0x02D6
    6e66:	f0 91 d7 02 	lds	r31, 0x02D7
    6e6a:	64 81       	ldd	r22, Z+4	; 0x04
    6e6c:	75 81       	ldd	r23, Z+5	; 0x05
    6e6e:	46 81       	ldd	r20, Z+6	; 0x06
    6e70:	57 81       	ldd	r21, Z+7	; 0x07
    6e72:	82 81       	ldd	r24, Z+2	; 0x02
    6e74:	93 81       	ldd	r25, Z+3	; 0x03
    6e76:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <commandSetConstSpeed>
    6e7a:	23 cf       	rjmp	.-442    	; 0x6cc2 <main+0x23a>
      case 0x95:    /* GETWAITTIME */
        sendText(commandGetWaitTime(commandParam[1]));
        break;

      case 0x96:    /* SETWAITTIME */
        commandSetWaitTime(commandParam[1], commandParam[2]);
    6e7c:	e0 91 d6 02 	lds	r30, 0x02D6
    6e80:	f0 91 d7 02 	lds	r31, 0x02D7
    6e84:	64 81       	ldd	r22, Z+4	; 0x04
    6e86:	75 81       	ldd	r23, Z+5	; 0x05
    6e88:	82 81       	ldd	r24, Z+2	; 0x02
    6e8a:	93 81       	ldd	r25, Z+3	; 0x03
    6e8c:	0e 94 34 23 	call	0x4668	; 0x4668 <commandSetWaitTime>
    6e90:	18 cf       	rjmp	.-464    	; 0x6cc2 <main+0x23a>
      case 0x94:    /* SETSUBSTEPS */
        commandSetSubSteps(commandParam[1], commandParam[2]);
        break;

      case 0x95:    /* GETWAITTIME */
        sendText(commandGetWaitTime(commandParam[1]));
    6e92:	e0 91 d6 02 	lds	r30, 0x02D6
    6e96:	f0 91 d7 02 	lds	r31, 0x02D7
    6e9a:	82 81       	ldd	r24, Z+2	; 0x02
    6e9c:	93 81       	ldd	r25, Z+3	; 0x03
    6e9e:	0e 94 c3 12 	call	0x2586	; 0x2586 <commandGetWaitTime>
    6ea2:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6ea6:	0d cf       	rjmp	.-486    	; 0x6cc2 <main+0x23a>
      case 0x93:    /* GETSUBSTEPS */
        sendText(commandGetSubSteps(commandParam[1]));
        break;

      case 0x94:    /* SETSUBSTEPS */
        commandSetSubSteps(commandParam[1], commandParam[2]);
    6ea8:	e0 91 d6 02 	lds	r30, 0x02D6
    6eac:	f0 91 d7 02 	lds	r31, 0x02D7
    6eb0:	64 81       	ldd	r22, Z+4	; 0x04
    6eb2:	75 81       	ldd	r23, Z+5	; 0x05
    6eb4:	82 81       	ldd	r24, Z+2	; 0x02
    6eb6:	93 81       	ldd	r25, Z+3	; 0x03
    6eb8:	0e 94 d4 2b 	call	0x57a8	; 0x57a8 <commandSetSubSteps>
    6ebc:	02 cf       	rjmp	.-508    	; 0x6cc2 <main+0x23a>
      case 0x92:    /* SETFULLROT */
        commandSetFullRotation(commandParam[1], commandParam[2]);
        break;

      case 0x93:    /* GETSUBSTEPS */
        sendText(commandGetSubSteps(commandParam[1]));
    6ebe:	e0 91 d6 02 	lds	r30, 0x02D6
    6ec2:	f0 91 d7 02 	lds	r31, 0x02D7
    6ec6:	82 81       	ldd	r24, Z+2	; 0x02
    6ec8:	93 81       	ldd	r25, Z+3	; 0x03
    6eca:	0e 94 2a 13 	call	0x2654	; 0x2654 <commandGetSubSteps>
    6ece:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6ed2:	f7 ce       	rjmp	.-530    	; 0x6cc2 <main+0x23a>
      case 0x91:    /* GETFULLROT */
        sendText(commandGetFullRotation(commandParam[1]));
        break;

      case 0x92:    /* SETFULLROT */
        commandSetFullRotation(commandParam[1], commandParam[2]);
    6ed4:	e0 91 d6 02 	lds	r30, 0x02D6
    6ed8:	f0 91 d7 02 	lds	r31, 0x02D7
    6edc:	64 81       	ldd	r22, Z+4	; 0x04
    6ede:	75 81       	ldd	r23, Z+5	; 0x05
    6ee0:	82 81       	ldd	r24, Z+2	; 0x02
    6ee2:	93 81       	ldd	r25, Z+3	; 0x03
    6ee4:	0e 94 6e 23 	call	0x46dc	; 0x46dc <commandSetFullRotation>
    6ee8:	ec ce       	rjmp	.-552    	; 0x6cc2 <main+0x23a>
      case 0x90:    /* SETGEARRATIO */
        commandSetGearRatio(commandParam[1], commandParam[2]);
        break;

      case 0x91:    /* GETFULLROT */
        sendText(commandGetFullRotation(commandParam[1]));
    6eea:	e0 91 d6 02 	lds	r30, 0x02D6
    6eee:	f0 91 d7 02 	lds	r31, 0x02D7
    6ef2:	82 81       	ldd	r24, Z+2	; 0x02
    6ef4:	93 81       	ldd	r25, Z+3	; 0x03
    6ef6:	0e 94 9a 13 	call	0x2734	; 0x2734 <commandGetFullRotation>
    6efa:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6efe:	e1 ce       	rjmp	.-574    	; 0x6cc2 <main+0x23a>
      case 0x8F:    /* GETGEARRATIO */
        sendText(commandGetGearRatio(commandParam[1]));
        break;

      case 0x90:    /* SETGEARRATIO */
        commandSetGearRatio(commandParam[1], commandParam[2]);
    6f00:	e0 91 d6 02 	lds	r30, 0x02D6
    6f04:	f0 91 d7 02 	lds	r31, 0x02D7
    6f08:	64 81       	ldd	r22, Z+4	; 0x04
    6f0a:	75 81       	ldd	r23, Z+5	; 0x05
    6f0c:	82 81       	ldd	r24, Z+2	; 0x02
    6f0e:	93 81       	ldd	r25, Z+3	; 0x03
    6f10:	0e 94 c2 23 	call	0x4784	; 0x4784 <commandSetGearRatio>
    6f14:	d6 ce       	rjmp	.-596    	; 0x6cc2 <main+0x23a>
      case 0x8E:    /* SETZEROPOS */
        commandSetOptZeroPos(commandParam[1], commandParam[2]);
        break;

      case 0x8F:    /* GETGEARRATIO */
        sendText(commandGetGearRatio(commandParam[1]));
    6f16:	e0 91 d6 02 	lds	r30, 0x02D6
    6f1a:	f0 91 d7 02 	lds	r31, 0x02D7
    6f1e:	82 81       	ldd	r24, Z+2	; 0x02
    6f20:	93 81       	ldd	r25, Z+3	; 0x03
    6f22:	0e 94 0a 14 	call	0x2814	; 0x2814 <commandGetGearRatio>
    6f26:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6f2a:	cb ce       	rjmp	.-618    	; 0x6cc2 <main+0x23a>
      case 0x8D:    /* GETZEROPOS */
        sendText(commandGetOptZeroPos(commandParam[1]));
        break;

      case 0x8E:    /* SETZEROPOS */
        commandSetOptZeroPos(commandParam[1], commandParam[2]);
    6f2c:	e0 91 d6 02 	lds	r30, 0x02D6
    6f30:	f0 91 d7 02 	lds	r31, 0x02D7
    6f34:	64 81       	ldd	r22, Z+4	; 0x04
    6f36:	75 81       	ldd	r23, Z+5	; 0x05
    6f38:	82 81       	ldd	r24, Z+2	; 0x02
    6f3a:	93 81       	ldd	r25, Z+3	; 0x03
    6f3c:	0e 94 16 24 	call	0x482c	; 0x482c <commandSetOptZeroPos>
    6f40:	c0 ce       	rjmp	.-640    	; 0x6cc2 <main+0x23a>
      case 0x8C:    /* GETANALOG */
        sendText(commandGetAnalog(commandParam[1]));
        break;

      case 0x8D:    /* GETZEROPOS */
        sendText(commandGetOptZeroPos(commandParam[1]));
    6f42:	e0 91 d6 02 	lds	r30, 0x02D6
    6f46:	f0 91 d7 02 	lds	r31, 0x02D7
    6f4a:	82 81       	ldd	r24, Z+2	; 0x02
    6f4c:	93 81       	ldd	r25, Z+3	; 0x03
    6f4e:	0e 94 7a 14 	call	0x28f4	; 0x28f4 <commandGetOptZeroPos>
    6f52:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6f56:	b5 ce       	rjmp	.-662    	; 0x6cc2 <main+0x23a>
      case 0x8B:    /* ISMOVING */
        sendText(commandIsMoving(commandParam[1]));
        break;

      case 0x8C:    /* GETANALOG */
        sendText(commandGetAnalog(commandParam[1]));
    6f58:	e0 91 d6 02 	lds	r30, 0x02D6
    6f5c:	f0 91 d7 02 	lds	r31, 0x02D7
    6f60:	82 81       	ldd	r24, Z+2	; 0x02
    6f62:	93 81       	ldd	r25, Z+3	; 0x03
    6f64:	0e 94 e3 14 	call	0x29c6	; 0x29c6 <commandGetAnalog>
    6f68:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6f6c:	aa ce       	rjmp	.-684    	; 0x6cc2 <main+0x23a>
        loadConfigFromEEPROM();
        updateIICvalues();
        break;

      case 0x8B:    /* ISMOVING */
        sendText(commandIsMoving(commandParam[1]));
    6f6e:	e0 91 d6 02 	lds	r30, 0x02D6
    6f72:	f0 91 d7 02 	lds	r31, 0x02D7
    6f76:	82 81       	ldd	r24, Z+2	; 0x02
    6f78:	93 81       	ldd	r25, Z+3	; 0x03
    6f7a:	0e 94 3a 15 	call	0x2a74	; 0x2a74 <commandIsMoving>
    6f7e:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6f82:	9f ce       	rjmp	.-706    	; 0x6cc2 <main+0x23a>
      case 0x89:    /* SAVECONF: save current machine configuration */
        saveConfigToEEPROM();
        break;

      case 0x8A:    /* LOADCONF: load last saved machine configuration */
        loadConfigFromEEPROM();
    6f84:	0e 94 a3 0a 	call	0x1546	; 0x1546 <loadConfigFromEEPROM>
        updateIICvalues();
    6f88:	0e 94 1d 2c 	call	0x583a	; 0x583a <updateIICvalues>
    6f8c:	9a ce       	rjmp	.-716    	; 0x6cc2 <main+0x23a>
      case 0x88:    /* GETPOS --> get position in [unit] */
        sendText(commandGetMotorPosition(commandParam[1], commandParam[2]));
        break;

      case 0x89:    /* SAVECONF: save current machine configuration */
        saveConfigToEEPROM();
    6f8e:	0e 94 7c 0b 	call	0x16f8	; 0x16f8 <saveConfigToEEPROM>
    6f92:	97 ce       	rjmp	.-722    	; 0x6cc2 <main+0x23a>
      case 0x87:    /* ENABLE */
        commandEnable(commandParam[1], commandParam[2]);
        break;

      case 0x88:    /* GETPOS --> get position in [unit] */
        sendText(commandGetMotorPosition(commandParam[1], commandParam[2]));
    6f94:	e0 91 d6 02 	lds	r30, 0x02D6
    6f98:	f0 91 d7 02 	lds	r31, 0x02D7
    6f9c:	64 81       	ldd	r22, Z+4	; 0x04
    6f9e:	75 81       	ldd	r23, Z+5	; 0x05
    6fa0:	82 81       	ldd	r24, Z+2	; 0x02
    6fa2:	93 81       	ldd	r25, Z+3	; 0x03
    6fa4:	0e 94 09 1e 	call	0x3c12	; 0x3c12 <commandGetMotorPosition>
    6fa8:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    6fac:	8a ce       	rjmp	.-748    	; 0x6cc2 <main+0x23a>
      case 0x86:    /* ZERORUN */
        motorZeroRun((uint8_t)atoi(commandParam[1]));
        break;

      case 0x87:    /* ENABLE */
        commandEnable(commandParam[1], commandParam[2]);
    6fae:	e0 91 d6 02 	lds	r30, 0x02D6
    6fb2:	f0 91 d7 02 	lds	r31, 0x02D7
    6fb6:	64 81       	ldd	r22, Z+4	; 0x04
    6fb8:	75 81       	ldd	r23, Z+5	; 0x05
    6fba:	82 81       	ldd	r24, Z+2	; 0x02
    6fbc:	93 81       	ldd	r25, Z+3	; 0x03
    6fbe:	0e 94 28 2b 	call	0x5650	; 0x5650 <commandEnable>
    6fc2:	7f ce       	rjmp	.-770    	; 0x6cc2 <main+0x23a>
      case 0x85:    /* MOVEREL */
        commandMoveRel(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x86:    /* ZERORUN */
        motorZeroRun((uint8_t)atoi(commandParam[1]));
    6fc4:	e0 91 d6 02 	lds	r30, 0x02D6
    6fc8:	f0 91 d7 02 	lds	r31, 0x02D7
    6fcc:	82 81       	ldd	r24, Z+2	; 0x02
    6fce:	93 81       	ldd	r25, Z+3	; 0x03
    6fd0:	0e 94 26 44 	call	0x884c	; 0x884c <atoi>
    6fd4:	0e 94 68 29 	call	0x52d0	; 0x52d0 <motorZeroRun>
    6fd8:	74 ce       	rjmp	.-792    	; 0x6cc2 <main+0x23a>
      case 0x84:    /* MOVEABS */
        commandMoveAbs(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x85:    /* MOVEREL */
        commandMoveRel(commandParam[1], commandParam[2], commandParam[3]);
    6fda:	e0 91 d6 02 	lds	r30, 0x02D6
    6fde:	f0 91 d7 02 	lds	r31, 0x02D7
    6fe2:	64 81       	ldd	r22, Z+4	; 0x04
    6fe4:	75 81       	ldd	r23, Z+5	; 0x05
    6fe6:	46 81       	ldd	r20, Z+6	; 0x06
    6fe8:	57 81       	ldd	r21, Z+7	; 0x07
    6fea:	82 81       	ldd	r24, Z+2	; 0x02
    6fec:	93 81       	ldd	r25, Z+3	; 0x03
    6fee:	0e 94 6e 24 	call	0x48dc	; 0x48dc <commandMoveRel>
    6ff2:	67 ce       	rjmp	.-818    	; 0x6cc2 <main+0x23a>
        }
        eeprom_update_block((const void*)commandParam[1], (void*)IDNtext, IDN_STRING_LENGTH + 1);
        break;

      case 0x84:    /* MOVEABS */
        commandMoveAbs(commandParam[1], commandParam[2], commandParam[3]);
    6ff4:	e0 91 d6 02 	lds	r30, 0x02D6
    6ff8:	f0 91 d7 02 	lds	r31, 0x02D7
    6ffc:	64 81       	ldd	r22, Z+4	; 0x04
    6ffe:	75 81       	ldd	r23, Z+5	; 0x05
    7000:	46 81       	ldd	r20, Z+6	; 0x06
    7002:	57 81       	ldd	r21, Z+7	; 0x07
    7004:	82 81       	ldd	r24, Z+2	; 0x02
    7006:	93 81       	ldd	r25, Z+3	; 0x03
    7008:	0e 94 f0 24 	call	0x49e0	; 0x49e0 <commandMoveAbs>
    700c:	5a ce       	rjmp	.-844    	; 0x6cc2 <main+0x23a>
        eeprom_read_block((void*)txString.buffer, (const void*)IDNtext, IDN_STRING_LENGTH + 1);
        sendText(txString.buffer);
        break;

      case 0x83:    /* set IDN */
        if(strlen(commandParam[1]) > IDN_STRING_LENGTH){
    700e:	e0 91 d6 02 	lds	r30, 0x02D6
    7012:	f0 91 d7 02 	lds	r31, 0x02D7
    7016:	82 81       	ldd	r24, Z+2	; 0x02
    7018:	93 81       	ldd	r25, Z+3	; 0x03
    701a:	dc 01       	movw	r26, r24
    701c:	fd 01       	movw	r30, r26
    701e:	01 90       	ld	r0, Z+
    7020:	00 20       	and	r0, r0
    7022:	e9 f7       	brne	.-6      	; 0x701e <main+0x596>
    7024:	31 97       	sbiw	r30, 0x01	; 1
    7026:	ea 1b       	sub	r30, r26
    7028:	fb 0b       	sbc	r31, r27
    702a:	f3 97       	sbiw	r30, 0x33	; 51
    702c:	08 f0       	brcs	.+2      	; 0x7030 <main+0x5a8>
    702e:	49 ce       	rjmp	.-878    	; 0x6cc2 <main+0x23a>
          break;
        }
        eeprom_update_block((const void*)commandParam[1], (void*)IDNtext, IDN_STRING_LENGTH + 1);
    7030:	60 e0       	ldi	r22, 0x00	; 0
    7032:	70 e0       	ldi	r23, 0x00	; 0
    7034:	43 e3       	ldi	r20, 0x33	; 51
    7036:	50 e0       	ldi	r21, 0x00	; 0
    7038:	0e 94 50 46 	call	0x8ca0	; 0x8ca0 <__eeupd_block_m1284p>
    703c:	42 ce       	rjmp	.-892    	; 0x6cc2 <main+0x23a>
        prepareReset();
        goto RESET;
        break;

      case 0x82:    /* *IDN? */
        eeprom_read_block((void*)txString.buffer, (const void*)IDNtext, IDN_STRING_LENGTH + 1);
    703e:	80 91 e7 03 	lds	r24, 0x03E7
    7042:	90 91 e8 03 	lds	r25, 0x03E8
    7046:	60 e0       	ldi	r22, 0x00	; 0
    7048:	70 e0       	ldi	r23, 0x00	; 0
    704a:	43 e3       	ldi	r20, 0x33	; 51
    704c:	50 e0       	ldi	r21, 0x00	; 0
    704e:	0e 94 40 46 	call	0x8c80	; 0x8c80 <__eerd_block_m1284p>
        sendText(txString.buffer);
    7052:	80 91 e7 03 	lds	r24, 0x03E7
    7056:	90 91 e8 03 	lds	r25, 0x03E8
    705a:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    705e:	31 ce       	rjmp	.-926    	; 0x6cc2 <main+0x23a>
      case 0x80:    /* no or unknown command, ignore it */
        break;

      case 0x81:    /* *RST */
        //sendText("reset\0");
        cli();
    7060:	f8 94       	cli
        prepareReset();
    7062:	0e 94 57 2b 	call	0x56ae	; 0x56ae <prepareReset>
    7066:	fb cd       	rjmp	.-1034   	; 0x6c5e <main+0x1d6>
      case 0xA3:    /* SETDECAY */
        commandSetMotorDecay(commandParam[1], commandParam[2]);
        break;
        
      case 0xA4:    /* ISCON */
        sendText(commandIsConnected(commandParam[1]));
    7068:	e0 91 d6 02 	lds	r30, 0x02D6
    706c:	f0 91 d7 02 	lds	r31, 0x02D7
    7070:	82 81       	ldd	r24, Z+2	; 0x02
    7072:	93 81       	ldd	r25, Z+3	; 0x03
    7074:	0e 94 d9 28 	call	0x51b2	; 0x51b2 <commandIsConnected>
    7078:	0e 94 cf 1f 	call	0x3f9e	; 0x3f9e <sendText>
    707c:	22 ce       	rjmp	.-956    	; 0x6cc2 <main+0x23a>

0000707e <OLEDpinMode>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDpinMode(uint8_t pin, uint8_t mode){
    707e:	38 2f       	mov	r19, r24

  if (mode) {
    7080:	66 23       	and	r22, r22
    7082:	61 f4       	brne	.+24     	; 0x709c <OLEDpinMode+0x1e>
    LCD_DDR |= (1 << pin);
  } //output
  else {
    LCD_DDR &= ~(1 << pin);
    7084:	24 b1       	in	r18, 0x04	; 4
    7086:	81 e0       	ldi	r24, 0x01	; 1
    7088:	90 e0       	ldi	r25, 0x00	; 0
    708a:	02 c0       	rjmp	.+4      	; 0x7090 <OLEDpinMode+0x12>
    708c:	88 0f       	add	r24, r24
    708e:	99 1f       	adc	r25, r25
    7090:	3a 95       	dec	r19
    7092:	e2 f7       	brpl	.-8      	; 0x708c <OLEDpinMode+0xe>
    7094:	80 95       	com	r24
    7096:	82 23       	and	r24, r18
    7098:	84 b9       	out	0x04, r24	; 4
    709a:	08 95       	ret
    unknown
 --------------------------------------------------------------------- */
void OLEDpinMode(uint8_t pin, uint8_t mode){

  if (mode) {
    LCD_DDR |= (1 << pin);
    709c:	24 b1       	in	r18, 0x04	; 4
    709e:	81 e0       	ldi	r24, 0x01	; 1
    70a0:	90 e0       	ldi	r25, 0x00	; 0
    70a2:	02 c0       	rjmp	.+4      	; 0x70a8 <OLEDpinMode+0x2a>
    70a4:	88 0f       	add	r24, r24
    70a6:	99 1f       	adc	r25, r25
    70a8:	3a 95       	dec	r19
    70aa:	e2 f7       	brpl	.-8      	; 0x70a4 <OLEDpinMode+0x26>
    70ac:	28 2b       	or	r18, r24
    70ae:	24 b9       	out	0x04, r18	; 4
    70b0:	08 95       	ret

000070b2 <OLEDdigitalWrite>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDdigitalWrite(uint8_t pin,uint8_t value){
    70b2:	38 2f       	mov	r19, r24

  if (value == LOW) {
    70b4:	66 23       	and	r22, r22
    70b6:	59 f0       	breq	.+22     	; 0x70ce <OLEDdigitalWrite+0x1c>
    LCD_PORT &= ~(1 << pin);
  } //If low, write 0
  else {
    LCD_PORT |= (1 << pin);
    70b8:	25 b1       	in	r18, 0x05	; 5
    70ba:	81 e0       	ldi	r24, 0x01	; 1
    70bc:	90 e0       	ldi	r25, 0x00	; 0
    70be:	02 c0       	rjmp	.+4      	; 0x70c4 <OLEDdigitalWrite+0x12>
    70c0:	88 0f       	add	r24, r24
    70c2:	99 1f       	adc	r25, r25
    70c4:	3a 95       	dec	r19
    70c6:	e2 f7       	brpl	.-8      	; 0x70c0 <OLEDdigitalWrite+0xe>
    70c8:	28 2b       	or	r18, r24
    70ca:	25 b9       	out	0x05, r18	; 5
    70cc:	08 95       	ret
    unknown
 --------------------------------------------------------------------- */
void OLEDdigitalWrite(uint8_t pin,uint8_t value){

  if (value == LOW) {
    LCD_PORT &= ~(1 << pin);
    70ce:	25 b1       	in	r18, 0x05	; 5
    70d0:	81 e0       	ldi	r24, 0x01	; 1
    70d2:	90 e0       	ldi	r25, 0x00	; 0
    70d4:	02 c0       	rjmp	.+4      	; 0x70da <OLEDdigitalWrite+0x28>
    70d6:	88 0f       	add	r24, r24
    70d8:	99 1f       	adc	r25, r25
    70da:	3a 95       	dec	r19
    70dc:	e2 f7       	brpl	.-8      	; 0x70d6 <OLEDdigitalWrite+0x24>
    70de:	80 95       	com	r24
    70e0:	82 23       	and	r24, r18
    70e2:	85 b9       	out	0x05, r24	; 5
    70e4:	08 95       	ret

000070e6 <OLEDdigitalRead>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
uint8_t OLEDdigitalRead(uint8_t pin){

  return (LCD_PIN & (1 << pin));
    70e6:	93 b1       	in	r25, 0x03	; 3
    70e8:	21 e0       	ldi	r18, 0x01	; 1
    70ea:	30 e0       	ldi	r19, 0x00	; 0
    70ec:	02 c0       	rjmp	.+4      	; 0x70f2 <OLEDdigitalRead+0xc>
    70ee:	22 0f       	add	r18, r18
    70f0:	33 1f       	adc	r19, r19
    70f2:	8a 95       	dec	r24
    70f4:	e2 f7       	brpl	.-8      	; 0x70ee <OLEDdigitalRead+0x8>
}
    70f6:	89 2f       	mov	r24, r25
    70f8:	82 23       	and	r24, r18
    70fa:	08 95       	ret

000070fc <OLEDpulseEnable>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDpulseEnable(void){

  OLEDdigitalWrite(_enable_pin, HIGH);
    70fc:	83 e0       	ldi	r24, 0x03	; 3
    70fe:	61 e0       	ldi	r22, 0x01	; 1
    7100:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
    7104:	8a ef       	ldi	r24, 0xFA	; 250
    7106:	90 e0       	ldi	r25, 0x00	; 0
    7108:	01 97       	sbiw	r24, 0x01	; 1
    710a:	f1 f7       	brne	.-4      	; 0x7108 <OLEDpulseEnable+0xc>
  _delay_us(50);    // TODO: Timing Spec?
  OLEDdigitalWrite(_enable_pin, LOW);
    710c:	83 e0       	ldi	r24, 0x03	; 3
    710e:	60 e0       	ldi	r22, 0x00	; 0
    7110:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
}
    7114:	08 95       	ret

00007116 <OLEDwrite4bits>:

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDwrite4bits(uint8_t value){
    7116:	ef 92       	push	r14
    7118:	ff 92       	push	r15
    711a:	0f 93       	push	r16
    711c:	1f 93       	push	r17
    711e:	cf 93       	push	r28
    7120:	df 93       	push	r29
    7122:	e8 2e       	mov	r14, r24
    7124:	ff 24       	eor	r15, r15
    7126:	05 ec       	ldi	r16, 0xC5	; 197
    7128:	13 e0       	ldi	r17, 0x03	; 3
    712a:	c0 e0       	ldi	r28, 0x00	; 0
    712c:	d0 e0       	ldi	r29, 0x00	; 0

  for(int i = 0; i < 4; i++){
    OLEDpinMode(_data_pins[i], OUTPUT);
    712e:	f8 01       	movw	r30, r16
    7130:	80 81       	ld	r24, Z
    7132:	61 e0       	ldi	r22, 0x01	; 1
    7134:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
    OLEDdigitalWrite(_data_pins[i], (value >> i) & 0x01);
    7138:	b7 01       	movw	r22, r14
    713a:	0c 2e       	mov	r0, r28
    713c:	02 c0       	rjmp	.+4      	; 0x7142 <OLEDwrite4bits+0x2c>
    713e:	75 95       	asr	r23
    7140:	67 95       	ror	r22
    7142:	0a 94       	dec	r0
    7144:	e2 f7       	brpl	.-8      	; 0x713e <OLEDwrite4bits+0x28>
    7146:	61 70       	andi	r22, 0x01	; 1
    7148:	f8 01       	movw	r30, r16
    714a:	81 91       	ld	r24, Z+
    714c:	8f 01       	movw	r16, r30
    714e:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDwrite4bits(uint8_t value){

  for(int i = 0; i < 4; i++){
    7152:	21 96       	adiw	r28, 0x01	; 1
    7154:	c4 30       	cpi	r28, 0x04	; 4
    7156:	d1 05       	cpc	r29, r1
    7158:	51 f7       	brne	.-44     	; 0x712e <OLEDwrite4bits+0x18>
    715a:	8a ef       	ldi	r24, 0xFA	; 250
    715c:	90 e0       	ldi	r25, 0x00	; 0
    715e:	01 97       	sbiw	r24, 0x01	; 1
    7160:	f1 f7       	brne	.-4      	; 0x715e <OLEDwrite4bits+0x48>
    OLEDpinMode(_data_pins[i], OUTPUT);
    OLEDdigitalWrite(_data_pins[i], (value >> i) & 0x01);
  }

  _delay_us(50); // Timing spec?
  OLEDpulseEnable();
    7162:	0e 94 7e 38 	call	0x70fc	; 0x70fc <OLEDpulseEnable>
}
    7166:	df 91       	pop	r29
    7168:	cf 91       	pop	r28
    716a:	1f 91       	pop	r17
    716c:	0f 91       	pop	r16
    716e:	ff 90       	pop	r15
    7170:	ef 90       	pop	r14
    7172:	08 95       	ret

00007174 <OLEDsend>:
}

/* ---------------------------------------------------------------------
    write either command or data
 --------------------------------------------------------------------- */
void OLEDsend(uint8_t value, uint8_t mode){
    7174:	1f 93       	push	r17
    7176:	18 2f       	mov	r17, r24

  OLEDdigitalWrite(rs_pin, mode);
    7178:	81 e0       	ldi	r24, 0x01	; 1
    717a:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
  OLEDpinMode(_rw_pin, OUTPUT);
    717e:	82 e0       	ldi	r24, 0x02	; 2
    7180:	61 e0       	ldi	r22, 0x01	; 1
    7182:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
  OLEDdigitalWrite(_rw_pin, LOW);
    7186:	82 e0       	ldi	r24, 0x02	; 2
    7188:	60 e0       	ldi	r22, 0x00	; 0
    718a:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>

  OLEDwrite4bits(value >> 4);
    718e:	81 2f       	mov	r24, r17
    7190:	82 95       	swap	r24
    7192:	8f 70       	andi	r24, 0x0F	; 15
    7194:	0e 94 8b 38 	call	0x7116	; 0x7116 <OLEDwrite4bits>
  OLEDwrite4bits(value);
    7198:	81 2f       	mov	r24, r17
    719a:	0e 94 8b 38 	call	0x7116	; 0x7116 <OLEDwrite4bits>
}
    719e:	1f 91       	pop	r17
    71a0:	08 95       	ret

000071a2 <OLEDwaitForReady>:
}

/* ---------------------------------------------------------------------
    Poll the busy bit until it goes LOW
 --------------------------------------------------------------------- */
void OLEDwaitForReady(void){
    71a2:	0f 93       	push	r16
    71a4:	1f 93       	push	r17

  unsigned char busy = 1;
  OLEDpinMode(_busy_pin, INPUT);
    71a6:	87 e0       	ldi	r24, 0x07	; 7
    71a8:	60 e0       	ldi	r22, 0x00	; 0
    71aa:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
  OLEDdigitalWrite(rs_pin, LOW);
    71ae:	81 e0       	ldi	r24, 0x01	; 1
    71b0:	60 e0       	ldi	r22, 0x00	; 0
    71b2:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, HIGH);
    71b6:	82 e0       	ldi	r24, 0x02	; 2
    71b8:	61 e0       	ldi	r22, 0x01	; 1
    71ba:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    71be:	02 e4       	ldi	r16, 0x42	; 66

  do{
    OLEDdigitalWrite(_enable_pin, LOW);
    71c0:	83 e0       	ldi	r24, 0x03	; 3
    71c2:	60 e0       	ldi	r22, 0x00	; 0
    71c4:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
    OLEDdigitalWrite(_enable_pin, HIGH);
    71c8:	83 e0       	ldi	r24, 0x03	; 3
    71ca:	61 e0       	ldi	r22, 0x01	; 1
    71cc:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
    71d0:	80 2f       	mov	r24, r16
    71d2:	8a 95       	dec	r24
    71d4:	f1 f7       	brne	.-4      	; 0x71d2 <OLEDwaitForReady+0x30>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
uint8_t OLEDdigitalRead(uint8_t pin){

  return (LCD_PIN & (1 << pin));
    71d6:	13 b1       	in	r17, 0x03	; 3
    OLEDdigitalWrite(_enable_pin, LOW);
    OLEDdigitalWrite(_enable_pin, HIGH);

    _delay_us(10);
    busy = OLEDdigitalRead(_busy_pin);
    OLEDdigitalWrite(_enable_pin, LOW);
    71d8:	83 e0       	ldi	r24, 0x03	; 3
    71da:	60 e0       	ldi	r22, 0x00	; 0
    71dc:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>

    OLEDpulseEnable();    // get remaining 4 bits, which are not used.
    71e0:	0e 94 7e 38 	call	0x70fc	; 0x70fc <OLEDpulseEnable>
  } while(busy);
    71e4:	17 fd       	sbrc	r17, 7
    71e6:	ec cf       	rjmp	.-40     	; 0x71c0 <OLEDwaitForReady+0x1e>

  OLEDpinMode(_busy_pin, OUTPUT);
    71e8:	87 e0       	ldi	r24, 0x07	; 7
    71ea:	61 e0       	ldi	r22, 0x01	; 1
    71ec:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
  OLEDdigitalWrite(_rw_pin, LOW);
    71f0:	82 e0       	ldi	r24, 0x02	; 2
    71f2:	60 e0       	ldi	r22, 0x00	; 0
    71f4:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
}
    71f8:	1f 91       	pop	r17
    71fa:	0f 91       	pop	r16
    71fc:	08 95       	ret

000071fe <OLEDwriteC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    71fe:	61 e0       	ldi	r22, 0x01	; 1
    7200:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7204:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
}
    7208:	08 95       	ret

0000720a <OLEDcommand>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    720a:	60 e0       	ldi	r22, 0x00	; 0
    720c:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7210:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
}
    7214:	08 95       	ret

00007216 <OLEDwriteCCC>:
}

/* ---------------------------------------------------------------------
    send a string with length to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCCC(const uint8_t *buffer, size_t size){
    7216:	0f 93       	push	r16
    7218:	1f 93       	push	r17
    721a:	cf 93       	push	r28
    721c:	df 93       	push	r29
    721e:	8c 01       	movw	r16, r24
    7220:	eb 01       	movw	r28, r22

  size_t n = 0;
  while(size--){
    7222:	61 15       	cp	r22, r1
    7224:	71 05       	cpc	r23, r1
    7226:	51 f0       	breq	.+20     	; 0x723c <OLEDwriteCCC+0x26>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    7228:	f8 01       	movw	r30, r16
    722a:	81 91       	ld	r24, Z+
    722c:	8f 01       	movw	r16, r30
    722e:	61 e0       	ldi	r22, 0x01	; 1
    7230:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7234:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    7238:	21 97       	sbiw	r28, 0x01	; 1
    send a string with length to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCCC(const uint8_t *buffer, size_t size){

  size_t n = 0;
  while(size--){
    723a:	b1 f7       	brne	.-20     	; 0x7228 <OLEDwriteCCC+0x12>
    n += OLEDwriteC(*buffer++);
  }

  return n;
}
    723c:	80 e0       	ldi	r24, 0x00	; 0
    723e:	90 e0       	ldi	r25, 0x00	; 0
    7240:	df 91       	pop	r29
    7242:	cf 91       	pop	r28
    7244:	1f 91       	pop	r17
    7246:	0f 91       	pop	r16
    7248:	08 95       	ret

0000724a <OLEDwriteCC>:
/* ---------------------------------------------------------------------
    send a string to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCC(const char *str){

  if(str == NULL){
    724a:	00 97       	sbiw	r24, 0x00	; 0
    724c:	69 f0       	breq	.+26     	; 0x7268 <OLEDwriteCC+0x1e>
    return 0;
  }

  return OLEDwriteCCC((const uint8_t *)str, strlen(str));
    724e:	fc 01       	movw	r30, r24
    7250:	01 90       	ld	r0, Z+
    7252:	00 20       	and	r0, r0
    7254:	e9 f7       	brne	.-6      	; 0x7250 <OLEDwriteCC+0x6>
    7256:	31 97       	sbiw	r30, 0x01	; 1
    7258:	e8 1b       	sub	r30, r24
    725a:	f9 0b       	sbc	r31, r25
    725c:	bf 01       	movw	r22, r30
    725e:	0e 94 0b 39 	call	0x7216	; 0x7216 <OLEDwriteCCC>
    7262:	9c 01       	movw	r18, r24
}
    7264:	c9 01       	movw	r24, r18
    7266:	08 95       	ret
/* ---------------------------------------------------------------------
    send a string to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCC(const char *str){

  if(str == NULL){
    7268:	20 e0       	ldi	r18, 0x00	; 0
    726a:	30 e0       	ldi	r19, 0x00	; 0
    return 0;
  }

  return OLEDwriteCCC((const uint8_t *)str, strlen(str));
}
    726c:	c9 01       	movw	r24, r18
    726e:	08 95       	ret

00007270 <OLEDprintCC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
size_t OLEDprintCC(const char str[]){

  return OLEDwriteCC(str);
    7270:	0e 94 25 39 	call	0x724a	; 0x724a <OLEDwriteCC>
}
    7274:	08 95       	ret

00007276 <OLEDprintC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    7276:	61 e0       	ldi	r22, 0x01	; 1
    7278:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    727c:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    unknown
 --------------------------------------------------------------------- */
size_t OLEDprintC(char c){

  return OLEDwriteC(c);
}
    7280:	80 e0       	ldi	r24, 0x00	; 0
    7282:	90 e0       	ldi	r25, 0x00	; 0
    7284:	08 95       	ret

00007286 <OLEDcreateChar>:

/* ---------------------------------------------------------------------
    Allows us to fill the first 8 CGRAM locations
    with custom characters
 --------------------------------------------------------------------- */
void OLEDcreateChar(uint8_t location, uint8_t charmap[]){
    7286:	0f 93       	push	r16
    7288:	1f 93       	push	r17
    728a:	cf 93       	push	r28
    728c:	df 93       	push	r29
    728e:	8b 01       	movw	r16, r22
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7290:	87 70       	andi	r24, 0x07	; 7
    7292:	88 0f       	add	r24, r24
    7294:	88 0f       	add	r24, r24
    7296:	88 0f       	add	r24, r24
    7298:	80 64       	ori	r24, 0x40	; 64
    729a:	60 e0       	ldi	r22, 0x00	; 0
    729c:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    72a0:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    72a4:	c0 e0       	ldi	r28, 0x00	; 0
    72a6:	d0 e0       	ldi	r29, 0x00	; 0
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    72a8:	f8 01       	movw	r30, r16
    72aa:	ec 0f       	add	r30, r28
    72ac:	fd 1f       	adc	r31, r29
    72ae:	80 81       	ld	r24, Z
    72b0:	61 e0       	ldi	r22, 0x01	; 1
    72b2:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    72b6:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDcreateChar(uint8_t location, uint8_t charmap[]){

  location &= 0x7; // we only have 8 locations 0-7
  OLEDcommand(LCD_SETCGRAMADDR | (location << 3));
  for (int i=0; i<8; i++){
    72ba:	21 96       	adiw	r28, 0x01	; 1
    72bc:	c8 30       	cpi	r28, 0x08	; 8
    72be:	d1 05       	cpc	r29, r1
    72c0:	99 f7       	brne	.-26     	; 0x72a8 <OLEDcreateChar+0x22>
    OLEDwriteC(charmap[i]);
  }
}
    72c2:	df 91       	pop	r29
    72c4:	cf 91       	pop	r28
    72c6:	1f 91       	pop	r17
    72c8:	0f 91       	pop	r16
    72ca:	08 95       	ret

000072cc <OLEDnoAutoscroll>:
/* ---------------------------------------------------------------------
    This will 'left justify' text from the cursor
 --------------------------------------------------------------------- */
void OLEDnoAutoscroll(void){

  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
    72cc:	80 91 c9 03 	lds	r24, 0x03C9
    72d0:	8e 7f       	andi	r24, 0xFE	; 254
    72d2:	80 93 c9 03 	sts	0x03C9, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    72d6:	84 60       	ori	r24, 0x04	; 4
    72d8:	60 e0       	ldi	r22, 0x00	; 0
    72da:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    72de:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoAutoscroll(void){

  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    72e2:	08 95       	ret

000072e4 <OLEDautoscroll>:
/* ---------------------------------------------------------------------
    This will 'right justify' text from the cursor
 --------------------------------------------------------------------- */
void OLEDautoscroll(void){

  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
    72e4:	80 91 c9 03 	lds	r24, 0x03C9
    72e8:	98 2f       	mov	r25, r24
    72ea:	91 60       	ori	r25, 0x01	; 1
    72ec:	90 93 c9 03 	sts	0x03C9, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    72f0:	85 60       	ori	r24, 0x05	; 5
    72f2:	60 e0       	ldi	r22, 0x00	; 0
    72f4:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    72f8:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDautoscroll(void){

  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    72fc:	08 95       	ret

000072fe <OLEDscrollDisplayRight>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    72fe:	8c e1       	ldi	r24, 0x1C	; 28
    7300:	60 e0       	ldi	r22, 0x00	; 0
    7302:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7306:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    unknown
 --------------------------------------------------------------------- */
void OLEDscrollDisplayRight(void){

  OLEDcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
}
    730a:	08 95       	ret

0000730c <OLEDscrollDisplayLeft>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    730c:	88 e1       	ldi	r24, 0x18	; 24
    730e:	60 e0       	ldi	r22, 0x00	; 0
    7310:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7314:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    These commands scroll the display without changing the RAM
 --------------------------------------------------------------------- */
void OLEDscrollDisplayLeft(void){

  OLEDcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
}
    7318:	08 95       	ret

0000731a <OLEDrightToLeft>:
/* ---------------------------------------------------------------------
    This is for text that flows Right to Left
 --------------------------------------------------------------------- */
void OLEDrightToLeft(void){

  _displaymode &= ~LCD_ENTRYLEFT;
    731a:	80 91 c9 03 	lds	r24, 0x03C9
    731e:	8d 7f       	andi	r24, 0xFD	; 253
    7320:	80 93 c9 03 	sts	0x03C9, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7324:	84 60       	ori	r24, 0x04	; 4
    7326:	60 e0       	ldi	r22, 0x00	; 0
    7328:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    732c:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDrightToLeft(void){

  _displaymode &= ~LCD_ENTRYLEFT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    7330:	08 95       	ret

00007332 <OLEDleftToRight>:
/* ---------------------------------------------------------------------
    This is for text that flows Left to Right
 --------------------------------------------------------------------- */
void OLEDleftToRight(void){

  _displaymode |= LCD_ENTRYLEFT;
    7332:	80 91 c9 03 	lds	r24, 0x03C9
    7336:	98 2f       	mov	r25, r24
    7338:	92 60       	ori	r25, 0x02	; 2
    733a:	90 93 c9 03 	sts	0x03C9, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    733e:	86 60       	ori	r24, 0x06	; 6
    7340:	60 e0       	ldi	r22, 0x00	; 0
    7342:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7346:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDleftToRight(void){

  _displaymode |= LCD_ENTRYLEFT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    734a:	08 95       	ret

0000734c <OLEDsetCursor>:
}

/* ---------------------------------------------------------------------
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){
    734c:	df 93       	push	r29
    734e:	cf 93       	push	r28
    7350:	00 d0       	rcall	.+0      	; 0x7352 <OLEDsetCursor+0x6>
    7352:	00 d0       	rcall	.+0      	; 0x7354 <OLEDsetCursor+0x8>
    7354:	cd b7       	in	r28, 0x3d	; 61
    7356:	de b7       	in	r29, 0x3e	; 62
    7358:	98 2f       	mov	r25, r24

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
  if (row >= _numlines){
    735a:	80 91 94 03 	lds	r24, 0x0394
    735e:	68 17       	cp	r22, r24
    7360:	d0 f0       	brcs	.+52     	; 0x7396 <OLEDsetCursor+0x4a>
    7362:	e0 e0       	ldi	r30, 0x00	; 0
    7364:	f0 e0       	ldi	r31, 0x00	; 0
/* ---------------------------------------------------------------------
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
    7366:	19 82       	std	Y+1, r1	; 0x01
    7368:	80 e4       	ldi	r24, 0x40	; 64
    736a:	8a 83       	std	Y+2, r24	; 0x02
    736c:	84 e1       	ldi	r24, 0x14	; 20
    736e:	8b 83       	std	Y+3, r24	; 0x03
    7370:	84 e5       	ldi	r24, 0x54	; 84
    7372:	8c 83       	std	Y+4, r24	; 0x04
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7374:	ec 0f       	add	r30, r28
    7376:	fd 1f       	adc	r31, r29
    7378:	81 81       	ldd	r24, Z+1	; 0x01
    737a:	89 0f       	add	r24, r25
    737c:	80 68       	ori	r24, 0x80	; 128
    737e:	60 e0       	ldi	r22, 0x00	; 0
    7380:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7384:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
  if (row >= _numlines){
    row = 0;  //write to first line if out off bounds
  }

  OLEDcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}
    7388:	0f 90       	pop	r0
    738a:	0f 90       	pop	r0
    738c:	0f 90       	pop	r0
    738e:	0f 90       	pop	r0
    7390:	cf 91       	pop	r28
    7392:	df 91       	pop	r29
    7394:	08 95       	ret
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
  if (row >= _numlines){
    7396:	e6 2f       	mov	r30, r22
    7398:	f0 e0       	ldi	r31, 0x00	; 0
    739a:	e5 cf       	rjmp	.-54     	; 0x7366 <OLEDsetCursor+0x1a>

0000739c <OLEDhome>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    739c:	82 e0       	ldi	r24, 0x02	; 2
    739e:	60 e0       	ldi	r22, 0x00	; 0
    73a0:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    73a4:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    set cursor to home position
 --------------------------------------------------------------------- */
void OLEDhome(void){
  OLEDcommand(LCD_RETURNHOME);  // set cursor position to zero
  //  _delay_us(2000);  // this command takes a long time!
}
    73a8:	08 95       	ret

000073aa <OLEDcursor>:
/* ---------------------------------------------------------------------
    Turns the underline cursor on
 --------------------------------------------------------------------- */
void OLEDcursor(void){

  _displaycontrol |= LCD_CURSORON;
    73aa:	80 91 93 03 	lds	r24, 0x0393
    73ae:	98 2f       	mov	r25, r24
    73b0:	92 60       	ori	r25, 0x02	; 2
    73b2:	90 93 93 03 	sts	0x0393, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    73b6:	8a 60       	ori	r24, 0x0A	; 10
    73b8:	60 e0       	ldi	r22, 0x00	; 0
    73ba:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    73be:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDcursor(void){

  _displaycontrol |= LCD_CURSORON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    73c2:	08 95       	ret

000073c4 <OLEDnoCursor>:
/* ---------------------------------------------------------------------
    Turns the underline cursor off
 --------------------------------------------------------------------- */
void OLEDnoCursor(void){

  _displaycontrol &= ~LCD_CURSORON;
    73c4:	80 91 93 03 	lds	r24, 0x0393
    73c8:	8d 7f       	andi	r24, 0xFD	; 253
    73ca:	80 93 93 03 	sts	0x0393, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    73ce:	88 60       	ori	r24, 0x08	; 8
    73d0:	60 e0       	ldi	r22, 0x00	; 0
    73d2:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    73d6:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoCursor(void){

  _displaycontrol &= ~LCD_CURSORON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    73da:	08 95       	ret

000073dc <OLEDblink>:
/* ---------------------------------------------------------------------
    Turn on the blinking cursor
 --------------------------------------------------------------------- */
void OLEDblink(void){

  _displaycontrol |= LCD_BLINKON;
    73dc:	80 91 93 03 	lds	r24, 0x0393
    73e0:	98 2f       	mov	r25, r24
    73e2:	91 60       	ori	r25, 0x01	; 1
    73e4:	90 93 93 03 	sts	0x0393, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    73e8:	89 60       	ori	r24, 0x09	; 9
    73ea:	60 e0       	ldi	r22, 0x00	; 0
    73ec:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    73f0:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDblink(void){

  _displaycontrol |= LCD_BLINKON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    73f4:	08 95       	ret

000073f6 <OLEDnoBlink>:
/* ---------------------------------------------------------------------
    Turn off the blinking cursor
 --------------------------------------------------------------------- */
void OLEDnoBlink(void){

  _displaycontrol &= ~LCD_BLINKON;
    73f6:	80 91 93 03 	lds	r24, 0x0393
    73fa:	8e 7f       	andi	r24, 0xFE	; 254
    73fc:	80 93 93 03 	sts	0x0393, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7400:	88 60       	ori	r24, 0x08	; 8
    7402:	60 e0       	ldi	r22, 0x00	; 0
    7404:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7408:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoBlink(void){

  _displaycontrol &= ~LCD_BLINKON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    740c:	08 95       	ret

0000740e <OLEDclear>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    740e:	81 e0       	ldi	r24, 0x01	; 1
    7410:	60 e0       	ldi	r22, 0x00	; 0
    7412:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7416:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDclear(void){

  OLEDcommand(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
  //  _delay_us(2000);  // this command takes a long time!
}
    741a:	08 95       	ret

0000741c <OLEDdisplay>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDdisplay(void){

  _displaycontrol |= LCD_DISPLAYON;
    741c:	80 91 93 03 	lds	r24, 0x0393
    7420:	98 2f       	mov	r25, r24
    7422:	94 60       	ori	r25, 0x04	; 4
    7424:	90 93 93 03 	sts	0x0393, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7428:	8c 60       	ori	r24, 0x0C	; 12
    742a:	60 e0       	ldi	r22, 0x00	; 0
    742c:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7430:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDdisplay(void){

  _displaycontrol |= LCD_DISPLAYON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7434:	08 95       	ret

00007436 <OLEDnoDisplay>:
/* ---------------------------------------------------------------------
    Turn the display on/off (quickly)
 --------------------------------------------------------------------- */
void OLEDnoDisplay(void){

  _displaycontrol &= ~LCD_DISPLAYON;
    7436:	80 91 93 03 	lds	r24, 0x0393
    743a:	8b 7f       	andi	r24, 0xFB	; 251
    743c:	80 93 93 03 	sts	0x0393, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7440:	88 60       	ori	r24, 0x08	; 8
    7442:	60 e0       	ldi	r22, 0x00	; 0
    7444:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7448:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoDisplay(void){

  _displaycontrol &= ~LCD_DISPLAYON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    744c:	08 95       	ret

0000744e <OLEDbegin>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDbegin(uint8_t cols, uint8_t lines){
    744e:	0f 93       	push	r16
    7450:	1f 93       	push	r17
    7452:	cf 93       	push	r28
    7454:	df 93       	push	r29

  _numlines = lines;
    7456:	60 93 94 03 	sts	0x0394, r22
  _currline = 0;
    745a:	10 92 f2 02 	sts	0x02F2, r1

  OLEDpinMode(rs_pin, OUTPUT);
    745e:	81 e0       	ldi	r24, 0x01	; 1
    7460:	61 e0       	ldi	r22, 0x01	; 1
    7462:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
  OLEDpinMode(_rw_pin, OUTPUT);
    7466:	82 e0       	ldi	r24, 0x02	; 2
    7468:	61 e0       	ldi	r22, 0x01	; 1
    746a:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
  OLEDpinMode(_enable_pin, OUTPUT);
    746e:	83 e0       	ldi	r24, 0x03	; 3
    7470:	61 e0       	ldi	r22, 0x01	; 1
    7472:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>

  OLEDdigitalWrite(rs_pin, LOW);
    7476:	81 e0       	ldi	r24, 0x01	; 1
    7478:	60 e0       	ldi	r22, 0x00	; 0
    747a:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
  OLEDdigitalWrite(_enable_pin, LOW);
    747e:	83 e0       	ldi	r24, 0x03	; 3
    7480:	60 e0       	ldi	r22, 0x00	; 0
    7482:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, LOW);
    7486:	82 e0       	ldi	r24, 0x02	; 2
    7488:	60 e0       	ldi	r22, 0x00	; 0
    748a:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
    748e:	24 ef       	ldi	r18, 0xF4	; 244
    7490:	31 e0       	ldi	r19, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7492:	44 ef       	ldi	r20, 0xF4	; 244
    7494:	51 e0       	ldi	r21, 0x01	; 1
    7496:	ca 01       	movw	r24, r20
    7498:	01 97       	sbiw	r24, 0x01	; 1
    749a:	f1 f7       	brne	.-4      	; 0x7498 <OLEDbegin+0x4a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    749c:	21 50       	subi	r18, 0x01	; 1
    749e:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    74a0:	d1 f7       	brne	.-12     	; 0x7496 <OLEDbegin+0x48>
    74a2:	c5 ec       	ldi	r28, 0xC5	; 197
    74a4:	d3 e0       	ldi	r29, 0x03	; 3

  _delay_us(50000); // give it some time to power up

  // Now we pull both RS and R/W low to begin commands
  for(int i = 0; i < 4; i++){
    OLEDpinMode(_data_pins[i], OUTPUT);
    74a6:	88 81       	ld	r24, Y
    74a8:	61 e0       	ldi	r22, 0x01	; 1
    74aa:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
    OLEDdigitalWrite(_data_pins[i], LOW);
    74ae:	89 91       	ld	r24, Y+
    74b0:	60 e0       	ldi	r22, 0x00	; 0
    74b2:	0e 94 59 38 	call	0x70b2	; 0x70b2 <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, LOW);

  _delay_us(50000); // give it some time to power up

  // Now we pull both RS and R/W low to begin commands
  for(int i = 0; i < 4; i++){
    74b6:	83 e0       	ldi	r24, 0x03	; 3
    74b8:	c9 3c       	cpi	r28, 0xC9	; 201
    74ba:	d8 07       	cpc	r29, r24
    74bc:	a1 f7       	brne	.-24     	; 0x74a6 <OLEDbegin+0x58>
  //
  // In the data sheet, the timing specs are all zeros(!).  These have been tested to
  // reliably handle both warm & cold starts.

  // 4-Bit initialization sequence from Technobly
  OLEDwrite4bits(0x03); // Put back into 8-bit mode
    74be:	83 e0       	ldi	r24, 0x03	; 3
    74c0:	0e 94 8b 38 	call	0x7116	; 0x7116 <OLEDwrite4bits>
    74c4:	c8 ea       	ldi	r28, 0xA8	; 168
    74c6:	d1 e6       	ldi	r29, 0x61	; 97
    74c8:	ce 01       	movw	r24, r28
    74ca:	01 97       	sbiw	r24, 0x01	; 1
    74cc:	f1 f7       	brne	.-4      	; 0x74ca <OLEDbegin+0x7c>
  _delay_us(5000);
  if(_oled_ver == OLED_V2){  // only run extra command for newer displays
    74ce:	80 91 97 04 	lds	r24, 0x0497
    74d2:	82 30       	cpi	r24, 0x02	; 2
    74d4:	09 f4       	brne	.+2      	; 0x74d8 <OLEDbegin+0x8a>
    74d6:	46 c0       	rjmp	.+140    	; 0x7564 <OLEDbegin+0x116>
    OLEDwrite4bits(0x08);
    _delay_us(5000);
  }

  OLEDwrite4bits(0x02); // Put into 4-bit mode
    74d8:	82 e0       	ldi	r24, 0x02	; 2
    74da:	0e 94 8b 38 	call	0x7116	; 0x7116 <OLEDwrite4bits>
    74de:	08 ea       	ldi	r16, 0xA8	; 168
    74e0:	11 e6       	ldi	r17, 0x61	; 97
    74e2:	c8 01       	movw	r24, r16
    74e4:	01 97       	sbiw	r24, 0x01	; 1
    74e6:	f1 f7       	brne	.-4      	; 0x74e4 <OLEDbegin+0x96>
  _delay_us(5000);
  OLEDwrite4bits(0x02);
    74e8:	82 e0       	ldi	r24, 0x02	; 2
    74ea:	0e 94 8b 38 	call	0x7116	; 0x7116 <OLEDwrite4bits>
    74ee:	c8 01       	movw	r24, r16
    74f0:	01 97       	sbiw	r24, 0x01	; 1
    74f2:	f1 f7       	brne	.-4      	; 0x74f0 <OLEDbegin+0xa2>
  _delay_us(5000);
  OLEDwrite4bits(0x08);
    74f4:	88 e0       	ldi	r24, 0x08	; 8
    74f6:	0e 94 8b 38 	call	0x7116	; 0x7116 <OLEDwrite4bits>
    74fa:	c8 01       	movw	r24, r16
    74fc:	01 97       	sbiw	r24, 0x01	; 1
    74fe:	f1 f7       	brne	.-4      	; 0x74fc <OLEDbegin+0xae>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7500:	88 e0       	ldi	r24, 0x08	; 8
    7502:	60 e0       	ldi	r22, 0x00	; 0
    7504:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7508:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    750c:	c8 01       	movw	r24, r16
    750e:	01 97       	sbiw	r24, 0x01	; 1
    7510:	f1 f7       	brne	.-4      	; 0x750e <OLEDbegin+0xc0>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7512:	81 e0       	ldi	r24, 0x01	; 1
    7514:	60 e0       	ldi	r22, 0x00	; 0
    7516:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    751a:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    751e:	c8 01       	movw	r24, r16
    7520:	01 97       	sbiw	r24, 0x01	; 1
    7522:	f1 f7       	brne	.-4      	; 0x7520 <OLEDbegin+0xd2>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7524:	86 e0       	ldi	r24, 0x06	; 6
    7526:	60 e0       	ldi	r22, 0x00	; 0
    7528:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    752c:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    7530:	c8 01       	movw	r24, r16
    7532:	01 97       	sbiw	r24, 0x01	; 1
    7534:	f1 f7       	brne	.-4      	; 0x7532 <OLEDbegin+0xe4>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7536:	82 e0       	ldi	r24, 0x02	; 2
    7538:	60 e0       	ldi	r22, 0x00	; 0
    753a:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    753e:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    7542:	c8 01       	movw	r24, r16
    7544:	01 97       	sbiw	r24, 0x01	; 1
    7546:	f1 f7       	brne	.-4      	; 0x7544 <OLEDbegin+0xf6>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7548:	8c e0       	ldi	r24, 0x0C	; 12
    754a:	60 e0       	ldi	r22, 0x00	; 0
    754c:	0e 94 ba 38 	call	0x7174	; 0x7174 <OLEDsend>
  OLEDwaitForReady();
    7550:	0e 94 d1 38 	call	0x71a2	; 0x71a2 <OLEDwaitForReady>
    7554:	c8 01       	movw	r24, r16
    7556:	01 97       	sbiw	r24, 0x01	; 1
    7558:	f1 f7       	brne	.-4      	; 0x7556 <OLEDbegin+0x108>
  _delay_us(5000);
  OLEDcommand(0x02);  // Home Cursor
  _delay_us(5000);
  OLEDcommand(0x0C);  // Turn On - enable cursor & blink
  _delay_us(5000);
}
    755a:	df 91       	pop	r29
    755c:	cf 91       	pop	r28
    755e:	1f 91       	pop	r17
    7560:	0f 91       	pop	r16
    7562:	08 95       	ret

  // 4-Bit initialization sequence from Technobly
  OLEDwrite4bits(0x03); // Put back into 8-bit mode
  _delay_us(5000);
  if(_oled_ver == OLED_V2){  // only run extra command for newer displays
    OLEDwrite4bits(0x08);
    7564:	88 e0       	ldi	r24, 0x08	; 8
    7566:	0e 94 8b 38 	call	0x7116	; 0x7116 <OLEDwrite4bits>
    756a:	ce 01       	movw	r24, r28
    756c:	01 97       	sbiw	r24, 0x01	; 1
    756e:	f1 f7       	brne	.-4      	; 0x756c <OLEDbegin+0x11e>
    7570:	b3 cf       	rjmp	.-154    	; 0x74d8 <OLEDbegin+0x8a>

00007572 <OLEDinit>:
/* ---------------------------------------------------------------------
    initialize OLED display
 --------------------------------------------------------------------- */
void OLEDinit(uint8_t ver){

  _oled_ver = ver;
    7572:	80 93 97 04 	sts	0x0497, r24
  if(_oled_ver != OLED_V1 && _oled_ver != OLED_V2){
    7576:	81 50       	subi	r24, 0x01	; 1
    7578:	82 30       	cpi	r24, 0x02	; 2
    757a:	18 f0       	brcs	.+6      	; 0x7582 <OLEDinit+0x10>
    _oled_ver = OLED_V2; // if error, default to newer version
    757c:	82 e0       	ldi	r24, 0x02	; 2
    757e:	80 93 97 04 	sts	0x0497, r24
  }

  _data_pins[0] = data4;
    7582:	84 e0       	ldi	r24, 0x04	; 4
    7584:	80 93 c5 03 	sts	0x03C5, r24
  _data_pins[1] = data5;
    7588:	85 e0       	ldi	r24, 0x05	; 5
    758a:	80 93 c6 03 	sts	0x03C6, r24
  _data_pins[2] = data6;
    758e:	86 e0       	ldi	r24, 0x06	; 6
    7590:	80 93 c7 03 	sts	0x03C7, r24
  _data_pins[3] = data7;
    7594:	87 e0       	ldi	r24, 0x07	; 7
    7596:	80 93 c8 03 	sts	0x03C8, r24

  OLEDpinMode(rs_pin, OUTPUT);
    759a:	81 e0       	ldi	r24, 0x01	; 1
    759c:	61 e0       	ldi	r22, 0x01	; 1
    759e:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
  OLEDpinMode(_rw_pin, OUTPUT);
    75a2:	82 e0       	ldi	r24, 0x02	; 2
    75a4:	61 e0       	ldi	r22, 0x01	; 1
    75a6:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>
  OLEDpinMode(_enable_pin, OUTPUT);
    75aa:	83 e0       	ldi	r24, 0x03	; 3
    75ac:	61 e0       	ldi	r22, 0x01	; 1
    75ae:	0e 94 3f 38 	call	0x707e	; 0x707e <OLEDpinMode>

  _displayfunction = LCD_FUNCTIONSET | LCD_4BITMODE;
    75b2:	88 e2       	ldi	r24, 0x28	; 40
    75b4:	80 93 ca 03 	sts	0x03CA, r24

  OLEDbegin(16, 2);
    75b8:	80 e1       	ldi	r24, 0x10	; 16
    75ba:	62 e0       	ldi	r22, 0x02	; 2
    75bc:	0e 94 27 3a 	call	0x744e	; 0x744e <OLEDbegin>
}
    75c0:	08 95       	ret

000075c2 <initIIC>:
/* ---------------------------------------------------------------------
   initialize I2C system
 --------------------------------------------------------------------- */
void initIIC(void){

  TWBR = TWBR_VALUE;    /* see macro above */
    75c2:	81 e1       	ldi	r24, 0x11	; 17
    75c4:	80 93 b8 00 	sts	0x00B8, r24
  TWSR &= ~((1<<TWPS0) | (1<<TWPS1));
    75c8:	e9 eb       	ldi	r30, 0xB9	; 185
    75ca:	f0 e0       	ldi	r31, 0x00	; 0
    75cc:	80 81       	ld	r24, Z
    75ce:	8c 7f       	andi	r24, 0xFC	; 252
    75d0:	80 83       	st	Z, r24
  TWCR = (1<<TWEN);
    75d2:	84 e0       	ldi	r24, 0x04	; 4
    75d4:	80 93 bc 00 	sts	0x00BC, r24

  return;
}
    75d8:	08 95       	ret

000075da <IICstart>:
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    75da:	84 ea       	ldi	r24, 0xA4	; 164
    75dc:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    75e0:	80 91 bc 00 	lds	r24, 0x00BC
    75e4:	87 ff       	sbrs	r24, 7
    75e6:	fc cf       	rjmp	.-8      	; 0x75e0 <IICstart+0x6>

  return;
}
    75e8:	08 95       	ret

000075ea <IICstop>:
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    75ea:	84 e9       	ldi	r24, 0x94	; 148
    75ec:	80 93 bc 00 	sts	0x00BC, r24

  return;
}
    75f0:	08 95       	ret

000075f2 <IICsendByte>:
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    75f2:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);
    75f6:	84 e8       	ldi	r24, 0x84	; 132
    75f8:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    75fc:	80 91 bc 00 	lds	r24, 0x00BC
    7600:	87 ff       	sbrs	r24, 7
    7602:	fc cf       	rjmp	.-8      	; 0x75fc <IICsendByte+0xa>

  return;
}
    7604:	08 95       	ret

00007606 <IICreadACK>:
/* ---------------------------------------------------------------------
   read a single byte with ACK
 --------------------------------------------------------------------- */
uint8_t IICreadACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    7606:	84 ec       	ldi	r24, 0xC4	; 196
    7608:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    760c:	80 91 bc 00 	lds	r24, 0x00BC
    7610:	87 ff       	sbrs	r24, 7
    7612:	fc cf       	rjmp	.-8      	; 0x760c <IICreadACK+0x6>

  return TWDR;
    7614:	80 91 bb 00 	lds	r24, 0x00BB
}
    7618:	08 95       	ret

0000761a <IICreadNACK>:
/* ---------------------------------------------------------------------
   read a single byte with NACK
 --------------------------------------------------------------------- */
uint8_t IICreadNACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN);
    761a:	84 e8       	ldi	r24, 0x84	; 132
    761c:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));
    7620:	80 91 bc 00 	lds	r24, 0x00BC
    7624:	87 ff       	sbrs	r24, 7
    7626:	fc cf       	rjmp	.-8      	; 0x7620 <IICreadNACK+0x6>

  return TWDR;
    7628:	80 91 bb 00 	lds	r24, 0x00BB
}
    762c:	08 95       	ret

0000762e <IICgetStatus>:
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    762e:	80 91 b9 00 	lds	r24, 0x00B9

  return status;
}
    7632:	88 7f       	andi	r24, 0xF8	; 248
    7634:	08 95       	ret

00007636 <IICwrite>:

/* ---------------------------------------------------------------------
   send a number of bytes to I2C slave
 --------------------------------------------------------------------- */
void IICwrite(uint8_t addr, uint8_t* data, uint8_t numDat){
    7636:	98 2f       	mov	r25, r24
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    7638:	84 ea       	ldi	r24, 0xA4	; 164
    763a:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    763e:	80 91 bc 00 	lds	r24, 0x00BC
    7642:	87 ff       	sbrs	r24, 7
    7644:	fc cf       	rjmp	.-8      	; 0x763e <IICwrite+0x8>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7646:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    764a:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    764e:	84 e8       	ldi	r24, 0x84	; 132
    7650:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7654:	80 91 bc 00 	lds	r24, 0x00BC
    7658:	87 ff       	sbrs	r24, 7
    765a:	fc cf       	rjmp	.-8      	; 0x7654 <IICwrite+0x1e>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    765c:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_WRITE);
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    7660:	44 23       	and	r20, r20
    7662:	91 f0       	breq	.+36     	; 0x7688 <IICwrite+0x52>
    7664:	fb 01       	movw	r30, r22
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
  TWCR = (1<<TWINT) | (1<<TWEN);
    7666:	94 e8       	ldi	r25, 0x84	; 132
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    IICsendByte(*data);
    7668:	80 81       	ld	r24, Z
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    766a:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);
    766e:	90 93 bc 00 	sts	0x00BC, r25
  while(!(TWCR & (1<<TWINT)));
    7672:	80 91 bc 00 	lds	r24, 0x00BC
    7676:	87 ff       	sbrs	r24, 7
    7678:	fc cf       	rjmp	.-8      	; 0x7672 <IICwrite+0x3c>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    767a:	80 91 b9 00 	lds	r24, 0x00B9
    767e:	31 96       	adiw	r30, 0x01	; 1
  IICsendByte(addr | TW_WRITE);
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    7680:	8e 2f       	mov	r24, r30
    7682:	86 1b       	sub	r24, r22
    7684:	84 17       	cp	r24, r20
    7686:	80 f3       	brcs	.-32     	; 0x7668 <IICwrite+0x32>
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    7688:	84 e9       	ldi	r24, 0x94	; 148
    768a:	80 93 bc 00 	sts	0x00BC, r24
  }

  IICstop();

  return;
}
    768e:	08 95       	ret

00007690 <IICread>:

/* ---------------------------------------------------------------------
   read a number of bytes from an I2C slave
 --------------------------------------------------------------------- */
void IICread(uint8_t addr, uint8_t* data, uint8_t numDat){
    7690:	98 2f       	mov	r25, r24
    7692:	db 01       	movw	r26, r22
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    7694:	84 ea       	ldi	r24, 0xA4	; 164
    7696:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    769a:	80 91 bc 00 	lds	r24, 0x00BC
    769e:	87 ff       	sbrs	r24, 7
    76a0:	fc cf       	rjmp	.-8      	; 0x769a <IICread+0xa>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    76a2:	80 91 b9 00 	lds	r24, 0x00B9
  IICstart();
  if(IICgetStatus() != TW_START){
    /* error handling */
  }

  IICsendByte(addr | TW_READ);
    76a6:	91 60       	ori	r25, 0x01	; 1
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    76a8:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    76ac:	84 e8       	ldi	r24, 0x84	; 132
    76ae:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    76b2:	80 91 bc 00 	lds	r24, 0x00BC
    76b6:	87 ff       	sbrs	r24, 7
    76b8:	fc cf       	rjmp	.-8      	; 0x76b2 <IICread+0x22>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    76ba:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_READ);
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    76be:	50 e0       	ldi	r21, 0x00	; 0
    76c0:	41 50       	subi	r20, 0x01	; 1
    76c2:	50 40       	sbci	r21, 0x00	; 0
    76c4:	14 16       	cp	r1, r20
    76c6:	15 06       	cpc	r1, r21
    76c8:	a4 f4       	brge	.+40     	; 0x76f2 <IICread+0x62>
    76ca:	fd 01       	movw	r30, r26
/* ---------------------------------------------------------------------
   read a single byte with ACK
 --------------------------------------------------------------------- */
uint8_t IICreadACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    76cc:	24 ec       	ldi	r18, 0xC4	; 196
    76ce:	20 93 bc 00 	sts	0x00BC, r18
  while(!(TWCR & (1<<TWINT)));
    76d2:	80 91 bc 00 	lds	r24, 0x00BC
    76d6:	87 ff       	sbrs	r24, 7
    76d8:	fc cf       	rjmp	.-8      	; 0x76d2 <IICread+0x42>

  return TWDR;
    76da:	80 91 bb 00 	lds	r24, 0x00BB
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    *data = IICreadACK();
    76de:	81 93       	st	Z+, r24
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    76e0:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_READ);
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    76e4:	8e 2f       	mov	r24, r30
    76e6:	8a 1b       	sub	r24, r26
    76e8:	90 e0       	ldi	r25, 0x00	; 0
    76ea:	84 17       	cp	r24, r20
    76ec:	95 07       	cpc	r25, r21
    76ee:	7c f3       	brlt	.-34     	; 0x76ce <IICread+0x3e>
    76f0:	df 01       	movw	r26, r30
/* ---------------------------------------------------------------------
   read a single byte with NACK
 --------------------------------------------------------------------- */
uint8_t IICreadNACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN);
    76f2:	84 e8       	ldi	r24, 0x84	; 132
    76f4:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));
    76f8:	80 91 bc 00 	lds	r24, 0x00BC
    76fc:	87 ff       	sbrs	r24, 7
    76fe:	fc cf       	rjmp	.-8      	; 0x76f8 <IICread+0x68>

  return TWDR;
    7700:	80 91 bb 00 	lds	r24, 0x00BB
      /* error handling */
    }
    data++;
  }

  *data = IICreadNACK();
    7704:	8c 93       	st	X, r24
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7706:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    770a:	84 e9       	ldi	r24, 0x94	; 148
    770c:	80 93 bc 00 	sts	0x00BC, r24
  }

  IICstop();

  return;
}
    7710:	08 95       	ret

00007712 <vfprintf>:
    7712:	2f 92       	push	r2
    7714:	3f 92       	push	r3
    7716:	4f 92       	push	r4
    7718:	5f 92       	push	r5
    771a:	6f 92       	push	r6
    771c:	7f 92       	push	r7
    771e:	8f 92       	push	r8
    7720:	9f 92       	push	r9
    7722:	af 92       	push	r10
    7724:	bf 92       	push	r11
    7726:	cf 92       	push	r12
    7728:	df 92       	push	r13
    772a:	ef 92       	push	r14
    772c:	ff 92       	push	r15
    772e:	0f 93       	push	r16
    7730:	1f 93       	push	r17
    7732:	df 93       	push	r29
    7734:	cf 93       	push	r28
    7736:	cd b7       	in	r28, 0x3d	; 61
    7738:	de b7       	in	r29, 0x3e	; 62
    773a:	61 97       	sbiw	r28, 0x11	; 17
    773c:	0f b6       	in	r0, 0x3f	; 63
    773e:	f8 94       	cli
    7740:	de bf       	out	0x3e, r29	; 62
    7742:	0f be       	out	0x3f, r0	; 63
    7744:	cd bf       	out	0x3d, r28	; 61
    7746:	3c 01       	movw	r6, r24
    7748:	7f 87       	std	Y+15, r23	; 0x0f
    774a:	6e 87       	std	Y+14, r22	; 0x0e
    774c:	6a 01       	movw	r12, r20
    774e:	fc 01       	movw	r30, r24
    7750:	17 82       	std	Z+7, r1	; 0x07
    7752:	16 82       	std	Z+6, r1	; 0x06
    7754:	83 81       	ldd	r24, Z+3	; 0x03
    7756:	81 fd       	sbrc	r24, 1
    7758:	03 c0       	rjmp	.+6      	; 0x7760 <vfprintf+0x4e>
    775a:	6f ef       	ldi	r22, 0xFF	; 255
    775c:	7f ef       	ldi	r23, 0xFF	; 255
    775e:	6f c3       	rjmp	.+1758   	; 0x7e3e <vfprintf+0x72c>
    7760:	9e 01       	movw	r18, r28
    7762:	2f 5f       	subi	r18, 0xFF	; 255
    7764:	3f 4f       	sbci	r19, 0xFF	; 255
    7766:	39 8b       	std	Y+17, r19	; 0x11
    7768:	28 8b       	std	Y+16, r18	; 0x10
    776a:	f3 01       	movw	r30, r6
    776c:	23 81       	ldd	r18, Z+3	; 0x03
    776e:	ee 85       	ldd	r30, Y+14	; 0x0e
    7770:	ff 85       	ldd	r31, Y+15	; 0x0f
    7772:	23 fd       	sbrc	r18, 3
    7774:	85 91       	lpm	r24, Z+
    7776:	23 ff       	sbrs	r18, 3
    7778:	81 91       	ld	r24, Z+
    777a:	ff 87       	std	Y+15, r31	; 0x0f
    777c:	ee 87       	std	Y+14, r30	; 0x0e
    777e:	88 23       	and	r24, r24
    7780:	09 f4       	brne	.+2      	; 0x7784 <vfprintf+0x72>
    7782:	5a c3       	rjmp	.+1716   	; 0x7e38 <vfprintf+0x726>
    7784:	85 32       	cpi	r24, 0x25	; 37
    7786:	51 f4       	brne	.+20     	; 0x779c <vfprintf+0x8a>
    7788:	ee 85       	ldd	r30, Y+14	; 0x0e
    778a:	ff 85       	ldd	r31, Y+15	; 0x0f
    778c:	23 fd       	sbrc	r18, 3
    778e:	85 91       	lpm	r24, Z+
    7790:	23 ff       	sbrs	r18, 3
    7792:	81 91       	ld	r24, Z+
    7794:	ff 87       	std	Y+15, r31	; 0x0f
    7796:	ee 87       	std	Y+14, r30	; 0x0e
    7798:	85 32       	cpi	r24, 0x25	; 37
    779a:	29 f4       	brne	.+10     	; 0x77a6 <vfprintf+0x94>
    779c:	90 e0       	ldi	r25, 0x00	; 0
    779e:	b3 01       	movw	r22, r6
    77a0:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    77a4:	e2 cf       	rjmp	.-60     	; 0x776a <vfprintf+0x58>
    77a6:	98 2f       	mov	r25, r24
    77a8:	10 e0       	ldi	r17, 0x00	; 0
    77aa:	88 24       	eor	r8, r8
    77ac:	99 24       	eor	r9, r9
    77ae:	10 32       	cpi	r17, 0x20	; 32
    77b0:	b0 f4       	brcc	.+44     	; 0x77de <vfprintf+0xcc>
    77b2:	9b 32       	cpi	r25, 0x2B	; 43
    77b4:	69 f0       	breq	.+26     	; 0x77d0 <vfprintf+0xbe>
    77b6:	9c 32       	cpi	r25, 0x2C	; 44
    77b8:	28 f4       	brcc	.+10     	; 0x77c4 <vfprintf+0xb2>
    77ba:	90 32       	cpi	r25, 0x20	; 32
    77bc:	51 f0       	breq	.+20     	; 0x77d2 <vfprintf+0xc0>
    77be:	93 32       	cpi	r25, 0x23	; 35
    77c0:	71 f4       	brne	.+28     	; 0x77de <vfprintf+0xcc>
    77c2:	0b c0       	rjmp	.+22     	; 0x77da <vfprintf+0xc8>
    77c4:	9d 32       	cpi	r25, 0x2D	; 45
    77c6:	39 f0       	breq	.+14     	; 0x77d6 <vfprintf+0xc4>
    77c8:	90 33       	cpi	r25, 0x30	; 48
    77ca:	49 f4       	brne	.+18     	; 0x77de <vfprintf+0xcc>
    77cc:	11 60       	ori	r17, 0x01	; 1
    77ce:	28 c0       	rjmp	.+80     	; 0x7820 <vfprintf+0x10e>
    77d0:	12 60       	ori	r17, 0x02	; 2
    77d2:	14 60       	ori	r17, 0x04	; 4
    77d4:	25 c0       	rjmp	.+74     	; 0x7820 <vfprintf+0x10e>
    77d6:	18 60       	ori	r17, 0x08	; 8
    77d8:	23 c0       	rjmp	.+70     	; 0x7820 <vfprintf+0x10e>
    77da:	10 61       	ori	r17, 0x10	; 16
    77dc:	21 c0       	rjmp	.+66     	; 0x7820 <vfprintf+0x10e>
    77de:	17 fd       	sbrc	r17, 7
    77e0:	2a c0       	rjmp	.+84     	; 0x7836 <vfprintf+0x124>
    77e2:	89 2f       	mov	r24, r25
    77e4:	80 53       	subi	r24, 0x30	; 48
    77e6:	8a 30       	cpi	r24, 0x0A	; 10
    77e8:	78 f4       	brcc	.+30     	; 0x7808 <vfprintf+0xf6>
    77ea:	16 ff       	sbrs	r17, 6
    77ec:	06 c0       	rjmp	.+12     	; 0x77fa <vfprintf+0xe8>
    77ee:	fa e0       	ldi	r31, 0x0A	; 10
    77f0:	9f 9e       	mul	r9, r31
    77f2:	90 2c       	mov	r9, r0
    77f4:	11 24       	eor	r1, r1
    77f6:	98 0e       	add	r9, r24
    77f8:	13 c0       	rjmp	.+38     	; 0x7820 <vfprintf+0x10e>
    77fa:	3a e0       	ldi	r19, 0x0A	; 10
    77fc:	83 9e       	mul	r8, r19
    77fe:	80 2c       	mov	r8, r0
    7800:	11 24       	eor	r1, r1
    7802:	88 0e       	add	r8, r24
    7804:	10 62       	ori	r17, 0x20	; 32
    7806:	0c c0       	rjmp	.+24     	; 0x7820 <vfprintf+0x10e>
    7808:	9e 32       	cpi	r25, 0x2E	; 46
    780a:	21 f4       	brne	.+8      	; 0x7814 <vfprintf+0x102>
    780c:	16 fd       	sbrc	r17, 6
    780e:	14 c3       	rjmp	.+1576   	; 0x7e38 <vfprintf+0x726>
    7810:	10 64       	ori	r17, 0x40	; 64
    7812:	06 c0       	rjmp	.+12     	; 0x7820 <vfprintf+0x10e>
    7814:	9c 36       	cpi	r25, 0x6C	; 108
    7816:	11 f4       	brne	.+4      	; 0x781c <vfprintf+0x10a>
    7818:	10 68       	ori	r17, 0x80	; 128
    781a:	02 c0       	rjmp	.+4      	; 0x7820 <vfprintf+0x10e>
    781c:	98 36       	cpi	r25, 0x68	; 104
    781e:	59 f4       	brne	.+22     	; 0x7836 <vfprintf+0x124>
    7820:	ee 85       	ldd	r30, Y+14	; 0x0e
    7822:	ff 85       	ldd	r31, Y+15	; 0x0f
    7824:	23 fd       	sbrc	r18, 3
    7826:	95 91       	lpm	r25, Z+
    7828:	23 ff       	sbrs	r18, 3
    782a:	91 91       	ld	r25, Z+
    782c:	ff 87       	std	Y+15, r31	; 0x0f
    782e:	ee 87       	std	Y+14, r30	; 0x0e
    7830:	99 23       	and	r25, r25
    7832:	09 f0       	breq	.+2      	; 0x7836 <vfprintf+0x124>
    7834:	bc cf       	rjmp	.-136    	; 0x77ae <vfprintf+0x9c>
    7836:	89 2f       	mov	r24, r25
    7838:	85 54       	subi	r24, 0x45	; 69
    783a:	83 30       	cpi	r24, 0x03	; 3
    783c:	20 f4       	brcc	.+8      	; 0x7846 <vfprintf+0x134>
    783e:	81 2f       	mov	r24, r17
    7840:	80 61       	ori	r24, 0x10	; 16
    7842:	90 5e       	subi	r25, 0xE0	; 224
    7844:	07 c0       	rjmp	.+14     	; 0x7854 <vfprintf+0x142>
    7846:	89 2f       	mov	r24, r25
    7848:	85 56       	subi	r24, 0x65	; 101
    784a:	83 30       	cpi	r24, 0x03	; 3
    784c:	08 f0       	brcs	.+2      	; 0x7850 <vfprintf+0x13e>
    784e:	9f c1       	rjmp	.+830    	; 0x7b8e <vfprintf+0x47c>
    7850:	81 2f       	mov	r24, r17
    7852:	8f 7e       	andi	r24, 0xEF	; 239
    7854:	86 fd       	sbrc	r24, 6
    7856:	02 c0       	rjmp	.+4      	; 0x785c <vfprintf+0x14a>
    7858:	76 e0       	ldi	r23, 0x06	; 6
    785a:	97 2e       	mov	r9, r23
    785c:	6f e3       	ldi	r22, 0x3F	; 63
    785e:	f6 2e       	mov	r15, r22
    7860:	f8 22       	and	r15, r24
    7862:	95 36       	cpi	r25, 0x65	; 101
    7864:	19 f4       	brne	.+6      	; 0x786c <vfprintf+0x15a>
    7866:	f0 e4       	ldi	r31, 0x40	; 64
    7868:	ff 2a       	or	r15, r31
    786a:	07 c0       	rjmp	.+14     	; 0x787a <vfprintf+0x168>
    786c:	96 36       	cpi	r25, 0x66	; 102
    786e:	19 f4       	brne	.+6      	; 0x7876 <vfprintf+0x164>
    7870:	20 e8       	ldi	r18, 0x80	; 128
    7872:	f2 2a       	or	r15, r18
    7874:	02 c0       	rjmp	.+4      	; 0x787a <vfprintf+0x168>
    7876:	91 10       	cpse	r9, r1
    7878:	9a 94       	dec	r9
    787a:	f7 fe       	sbrs	r15, 7
    787c:	0a c0       	rjmp	.+20     	; 0x7892 <vfprintf+0x180>
    787e:	3b e3       	ldi	r19, 0x3B	; 59
    7880:	39 15       	cp	r19, r9
    7882:	18 f4       	brcc	.+6      	; 0x788a <vfprintf+0x178>
    7884:	5c e3       	ldi	r21, 0x3C	; 60
    7886:	b5 2e       	mov	r11, r21
    7888:	02 c0       	rjmp	.+4      	; 0x788e <vfprintf+0x17c>
    788a:	b9 2c       	mov	r11, r9
    788c:	b3 94       	inc	r11
    788e:	27 e0       	ldi	r18, 0x07	; 7
    7890:	09 c0       	rjmp	.+18     	; 0x78a4 <vfprintf+0x192>
    7892:	47 e0       	ldi	r20, 0x07	; 7
    7894:	49 15       	cp	r20, r9
    7896:	20 f4       	brcc	.+8      	; 0x78a0 <vfprintf+0x18e>
    7898:	bb 24       	eor	r11, r11
    789a:	47 e0       	ldi	r20, 0x07	; 7
    789c:	94 2e       	mov	r9, r20
    789e:	f7 cf       	rjmp	.-18     	; 0x788e <vfprintf+0x17c>
    78a0:	29 2d       	mov	r18, r9
    78a2:	bb 24       	eor	r11, r11
    78a4:	c6 01       	movw	r24, r12
    78a6:	04 96       	adiw	r24, 0x04	; 4
    78a8:	9d 87       	std	Y+13, r25	; 0x0d
    78aa:	8c 87       	std	Y+12, r24	; 0x0c
    78ac:	f6 01       	movw	r30, r12
    78ae:	60 81       	ld	r22, Z
    78b0:	71 81       	ldd	r23, Z+1	; 0x01
    78b2:	82 81       	ldd	r24, Z+2	; 0x02
    78b4:	93 81       	ldd	r25, Z+3	; 0x03
    78b6:	ae 01       	movw	r20, r28
    78b8:	4f 5f       	subi	r20, 0xFF	; 255
    78ba:	5f 4f       	sbci	r21, 0xFF	; 255
    78bc:	0b 2d       	mov	r16, r11
    78be:	0e 94 44 44 	call	0x8888	; 0x8888 <__ftoa_engine>
    78c2:	6c 01       	movw	r12, r24
    78c4:	09 81       	ldd	r16, Y+1	; 0x01
    78c6:	20 2e       	mov	r2, r16
    78c8:	33 24       	eor	r3, r3
    78ca:	00 ff       	sbrs	r16, 0
    78cc:	04 c0       	rjmp	.+8      	; 0x78d6 <vfprintf+0x1c4>
    78ce:	03 fd       	sbrc	r16, 3
    78d0:	02 c0       	rjmp	.+4      	; 0x78d6 <vfprintf+0x1c4>
    78d2:	1d e2       	ldi	r17, 0x2D	; 45
    78d4:	09 c0       	rjmp	.+18     	; 0x78e8 <vfprintf+0x1d6>
    78d6:	f1 fe       	sbrs	r15, 1
    78d8:	02 c0       	rjmp	.+4      	; 0x78de <vfprintf+0x1cc>
    78da:	1b e2       	ldi	r17, 0x2B	; 43
    78dc:	05 c0       	rjmp	.+10     	; 0x78e8 <vfprintf+0x1d6>
    78de:	f2 fc       	sbrc	r15, 2
    78e0:	02 c0       	rjmp	.+4      	; 0x78e6 <vfprintf+0x1d4>
    78e2:	10 e0       	ldi	r17, 0x00	; 0
    78e4:	01 c0       	rjmp	.+2      	; 0x78e8 <vfprintf+0x1d6>
    78e6:	10 e2       	ldi	r17, 0x20	; 32
    78e8:	c1 01       	movw	r24, r2
    78ea:	8c 70       	andi	r24, 0x0C	; 12
    78ec:	90 70       	andi	r25, 0x00	; 0
    78ee:	89 2b       	or	r24, r25
    78f0:	b9 f1       	breq	.+110    	; 0x7960 <vfprintf+0x24e>
    78f2:	11 23       	and	r17, r17
    78f4:	11 f4       	brne	.+4      	; 0x78fa <vfprintf+0x1e8>
    78f6:	83 e0       	ldi	r24, 0x03	; 3
    78f8:	01 c0       	rjmp	.+2      	; 0x78fc <vfprintf+0x1ea>
    78fa:	84 e0       	ldi	r24, 0x04	; 4
    78fc:	88 15       	cp	r24, r8
    78fe:	10 f0       	brcs	.+4      	; 0x7904 <vfprintf+0x1f2>
    7900:	88 24       	eor	r8, r8
    7902:	0a c0       	rjmp	.+20     	; 0x7918 <vfprintf+0x206>
    7904:	88 1a       	sub	r8, r24
    7906:	f3 fc       	sbrc	r15, 3
    7908:	07 c0       	rjmp	.+14     	; 0x7918 <vfprintf+0x206>
    790a:	80 e2       	ldi	r24, 0x20	; 32
    790c:	90 e0       	ldi	r25, 0x00	; 0
    790e:	b3 01       	movw	r22, r6
    7910:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7914:	8a 94       	dec	r8
    7916:	c9 f7       	brne	.-14     	; 0x790a <vfprintf+0x1f8>
    7918:	11 23       	and	r17, r17
    791a:	29 f0       	breq	.+10     	; 0x7926 <vfprintf+0x214>
    791c:	81 2f       	mov	r24, r17
    791e:	90 e0       	ldi	r25, 0x00	; 0
    7920:	b3 01       	movw	r22, r6
    7922:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7926:	23 fe       	sbrs	r2, 3
    7928:	03 c0       	rjmp	.+6      	; 0x7930 <vfprintf+0x21e>
    792a:	00 e0       	ldi	r16, 0x00	; 0
    792c:	15 e0       	ldi	r17, 0x05	; 5
    792e:	0e c0       	rjmp	.+28     	; 0x794c <vfprintf+0x23a>
    7930:	04 e0       	ldi	r16, 0x04	; 4
    7932:	15 e0       	ldi	r17, 0x05	; 5
    7934:	0b c0       	rjmp	.+22     	; 0x794c <vfprintf+0x23a>
    7936:	e1 14       	cp	r14, r1
    7938:	f1 04       	cpc	r15, r1
    793a:	09 f0       	breq	.+2      	; 0x793e <vfprintf+0x22c>
    793c:	80 52       	subi	r24, 0x20	; 32
    793e:	90 e0       	ldi	r25, 0x00	; 0
    7940:	b3 01       	movw	r22, r6
    7942:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7946:	0f 5f       	subi	r16, 0xFF	; 255
    7948:	1f 4f       	sbci	r17, 0xFF	; 255
    794a:	05 c0       	rjmp	.+10     	; 0x7956 <vfprintf+0x244>
    794c:	ef 2c       	mov	r14, r15
    794e:	ff 24       	eor	r15, r15
    7950:	f0 e1       	ldi	r31, 0x10	; 16
    7952:	ef 22       	and	r14, r31
    7954:	ff 24       	eor	r15, r15
    7956:	f8 01       	movw	r30, r16
    7958:	84 91       	lpm	r24, Z+
    795a:	88 23       	and	r24, r24
    795c:	61 f7       	brne	.-40     	; 0x7936 <vfprintf+0x224>
    795e:	14 c1       	rjmp	.+552    	; 0x7b88 <vfprintf+0x476>
    7960:	f7 fe       	sbrs	r15, 7
    7962:	12 c0       	rjmp	.+36     	; 0x7988 <vfprintf+0x276>
    7964:	bc 0c       	add	r11, r12
    7966:	24 fe       	sbrs	r2, 4
    7968:	04 c0       	rjmp	.+8      	; 0x7972 <vfprintf+0x260>
    796a:	8a 81       	ldd	r24, Y+2	; 0x02
    796c:	81 33       	cpi	r24, 0x31	; 49
    796e:	09 f4       	brne	.+2      	; 0x7972 <vfprintf+0x260>
    7970:	ba 94       	dec	r11
    7972:	1b 14       	cp	r1, r11
    7974:	1c f0       	brlt	.+6      	; 0x797c <vfprintf+0x26a>
    7976:	bb 24       	eor	r11, r11
    7978:	b3 94       	inc	r11
    797a:	2d c0       	rjmp	.+90     	; 0x79d6 <vfprintf+0x2c4>
    797c:	f8 e0       	ldi	r31, 0x08	; 8
    797e:	fb 15       	cp	r31, r11
    7980:	50 f5       	brcc	.+84     	; 0x79d6 <vfprintf+0x2c4>
    7982:	38 e0       	ldi	r19, 0x08	; 8
    7984:	b3 2e       	mov	r11, r19
    7986:	27 c0       	rjmp	.+78     	; 0x79d6 <vfprintf+0x2c4>
    7988:	f6 fc       	sbrc	r15, 6
    798a:	25 c0       	rjmp	.+74     	; 0x79d6 <vfprintf+0x2c4>
    798c:	89 2d       	mov	r24, r9
    798e:	90 e0       	ldi	r25, 0x00	; 0
    7990:	8c 15       	cp	r24, r12
    7992:	9d 05       	cpc	r25, r13
    7994:	4c f0       	brlt	.+18     	; 0x79a8 <vfprintf+0x296>
    7996:	2c ef       	ldi	r18, 0xFC	; 252
    7998:	c2 16       	cp	r12, r18
    799a:	2f ef       	ldi	r18, 0xFF	; 255
    799c:	d2 06       	cpc	r13, r18
    799e:	24 f0       	brlt	.+8      	; 0x79a8 <vfprintf+0x296>
    79a0:	30 e8       	ldi	r19, 0x80	; 128
    79a2:	f3 2a       	or	r15, r19
    79a4:	01 c0       	rjmp	.+2      	; 0x79a8 <vfprintf+0x296>
    79a6:	9a 94       	dec	r9
    79a8:	99 20       	and	r9, r9
    79aa:	49 f0       	breq	.+18     	; 0x79be <vfprintf+0x2ac>
    79ac:	e2 e0       	ldi	r30, 0x02	; 2
    79ae:	f0 e0       	ldi	r31, 0x00	; 0
    79b0:	ec 0f       	add	r30, r28
    79b2:	fd 1f       	adc	r31, r29
    79b4:	e9 0d       	add	r30, r9
    79b6:	f1 1d       	adc	r31, r1
    79b8:	80 81       	ld	r24, Z
    79ba:	80 33       	cpi	r24, 0x30	; 48
    79bc:	a1 f3       	breq	.-24     	; 0x79a6 <vfprintf+0x294>
    79be:	f7 fe       	sbrs	r15, 7
    79c0:	0a c0       	rjmp	.+20     	; 0x79d6 <vfprintf+0x2c4>
    79c2:	b9 2c       	mov	r11, r9
    79c4:	b3 94       	inc	r11
    79c6:	89 2d       	mov	r24, r9
    79c8:	90 e0       	ldi	r25, 0x00	; 0
    79ca:	c8 16       	cp	r12, r24
    79cc:	d9 06       	cpc	r13, r25
    79ce:	14 f0       	brlt	.+4      	; 0x79d4 <vfprintf+0x2c2>
    79d0:	99 24       	eor	r9, r9
    79d2:	01 c0       	rjmp	.+2      	; 0x79d6 <vfprintf+0x2c4>
    79d4:	9c 18       	sub	r9, r12
    79d6:	f7 fc       	sbrc	r15, 7
    79d8:	03 c0       	rjmp	.+6      	; 0x79e0 <vfprintf+0x2ce>
    79da:	25 e0       	ldi	r18, 0x05	; 5
    79dc:	30 e0       	ldi	r19, 0x00	; 0
    79de:	09 c0       	rjmp	.+18     	; 0x79f2 <vfprintf+0x2e0>
    79e0:	1c 14       	cp	r1, r12
    79e2:	1d 04       	cpc	r1, r13
    79e4:	1c f0       	brlt	.+6      	; 0x79ec <vfprintf+0x2da>
    79e6:	21 e0       	ldi	r18, 0x01	; 1
    79e8:	30 e0       	ldi	r19, 0x00	; 0
    79ea:	03 c0       	rjmp	.+6      	; 0x79f2 <vfprintf+0x2e0>
    79ec:	96 01       	movw	r18, r12
    79ee:	2f 5f       	subi	r18, 0xFF	; 255
    79f0:	3f 4f       	sbci	r19, 0xFF	; 255
    79f2:	11 23       	and	r17, r17
    79f4:	11 f0       	breq	.+4      	; 0x79fa <vfprintf+0x2e8>
    79f6:	2f 5f       	subi	r18, 0xFF	; 255
    79f8:	3f 4f       	sbci	r19, 0xFF	; 255
    79fa:	99 20       	and	r9, r9
    79fc:	29 f0       	breq	.+10     	; 0x7a08 <vfprintf+0x2f6>
    79fe:	89 2d       	mov	r24, r9
    7a00:	90 e0       	ldi	r25, 0x00	; 0
    7a02:	01 96       	adiw	r24, 0x01	; 1
    7a04:	28 0f       	add	r18, r24
    7a06:	39 1f       	adc	r19, r25
    7a08:	88 2d       	mov	r24, r8
    7a0a:	90 e0       	ldi	r25, 0x00	; 0
    7a0c:	28 17       	cp	r18, r24
    7a0e:	39 07       	cpc	r19, r25
    7a10:	14 f0       	brlt	.+4      	; 0x7a16 <vfprintf+0x304>
    7a12:	88 24       	eor	r8, r8
    7a14:	01 c0       	rjmp	.+2      	; 0x7a18 <vfprintf+0x306>
    7a16:	82 1a       	sub	r8, r18
    7a18:	4f 2c       	mov	r4, r15
    7a1a:	55 24       	eor	r5, r5
    7a1c:	c2 01       	movw	r24, r4
    7a1e:	89 70       	andi	r24, 0x09	; 9
    7a20:	90 70       	andi	r25, 0x00	; 0
    7a22:	89 2b       	or	r24, r25
    7a24:	39 f0       	breq	.+14     	; 0x7a34 <vfprintf+0x322>
    7a26:	08 c0       	rjmp	.+16     	; 0x7a38 <vfprintf+0x326>
    7a28:	80 e2       	ldi	r24, 0x20	; 32
    7a2a:	90 e0       	ldi	r25, 0x00	; 0
    7a2c:	b3 01       	movw	r22, r6
    7a2e:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7a32:	8a 94       	dec	r8
    7a34:	88 20       	and	r8, r8
    7a36:	c1 f7       	brne	.-16     	; 0x7a28 <vfprintf+0x316>
    7a38:	11 23       	and	r17, r17
    7a3a:	29 f0       	breq	.+10     	; 0x7a46 <vfprintf+0x334>
    7a3c:	81 2f       	mov	r24, r17
    7a3e:	90 e0       	ldi	r25, 0x00	; 0
    7a40:	b3 01       	movw	r22, r6
    7a42:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7a46:	43 fe       	sbrs	r4, 3
    7a48:	07 c0       	rjmp	.+14     	; 0x7a58 <vfprintf+0x346>
    7a4a:	08 c0       	rjmp	.+16     	; 0x7a5c <vfprintf+0x34a>
    7a4c:	80 e3       	ldi	r24, 0x30	; 48
    7a4e:	90 e0       	ldi	r25, 0x00	; 0
    7a50:	b3 01       	movw	r22, r6
    7a52:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7a56:	8a 94       	dec	r8
    7a58:	88 20       	and	r8, r8
    7a5a:	c1 f7       	brne	.-16     	; 0x7a4c <vfprintf+0x33a>
    7a5c:	f7 fe       	sbrs	r15, 7
    7a5e:	46 c0       	rjmp	.+140    	; 0x7aec <vfprintf+0x3da>
    7a60:	86 01       	movw	r16, r12
    7a62:	d7 fe       	sbrs	r13, 7
    7a64:	02 c0       	rjmp	.+4      	; 0x7a6a <vfprintf+0x358>
    7a66:	00 e0       	ldi	r16, 0x00	; 0
    7a68:	10 e0       	ldi	r17, 0x00	; 0
    7a6a:	76 01       	movw	r14, r12
    7a6c:	08 94       	sec
    7a6e:	e1 1c       	adc	r14, r1
    7a70:	f1 1c       	adc	r15, r1
    7a72:	e0 1a       	sub	r14, r16
    7a74:	f1 0a       	sbc	r15, r17
    7a76:	41 e0       	ldi	r20, 0x01	; 1
    7a78:	50 e0       	ldi	r21, 0x00	; 0
    7a7a:	4c 0f       	add	r20, r28
    7a7c:	5d 1f       	adc	r21, r29
    7a7e:	e4 0e       	add	r14, r20
    7a80:	f5 1e       	adc	r15, r21
    7a82:	26 01       	movw	r4, r12
    7a84:	4b 18       	sub	r4, r11
    7a86:	51 08       	sbc	r5, r1
    7a88:	89 2d       	mov	r24, r9
    7a8a:	90 e0       	ldi	r25, 0x00	; 0
    7a8c:	aa 24       	eor	r10, r10
    7a8e:	bb 24       	eor	r11, r11
    7a90:	a8 1a       	sub	r10, r24
    7a92:	b9 0a       	sbc	r11, r25
    7a94:	5f ef       	ldi	r21, 0xFF	; 255
    7a96:	0f 3f       	cpi	r16, 0xFF	; 255
    7a98:	15 07       	cpc	r17, r21
    7a9a:	29 f4       	brne	.+10     	; 0x7aa6 <vfprintf+0x394>
    7a9c:	8e e2       	ldi	r24, 0x2E	; 46
    7a9e:	90 e0       	ldi	r25, 0x00	; 0
    7aa0:	b3 01       	movw	r22, r6
    7aa2:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7aa6:	c0 16       	cp	r12, r16
    7aa8:	d1 06       	cpc	r13, r17
    7aaa:	34 f0       	brlt	.+12     	; 0x7ab8 <vfprintf+0x3a6>
    7aac:	40 16       	cp	r4, r16
    7aae:	51 06       	cpc	r5, r17
    7ab0:	1c f4       	brge	.+6      	; 0x7ab8 <vfprintf+0x3a6>
    7ab2:	f7 01       	movw	r30, r14
    7ab4:	80 81       	ld	r24, Z
    7ab6:	01 c0       	rjmp	.+2      	; 0x7aba <vfprintf+0x3a8>
    7ab8:	80 e3       	ldi	r24, 0x30	; 48
    7aba:	01 50       	subi	r16, 0x01	; 1
    7abc:	10 40       	sbci	r17, 0x00	; 0
    7abe:	08 94       	sec
    7ac0:	e1 1c       	adc	r14, r1
    7ac2:	f1 1c       	adc	r15, r1
    7ac4:	0a 15       	cp	r16, r10
    7ac6:	1b 05       	cpc	r17, r11
    7ac8:	2c f0       	brlt	.+10     	; 0x7ad4 <vfprintf+0x3c2>
    7aca:	90 e0       	ldi	r25, 0x00	; 0
    7acc:	b3 01       	movw	r22, r6
    7ace:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7ad2:	e0 cf       	rjmp	.-64     	; 0x7a94 <vfprintf+0x382>
    7ad4:	0c 15       	cp	r16, r12
    7ad6:	1d 05       	cpc	r17, r13
    7ad8:	39 f4       	brne	.+14     	; 0x7ae8 <vfprintf+0x3d6>
    7ada:	9a 81       	ldd	r25, Y+2	; 0x02
    7adc:	96 33       	cpi	r25, 0x36	; 54
    7ade:	18 f4       	brcc	.+6      	; 0x7ae6 <vfprintf+0x3d4>
    7ae0:	95 33       	cpi	r25, 0x35	; 53
    7ae2:	11 f4       	brne	.+4      	; 0x7ae8 <vfprintf+0x3d6>
    7ae4:	24 fe       	sbrs	r2, 4
    7ae6:	81 e3       	ldi	r24, 0x31	; 49
    7ae8:	90 e0       	ldi	r25, 0x00	; 0
    7aea:	4b c0       	rjmp	.+150    	; 0x7b82 <vfprintf+0x470>
    7aec:	8a 81       	ldd	r24, Y+2	; 0x02
    7aee:	81 33       	cpi	r24, 0x31	; 49
    7af0:	09 f0       	breq	.+2      	; 0x7af4 <vfprintf+0x3e2>
    7af2:	0f 7e       	andi	r16, 0xEF	; 239
    7af4:	90 e0       	ldi	r25, 0x00	; 0
    7af6:	b3 01       	movw	r22, r6
    7af8:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7afc:	99 20       	and	r9, r9
    7afe:	a1 f0       	breq	.+40     	; 0x7b28 <vfprintf+0x416>
    7b00:	8e e2       	ldi	r24, 0x2E	; 46
    7b02:	90 e0       	ldi	r25, 0x00	; 0
    7b04:	b3 01       	movw	r22, r6
    7b06:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7b0a:	12 e0       	ldi	r17, 0x02	; 2
    7b0c:	e1 e0       	ldi	r30, 0x01	; 1
    7b0e:	f0 e0       	ldi	r31, 0x00	; 0
    7b10:	ec 0f       	add	r30, r28
    7b12:	fd 1f       	adc	r31, r29
    7b14:	e1 0f       	add	r30, r17
    7b16:	f1 1d       	adc	r31, r1
    7b18:	1f 5f       	subi	r17, 0xFF	; 255
    7b1a:	80 81       	ld	r24, Z
    7b1c:	90 e0       	ldi	r25, 0x00	; 0
    7b1e:	b3 01       	movw	r22, r6
    7b20:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7b24:	9a 94       	dec	r9
    7b26:	91 f7       	brne	.-28     	; 0x7b0c <vfprintf+0x3fa>
    7b28:	44 fc       	sbrc	r4, 4
    7b2a:	03 c0       	rjmp	.+6      	; 0x7b32 <vfprintf+0x420>
    7b2c:	85 e6       	ldi	r24, 0x65	; 101
    7b2e:	90 e0       	ldi	r25, 0x00	; 0
    7b30:	02 c0       	rjmp	.+4      	; 0x7b36 <vfprintf+0x424>
    7b32:	85 e4       	ldi	r24, 0x45	; 69
    7b34:	90 e0       	ldi	r25, 0x00	; 0
    7b36:	b3 01       	movw	r22, r6
    7b38:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7b3c:	d7 fc       	sbrc	r13, 7
    7b3e:	05 c0       	rjmp	.+10     	; 0x7b4a <vfprintf+0x438>
    7b40:	c1 14       	cp	r12, r1
    7b42:	d1 04       	cpc	r13, r1
    7b44:	41 f4       	brne	.+16     	; 0x7b56 <vfprintf+0x444>
    7b46:	04 ff       	sbrs	r16, 4
    7b48:	06 c0       	rjmp	.+12     	; 0x7b56 <vfprintf+0x444>
    7b4a:	d0 94       	com	r13
    7b4c:	c1 94       	neg	r12
    7b4e:	d1 08       	sbc	r13, r1
    7b50:	d3 94       	inc	r13
    7b52:	8d e2       	ldi	r24, 0x2D	; 45
    7b54:	01 c0       	rjmp	.+2      	; 0x7b58 <vfprintf+0x446>
    7b56:	8b e2       	ldi	r24, 0x2B	; 43
    7b58:	90 e0       	ldi	r25, 0x00	; 0
    7b5a:	b3 01       	movw	r22, r6
    7b5c:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7b60:	80 e3       	ldi	r24, 0x30	; 48
    7b62:	05 c0       	rjmp	.+10     	; 0x7b6e <vfprintf+0x45c>
    7b64:	8f 5f       	subi	r24, 0xFF	; 255
    7b66:	26 ef       	ldi	r18, 0xF6	; 246
    7b68:	3f ef       	ldi	r19, 0xFF	; 255
    7b6a:	c2 0e       	add	r12, r18
    7b6c:	d3 1e       	adc	r13, r19
    7b6e:	3a e0       	ldi	r19, 0x0A	; 10
    7b70:	c3 16       	cp	r12, r19
    7b72:	d1 04       	cpc	r13, r1
    7b74:	bc f7       	brge	.-18     	; 0x7b64 <vfprintf+0x452>
    7b76:	90 e0       	ldi	r25, 0x00	; 0
    7b78:	b3 01       	movw	r22, r6
    7b7a:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7b7e:	c6 01       	movw	r24, r12
    7b80:	c0 96       	adiw	r24, 0x30	; 48
    7b82:	b3 01       	movw	r22, r6
    7b84:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7b88:	cc 84       	ldd	r12, Y+12	; 0x0c
    7b8a:	dd 84       	ldd	r13, Y+13	; 0x0d
    7b8c:	52 c1       	rjmp	.+676    	; 0x7e32 <vfprintf+0x720>
    7b8e:	93 36       	cpi	r25, 0x63	; 99
    7b90:	31 f0       	breq	.+12     	; 0x7b9e <vfprintf+0x48c>
    7b92:	93 37       	cpi	r25, 0x73	; 115
    7b94:	99 f0       	breq	.+38     	; 0x7bbc <vfprintf+0x4aa>
    7b96:	93 35       	cpi	r25, 0x53	; 83
    7b98:	09 f0       	breq	.+2      	; 0x7b9c <vfprintf+0x48a>
    7b9a:	59 c0       	rjmp	.+178    	; 0x7c4e <vfprintf+0x53c>
    7b9c:	23 c0       	rjmp	.+70     	; 0x7be4 <vfprintf+0x4d2>
    7b9e:	f6 01       	movw	r30, r12
    7ba0:	80 81       	ld	r24, Z
    7ba2:	89 83       	std	Y+1, r24	; 0x01
    7ba4:	5e 01       	movw	r10, r28
    7ba6:	08 94       	sec
    7ba8:	a1 1c       	adc	r10, r1
    7baa:	b1 1c       	adc	r11, r1
    7bac:	22 e0       	ldi	r18, 0x02	; 2
    7bae:	30 e0       	ldi	r19, 0x00	; 0
    7bb0:	c2 0e       	add	r12, r18
    7bb2:	d3 1e       	adc	r13, r19
    7bb4:	21 e0       	ldi	r18, 0x01	; 1
    7bb6:	e2 2e       	mov	r14, r18
    7bb8:	f1 2c       	mov	r15, r1
    7bba:	12 c0       	rjmp	.+36     	; 0x7be0 <vfprintf+0x4ce>
    7bbc:	f6 01       	movw	r30, r12
    7bbe:	a0 80       	ld	r10, Z
    7bc0:	b1 80       	ldd	r11, Z+1	; 0x01
    7bc2:	16 fd       	sbrc	r17, 6
    7bc4:	03 c0       	rjmp	.+6      	; 0x7bcc <vfprintf+0x4ba>
    7bc6:	6f ef       	ldi	r22, 0xFF	; 255
    7bc8:	7f ef       	ldi	r23, 0xFF	; 255
    7bca:	02 c0       	rjmp	.+4      	; 0x7bd0 <vfprintf+0x4be>
    7bcc:	69 2d       	mov	r22, r9
    7bce:	70 e0       	ldi	r23, 0x00	; 0
    7bd0:	22 e0       	ldi	r18, 0x02	; 2
    7bd2:	30 e0       	ldi	r19, 0x00	; 0
    7bd4:	c2 0e       	add	r12, r18
    7bd6:	d3 1e       	adc	r13, r19
    7bd8:	c5 01       	movw	r24, r10
    7bda:	0e 94 4b 45 	call	0x8a96	; 0x8a96 <strnlen>
    7bde:	7c 01       	movw	r14, r24
    7be0:	1f 77       	andi	r17, 0x7F	; 127
    7be2:	13 c0       	rjmp	.+38     	; 0x7c0a <vfprintf+0x4f8>
    7be4:	f6 01       	movw	r30, r12
    7be6:	a0 80       	ld	r10, Z
    7be8:	b1 80       	ldd	r11, Z+1	; 0x01
    7bea:	16 fd       	sbrc	r17, 6
    7bec:	03 c0       	rjmp	.+6      	; 0x7bf4 <vfprintf+0x4e2>
    7bee:	6f ef       	ldi	r22, 0xFF	; 255
    7bf0:	7f ef       	ldi	r23, 0xFF	; 255
    7bf2:	02 c0       	rjmp	.+4      	; 0x7bf8 <vfprintf+0x4e6>
    7bf4:	69 2d       	mov	r22, r9
    7bf6:	70 e0       	ldi	r23, 0x00	; 0
    7bf8:	22 e0       	ldi	r18, 0x02	; 2
    7bfa:	30 e0       	ldi	r19, 0x00	; 0
    7bfc:	c2 0e       	add	r12, r18
    7bfe:	d3 1e       	adc	r13, r19
    7c00:	c5 01       	movw	r24, r10
    7c02:	0e 94 2b 45 	call	0x8a56	; 0x8a56 <strnlen_P>
    7c06:	7c 01       	movw	r14, r24
    7c08:	10 68       	ori	r17, 0x80	; 128
    7c0a:	13 ff       	sbrs	r17, 3
    7c0c:	07 c0       	rjmp	.+14     	; 0x7c1c <vfprintf+0x50a>
    7c0e:	1b c0       	rjmp	.+54     	; 0x7c46 <vfprintf+0x534>
    7c10:	80 e2       	ldi	r24, 0x20	; 32
    7c12:	90 e0       	ldi	r25, 0x00	; 0
    7c14:	b3 01       	movw	r22, r6
    7c16:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7c1a:	8a 94       	dec	r8
    7c1c:	88 2d       	mov	r24, r8
    7c1e:	90 e0       	ldi	r25, 0x00	; 0
    7c20:	e8 16       	cp	r14, r24
    7c22:	f9 06       	cpc	r15, r25
    7c24:	a8 f3       	brcs	.-22     	; 0x7c10 <vfprintf+0x4fe>
    7c26:	0f c0       	rjmp	.+30     	; 0x7c46 <vfprintf+0x534>
    7c28:	f5 01       	movw	r30, r10
    7c2a:	17 fd       	sbrc	r17, 7
    7c2c:	85 91       	lpm	r24, Z+
    7c2e:	17 ff       	sbrs	r17, 7
    7c30:	81 91       	ld	r24, Z+
    7c32:	5f 01       	movw	r10, r30
    7c34:	90 e0       	ldi	r25, 0x00	; 0
    7c36:	b3 01       	movw	r22, r6
    7c38:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7c3c:	81 10       	cpse	r8, r1
    7c3e:	8a 94       	dec	r8
    7c40:	08 94       	sec
    7c42:	e1 08       	sbc	r14, r1
    7c44:	f1 08       	sbc	r15, r1
    7c46:	e1 14       	cp	r14, r1
    7c48:	f1 04       	cpc	r15, r1
    7c4a:	71 f7       	brne	.-36     	; 0x7c28 <vfprintf+0x516>
    7c4c:	f2 c0       	rjmp	.+484    	; 0x7e32 <vfprintf+0x720>
    7c4e:	94 36       	cpi	r25, 0x64	; 100
    7c50:	11 f0       	breq	.+4      	; 0x7c56 <vfprintf+0x544>
    7c52:	99 36       	cpi	r25, 0x69	; 105
    7c54:	89 f5       	brne	.+98     	; 0x7cb8 <vfprintf+0x5a6>
    7c56:	17 ff       	sbrs	r17, 7
    7c58:	08 c0       	rjmp	.+16     	; 0x7c6a <vfprintf+0x558>
    7c5a:	f6 01       	movw	r30, r12
    7c5c:	20 81       	ld	r18, Z
    7c5e:	31 81       	ldd	r19, Z+1	; 0x01
    7c60:	42 81       	ldd	r20, Z+2	; 0x02
    7c62:	53 81       	ldd	r21, Z+3	; 0x03
    7c64:	84 e0       	ldi	r24, 0x04	; 4
    7c66:	90 e0       	ldi	r25, 0x00	; 0
    7c68:	0a c0       	rjmp	.+20     	; 0x7c7e <vfprintf+0x56c>
    7c6a:	f6 01       	movw	r30, r12
    7c6c:	80 81       	ld	r24, Z
    7c6e:	91 81       	ldd	r25, Z+1	; 0x01
    7c70:	9c 01       	movw	r18, r24
    7c72:	44 27       	eor	r20, r20
    7c74:	37 fd       	sbrc	r19, 7
    7c76:	40 95       	com	r20
    7c78:	54 2f       	mov	r21, r20
    7c7a:	82 e0       	ldi	r24, 0x02	; 2
    7c7c:	90 e0       	ldi	r25, 0x00	; 0
    7c7e:	c8 0e       	add	r12, r24
    7c80:	d9 1e       	adc	r13, r25
    7c82:	9f e6       	ldi	r25, 0x6F	; 111
    7c84:	f9 2e       	mov	r15, r25
    7c86:	f1 22       	and	r15, r17
    7c88:	57 ff       	sbrs	r21, 7
    7c8a:	09 c0       	rjmp	.+18     	; 0x7c9e <vfprintf+0x58c>
    7c8c:	50 95       	com	r21
    7c8e:	40 95       	com	r20
    7c90:	30 95       	com	r19
    7c92:	21 95       	neg	r18
    7c94:	3f 4f       	sbci	r19, 0xFF	; 255
    7c96:	4f 4f       	sbci	r20, 0xFF	; 255
    7c98:	5f 4f       	sbci	r21, 0xFF	; 255
    7c9a:	90 e8       	ldi	r25, 0x80	; 128
    7c9c:	f9 2a       	or	r15, r25
    7c9e:	ca 01       	movw	r24, r20
    7ca0:	b9 01       	movw	r22, r18
    7ca2:	ae 01       	movw	r20, r28
    7ca4:	4f 5f       	subi	r20, 0xFF	; 255
    7ca6:	5f 4f       	sbci	r21, 0xFF	; 255
    7ca8:	2a e0       	ldi	r18, 0x0A	; 10
    7caa:	30 e0       	ldi	r19, 0x00	; 0
    7cac:	0e 94 e2 45 	call	0x8bc4	; 0x8bc4 <__ultoa_invert>
    7cb0:	e8 2e       	mov	r14, r24
    7cb2:	e8 89       	ldd	r30, Y+16	; 0x10
    7cb4:	ee 1a       	sub	r14, r30
    7cb6:	41 c0       	rjmp	.+130    	; 0x7d3a <vfprintf+0x628>
    7cb8:	95 37       	cpi	r25, 0x75	; 117
    7cba:	21 f4       	brne	.+8      	; 0x7cc4 <vfprintf+0x5b2>
    7cbc:	1f 7e       	andi	r17, 0xEF	; 239
    7cbe:	2a e0       	ldi	r18, 0x0A	; 10
    7cc0:	30 e0       	ldi	r19, 0x00	; 0
    7cc2:	1c c0       	rjmp	.+56     	; 0x7cfc <vfprintf+0x5ea>
    7cc4:	19 7f       	andi	r17, 0xF9	; 249
    7cc6:	9f 36       	cpi	r25, 0x6F	; 111
    7cc8:	61 f0       	breq	.+24     	; 0x7ce2 <vfprintf+0x5d0>
    7cca:	90 37       	cpi	r25, 0x70	; 112
    7ccc:	20 f4       	brcc	.+8      	; 0x7cd6 <vfprintf+0x5c4>
    7cce:	98 35       	cpi	r25, 0x58	; 88
    7cd0:	09 f0       	breq	.+2      	; 0x7cd4 <vfprintf+0x5c2>
    7cd2:	b2 c0       	rjmp	.+356    	; 0x7e38 <vfprintf+0x726>
    7cd4:	0f c0       	rjmp	.+30     	; 0x7cf4 <vfprintf+0x5e2>
    7cd6:	90 37       	cpi	r25, 0x70	; 112
    7cd8:	39 f0       	breq	.+14     	; 0x7ce8 <vfprintf+0x5d6>
    7cda:	98 37       	cpi	r25, 0x78	; 120
    7cdc:	09 f0       	breq	.+2      	; 0x7ce0 <vfprintf+0x5ce>
    7cde:	ac c0       	rjmp	.+344    	; 0x7e38 <vfprintf+0x726>
    7ce0:	04 c0       	rjmp	.+8      	; 0x7cea <vfprintf+0x5d8>
    7ce2:	28 e0       	ldi	r18, 0x08	; 8
    7ce4:	30 e0       	ldi	r19, 0x00	; 0
    7ce6:	0a c0       	rjmp	.+20     	; 0x7cfc <vfprintf+0x5ea>
    7ce8:	10 61       	ori	r17, 0x10	; 16
    7cea:	14 fd       	sbrc	r17, 4
    7cec:	14 60       	ori	r17, 0x04	; 4
    7cee:	20 e1       	ldi	r18, 0x10	; 16
    7cf0:	30 e0       	ldi	r19, 0x00	; 0
    7cf2:	04 c0       	rjmp	.+8      	; 0x7cfc <vfprintf+0x5ea>
    7cf4:	14 fd       	sbrc	r17, 4
    7cf6:	16 60       	ori	r17, 0x06	; 6
    7cf8:	20 e1       	ldi	r18, 0x10	; 16
    7cfa:	32 e0       	ldi	r19, 0x02	; 2
    7cfc:	17 ff       	sbrs	r17, 7
    7cfe:	08 c0       	rjmp	.+16     	; 0x7d10 <vfprintf+0x5fe>
    7d00:	f6 01       	movw	r30, r12
    7d02:	60 81       	ld	r22, Z
    7d04:	71 81       	ldd	r23, Z+1	; 0x01
    7d06:	82 81       	ldd	r24, Z+2	; 0x02
    7d08:	93 81       	ldd	r25, Z+3	; 0x03
    7d0a:	44 e0       	ldi	r20, 0x04	; 4
    7d0c:	50 e0       	ldi	r21, 0x00	; 0
    7d0e:	08 c0       	rjmp	.+16     	; 0x7d20 <vfprintf+0x60e>
    7d10:	f6 01       	movw	r30, r12
    7d12:	80 81       	ld	r24, Z
    7d14:	91 81       	ldd	r25, Z+1	; 0x01
    7d16:	bc 01       	movw	r22, r24
    7d18:	80 e0       	ldi	r24, 0x00	; 0
    7d1a:	90 e0       	ldi	r25, 0x00	; 0
    7d1c:	42 e0       	ldi	r20, 0x02	; 2
    7d1e:	50 e0       	ldi	r21, 0x00	; 0
    7d20:	c4 0e       	add	r12, r20
    7d22:	d5 1e       	adc	r13, r21
    7d24:	ae 01       	movw	r20, r28
    7d26:	4f 5f       	subi	r20, 0xFF	; 255
    7d28:	5f 4f       	sbci	r21, 0xFF	; 255
    7d2a:	0e 94 e2 45 	call	0x8bc4	; 0x8bc4 <__ultoa_invert>
    7d2e:	e8 2e       	mov	r14, r24
    7d30:	58 89       	ldd	r21, Y+16	; 0x10
    7d32:	e5 1a       	sub	r14, r21
    7d34:	8f e7       	ldi	r24, 0x7F	; 127
    7d36:	f8 2e       	mov	r15, r24
    7d38:	f1 22       	and	r15, r17
    7d3a:	f6 fe       	sbrs	r15, 6
    7d3c:	0b c0       	rjmp	.+22     	; 0x7d54 <vfprintf+0x642>
    7d3e:	8e ef       	ldi	r24, 0xFE	; 254
    7d40:	f8 22       	and	r15, r24
    7d42:	e9 14       	cp	r14, r9
    7d44:	38 f4       	brcc	.+14     	; 0x7d54 <vfprintf+0x642>
    7d46:	f4 fe       	sbrs	r15, 4
    7d48:	07 c0       	rjmp	.+14     	; 0x7d58 <vfprintf+0x646>
    7d4a:	f2 fc       	sbrc	r15, 2
    7d4c:	05 c0       	rjmp	.+10     	; 0x7d58 <vfprintf+0x646>
    7d4e:	9f ee       	ldi	r25, 0xEF	; 239
    7d50:	f9 22       	and	r15, r25
    7d52:	02 c0       	rjmp	.+4      	; 0x7d58 <vfprintf+0x646>
    7d54:	1e 2d       	mov	r17, r14
    7d56:	01 c0       	rjmp	.+2      	; 0x7d5a <vfprintf+0x648>
    7d58:	19 2d       	mov	r17, r9
    7d5a:	f4 fe       	sbrs	r15, 4
    7d5c:	0d c0       	rjmp	.+26     	; 0x7d78 <vfprintf+0x666>
    7d5e:	fe 01       	movw	r30, r28
    7d60:	ee 0d       	add	r30, r14
    7d62:	f1 1d       	adc	r31, r1
    7d64:	80 81       	ld	r24, Z
    7d66:	80 33       	cpi	r24, 0x30	; 48
    7d68:	19 f4       	brne	.+6      	; 0x7d70 <vfprintf+0x65e>
    7d6a:	e9 ee       	ldi	r30, 0xE9	; 233
    7d6c:	fe 22       	and	r15, r30
    7d6e:	08 c0       	rjmp	.+16     	; 0x7d80 <vfprintf+0x66e>
    7d70:	1f 5f       	subi	r17, 0xFF	; 255
    7d72:	f2 fe       	sbrs	r15, 2
    7d74:	05 c0       	rjmp	.+10     	; 0x7d80 <vfprintf+0x66e>
    7d76:	03 c0       	rjmp	.+6      	; 0x7d7e <vfprintf+0x66c>
    7d78:	8f 2d       	mov	r24, r15
    7d7a:	86 78       	andi	r24, 0x86	; 134
    7d7c:	09 f0       	breq	.+2      	; 0x7d80 <vfprintf+0x66e>
    7d7e:	1f 5f       	subi	r17, 0xFF	; 255
    7d80:	0f 2d       	mov	r16, r15
    7d82:	f3 fc       	sbrc	r15, 3
    7d84:	14 c0       	rjmp	.+40     	; 0x7dae <vfprintf+0x69c>
    7d86:	f0 fe       	sbrs	r15, 0
    7d88:	0f c0       	rjmp	.+30     	; 0x7da8 <vfprintf+0x696>
    7d8a:	18 15       	cp	r17, r8
    7d8c:	10 f0       	brcs	.+4      	; 0x7d92 <vfprintf+0x680>
    7d8e:	9e 2c       	mov	r9, r14
    7d90:	0b c0       	rjmp	.+22     	; 0x7da8 <vfprintf+0x696>
    7d92:	9e 2c       	mov	r9, r14
    7d94:	98 0c       	add	r9, r8
    7d96:	91 1a       	sub	r9, r17
    7d98:	18 2d       	mov	r17, r8
    7d9a:	06 c0       	rjmp	.+12     	; 0x7da8 <vfprintf+0x696>
    7d9c:	80 e2       	ldi	r24, 0x20	; 32
    7d9e:	90 e0       	ldi	r25, 0x00	; 0
    7da0:	b3 01       	movw	r22, r6
    7da2:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7da6:	1f 5f       	subi	r17, 0xFF	; 255
    7da8:	18 15       	cp	r17, r8
    7daa:	c0 f3       	brcs	.-16     	; 0x7d9c <vfprintf+0x68a>
    7dac:	04 c0       	rjmp	.+8      	; 0x7db6 <vfprintf+0x6a4>
    7dae:	18 15       	cp	r17, r8
    7db0:	10 f4       	brcc	.+4      	; 0x7db6 <vfprintf+0x6a4>
    7db2:	81 1a       	sub	r8, r17
    7db4:	01 c0       	rjmp	.+2      	; 0x7db8 <vfprintf+0x6a6>
    7db6:	88 24       	eor	r8, r8
    7db8:	04 ff       	sbrs	r16, 4
    7dba:	0f c0       	rjmp	.+30     	; 0x7dda <vfprintf+0x6c8>
    7dbc:	80 e3       	ldi	r24, 0x30	; 48
    7dbe:	90 e0       	ldi	r25, 0x00	; 0
    7dc0:	b3 01       	movw	r22, r6
    7dc2:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7dc6:	02 ff       	sbrs	r16, 2
    7dc8:	1d c0       	rjmp	.+58     	; 0x7e04 <vfprintf+0x6f2>
    7dca:	01 fd       	sbrc	r16, 1
    7dcc:	03 c0       	rjmp	.+6      	; 0x7dd4 <vfprintf+0x6c2>
    7dce:	88 e7       	ldi	r24, 0x78	; 120
    7dd0:	90 e0       	ldi	r25, 0x00	; 0
    7dd2:	0e c0       	rjmp	.+28     	; 0x7df0 <vfprintf+0x6de>
    7dd4:	88 e5       	ldi	r24, 0x58	; 88
    7dd6:	90 e0       	ldi	r25, 0x00	; 0
    7dd8:	0b c0       	rjmp	.+22     	; 0x7df0 <vfprintf+0x6de>
    7dda:	80 2f       	mov	r24, r16
    7ddc:	86 78       	andi	r24, 0x86	; 134
    7dde:	91 f0       	breq	.+36     	; 0x7e04 <vfprintf+0x6f2>
    7de0:	01 ff       	sbrs	r16, 1
    7de2:	02 c0       	rjmp	.+4      	; 0x7de8 <vfprintf+0x6d6>
    7de4:	8b e2       	ldi	r24, 0x2B	; 43
    7de6:	01 c0       	rjmp	.+2      	; 0x7dea <vfprintf+0x6d8>
    7de8:	80 e2       	ldi	r24, 0x20	; 32
    7dea:	f7 fc       	sbrc	r15, 7
    7dec:	8d e2       	ldi	r24, 0x2D	; 45
    7dee:	90 e0       	ldi	r25, 0x00	; 0
    7df0:	b3 01       	movw	r22, r6
    7df2:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7df6:	06 c0       	rjmp	.+12     	; 0x7e04 <vfprintf+0x6f2>
    7df8:	80 e3       	ldi	r24, 0x30	; 48
    7dfa:	90 e0       	ldi	r25, 0x00	; 0
    7dfc:	b3 01       	movw	r22, r6
    7dfe:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7e02:	9a 94       	dec	r9
    7e04:	e9 14       	cp	r14, r9
    7e06:	c0 f3       	brcs	.-16     	; 0x7df8 <vfprintf+0x6e6>
    7e08:	ea 94       	dec	r14
    7e0a:	e1 e0       	ldi	r30, 0x01	; 1
    7e0c:	f0 e0       	ldi	r31, 0x00	; 0
    7e0e:	ec 0f       	add	r30, r28
    7e10:	fd 1f       	adc	r31, r29
    7e12:	ee 0d       	add	r30, r14
    7e14:	f1 1d       	adc	r31, r1
    7e16:	80 81       	ld	r24, Z
    7e18:	90 e0       	ldi	r25, 0x00	; 0
    7e1a:	b3 01       	movw	r22, r6
    7e1c:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7e20:	ee 20       	and	r14, r14
    7e22:	91 f7       	brne	.-28     	; 0x7e08 <vfprintf+0x6f6>
    7e24:	06 c0       	rjmp	.+12     	; 0x7e32 <vfprintf+0x720>
    7e26:	80 e2       	ldi	r24, 0x20	; 32
    7e28:	90 e0       	ldi	r25, 0x00	; 0
    7e2a:	b3 01       	movw	r22, r6
    7e2c:	0e 94 85 45 	call	0x8b0a	; 0x8b0a <fputc>
    7e30:	8a 94       	dec	r8
    7e32:	88 20       	and	r8, r8
    7e34:	c1 f7       	brne	.-16     	; 0x7e26 <vfprintf+0x714>
    7e36:	99 cc       	rjmp	.-1742   	; 0x776a <vfprintf+0x58>
    7e38:	f3 01       	movw	r30, r6
    7e3a:	66 81       	ldd	r22, Z+6	; 0x06
    7e3c:	77 81       	ldd	r23, Z+7	; 0x07
    7e3e:	cb 01       	movw	r24, r22
    7e40:	61 96       	adiw	r28, 0x11	; 17
    7e42:	0f b6       	in	r0, 0x3f	; 63
    7e44:	f8 94       	cli
    7e46:	de bf       	out	0x3e, r29	; 62
    7e48:	0f be       	out	0x3f, r0	; 63
    7e4a:	cd bf       	out	0x3d, r28	; 61
    7e4c:	cf 91       	pop	r28
    7e4e:	df 91       	pop	r29
    7e50:	1f 91       	pop	r17
    7e52:	0f 91       	pop	r16
    7e54:	ff 90       	pop	r15
    7e56:	ef 90       	pop	r14
    7e58:	df 90       	pop	r13
    7e5a:	cf 90       	pop	r12
    7e5c:	bf 90       	pop	r11
    7e5e:	af 90       	pop	r10
    7e60:	9f 90       	pop	r9
    7e62:	8f 90       	pop	r8
    7e64:	7f 90       	pop	r7
    7e66:	6f 90       	pop	r6
    7e68:	5f 90       	pop	r5
    7e6a:	4f 90       	pop	r4
    7e6c:	3f 90       	pop	r3
    7e6e:	2f 90       	pop	r2
    7e70:	08 95       	ret

00007e72 <__subsf3>:
    7e72:	50 58       	subi	r21, 0x80	; 128

00007e74 <__addsf3>:
    7e74:	bb 27       	eor	r27, r27
    7e76:	aa 27       	eor	r26, r26
    7e78:	0e d0       	rcall	.+28     	; 0x7e96 <__addsf3x>
    7e7a:	b1 c1       	rjmp	.+866    	; 0x81de <__fp_round>
    7e7c:	a2 d1       	rcall	.+836    	; 0x81c2 <__fp_pscA>
    7e7e:	30 f0       	brcs	.+12     	; 0x7e8c <__addsf3+0x18>
    7e80:	a7 d1       	rcall	.+846    	; 0x81d0 <__fp_pscB>
    7e82:	20 f0       	brcs	.+8      	; 0x7e8c <__addsf3+0x18>
    7e84:	31 f4       	brne	.+12     	; 0x7e92 <__addsf3+0x1e>
    7e86:	9f 3f       	cpi	r25, 0xFF	; 255
    7e88:	11 f4       	brne	.+4      	; 0x7e8e <__addsf3+0x1a>
    7e8a:	1e f4       	brtc	.+6      	; 0x7e92 <__addsf3+0x1e>
    7e8c:	97 c1       	rjmp	.+814    	; 0x81bc <__fp_nan>
    7e8e:	0e f4       	brtc	.+2      	; 0x7e92 <__addsf3+0x1e>
    7e90:	e0 95       	com	r30
    7e92:	e7 fb       	bst	r30, 7
    7e94:	64 c1       	rjmp	.+712    	; 0x815e <__fp_inf>

00007e96 <__addsf3x>:
    7e96:	e9 2f       	mov	r30, r25
    7e98:	b3 d1       	rcall	.+870    	; 0x8200 <__fp_split3>
    7e9a:	80 f3       	brcs	.-32     	; 0x7e7c <__addsf3+0x8>
    7e9c:	ba 17       	cp	r27, r26
    7e9e:	62 07       	cpc	r22, r18
    7ea0:	73 07       	cpc	r23, r19
    7ea2:	84 07       	cpc	r24, r20
    7ea4:	95 07       	cpc	r25, r21
    7ea6:	18 f0       	brcs	.+6      	; 0x7eae <__addsf3x+0x18>
    7ea8:	71 f4       	brne	.+28     	; 0x7ec6 <__addsf3x+0x30>
    7eaa:	9e f5       	brtc	.+102    	; 0x7f12 <__addsf3x+0x7c>
    7eac:	e2 c1       	rjmp	.+964    	; 0x8272 <__fp_zero>
    7eae:	0e f4       	brtc	.+2      	; 0x7eb2 <__addsf3x+0x1c>
    7eb0:	e0 95       	com	r30
    7eb2:	0b 2e       	mov	r0, r27
    7eb4:	ba 2f       	mov	r27, r26
    7eb6:	a0 2d       	mov	r26, r0
    7eb8:	0b 01       	movw	r0, r22
    7eba:	b9 01       	movw	r22, r18
    7ebc:	90 01       	movw	r18, r0
    7ebe:	0c 01       	movw	r0, r24
    7ec0:	ca 01       	movw	r24, r20
    7ec2:	a0 01       	movw	r20, r0
    7ec4:	11 24       	eor	r1, r1
    7ec6:	ff 27       	eor	r31, r31
    7ec8:	59 1b       	sub	r21, r25
    7eca:	99 f0       	breq	.+38     	; 0x7ef2 <__addsf3x+0x5c>
    7ecc:	59 3f       	cpi	r21, 0xF9	; 249
    7ece:	50 f4       	brcc	.+20     	; 0x7ee4 <__addsf3x+0x4e>
    7ed0:	50 3e       	cpi	r21, 0xE0	; 224
    7ed2:	68 f1       	brcs	.+90     	; 0x7f2e <__addsf3x+0x98>
    7ed4:	1a 16       	cp	r1, r26
    7ed6:	f0 40       	sbci	r31, 0x00	; 0
    7ed8:	a2 2f       	mov	r26, r18
    7eda:	23 2f       	mov	r18, r19
    7edc:	34 2f       	mov	r19, r20
    7ede:	44 27       	eor	r20, r20
    7ee0:	58 5f       	subi	r21, 0xF8	; 248
    7ee2:	f3 cf       	rjmp	.-26     	; 0x7eca <__addsf3x+0x34>
    7ee4:	46 95       	lsr	r20
    7ee6:	37 95       	ror	r19
    7ee8:	27 95       	ror	r18
    7eea:	a7 95       	ror	r26
    7eec:	f0 40       	sbci	r31, 0x00	; 0
    7eee:	53 95       	inc	r21
    7ef0:	c9 f7       	brne	.-14     	; 0x7ee4 <__addsf3x+0x4e>
    7ef2:	7e f4       	brtc	.+30     	; 0x7f12 <__addsf3x+0x7c>
    7ef4:	1f 16       	cp	r1, r31
    7ef6:	ba 0b       	sbc	r27, r26
    7ef8:	62 0b       	sbc	r22, r18
    7efa:	73 0b       	sbc	r23, r19
    7efc:	84 0b       	sbc	r24, r20
    7efe:	ba f0       	brmi	.+46     	; 0x7f2e <__addsf3x+0x98>
    7f00:	91 50       	subi	r25, 0x01	; 1
    7f02:	a1 f0       	breq	.+40     	; 0x7f2c <__addsf3x+0x96>
    7f04:	ff 0f       	add	r31, r31
    7f06:	bb 1f       	adc	r27, r27
    7f08:	66 1f       	adc	r22, r22
    7f0a:	77 1f       	adc	r23, r23
    7f0c:	88 1f       	adc	r24, r24
    7f0e:	c2 f7       	brpl	.-16     	; 0x7f00 <__addsf3x+0x6a>
    7f10:	0e c0       	rjmp	.+28     	; 0x7f2e <__addsf3x+0x98>
    7f12:	ba 0f       	add	r27, r26
    7f14:	62 1f       	adc	r22, r18
    7f16:	73 1f       	adc	r23, r19
    7f18:	84 1f       	adc	r24, r20
    7f1a:	48 f4       	brcc	.+18     	; 0x7f2e <__addsf3x+0x98>
    7f1c:	87 95       	ror	r24
    7f1e:	77 95       	ror	r23
    7f20:	67 95       	ror	r22
    7f22:	b7 95       	ror	r27
    7f24:	f7 95       	ror	r31
    7f26:	9e 3f       	cpi	r25, 0xFE	; 254
    7f28:	08 f0       	brcs	.+2      	; 0x7f2c <__addsf3x+0x96>
    7f2a:	b3 cf       	rjmp	.-154    	; 0x7e92 <__addsf3+0x1e>
    7f2c:	93 95       	inc	r25
    7f2e:	88 0f       	add	r24, r24
    7f30:	08 f0       	brcs	.+2      	; 0x7f34 <__addsf3x+0x9e>
    7f32:	99 27       	eor	r25, r25
    7f34:	ee 0f       	add	r30, r30
    7f36:	97 95       	ror	r25
    7f38:	87 95       	ror	r24
    7f3a:	08 95       	ret

00007f3c <__cmpsf2>:
    7f3c:	ec d0       	rcall	.+472    	; 0x8116 <__fp_cmp>
    7f3e:	08 f4       	brcc	.+2      	; 0x7f42 <__cmpsf2+0x6>
    7f40:	81 e0       	ldi	r24, 0x01	; 1
    7f42:	08 95       	ret

00007f44 <__divsf3>:
    7f44:	0c d0       	rcall	.+24     	; 0x7f5e <__divsf3x>
    7f46:	4b c1       	rjmp	.+662    	; 0x81de <__fp_round>
    7f48:	43 d1       	rcall	.+646    	; 0x81d0 <__fp_pscB>
    7f4a:	40 f0       	brcs	.+16     	; 0x7f5c <__divsf3+0x18>
    7f4c:	3a d1       	rcall	.+628    	; 0x81c2 <__fp_pscA>
    7f4e:	30 f0       	brcs	.+12     	; 0x7f5c <__divsf3+0x18>
    7f50:	21 f4       	brne	.+8      	; 0x7f5a <__divsf3+0x16>
    7f52:	5f 3f       	cpi	r21, 0xFF	; 255
    7f54:	19 f0       	breq	.+6      	; 0x7f5c <__divsf3+0x18>
    7f56:	03 c1       	rjmp	.+518    	; 0x815e <__fp_inf>
    7f58:	51 11       	cpse	r21, r1
    7f5a:	8c c1       	rjmp	.+792    	; 0x8274 <__fp_szero>
    7f5c:	2f c1       	rjmp	.+606    	; 0x81bc <__fp_nan>

00007f5e <__divsf3x>:
    7f5e:	50 d1       	rcall	.+672    	; 0x8200 <__fp_split3>
    7f60:	98 f3       	brcs	.-26     	; 0x7f48 <__divsf3+0x4>

00007f62 <__divsf3_pse>:
    7f62:	99 23       	and	r25, r25
    7f64:	c9 f3       	breq	.-14     	; 0x7f58 <__divsf3+0x14>
    7f66:	55 23       	and	r21, r21
    7f68:	b1 f3       	breq	.-20     	; 0x7f56 <__divsf3+0x12>
    7f6a:	95 1b       	sub	r25, r21
    7f6c:	55 0b       	sbc	r21, r21
    7f6e:	bb 27       	eor	r27, r27
    7f70:	aa 27       	eor	r26, r26
    7f72:	62 17       	cp	r22, r18
    7f74:	73 07       	cpc	r23, r19
    7f76:	84 07       	cpc	r24, r20
    7f78:	38 f0       	brcs	.+14     	; 0x7f88 <__divsf3_pse+0x26>
    7f7a:	9f 5f       	subi	r25, 0xFF	; 255
    7f7c:	5f 4f       	sbci	r21, 0xFF	; 255
    7f7e:	22 0f       	add	r18, r18
    7f80:	33 1f       	adc	r19, r19
    7f82:	44 1f       	adc	r20, r20
    7f84:	aa 1f       	adc	r26, r26
    7f86:	a9 f3       	breq	.-22     	; 0x7f72 <__divsf3_pse+0x10>
    7f88:	33 d0       	rcall	.+102    	; 0x7ff0 <__divsf3_pse+0x8e>
    7f8a:	0e 2e       	mov	r0, r30
    7f8c:	3a f0       	brmi	.+14     	; 0x7f9c <__divsf3_pse+0x3a>
    7f8e:	e0 e8       	ldi	r30, 0x80	; 128
    7f90:	30 d0       	rcall	.+96     	; 0x7ff2 <__divsf3_pse+0x90>
    7f92:	91 50       	subi	r25, 0x01	; 1
    7f94:	50 40       	sbci	r21, 0x00	; 0
    7f96:	e6 95       	lsr	r30
    7f98:	00 1c       	adc	r0, r0
    7f9a:	ca f7       	brpl	.-14     	; 0x7f8e <__divsf3_pse+0x2c>
    7f9c:	29 d0       	rcall	.+82     	; 0x7ff0 <__divsf3_pse+0x8e>
    7f9e:	fe 2f       	mov	r31, r30
    7fa0:	27 d0       	rcall	.+78     	; 0x7ff0 <__divsf3_pse+0x8e>
    7fa2:	66 0f       	add	r22, r22
    7fa4:	77 1f       	adc	r23, r23
    7fa6:	88 1f       	adc	r24, r24
    7fa8:	bb 1f       	adc	r27, r27
    7faa:	26 17       	cp	r18, r22
    7fac:	37 07       	cpc	r19, r23
    7fae:	48 07       	cpc	r20, r24
    7fb0:	ab 07       	cpc	r26, r27
    7fb2:	b0 e8       	ldi	r27, 0x80	; 128
    7fb4:	09 f0       	breq	.+2      	; 0x7fb8 <__divsf3_pse+0x56>
    7fb6:	bb 0b       	sbc	r27, r27
    7fb8:	80 2d       	mov	r24, r0
    7fba:	bf 01       	movw	r22, r30
    7fbc:	ff 27       	eor	r31, r31
    7fbe:	93 58       	subi	r25, 0x83	; 131
    7fc0:	5f 4f       	sbci	r21, 0xFF	; 255
    7fc2:	2a f0       	brmi	.+10     	; 0x7fce <__divsf3_pse+0x6c>
    7fc4:	9e 3f       	cpi	r25, 0xFE	; 254
    7fc6:	51 05       	cpc	r21, r1
    7fc8:	68 f0       	brcs	.+26     	; 0x7fe4 <__divsf3_pse+0x82>
    7fca:	c9 c0       	rjmp	.+402    	; 0x815e <__fp_inf>
    7fcc:	53 c1       	rjmp	.+678    	; 0x8274 <__fp_szero>
    7fce:	5f 3f       	cpi	r21, 0xFF	; 255
    7fd0:	ec f3       	brlt	.-6      	; 0x7fcc <__divsf3_pse+0x6a>
    7fd2:	98 3e       	cpi	r25, 0xE8	; 232
    7fd4:	dc f3       	brlt	.-10     	; 0x7fcc <__divsf3_pse+0x6a>
    7fd6:	86 95       	lsr	r24
    7fd8:	77 95       	ror	r23
    7fda:	67 95       	ror	r22
    7fdc:	b7 95       	ror	r27
    7fde:	f7 95       	ror	r31
    7fe0:	9f 5f       	subi	r25, 0xFF	; 255
    7fe2:	c9 f7       	brne	.-14     	; 0x7fd6 <__divsf3_pse+0x74>
    7fe4:	88 0f       	add	r24, r24
    7fe6:	91 1d       	adc	r25, r1
    7fe8:	96 95       	lsr	r25
    7fea:	87 95       	ror	r24
    7fec:	97 f9       	bld	r25, 7
    7fee:	08 95       	ret
    7ff0:	e1 e0       	ldi	r30, 0x01	; 1
    7ff2:	66 0f       	add	r22, r22
    7ff4:	77 1f       	adc	r23, r23
    7ff6:	88 1f       	adc	r24, r24
    7ff8:	bb 1f       	adc	r27, r27
    7ffa:	62 17       	cp	r22, r18
    7ffc:	73 07       	cpc	r23, r19
    7ffe:	84 07       	cpc	r24, r20
    8000:	ba 07       	cpc	r27, r26
    8002:	20 f0       	brcs	.+8      	; 0x800c <__divsf3_pse+0xaa>
    8004:	62 1b       	sub	r22, r18
    8006:	73 0b       	sbc	r23, r19
    8008:	84 0b       	sbc	r24, r20
    800a:	ba 0b       	sbc	r27, r26
    800c:	ee 1f       	adc	r30, r30
    800e:	88 f7       	brcc	.-30     	; 0x7ff2 <__divsf3_pse+0x90>
    8010:	e0 95       	com	r30
    8012:	08 95       	ret

00008014 <__fixsfsi>:
    8014:	04 d0       	rcall	.+8      	; 0x801e <__fixunssfsi>
    8016:	68 94       	set
    8018:	b1 11       	cpse	r27, r1
    801a:	2c c1       	rjmp	.+600    	; 0x8274 <__fp_szero>
    801c:	08 95       	ret

0000801e <__fixunssfsi>:
    801e:	f8 d0       	rcall	.+496    	; 0x8210 <__fp_splitA>
    8020:	88 f0       	brcs	.+34     	; 0x8044 <__fixunssfsi+0x26>
    8022:	9f 57       	subi	r25, 0x7F	; 127
    8024:	90 f0       	brcs	.+36     	; 0x804a <__fixunssfsi+0x2c>
    8026:	b9 2f       	mov	r27, r25
    8028:	99 27       	eor	r25, r25
    802a:	b7 51       	subi	r27, 0x17	; 23
    802c:	a0 f0       	brcs	.+40     	; 0x8056 <__fixunssfsi+0x38>
    802e:	d1 f0       	breq	.+52     	; 0x8064 <__fixunssfsi+0x46>
    8030:	66 0f       	add	r22, r22
    8032:	77 1f       	adc	r23, r23
    8034:	88 1f       	adc	r24, r24
    8036:	99 1f       	adc	r25, r25
    8038:	1a f0       	brmi	.+6      	; 0x8040 <__fixunssfsi+0x22>
    803a:	ba 95       	dec	r27
    803c:	c9 f7       	brne	.-14     	; 0x8030 <__fixunssfsi+0x12>
    803e:	12 c0       	rjmp	.+36     	; 0x8064 <__fixunssfsi+0x46>
    8040:	b1 30       	cpi	r27, 0x01	; 1
    8042:	81 f0       	breq	.+32     	; 0x8064 <__fixunssfsi+0x46>
    8044:	16 d1       	rcall	.+556    	; 0x8272 <__fp_zero>
    8046:	b1 e0       	ldi	r27, 0x01	; 1
    8048:	08 95       	ret
    804a:	13 c1       	rjmp	.+550    	; 0x8272 <__fp_zero>
    804c:	67 2f       	mov	r22, r23
    804e:	78 2f       	mov	r23, r24
    8050:	88 27       	eor	r24, r24
    8052:	b8 5f       	subi	r27, 0xF8	; 248
    8054:	39 f0       	breq	.+14     	; 0x8064 <__fixunssfsi+0x46>
    8056:	b9 3f       	cpi	r27, 0xF9	; 249
    8058:	cc f3       	brlt	.-14     	; 0x804c <__fixunssfsi+0x2e>
    805a:	86 95       	lsr	r24
    805c:	77 95       	ror	r23
    805e:	67 95       	ror	r22
    8060:	b3 95       	inc	r27
    8062:	d9 f7       	brne	.-10     	; 0x805a <__fixunssfsi+0x3c>
    8064:	3e f4       	brtc	.+14     	; 0x8074 <__fixunssfsi+0x56>
    8066:	90 95       	com	r25
    8068:	80 95       	com	r24
    806a:	70 95       	com	r23
    806c:	61 95       	neg	r22
    806e:	7f 4f       	sbci	r23, 0xFF	; 255
    8070:	8f 4f       	sbci	r24, 0xFF	; 255
    8072:	9f 4f       	sbci	r25, 0xFF	; 255
    8074:	08 95       	ret

00008076 <__floatunsisf>:
    8076:	e8 94       	clt
    8078:	09 c0       	rjmp	.+18     	; 0x808c <__floatsisf+0x12>

0000807a <__floatsisf>:
    807a:	97 fb       	bst	r25, 7
    807c:	3e f4       	brtc	.+14     	; 0x808c <__floatsisf+0x12>
    807e:	90 95       	com	r25
    8080:	80 95       	com	r24
    8082:	70 95       	com	r23
    8084:	61 95       	neg	r22
    8086:	7f 4f       	sbci	r23, 0xFF	; 255
    8088:	8f 4f       	sbci	r24, 0xFF	; 255
    808a:	9f 4f       	sbci	r25, 0xFF	; 255
    808c:	99 23       	and	r25, r25
    808e:	a9 f0       	breq	.+42     	; 0x80ba <__floatsisf+0x40>
    8090:	f9 2f       	mov	r31, r25
    8092:	96 e9       	ldi	r25, 0x96	; 150
    8094:	bb 27       	eor	r27, r27
    8096:	93 95       	inc	r25
    8098:	f6 95       	lsr	r31
    809a:	87 95       	ror	r24
    809c:	77 95       	ror	r23
    809e:	67 95       	ror	r22
    80a0:	b7 95       	ror	r27
    80a2:	f1 11       	cpse	r31, r1
    80a4:	f8 cf       	rjmp	.-16     	; 0x8096 <__floatsisf+0x1c>
    80a6:	fa f4       	brpl	.+62     	; 0x80e6 <__floatsisf+0x6c>
    80a8:	bb 0f       	add	r27, r27
    80aa:	11 f4       	brne	.+4      	; 0x80b0 <__floatsisf+0x36>
    80ac:	60 ff       	sbrs	r22, 0
    80ae:	1b c0       	rjmp	.+54     	; 0x80e6 <__floatsisf+0x6c>
    80b0:	6f 5f       	subi	r22, 0xFF	; 255
    80b2:	7f 4f       	sbci	r23, 0xFF	; 255
    80b4:	8f 4f       	sbci	r24, 0xFF	; 255
    80b6:	9f 4f       	sbci	r25, 0xFF	; 255
    80b8:	16 c0       	rjmp	.+44     	; 0x80e6 <__floatsisf+0x6c>
    80ba:	88 23       	and	r24, r24
    80bc:	11 f0       	breq	.+4      	; 0x80c2 <__floatsisf+0x48>
    80be:	96 e9       	ldi	r25, 0x96	; 150
    80c0:	11 c0       	rjmp	.+34     	; 0x80e4 <__floatsisf+0x6a>
    80c2:	77 23       	and	r23, r23
    80c4:	21 f0       	breq	.+8      	; 0x80ce <__floatsisf+0x54>
    80c6:	9e e8       	ldi	r25, 0x8E	; 142
    80c8:	87 2f       	mov	r24, r23
    80ca:	76 2f       	mov	r23, r22
    80cc:	05 c0       	rjmp	.+10     	; 0x80d8 <__floatsisf+0x5e>
    80ce:	66 23       	and	r22, r22
    80d0:	71 f0       	breq	.+28     	; 0x80ee <__floatsisf+0x74>
    80d2:	96 e8       	ldi	r25, 0x86	; 134
    80d4:	86 2f       	mov	r24, r22
    80d6:	70 e0       	ldi	r23, 0x00	; 0
    80d8:	60 e0       	ldi	r22, 0x00	; 0
    80da:	2a f0       	brmi	.+10     	; 0x80e6 <__floatsisf+0x6c>
    80dc:	9a 95       	dec	r25
    80de:	66 0f       	add	r22, r22
    80e0:	77 1f       	adc	r23, r23
    80e2:	88 1f       	adc	r24, r24
    80e4:	da f7       	brpl	.-10     	; 0x80dc <__floatsisf+0x62>
    80e6:	88 0f       	add	r24, r24
    80e8:	96 95       	lsr	r25
    80ea:	87 95       	ror	r24
    80ec:	97 f9       	bld	r25, 7
    80ee:	08 95       	ret

000080f0 <floor>:
    80f0:	a9 d0       	rcall	.+338    	; 0x8244 <__fp_trunc>
    80f2:	80 f0       	brcs	.+32     	; 0x8114 <floor+0x24>
    80f4:	9f 37       	cpi	r25, 0x7F	; 127
    80f6:	40 f4       	brcc	.+16     	; 0x8108 <floor+0x18>
    80f8:	91 11       	cpse	r25, r1
    80fa:	0e f0       	brts	.+2      	; 0x80fe <floor+0xe>
    80fc:	bb c0       	rjmp	.+374    	; 0x8274 <__fp_szero>
    80fe:	60 e0       	ldi	r22, 0x00	; 0
    8100:	70 e0       	ldi	r23, 0x00	; 0
    8102:	80 e8       	ldi	r24, 0x80	; 128
    8104:	9f eb       	ldi	r25, 0xBF	; 191
    8106:	08 95       	ret
    8108:	26 f4       	brtc	.+8      	; 0x8112 <floor+0x22>
    810a:	1b 16       	cp	r1, r27
    810c:	61 1d       	adc	r22, r1
    810e:	71 1d       	adc	r23, r1
    8110:	81 1d       	adc	r24, r1
    8112:	2b c0       	rjmp	.+86     	; 0x816a <__fp_mintl>
    8114:	45 c0       	rjmp	.+138    	; 0x81a0 <__fp_mpack>

00008116 <__fp_cmp>:
    8116:	99 0f       	add	r25, r25
    8118:	00 08       	sbc	r0, r0
    811a:	55 0f       	add	r21, r21
    811c:	aa 0b       	sbc	r26, r26
    811e:	e0 e8       	ldi	r30, 0x80	; 128
    8120:	fe ef       	ldi	r31, 0xFE	; 254
    8122:	16 16       	cp	r1, r22
    8124:	17 06       	cpc	r1, r23
    8126:	e8 07       	cpc	r30, r24
    8128:	f9 07       	cpc	r31, r25
    812a:	c0 f0       	brcs	.+48     	; 0x815c <__fp_cmp+0x46>
    812c:	12 16       	cp	r1, r18
    812e:	13 06       	cpc	r1, r19
    8130:	e4 07       	cpc	r30, r20
    8132:	f5 07       	cpc	r31, r21
    8134:	98 f0       	brcs	.+38     	; 0x815c <__fp_cmp+0x46>
    8136:	62 1b       	sub	r22, r18
    8138:	73 0b       	sbc	r23, r19
    813a:	84 0b       	sbc	r24, r20
    813c:	95 0b       	sbc	r25, r21
    813e:	39 f4       	brne	.+14     	; 0x814e <__fp_cmp+0x38>
    8140:	0a 26       	eor	r0, r26
    8142:	61 f0       	breq	.+24     	; 0x815c <__fp_cmp+0x46>
    8144:	23 2b       	or	r18, r19
    8146:	24 2b       	or	r18, r20
    8148:	25 2b       	or	r18, r21
    814a:	21 f4       	brne	.+8      	; 0x8154 <__fp_cmp+0x3e>
    814c:	08 95       	ret
    814e:	0a 26       	eor	r0, r26
    8150:	09 f4       	brne	.+2      	; 0x8154 <__fp_cmp+0x3e>
    8152:	a1 40       	sbci	r26, 0x01	; 1
    8154:	a6 95       	lsr	r26
    8156:	8f ef       	ldi	r24, 0xFF	; 255
    8158:	81 1d       	adc	r24, r1
    815a:	81 1d       	adc	r24, r1
    815c:	08 95       	ret

0000815e <__fp_inf>:
    815e:	97 f9       	bld	r25, 7
    8160:	9f 67       	ori	r25, 0x7F	; 127
    8162:	80 e8       	ldi	r24, 0x80	; 128
    8164:	70 e0       	ldi	r23, 0x00	; 0
    8166:	60 e0       	ldi	r22, 0x00	; 0
    8168:	08 95       	ret

0000816a <__fp_mintl>:
    816a:	88 23       	and	r24, r24
    816c:	71 f4       	brne	.+28     	; 0x818a <__fp_mintl+0x20>
    816e:	77 23       	and	r23, r23
    8170:	21 f0       	breq	.+8      	; 0x817a <__fp_mintl+0x10>
    8172:	98 50       	subi	r25, 0x08	; 8
    8174:	87 2b       	or	r24, r23
    8176:	76 2f       	mov	r23, r22
    8178:	07 c0       	rjmp	.+14     	; 0x8188 <__fp_mintl+0x1e>
    817a:	66 23       	and	r22, r22
    817c:	11 f4       	brne	.+4      	; 0x8182 <__fp_mintl+0x18>
    817e:	99 27       	eor	r25, r25
    8180:	0d c0       	rjmp	.+26     	; 0x819c <__fp_mintl+0x32>
    8182:	90 51       	subi	r25, 0x10	; 16
    8184:	86 2b       	or	r24, r22
    8186:	70 e0       	ldi	r23, 0x00	; 0
    8188:	60 e0       	ldi	r22, 0x00	; 0
    818a:	2a f0       	brmi	.+10     	; 0x8196 <__fp_mintl+0x2c>
    818c:	9a 95       	dec	r25
    818e:	66 0f       	add	r22, r22
    8190:	77 1f       	adc	r23, r23
    8192:	88 1f       	adc	r24, r24
    8194:	da f7       	brpl	.-10     	; 0x818c <__fp_mintl+0x22>
    8196:	88 0f       	add	r24, r24
    8198:	96 95       	lsr	r25
    819a:	87 95       	ror	r24
    819c:	97 f9       	bld	r25, 7
    819e:	08 95       	ret

000081a0 <__fp_mpack>:
    81a0:	9f 3f       	cpi	r25, 0xFF	; 255
    81a2:	31 f0       	breq	.+12     	; 0x81b0 <__fp_mpack_finite+0xc>

000081a4 <__fp_mpack_finite>:
    81a4:	91 50       	subi	r25, 0x01	; 1
    81a6:	20 f4       	brcc	.+8      	; 0x81b0 <__fp_mpack_finite+0xc>
    81a8:	87 95       	ror	r24
    81aa:	77 95       	ror	r23
    81ac:	67 95       	ror	r22
    81ae:	b7 95       	ror	r27
    81b0:	88 0f       	add	r24, r24
    81b2:	91 1d       	adc	r25, r1
    81b4:	96 95       	lsr	r25
    81b6:	87 95       	ror	r24
    81b8:	97 f9       	bld	r25, 7
    81ba:	08 95       	ret

000081bc <__fp_nan>:
    81bc:	9f ef       	ldi	r25, 0xFF	; 255
    81be:	80 ec       	ldi	r24, 0xC0	; 192
    81c0:	08 95       	ret

000081c2 <__fp_pscA>:
    81c2:	00 24       	eor	r0, r0
    81c4:	0a 94       	dec	r0
    81c6:	16 16       	cp	r1, r22
    81c8:	17 06       	cpc	r1, r23
    81ca:	18 06       	cpc	r1, r24
    81cc:	09 06       	cpc	r0, r25
    81ce:	08 95       	ret

000081d0 <__fp_pscB>:
    81d0:	00 24       	eor	r0, r0
    81d2:	0a 94       	dec	r0
    81d4:	12 16       	cp	r1, r18
    81d6:	13 06       	cpc	r1, r19
    81d8:	14 06       	cpc	r1, r20
    81da:	05 06       	cpc	r0, r21
    81dc:	08 95       	ret

000081de <__fp_round>:
    81de:	09 2e       	mov	r0, r25
    81e0:	03 94       	inc	r0
    81e2:	00 0c       	add	r0, r0
    81e4:	11 f4       	brne	.+4      	; 0x81ea <__fp_round+0xc>
    81e6:	88 23       	and	r24, r24
    81e8:	52 f0       	brmi	.+20     	; 0x81fe <__fp_round+0x20>
    81ea:	bb 0f       	add	r27, r27
    81ec:	40 f4       	brcc	.+16     	; 0x81fe <__fp_round+0x20>
    81ee:	bf 2b       	or	r27, r31
    81f0:	11 f4       	brne	.+4      	; 0x81f6 <__fp_round+0x18>
    81f2:	60 ff       	sbrs	r22, 0
    81f4:	04 c0       	rjmp	.+8      	; 0x81fe <__fp_round+0x20>
    81f6:	6f 5f       	subi	r22, 0xFF	; 255
    81f8:	7f 4f       	sbci	r23, 0xFF	; 255
    81fa:	8f 4f       	sbci	r24, 0xFF	; 255
    81fc:	9f 4f       	sbci	r25, 0xFF	; 255
    81fe:	08 95       	ret

00008200 <__fp_split3>:
    8200:	57 fd       	sbrc	r21, 7
    8202:	90 58       	subi	r25, 0x80	; 128
    8204:	44 0f       	add	r20, r20
    8206:	55 1f       	adc	r21, r21
    8208:	59 f0       	breq	.+22     	; 0x8220 <__fp_splitA+0x10>
    820a:	5f 3f       	cpi	r21, 0xFF	; 255
    820c:	71 f0       	breq	.+28     	; 0x822a <__fp_splitA+0x1a>
    820e:	47 95       	ror	r20

00008210 <__fp_splitA>:
    8210:	88 0f       	add	r24, r24
    8212:	97 fb       	bst	r25, 7
    8214:	99 1f       	adc	r25, r25
    8216:	61 f0       	breq	.+24     	; 0x8230 <__fp_splitA+0x20>
    8218:	9f 3f       	cpi	r25, 0xFF	; 255
    821a:	79 f0       	breq	.+30     	; 0x823a <__fp_splitA+0x2a>
    821c:	87 95       	ror	r24
    821e:	08 95       	ret
    8220:	12 16       	cp	r1, r18
    8222:	13 06       	cpc	r1, r19
    8224:	14 06       	cpc	r1, r20
    8226:	55 1f       	adc	r21, r21
    8228:	f2 cf       	rjmp	.-28     	; 0x820e <__fp_split3+0xe>
    822a:	46 95       	lsr	r20
    822c:	f1 df       	rcall	.-30     	; 0x8210 <__fp_splitA>
    822e:	08 c0       	rjmp	.+16     	; 0x8240 <__fp_splitA+0x30>
    8230:	16 16       	cp	r1, r22
    8232:	17 06       	cpc	r1, r23
    8234:	18 06       	cpc	r1, r24
    8236:	99 1f       	adc	r25, r25
    8238:	f1 cf       	rjmp	.-30     	; 0x821c <__fp_splitA+0xc>
    823a:	86 95       	lsr	r24
    823c:	71 05       	cpc	r23, r1
    823e:	61 05       	cpc	r22, r1
    8240:	08 94       	sec
    8242:	08 95       	ret

00008244 <__fp_trunc>:
    8244:	e5 df       	rcall	.-54     	; 0x8210 <__fp_splitA>
    8246:	a0 f0       	brcs	.+40     	; 0x8270 <__fp_trunc+0x2c>
    8248:	be e7       	ldi	r27, 0x7E	; 126
    824a:	b9 17       	cp	r27, r25
    824c:	88 f4       	brcc	.+34     	; 0x8270 <__fp_trunc+0x2c>
    824e:	bb 27       	eor	r27, r27
    8250:	9f 38       	cpi	r25, 0x8F	; 143
    8252:	60 f4       	brcc	.+24     	; 0x826c <__fp_trunc+0x28>
    8254:	16 16       	cp	r1, r22
    8256:	b1 1d       	adc	r27, r1
    8258:	67 2f       	mov	r22, r23
    825a:	78 2f       	mov	r23, r24
    825c:	88 27       	eor	r24, r24
    825e:	98 5f       	subi	r25, 0xF8	; 248
    8260:	f7 cf       	rjmp	.-18     	; 0x8250 <__fp_trunc+0xc>
    8262:	86 95       	lsr	r24
    8264:	77 95       	ror	r23
    8266:	67 95       	ror	r22
    8268:	b1 1d       	adc	r27, r1
    826a:	93 95       	inc	r25
    826c:	96 39       	cpi	r25, 0x96	; 150
    826e:	c8 f3       	brcs	.-14     	; 0x8262 <__fp_trunc+0x1e>
    8270:	08 95       	ret

00008272 <__fp_zero>:
    8272:	e8 94       	clt

00008274 <__fp_szero>:
    8274:	bb 27       	eor	r27, r27
    8276:	66 27       	eor	r22, r22
    8278:	77 27       	eor	r23, r23
    827a:	cb 01       	movw	r24, r22
    827c:	97 f9       	bld	r25, 7
    827e:	08 95       	ret

00008280 <__gesf2>:
    8280:	4a df       	rcall	.-364    	; 0x8116 <__fp_cmp>
    8282:	08 f4       	brcc	.+2      	; 0x8286 <__gesf2+0x6>
    8284:	8f ef       	ldi	r24, 0xFF	; 255
    8286:	08 95       	ret

00008288 <__mulsf3>:
    8288:	0b d0       	rcall	.+22     	; 0x82a0 <__mulsf3x>
    828a:	a9 cf       	rjmp	.-174    	; 0x81de <__fp_round>
    828c:	9a df       	rcall	.-204    	; 0x81c2 <__fp_pscA>
    828e:	28 f0       	brcs	.+10     	; 0x829a <__mulsf3+0x12>
    8290:	9f df       	rcall	.-194    	; 0x81d0 <__fp_pscB>
    8292:	18 f0       	brcs	.+6      	; 0x829a <__mulsf3+0x12>
    8294:	95 23       	and	r25, r21
    8296:	09 f0       	breq	.+2      	; 0x829a <__mulsf3+0x12>
    8298:	62 cf       	rjmp	.-316    	; 0x815e <__fp_inf>
    829a:	90 cf       	rjmp	.-224    	; 0x81bc <__fp_nan>
    829c:	11 24       	eor	r1, r1
    829e:	ea cf       	rjmp	.-44     	; 0x8274 <__fp_szero>

000082a0 <__mulsf3x>:
    82a0:	af df       	rcall	.-162    	; 0x8200 <__fp_split3>
    82a2:	a0 f3       	brcs	.-24     	; 0x828c <__mulsf3+0x4>

000082a4 <__mulsf3_pse>:
    82a4:	95 9f       	mul	r25, r21
    82a6:	d1 f3       	breq	.-12     	; 0x829c <__mulsf3+0x14>
    82a8:	95 0f       	add	r25, r21
    82aa:	50 e0       	ldi	r21, 0x00	; 0
    82ac:	55 1f       	adc	r21, r21
    82ae:	62 9f       	mul	r22, r18
    82b0:	f0 01       	movw	r30, r0
    82b2:	72 9f       	mul	r23, r18
    82b4:	bb 27       	eor	r27, r27
    82b6:	f0 0d       	add	r31, r0
    82b8:	b1 1d       	adc	r27, r1
    82ba:	63 9f       	mul	r22, r19
    82bc:	aa 27       	eor	r26, r26
    82be:	f0 0d       	add	r31, r0
    82c0:	b1 1d       	adc	r27, r1
    82c2:	aa 1f       	adc	r26, r26
    82c4:	64 9f       	mul	r22, r20
    82c6:	66 27       	eor	r22, r22
    82c8:	b0 0d       	add	r27, r0
    82ca:	a1 1d       	adc	r26, r1
    82cc:	66 1f       	adc	r22, r22
    82ce:	82 9f       	mul	r24, r18
    82d0:	22 27       	eor	r18, r18
    82d2:	b0 0d       	add	r27, r0
    82d4:	a1 1d       	adc	r26, r1
    82d6:	62 1f       	adc	r22, r18
    82d8:	73 9f       	mul	r23, r19
    82da:	b0 0d       	add	r27, r0
    82dc:	a1 1d       	adc	r26, r1
    82de:	62 1f       	adc	r22, r18
    82e0:	83 9f       	mul	r24, r19
    82e2:	a0 0d       	add	r26, r0
    82e4:	61 1d       	adc	r22, r1
    82e6:	22 1f       	adc	r18, r18
    82e8:	74 9f       	mul	r23, r20
    82ea:	33 27       	eor	r19, r19
    82ec:	a0 0d       	add	r26, r0
    82ee:	61 1d       	adc	r22, r1
    82f0:	23 1f       	adc	r18, r19
    82f2:	84 9f       	mul	r24, r20
    82f4:	60 0d       	add	r22, r0
    82f6:	21 1d       	adc	r18, r1
    82f8:	82 2f       	mov	r24, r18
    82fa:	76 2f       	mov	r23, r22
    82fc:	6a 2f       	mov	r22, r26
    82fe:	11 24       	eor	r1, r1
    8300:	9f 57       	subi	r25, 0x7F	; 127
    8302:	50 40       	sbci	r21, 0x00	; 0
    8304:	8a f0       	brmi	.+34     	; 0x8328 <__mulsf3_pse+0x84>
    8306:	e1 f0       	breq	.+56     	; 0x8340 <__mulsf3_pse+0x9c>
    8308:	88 23       	and	r24, r24
    830a:	4a f0       	brmi	.+18     	; 0x831e <__mulsf3_pse+0x7a>
    830c:	ee 0f       	add	r30, r30
    830e:	ff 1f       	adc	r31, r31
    8310:	bb 1f       	adc	r27, r27
    8312:	66 1f       	adc	r22, r22
    8314:	77 1f       	adc	r23, r23
    8316:	88 1f       	adc	r24, r24
    8318:	91 50       	subi	r25, 0x01	; 1
    831a:	50 40       	sbci	r21, 0x00	; 0
    831c:	a9 f7       	brne	.-22     	; 0x8308 <__mulsf3_pse+0x64>
    831e:	9e 3f       	cpi	r25, 0xFE	; 254
    8320:	51 05       	cpc	r21, r1
    8322:	70 f0       	brcs	.+28     	; 0x8340 <__mulsf3_pse+0x9c>
    8324:	1c cf       	rjmp	.-456    	; 0x815e <__fp_inf>
    8326:	a6 cf       	rjmp	.-180    	; 0x8274 <__fp_szero>
    8328:	5f 3f       	cpi	r21, 0xFF	; 255
    832a:	ec f3       	brlt	.-6      	; 0x8326 <__mulsf3_pse+0x82>
    832c:	98 3e       	cpi	r25, 0xE8	; 232
    832e:	dc f3       	brlt	.-10     	; 0x8326 <__mulsf3_pse+0x82>
    8330:	86 95       	lsr	r24
    8332:	77 95       	ror	r23
    8334:	67 95       	ror	r22
    8336:	b7 95       	ror	r27
    8338:	f7 95       	ror	r31
    833a:	e7 95       	ror	r30
    833c:	9f 5f       	subi	r25, 0xFF	; 255
    833e:	c1 f7       	brne	.-16     	; 0x8330 <__mulsf3_pse+0x8c>
    8340:	fe 2b       	or	r31, r30
    8342:	88 0f       	add	r24, r24
    8344:	91 1d       	adc	r25, r1
    8346:	96 95       	lsr	r25
    8348:	87 95       	ror	r24
    834a:	97 f9       	bld	r25, 7
    834c:	08 95       	ret

0000834e <round>:
    834e:	60 df       	rcall	.-320    	; 0x8210 <__fp_splitA>
    8350:	e0 f0       	brcs	.+56     	; 0x838a <round+0x3c>
    8352:	9e 37       	cpi	r25, 0x7E	; 126
    8354:	d8 f0       	brcs	.+54     	; 0x838c <round+0x3e>
    8356:	96 39       	cpi	r25, 0x96	; 150
    8358:	b8 f4       	brcc	.+46     	; 0x8388 <round+0x3a>
    835a:	9e 38       	cpi	r25, 0x8E	; 142
    835c:	48 f4       	brcc	.+18     	; 0x8370 <round+0x22>
    835e:	67 2f       	mov	r22, r23
    8360:	78 2f       	mov	r23, r24
    8362:	88 27       	eor	r24, r24
    8364:	98 5f       	subi	r25, 0xF8	; 248
    8366:	f9 cf       	rjmp	.-14     	; 0x835a <round+0xc>
    8368:	86 95       	lsr	r24
    836a:	77 95       	ror	r23
    836c:	67 95       	ror	r22
    836e:	93 95       	inc	r25
    8370:	95 39       	cpi	r25, 0x95	; 149
    8372:	d0 f3       	brcs	.-12     	; 0x8368 <round+0x1a>
    8374:	b6 2f       	mov	r27, r22
    8376:	b1 70       	andi	r27, 0x01	; 1
    8378:	6b 0f       	add	r22, r27
    837a:	71 1d       	adc	r23, r1
    837c:	81 1d       	adc	r24, r1
    837e:	20 f4       	brcc	.+8      	; 0x8388 <round+0x3a>
    8380:	87 95       	ror	r24
    8382:	77 95       	ror	r23
    8384:	67 95       	ror	r22
    8386:	93 95       	inc	r25
    8388:	f0 ce       	rjmp	.-544    	; 0x816a <__fp_mintl>
    838a:	0a cf       	rjmp	.-492    	; 0x81a0 <__fp_mpack>
    838c:	73 cf       	rjmp	.-282    	; 0x8274 <__fp_szero>

0000838e <__udivmodhi4>:
    838e:	aa 1b       	sub	r26, r26
    8390:	bb 1b       	sub	r27, r27
    8392:	51 e1       	ldi	r21, 0x11	; 17
    8394:	07 c0       	rjmp	.+14     	; 0x83a4 <__udivmodhi4_ep>

00008396 <__udivmodhi4_loop>:
    8396:	aa 1f       	adc	r26, r26
    8398:	bb 1f       	adc	r27, r27
    839a:	a6 17       	cp	r26, r22
    839c:	b7 07       	cpc	r27, r23
    839e:	10 f0       	brcs	.+4      	; 0x83a4 <__udivmodhi4_ep>
    83a0:	a6 1b       	sub	r26, r22
    83a2:	b7 0b       	sbc	r27, r23

000083a4 <__udivmodhi4_ep>:
    83a4:	88 1f       	adc	r24, r24
    83a6:	99 1f       	adc	r25, r25
    83a8:	5a 95       	dec	r21
    83aa:	a9 f7       	brne	.-22     	; 0x8396 <__udivmodhi4_loop>
    83ac:	80 95       	com	r24
    83ae:	90 95       	com	r25
    83b0:	bc 01       	movw	r22, r24
    83b2:	cd 01       	movw	r24, r26
    83b4:	08 95       	ret

000083b6 <__divmodhi4>:
    83b6:	97 fb       	bst	r25, 7
    83b8:	09 2e       	mov	r0, r25
    83ba:	07 26       	eor	r0, r23
    83bc:	0a d0       	rcall	.+20     	; 0x83d2 <__divmodhi4_neg1>
    83be:	77 fd       	sbrc	r23, 7
    83c0:	04 d0       	rcall	.+8      	; 0x83ca <__divmodhi4_neg2>
    83c2:	e5 df       	rcall	.-54     	; 0x838e <__udivmodhi4>
    83c4:	06 d0       	rcall	.+12     	; 0x83d2 <__divmodhi4_neg1>
    83c6:	00 20       	and	r0, r0
    83c8:	1a f4       	brpl	.+6      	; 0x83d0 <__divmodhi4_exit>

000083ca <__divmodhi4_neg2>:
    83ca:	70 95       	com	r23
    83cc:	61 95       	neg	r22
    83ce:	7f 4f       	sbci	r23, 0xFF	; 255

000083d0 <__divmodhi4_exit>:
    83d0:	08 95       	ret

000083d2 <__divmodhi4_neg1>:
    83d2:	f6 f7       	brtc	.-4      	; 0x83d0 <__divmodhi4_exit>
    83d4:	90 95       	com	r25
    83d6:	81 95       	neg	r24
    83d8:	9f 4f       	sbci	r25, 0xFF	; 255
    83da:	08 95       	ret

000083dc <malloc>:
    83dc:	cf 93       	push	r28
    83de:	df 93       	push	r29
    83e0:	bc 01       	movw	r22, r24
    83e2:	82 30       	cpi	r24, 0x02	; 2
    83e4:	91 05       	cpc	r25, r1
    83e6:	10 f4       	brcc	.+4      	; 0x83ec <malloc+0x10>
    83e8:	62 e0       	ldi	r22, 0x02	; 2
    83ea:	70 e0       	ldi	r23, 0x00	; 0
    83ec:	a0 91 9a 04 	lds	r26, 0x049A
    83f0:	b0 91 9b 04 	lds	r27, 0x049B
    83f4:	ed 01       	movw	r28, r26
    83f6:	e0 e0       	ldi	r30, 0x00	; 0
    83f8:	f0 e0       	ldi	r31, 0x00	; 0
    83fa:	40 e0       	ldi	r20, 0x00	; 0
    83fc:	50 e0       	ldi	r21, 0x00	; 0
    83fe:	21 c0       	rjmp	.+66     	; 0x8442 <malloc+0x66>
    8400:	88 81       	ld	r24, Y
    8402:	99 81       	ldd	r25, Y+1	; 0x01
    8404:	86 17       	cp	r24, r22
    8406:	97 07       	cpc	r25, r23
    8408:	69 f4       	brne	.+26     	; 0x8424 <malloc+0x48>
    840a:	8a 81       	ldd	r24, Y+2	; 0x02
    840c:	9b 81       	ldd	r25, Y+3	; 0x03
    840e:	30 97       	sbiw	r30, 0x00	; 0
    8410:	19 f0       	breq	.+6      	; 0x8418 <malloc+0x3c>
    8412:	93 83       	std	Z+3, r25	; 0x03
    8414:	82 83       	std	Z+2, r24	; 0x02
    8416:	04 c0       	rjmp	.+8      	; 0x8420 <malloc+0x44>
    8418:	90 93 9b 04 	sts	0x049B, r25
    841c:	80 93 9a 04 	sts	0x049A, r24
    8420:	fe 01       	movw	r30, r28
    8422:	34 c0       	rjmp	.+104    	; 0x848c <malloc+0xb0>
    8424:	68 17       	cp	r22, r24
    8426:	79 07       	cpc	r23, r25
    8428:	38 f4       	brcc	.+14     	; 0x8438 <malloc+0x5c>
    842a:	41 15       	cp	r20, r1
    842c:	51 05       	cpc	r21, r1
    842e:	19 f0       	breq	.+6      	; 0x8436 <malloc+0x5a>
    8430:	84 17       	cp	r24, r20
    8432:	95 07       	cpc	r25, r21
    8434:	08 f4       	brcc	.+2      	; 0x8438 <malloc+0x5c>
    8436:	ac 01       	movw	r20, r24
    8438:	fe 01       	movw	r30, r28
    843a:	8a 81       	ldd	r24, Y+2	; 0x02
    843c:	9b 81       	ldd	r25, Y+3	; 0x03
    843e:	9c 01       	movw	r18, r24
    8440:	e9 01       	movw	r28, r18
    8442:	20 97       	sbiw	r28, 0x00	; 0
    8444:	e9 f6       	brne	.-70     	; 0x8400 <malloc+0x24>
    8446:	41 15       	cp	r20, r1
    8448:	51 05       	cpc	r21, r1
    844a:	a9 f1       	breq	.+106    	; 0x84b6 <malloc+0xda>
    844c:	ca 01       	movw	r24, r20
    844e:	86 1b       	sub	r24, r22
    8450:	97 0b       	sbc	r25, r23
    8452:	04 97       	sbiw	r24, 0x04	; 4
    8454:	08 f4       	brcc	.+2      	; 0x8458 <malloc+0x7c>
    8456:	ba 01       	movw	r22, r20
    8458:	e0 e0       	ldi	r30, 0x00	; 0
    845a:	f0 e0       	ldi	r31, 0x00	; 0
    845c:	2a c0       	rjmp	.+84     	; 0x84b2 <malloc+0xd6>
    845e:	8d 91       	ld	r24, X+
    8460:	9c 91       	ld	r25, X
    8462:	11 97       	sbiw	r26, 0x01	; 1
    8464:	84 17       	cp	r24, r20
    8466:	95 07       	cpc	r25, r21
    8468:	f9 f4       	brne	.+62     	; 0x84a8 <malloc+0xcc>
    846a:	64 17       	cp	r22, r20
    846c:	75 07       	cpc	r23, r21
    846e:	81 f4       	brne	.+32     	; 0x8490 <malloc+0xb4>
    8470:	12 96       	adiw	r26, 0x02	; 2
    8472:	8d 91       	ld	r24, X+
    8474:	9c 91       	ld	r25, X
    8476:	13 97       	sbiw	r26, 0x03	; 3
    8478:	30 97       	sbiw	r30, 0x00	; 0
    847a:	19 f0       	breq	.+6      	; 0x8482 <malloc+0xa6>
    847c:	93 83       	std	Z+3, r25	; 0x03
    847e:	82 83       	std	Z+2, r24	; 0x02
    8480:	04 c0       	rjmp	.+8      	; 0x848a <malloc+0xae>
    8482:	90 93 9b 04 	sts	0x049B, r25
    8486:	80 93 9a 04 	sts	0x049A, r24
    848a:	fd 01       	movw	r30, r26
    848c:	32 96       	adiw	r30, 0x02	; 2
    848e:	4f c0       	rjmp	.+158    	; 0x852e <malloc+0x152>
    8490:	ca 01       	movw	r24, r20
    8492:	86 1b       	sub	r24, r22
    8494:	97 0b       	sbc	r25, r23
    8496:	fd 01       	movw	r30, r26
    8498:	e8 0f       	add	r30, r24
    849a:	f9 1f       	adc	r31, r25
    849c:	61 93       	st	Z+, r22
    849e:	71 93       	st	Z+, r23
    84a0:	02 97       	sbiw	r24, 0x02	; 2
    84a2:	8d 93       	st	X+, r24
    84a4:	9c 93       	st	X, r25
    84a6:	43 c0       	rjmp	.+134    	; 0x852e <malloc+0x152>
    84a8:	fd 01       	movw	r30, r26
    84aa:	82 81       	ldd	r24, Z+2	; 0x02
    84ac:	93 81       	ldd	r25, Z+3	; 0x03
    84ae:	9c 01       	movw	r18, r24
    84b0:	d9 01       	movw	r26, r18
    84b2:	10 97       	sbiw	r26, 0x00	; 0
    84b4:	a1 f6       	brne	.-88     	; 0x845e <malloc+0x82>
    84b6:	80 91 98 04 	lds	r24, 0x0498
    84ba:	90 91 99 04 	lds	r25, 0x0499
    84be:	89 2b       	or	r24, r25
    84c0:	41 f4       	brne	.+16     	; 0x84d2 <malloc+0xf6>
    84c2:	80 91 d1 02 	lds	r24, 0x02D1
    84c6:	90 91 d2 02 	lds	r25, 0x02D2
    84ca:	90 93 99 04 	sts	0x0499, r25
    84ce:	80 93 98 04 	sts	0x0498, r24
    84d2:	40 91 d3 02 	lds	r20, 0x02D3
    84d6:	50 91 d4 02 	lds	r21, 0x02D4
    84da:	41 15       	cp	r20, r1
    84dc:	51 05       	cpc	r21, r1
    84de:	41 f4       	brne	.+16     	; 0x84f0 <malloc+0x114>
    84e0:	4d b7       	in	r20, 0x3d	; 61
    84e2:	5e b7       	in	r21, 0x3e	; 62
    84e4:	80 91 cf 02 	lds	r24, 0x02CF
    84e8:	90 91 d0 02 	lds	r25, 0x02D0
    84ec:	48 1b       	sub	r20, r24
    84ee:	59 0b       	sbc	r21, r25
    84f0:	20 91 98 04 	lds	r18, 0x0498
    84f4:	30 91 99 04 	lds	r19, 0x0499
    84f8:	24 17       	cp	r18, r20
    84fa:	35 07       	cpc	r19, r21
    84fc:	b0 f4       	brcc	.+44     	; 0x852a <malloc+0x14e>
    84fe:	ca 01       	movw	r24, r20
    8500:	82 1b       	sub	r24, r18
    8502:	93 0b       	sbc	r25, r19
    8504:	86 17       	cp	r24, r22
    8506:	97 07       	cpc	r25, r23
    8508:	80 f0       	brcs	.+32     	; 0x852a <malloc+0x14e>
    850a:	ab 01       	movw	r20, r22
    850c:	4e 5f       	subi	r20, 0xFE	; 254
    850e:	5f 4f       	sbci	r21, 0xFF	; 255
    8510:	84 17       	cp	r24, r20
    8512:	95 07       	cpc	r25, r21
    8514:	50 f0       	brcs	.+20     	; 0x852a <malloc+0x14e>
    8516:	42 0f       	add	r20, r18
    8518:	53 1f       	adc	r21, r19
    851a:	50 93 99 04 	sts	0x0499, r21
    851e:	40 93 98 04 	sts	0x0498, r20
    8522:	f9 01       	movw	r30, r18
    8524:	61 93       	st	Z+, r22
    8526:	71 93       	st	Z+, r23
    8528:	02 c0       	rjmp	.+4      	; 0x852e <malloc+0x152>
    852a:	e0 e0       	ldi	r30, 0x00	; 0
    852c:	f0 e0       	ldi	r31, 0x00	; 0
    852e:	cf 01       	movw	r24, r30
    8530:	df 91       	pop	r29
    8532:	cf 91       	pop	r28
    8534:	08 95       	ret

00008536 <free>:
    8536:	cf 93       	push	r28
    8538:	df 93       	push	r29
    853a:	00 97       	sbiw	r24, 0x00	; 0
    853c:	09 f4       	brne	.+2      	; 0x8540 <free+0xa>
    853e:	50 c0       	rjmp	.+160    	; 0x85e0 <free+0xaa>
    8540:	ec 01       	movw	r28, r24
    8542:	22 97       	sbiw	r28, 0x02	; 2
    8544:	1b 82       	std	Y+3, r1	; 0x03
    8546:	1a 82       	std	Y+2, r1	; 0x02
    8548:	a0 91 9a 04 	lds	r26, 0x049A
    854c:	b0 91 9b 04 	lds	r27, 0x049B
    8550:	10 97       	sbiw	r26, 0x00	; 0
    8552:	09 f1       	breq	.+66     	; 0x8596 <free+0x60>
    8554:	40 e0       	ldi	r20, 0x00	; 0
    8556:	50 e0       	ldi	r21, 0x00	; 0
    8558:	ac 17       	cp	r26, r28
    855a:	bd 07       	cpc	r27, r29
    855c:	08 f1       	brcs	.+66     	; 0x85a0 <free+0x6a>
    855e:	bb 83       	std	Y+3, r27	; 0x03
    8560:	aa 83       	std	Y+2, r26	; 0x02
    8562:	fe 01       	movw	r30, r28
    8564:	21 91       	ld	r18, Z+
    8566:	31 91       	ld	r19, Z+
    8568:	e2 0f       	add	r30, r18
    856a:	f3 1f       	adc	r31, r19
    856c:	ae 17       	cp	r26, r30
    856e:	bf 07       	cpc	r27, r31
    8570:	79 f4       	brne	.+30     	; 0x8590 <free+0x5a>
    8572:	8d 91       	ld	r24, X+
    8574:	9c 91       	ld	r25, X
    8576:	11 97       	sbiw	r26, 0x01	; 1
    8578:	28 0f       	add	r18, r24
    857a:	39 1f       	adc	r19, r25
    857c:	2e 5f       	subi	r18, 0xFE	; 254
    857e:	3f 4f       	sbci	r19, 0xFF	; 255
    8580:	39 83       	std	Y+1, r19	; 0x01
    8582:	28 83       	st	Y, r18
    8584:	12 96       	adiw	r26, 0x02	; 2
    8586:	8d 91       	ld	r24, X+
    8588:	9c 91       	ld	r25, X
    858a:	13 97       	sbiw	r26, 0x03	; 3
    858c:	9b 83       	std	Y+3, r25	; 0x03
    858e:	8a 83       	std	Y+2, r24	; 0x02
    8590:	41 15       	cp	r20, r1
    8592:	51 05       	cpc	r21, r1
    8594:	71 f4       	brne	.+28     	; 0x85b2 <free+0x7c>
    8596:	d0 93 9b 04 	sts	0x049B, r29
    859a:	c0 93 9a 04 	sts	0x049A, r28
    859e:	20 c0       	rjmp	.+64     	; 0x85e0 <free+0xaa>
    85a0:	12 96       	adiw	r26, 0x02	; 2
    85a2:	8d 91       	ld	r24, X+
    85a4:	9c 91       	ld	r25, X
    85a6:	13 97       	sbiw	r26, 0x03	; 3
    85a8:	ad 01       	movw	r20, r26
    85aa:	00 97       	sbiw	r24, 0x00	; 0
    85ac:	11 f0       	breq	.+4      	; 0x85b2 <free+0x7c>
    85ae:	dc 01       	movw	r26, r24
    85b0:	d3 cf       	rjmp	.-90     	; 0x8558 <free+0x22>
    85b2:	fa 01       	movw	r30, r20
    85b4:	d3 83       	std	Z+3, r29	; 0x03
    85b6:	c2 83       	std	Z+2, r28	; 0x02
    85b8:	21 91       	ld	r18, Z+
    85ba:	31 91       	ld	r19, Z+
    85bc:	e2 0f       	add	r30, r18
    85be:	f3 1f       	adc	r31, r19
    85c0:	ce 17       	cp	r28, r30
    85c2:	df 07       	cpc	r29, r31
    85c4:	69 f4       	brne	.+26     	; 0x85e0 <free+0xaa>
    85c6:	88 81       	ld	r24, Y
    85c8:	99 81       	ldd	r25, Y+1	; 0x01
    85ca:	28 0f       	add	r18, r24
    85cc:	39 1f       	adc	r19, r25
    85ce:	2e 5f       	subi	r18, 0xFE	; 254
    85d0:	3f 4f       	sbci	r19, 0xFF	; 255
    85d2:	fa 01       	movw	r30, r20
    85d4:	31 83       	std	Z+1, r19	; 0x01
    85d6:	20 83       	st	Z, r18
    85d8:	8a 81       	ldd	r24, Y+2	; 0x02
    85da:	9b 81       	ldd	r25, Y+3	; 0x03
    85dc:	93 83       	std	Z+3, r25	; 0x03
    85de:	82 83       	std	Z+2, r24	; 0x02
    85e0:	df 91       	pop	r29
    85e2:	cf 91       	pop	r28
    85e4:	08 95       	ret

000085e6 <strtol>:
    85e6:	2f 92       	push	r2
    85e8:	3f 92       	push	r3
    85ea:	5f 92       	push	r5
    85ec:	6f 92       	push	r6
    85ee:	7f 92       	push	r7
    85f0:	8f 92       	push	r8
    85f2:	9f 92       	push	r9
    85f4:	af 92       	push	r10
    85f6:	bf 92       	push	r11
    85f8:	cf 92       	push	r12
    85fa:	df 92       	push	r13
    85fc:	ef 92       	push	r14
    85fe:	ff 92       	push	r15
    8600:	0f 93       	push	r16
    8602:	1f 93       	push	r17
    8604:	cf 93       	push	r28
    8606:	df 93       	push	r29
    8608:	8c 01       	movw	r16, r24
    860a:	1b 01       	movw	r2, r22
    860c:	ea 01       	movw	r28, r20
    860e:	61 15       	cp	r22, r1
    8610:	71 05       	cpc	r23, r1
    8612:	19 f0       	breq	.+6      	; 0x861a <strtol+0x34>
    8614:	fb 01       	movw	r30, r22
    8616:	91 83       	std	Z+1, r25	; 0x01
    8618:	80 83       	st	Z, r24
    861a:	20 97       	sbiw	r28, 0x00	; 0
    861c:	49 f0       	breq	.+18     	; 0x8630 <strtol+0x4a>
    861e:	ce 01       	movw	r24, r28
    8620:	02 97       	sbiw	r24, 0x02	; 2
    8622:	83 97       	sbiw	r24, 0x23	; 35
    8624:	28 f0       	brcs	.+10     	; 0x8630 <strtol+0x4a>
    8626:	20 e0       	ldi	r18, 0x00	; 0
    8628:	30 e0       	ldi	r19, 0x00	; 0
    862a:	40 e0       	ldi	r20, 0x00	; 0
    862c:	50 e0       	ldi	r21, 0x00	; 0
    862e:	f6 c0       	rjmp	.+492    	; 0x881c <strtol+0x236>
    8630:	f8 01       	movw	r30, r16
    8632:	a1 90       	ld	r10, Z+
    8634:	8f 01       	movw	r16, r30
    8636:	8a 2d       	mov	r24, r10
    8638:	90 e0       	ldi	r25, 0x00	; 0
    863a:	0e 94 1c 45 	call	0x8a38	; 0x8a38 <isspace>
    863e:	89 2b       	or	r24, r25
    8640:	b9 f7       	brne	.-18     	; 0x8630 <strtol+0x4a>
    8642:	fd e2       	ldi	r31, 0x2D	; 45
    8644:	af 16       	cp	r10, r31
    8646:	31 f4       	brne	.+12     	; 0x8654 <strtol+0x6e>
    8648:	f8 01       	movw	r30, r16
    864a:	a1 90       	ld	r10, Z+
    864c:	8f 01       	movw	r16, r30
    864e:	55 24       	eor	r5, r5
    8650:	53 94       	inc	r5
    8652:	07 c0       	rjmp	.+14     	; 0x8662 <strtol+0x7c>
    8654:	fb e2       	ldi	r31, 0x2B	; 43
    8656:	af 16       	cp	r10, r31
    8658:	19 f4       	brne	.+6      	; 0x8660 <strtol+0x7a>
    865a:	f8 01       	movw	r30, r16
    865c:	a1 90       	ld	r10, Z+
    865e:	8f 01       	movw	r16, r30
    8660:	55 24       	eor	r5, r5
    8662:	20 97       	sbiw	r28, 0x00	; 0
    8664:	19 f0       	breq	.+6      	; 0x866c <strtol+0x86>
    8666:	c0 31       	cpi	r28, 0x10	; 16
    8668:	d1 05       	cpc	r29, r1
    866a:	c1 f4       	brne	.+48     	; 0x869c <strtol+0xb6>
    866c:	f0 e3       	ldi	r31, 0x30	; 48
    866e:	af 16       	cp	r10, r31
    8670:	79 f4       	brne	.+30     	; 0x8690 <strtol+0xaa>
    8672:	f8 01       	movw	r30, r16
    8674:	80 81       	ld	r24, Z
    8676:	88 37       	cpi	r24, 0x78	; 120
    8678:	11 f0       	breq	.+4      	; 0x867e <strtol+0x98>
    867a:	88 35       	cpi	r24, 0x58	; 88
    867c:	49 f4       	brne	.+18     	; 0x8690 <strtol+0xaa>
    867e:	f8 01       	movw	r30, r16
    8680:	a1 80       	ldd	r10, Z+1	; 0x01
    8682:	0e 5f       	subi	r16, 0xFE	; 254
    8684:	1f 4f       	sbci	r17, 0xFF	; 255
    8686:	f2 e0       	ldi	r31, 0x02	; 2
    8688:	5f 2a       	or	r5, r31
    868a:	c0 e1       	ldi	r28, 0x10	; 16
    868c:	d0 e0       	ldi	r29, 0x00	; 0
    868e:	06 c0       	rjmp	.+12     	; 0x869c <strtol+0xb6>
    8690:	20 97       	sbiw	r28, 0x00	; 0
    8692:	21 f4       	brne	.+8      	; 0x869c <strtol+0xb6>
    8694:	80 e3       	ldi	r24, 0x30	; 48
    8696:	a8 16       	cp	r10, r24
    8698:	e9 f4       	brne	.+58     	; 0x86d4 <strtol+0xee>
    869a:	27 c0       	rjmp	.+78     	; 0x86ea <strtol+0x104>
    869c:	c8 30       	cpi	r28, 0x08	; 8
    869e:	d1 05       	cpc	r29, r1
    86a0:	31 f1       	breq	.+76     	; 0x86ee <strtol+0x108>
    86a2:	c9 30       	cpi	r28, 0x09	; 9
    86a4:	d1 05       	cpc	r29, r1
    86a6:	24 f4       	brge	.+8      	; 0x86b0 <strtol+0xca>
    86a8:	c2 30       	cpi	r28, 0x02	; 2
    86aa:	d1 05       	cpc	r29, r1
    86ac:	31 f5       	brne	.+76     	; 0x86fa <strtol+0x114>
    86ae:	0c c0       	rjmp	.+24     	; 0x86c8 <strtol+0xe2>
    86b0:	ca 30       	cpi	r28, 0x0A	; 10
    86b2:	d1 05       	cpc	r29, r1
    86b4:	89 f0       	breq	.+34     	; 0x86d8 <strtol+0xf2>
    86b6:	c0 31       	cpi	r28, 0x10	; 16
    86b8:	d1 05       	cpc	r29, r1
    86ba:	f9 f4       	brne	.+62     	; 0x86fa <strtol+0x114>
    86bc:	c1 2c       	mov	r12, r1
    86be:	d1 2c       	mov	r13, r1
    86c0:	e1 2c       	mov	r14, r1
    86c2:	b8 e0       	ldi	r27, 0x08	; 8
    86c4:	fb 2e       	mov	r15, r27
    86c6:	28 c0       	rjmp	.+80     	; 0x8718 <strtol+0x132>
    86c8:	c1 2c       	mov	r12, r1
    86ca:	d1 2c       	mov	r13, r1
    86cc:	e1 2c       	mov	r14, r1
    86ce:	a0 e4       	ldi	r26, 0x40	; 64
    86d0:	fa 2e       	mov	r15, r26
    86d2:	22 c0       	rjmp	.+68     	; 0x8718 <strtol+0x132>
    86d4:	ca e0       	ldi	r28, 0x0A	; 10
    86d6:	d0 e0       	ldi	r29, 0x00	; 0
    86d8:	fc ec       	ldi	r31, 0xCC	; 204
    86da:	cf 2e       	mov	r12, r31
    86dc:	fc ec       	ldi	r31, 0xCC	; 204
    86de:	df 2e       	mov	r13, r31
    86e0:	fc ec       	ldi	r31, 0xCC	; 204
    86e2:	ef 2e       	mov	r14, r31
    86e4:	fc e0       	ldi	r31, 0x0C	; 12
    86e6:	ff 2e       	mov	r15, r31
    86e8:	17 c0       	rjmp	.+46     	; 0x8718 <strtol+0x132>
    86ea:	c8 e0       	ldi	r28, 0x08	; 8
    86ec:	d0 e0       	ldi	r29, 0x00	; 0
    86ee:	c1 2c       	mov	r12, r1
    86f0:	d1 2c       	mov	r13, r1
    86f2:	e1 2c       	mov	r14, r1
    86f4:	e0 e1       	ldi	r30, 0x10	; 16
    86f6:	fe 2e       	mov	r15, r30
    86f8:	0f c0       	rjmp	.+30     	; 0x8718 <strtol+0x132>
    86fa:	9e 01       	movw	r18, r28
    86fc:	44 27       	eor	r20, r20
    86fe:	37 fd       	sbrc	r19, 7
    8700:	40 95       	com	r20
    8702:	54 2f       	mov	r21, r20
    8704:	60 e0       	ldi	r22, 0x00	; 0
    8706:	70 e0       	ldi	r23, 0x00	; 0
    8708:	80 e0       	ldi	r24, 0x00	; 0
    870a:	90 e8       	ldi	r25, 0x80	; 128
    870c:	0e 94 1a 48 	call	0x9034	; 0x9034 <__udivmodsi4>
    8710:	c9 01       	movw	r24, r18
    8712:	da 01       	movw	r26, r20
    8714:	6c 01       	movw	r12, r24
    8716:	7d 01       	movw	r14, r26
    8718:	20 e0       	ldi	r18, 0x00	; 0
    871a:	30 e0       	ldi	r19, 0x00	; 0
    871c:	40 e0       	ldi	r20, 0x00	; 0
    871e:	50 e0       	ldi	r21, 0x00	; 0
    8720:	60 e0       	ldi	r22, 0x00	; 0
    8722:	3e 01       	movw	r6, r28
    8724:	88 24       	eor	r8, r8
    8726:	77 fc       	sbrc	r7, 7
    8728:	80 94       	com	r8
    872a:	98 2c       	mov	r9, r8
    872c:	70 ed       	ldi	r23, 0xD0	; 208
    872e:	b7 2e       	mov	r11, r23
    8730:	ba 0c       	add	r11, r10
    8732:	e9 e0       	ldi	r30, 0x09	; 9
    8734:	eb 15       	cp	r30, r11
    8736:	70 f4       	brcc	.+28     	; 0x8754 <strtol+0x16e>
    8738:	8a 2d       	mov	r24, r10
    873a:	81 54       	subi	r24, 0x41	; 65
    873c:	8a 31       	cpi	r24, 0x1A	; 26
    873e:	18 f4       	brcc	.+6      	; 0x8746 <strtol+0x160>
    8740:	99 ec       	ldi	r25, 0xC9	; 201
    8742:	b9 2e       	mov	r11, r25
    8744:	06 c0       	rjmp	.+12     	; 0x8752 <strtol+0x16c>
    8746:	8a 2d       	mov	r24, r10
    8748:	81 56       	subi	r24, 0x61	; 97
    874a:	8a 31       	cpi	r24, 0x1A	; 26
    874c:	50 f5       	brcc	.+84     	; 0x87a2 <strtol+0x1bc>
    874e:	89 ea       	ldi	r24, 0xA9	; 169
    8750:	b8 2e       	mov	r11, r24
    8752:	ba 0c       	add	r11, r10
    8754:	8b 2d       	mov	r24, r11
    8756:	90 e0       	ldi	r25, 0x00	; 0
    8758:	8c 17       	cp	r24, r28
    875a:	9d 07       	cpc	r25, r29
    875c:	14 f5       	brge	.+68     	; 0x87a2 <strtol+0x1bc>
    875e:	6f 3f       	cpi	r22, 0xFF	; 255
    8760:	e1 f0       	breq	.+56     	; 0x879a <strtol+0x1b4>
    8762:	c2 16       	cp	r12, r18
    8764:	d3 06       	cpc	r13, r19
    8766:	e4 06       	cpc	r14, r20
    8768:	f5 06       	cpc	r15, r21
    876a:	b0 f0       	brcs	.+44     	; 0x8798 <strtol+0x1b2>
    876c:	ca 01       	movw	r24, r20
    876e:	b9 01       	movw	r22, r18
    8770:	a4 01       	movw	r20, r8
    8772:	93 01       	movw	r18, r6
    8774:	0e 94 fb 47 	call	0x8ff6	; 0x8ff6 <__mulsi3>
    8778:	9b 01       	movw	r18, r22
    877a:	ac 01       	movw	r20, r24
    877c:	2b 0d       	add	r18, r11
    877e:	31 1d       	adc	r19, r1
    8780:	41 1d       	adc	r20, r1
    8782:	51 1d       	adc	r21, r1
    8784:	21 30       	cpi	r18, 0x01	; 1
    8786:	f0 e0       	ldi	r31, 0x00	; 0
    8788:	3f 07       	cpc	r19, r31
    878a:	f0 e0       	ldi	r31, 0x00	; 0
    878c:	4f 07       	cpc	r20, r31
    878e:	f0 e8       	ldi	r31, 0x80	; 128
    8790:	5f 07       	cpc	r21, r31
    8792:	10 f4       	brcc	.+4      	; 0x8798 <strtol+0x1b2>
    8794:	61 e0       	ldi	r22, 0x01	; 1
    8796:	01 c0       	rjmp	.+2      	; 0x879a <strtol+0x1b4>
    8798:	6f ef       	ldi	r22, 0xFF	; 255
    879a:	f8 01       	movw	r30, r16
    879c:	a1 90       	ld	r10, Z+
    879e:	8f 01       	movw	r16, r30
    87a0:	c5 cf       	rjmp	.-118    	; 0x872c <strtol+0x146>
    87a2:	21 14       	cp	r2, r1
    87a4:	31 04       	cpc	r3, r1
    87a6:	81 f0       	breq	.+32     	; 0x87c8 <strtol+0x1e2>
    87a8:	66 23       	and	r22, r22
    87aa:	31 f0       	breq	.+12     	; 0x87b8 <strtol+0x1d2>
    87ac:	01 50       	subi	r16, 0x01	; 1
    87ae:	10 40       	sbci	r17, 0x00	; 0
    87b0:	f1 01       	movw	r30, r2
    87b2:	11 83       	std	Z+1, r17	; 0x01
    87b4:	00 83       	st	Z, r16
    87b6:	08 c0       	rjmp	.+16     	; 0x87c8 <strtol+0x1e2>
    87b8:	51 fe       	sbrs	r5, 1
    87ba:	1a c0       	rjmp	.+52     	; 0x87f0 <strtol+0x20a>
    87bc:	02 50       	subi	r16, 0x02	; 2
    87be:	10 40       	sbci	r17, 0x00	; 0
    87c0:	f1 01       	movw	r30, r2
    87c2:	11 83       	std	Z+1, r17	; 0x01
    87c4:	00 83       	st	Z, r16
    87c6:	14 c0       	rjmp	.+40     	; 0x87f0 <strtol+0x20a>
    87c8:	67 ff       	sbrs	r22, 7
    87ca:	12 c0       	rjmp	.+36     	; 0x87f0 <strtol+0x20a>
    87cc:	50 fc       	sbrc	r5, 0
    87ce:	05 c0       	rjmp	.+10     	; 0x87da <strtol+0x1f4>
    87d0:	2f ef       	ldi	r18, 0xFF	; 255
    87d2:	3f ef       	ldi	r19, 0xFF	; 255
    87d4:	4f ef       	ldi	r20, 0xFF	; 255
    87d6:	5f e7       	ldi	r21, 0x7F	; 127
    87d8:	04 c0       	rjmp	.+8      	; 0x87e2 <strtol+0x1fc>
    87da:	20 e0       	ldi	r18, 0x00	; 0
    87dc:	30 e0       	ldi	r19, 0x00	; 0
    87de:	40 e0       	ldi	r20, 0x00	; 0
    87e0:	50 e8       	ldi	r21, 0x80	; 128
    87e2:	82 e2       	ldi	r24, 0x22	; 34
    87e4:	90 e0       	ldi	r25, 0x00	; 0
    87e6:	90 93 9d 04 	sts	0x049D, r25
    87ea:	80 93 9c 04 	sts	0x049C, r24
    87ee:	16 c0       	rjmp	.+44     	; 0x881c <strtol+0x236>
    87f0:	50 fe       	sbrs	r5, 0
    87f2:	08 c0       	rjmp	.+16     	; 0x8804 <strtol+0x21e>
    87f4:	50 95       	com	r21
    87f6:	40 95       	com	r20
    87f8:	30 95       	com	r19
    87fa:	21 95       	neg	r18
    87fc:	3f 4f       	sbci	r19, 0xFF	; 255
    87fe:	4f 4f       	sbci	r20, 0xFF	; 255
    8800:	5f 4f       	sbci	r21, 0xFF	; 255
    8802:	0c c0       	rjmp	.+24     	; 0x881c <strtol+0x236>
    8804:	57 ff       	sbrs	r21, 7
    8806:	0a c0       	rjmp	.+20     	; 0x881c <strtol+0x236>
    8808:	82 e2       	ldi	r24, 0x22	; 34
    880a:	90 e0       	ldi	r25, 0x00	; 0
    880c:	90 93 9d 04 	sts	0x049D, r25
    8810:	80 93 9c 04 	sts	0x049C, r24
    8814:	2f ef       	ldi	r18, 0xFF	; 255
    8816:	3f ef       	ldi	r19, 0xFF	; 255
    8818:	4f ef       	ldi	r20, 0xFF	; 255
    881a:	5f e7       	ldi	r21, 0x7F	; 127
    881c:	b9 01       	movw	r22, r18
    881e:	ca 01       	movw	r24, r20
    8820:	df 91       	pop	r29
    8822:	cf 91       	pop	r28
    8824:	1f 91       	pop	r17
    8826:	0f 91       	pop	r16
    8828:	ff 90       	pop	r15
    882a:	ef 90       	pop	r14
    882c:	df 90       	pop	r13
    882e:	cf 90       	pop	r12
    8830:	bf 90       	pop	r11
    8832:	af 90       	pop	r10
    8834:	9f 90       	pop	r9
    8836:	8f 90       	pop	r8
    8838:	7f 90       	pop	r7
    883a:	6f 90       	pop	r6
    883c:	5f 90       	pop	r5
    883e:	3f 90       	pop	r3
    8840:	2f 90       	pop	r2
    8842:	08 95       	ret

00008844 <atof>:
    8844:	66 27       	eor	r22, r22
    8846:	77 27       	eor	r23, r23
    8848:	0c 94 72 46 	jmp	0x8ce4	; 0x8ce4 <strtod>

0000884c <atoi>:
    884c:	fc 01       	movw	r30, r24
    884e:	88 27       	eor	r24, r24
    8850:	99 27       	eor	r25, r25
    8852:	e8 94       	clt
    8854:	21 91       	ld	r18, Z+
    8856:	20 32       	cpi	r18, 0x20	; 32
    8858:	e9 f3       	breq	.-6      	; 0x8854 <atoi+0x8>
    885a:	29 30       	cpi	r18, 0x09	; 9
    885c:	10 f0       	brcs	.+4      	; 0x8862 <atoi+0x16>
    885e:	2e 30       	cpi	r18, 0x0E	; 14
    8860:	c8 f3       	brcs	.-14     	; 0x8854 <atoi+0x8>
    8862:	2b 32       	cpi	r18, 0x2B	; 43
    8864:	41 f0       	breq	.+16     	; 0x8876 <atoi+0x2a>
    8866:	2d 32       	cpi	r18, 0x2D	; 45
    8868:	39 f4       	brne	.+14     	; 0x8878 <atoi+0x2c>
    886a:	68 94       	set
    886c:	04 c0       	rjmp	.+8      	; 0x8876 <atoi+0x2a>
    886e:	0e 94 7d 45 	call	0x8afa	; 0x8afa <__mulhi_const_10>
    8872:	82 0f       	add	r24, r18
    8874:	91 1d       	adc	r25, r1
    8876:	21 91       	ld	r18, Z+
    8878:	20 53       	subi	r18, 0x30	; 48
    887a:	2a 30       	cpi	r18, 0x0A	; 10
    887c:	c0 f3       	brcs	.-16     	; 0x886e <atoi+0x22>
    887e:	1e f4       	brtc	.+6      	; 0x8886 <atoi+0x3a>
    8880:	90 95       	com	r25
    8882:	81 95       	neg	r24
    8884:	9f 4f       	sbci	r25, 0xFF	; 255
    8886:	08 95       	ret

00008888 <__ftoa_engine>:
    8888:	28 30       	cpi	r18, 0x08	; 8
    888a:	08 f0       	brcs	.+2      	; 0x888e <__ftoa_engine+0x6>
    888c:	27 e0       	ldi	r18, 0x07	; 7
    888e:	33 27       	eor	r19, r19
    8890:	da 01       	movw	r26, r20
    8892:	99 0f       	add	r25, r25
    8894:	31 1d       	adc	r19, r1
    8896:	87 fd       	sbrc	r24, 7
    8898:	91 60       	ori	r25, 0x01	; 1
    889a:	00 96       	adiw	r24, 0x00	; 0
    889c:	61 05       	cpc	r22, r1
    889e:	71 05       	cpc	r23, r1
    88a0:	39 f4       	brne	.+14     	; 0x88b0 <__ftoa_engine+0x28>
    88a2:	32 60       	ori	r19, 0x02	; 2
    88a4:	2e 5f       	subi	r18, 0xFE	; 254
    88a6:	3d 93       	st	X+, r19
    88a8:	30 e3       	ldi	r19, 0x30	; 48
    88aa:	2a 95       	dec	r18
    88ac:	e1 f7       	brne	.-8      	; 0x88a6 <__ftoa_engine+0x1e>
    88ae:	08 95       	ret
    88b0:	9f 3f       	cpi	r25, 0xFF	; 255
    88b2:	30 f0       	brcs	.+12     	; 0x88c0 <__ftoa_engine+0x38>
    88b4:	80 38       	cpi	r24, 0x80	; 128
    88b6:	71 05       	cpc	r23, r1
    88b8:	61 05       	cpc	r22, r1
    88ba:	09 f0       	breq	.+2      	; 0x88be <__ftoa_engine+0x36>
    88bc:	3c 5f       	subi	r19, 0xFC	; 252
    88be:	3c 5f       	subi	r19, 0xFC	; 252
    88c0:	3d 93       	st	X+, r19
    88c2:	91 30       	cpi	r25, 0x01	; 1
    88c4:	08 f0       	brcs	.+2      	; 0x88c8 <__ftoa_engine+0x40>
    88c6:	80 68       	ori	r24, 0x80	; 128
    88c8:	91 1d       	adc	r25, r1
    88ca:	df 93       	push	r29
    88cc:	cf 93       	push	r28
    88ce:	1f 93       	push	r17
    88d0:	0f 93       	push	r16
    88d2:	ff 92       	push	r15
    88d4:	ef 92       	push	r14
    88d6:	19 2f       	mov	r17, r25
    88d8:	98 7f       	andi	r25, 0xF8	; 248
    88da:	96 95       	lsr	r25
    88dc:	e9 2f       	mov	r30, r25
    88de:	96 95       	lsr	r25
    88e0:	96 95       	lsr	r25
    88e2:	e9 0f       	add	r30, r25
    88e4:	ff 27       	eor	r31, r31
    88e6:	ee 59       	subi	r30, 0x9E	; 158
    88e8:	fa 4f       	sbci	r31, 0xFA	; 250
    88ea:	99 27       	eor	r25, r25
    88ec:	33 27       	eor	r19, r19
    88ee:	ee 24       	eor	r14, r14
    88f0:	ff 24       	eor	r15, r15
    88f2:	a7 01       	movw	r20, r14
    88f4:	e7 01       	movw	r28, r14
    88f6:	05 90       	lpm	r0, Z+
    88f8:	08 94       	sec
    88fa:	07 94       	ror	r0
    88fc:	28 f4       	brcc	.+10     	; 0x8908 <__ftoa_engine+0x80>
    88fe:	36 0f       	add	r19, r22
    8900:	e7 1e       	adc	r14, r23
    8902:	f8 1e       	adc	r15, r24
    8904:	49 1f       	adc	r20, r25
    8906:	51 1d       	adc	r21, r1
    8908:	66 0f       	add	r22, r22
    890a:	77 1f       	adc	r23, r23
    890c:	88 1f       	adc	r24, r24
    890e:	99 1f       	adc	r25, r25
    8910:	06 94       	lsr	r0
    8912:	a1 f7       	brne	.-24     	; 0x88fc <__ftoa_engine+0x74>
    8914:	05 90       	lpm	r0, Z+
    8916:	07 94       	ror	r0
    8918:	28 f4       	brcc	.+10     	; 0x8924 <__ftoa_engine+0x9c>
    891a:	e7 0e       	add	r14, r23
    891c:	f8 1e       	adc	r15, r24
    891e:	49 1f       	adc	r20, r25
    8920:	56 1f       	adc	r21, r22
    8922:	c1 1d       	adc	r28, r1
    8924:	77 0f       	add	r23, r23
    8926:	88 1f       	adc	r24, r24
    8928:	99 1f       	adc	r25, r25
    892a:	66 1f       	adc	r22, r22
    892c:	06 94       	lsr	r0
    892e:	a1 f7       	brne	.-24     	; 0x8918 <__ftoa_engine+0x90>
    8930:	05 90       	lpm	r0, Z+
    8932:	07 94       	ror	r0
    8934:	28 f4       	brcc	.+10     	; 0x8940 <__ftoa_engine+0xb8>
    8936:	f8 0e       	add	r15, r24
    8938:	49 1f       	adc	r20, r25
    893a:	56 1f       	adc	r21, r22
    893c:	c7 1f       	adc	r28, r23
    893e:	d1 1d       	adc	r29, r1
    8940:	88 0f       	add	r24, r24
    8942:	99 1f       	adc	r25, r25
    8944:	66 1f       	adc	r22, r22
    8946:	77 1f       	adc	r23, r23
    8948:	06 94       	lsr	r0
    894a:	a1 f7       	brne	.-24     	; 0x8934 <__ftoa_engine+0xac>
    894c:	05 90       	lpm	r0, Z+
    894e:	07 94       	ror	r0
    8950:	20 f4       	brcc	.+8      	; 0x895a <__ftoa_engine+0xd2>
    8952:	49 0f       	add	r20, r25
    8954:	56 1f       	adc	r21, r22
    8956:	c7 1f       	adc	r28, r23
    8958:	d8 1f       	adc	r29, r24
    895a:	99 0f       	add	r25, r25
    895c:	66 1f       	adc	r22, r22
    895e:	77 1f       	adc	r23, r23
    8960:	88 1f       	adc	r24, r24
    8962:	06 94       	lsr	r0
    8964:	a9 f7       	brne	.-22     	; 0x8950 <__ftoa_engine+0xc8>
    8966:	84 91       	lpm	r24, Z+
    8968:	10 95       	com	r17
    896a:	17 70       	andi	r17, 0x07	; 7
    896c:	41 f0       	breq	.+16     	; 0x897e <__ftoa_engine+0xf6>
    896e:	d6 95       	lsr	r29
    8970:	c7 95       	ror	r28
    8972:	57 95       	ror	r21
    8974:	47 95       	ror	r20
    8976:	f7 94       	ror	r15
    8978:	e7 94       	ror	r14
    897a:	1a 95       	dec	r17
    897c:	c1 f7       	brne	.-16     	; 0x896e <__ftoa_engine+0xe6>
    897e:	e8 e0       	ldi	r30, 0x08	; 8
    8980:	f5 e0       	ldi	r31, 0x05	; 5
    8982:	68 94       	set
    8984:	15 90       	lpm	r1, Z+
    8986:	15 91       	lpm	r17, Z+
    8988:	35 91       	lpm	r19, Z+
    898a:	65 91       	lpm	r22, Z+
    898c:	95 91       	lpm	r25, Z+
    898e:	05 90       	lpm	r0, Z+
    8990:	7f e2       	ldi	r23, 0x2F	; 47
    8992:	73 95       	inc	r23
    8994:	e1 18       	sub	r14, r1
    8996:	f1 0a       	sbc	r15, r17
    8998:	43 0b       	sbc	r20, r19
    899a:	56 0b       	sbc	r21, r22
    899c:	c9 0b       	sbc	r28, r25
    899e:	d0 09       	sbc	r29, r0
    89a0:	c0 f7       	brcc	.-16     	; 0x8992 <__ftoa_engine+0x10a>
    89a2:	e1 0c       	add	r14, r1
    89a4:	f1 1e       	adc	r15, r17
    89a6:	43 1f       	adc	r20, r19
    89a8:	56 1f       	adc	r21, r22
    89aa:	c9 1f       	adc	r28, r25
    89ac:	d0 1d       	adc	r29, r0
    89ae:	7e f4       	brtc	.+30     	; 0x89ce <__ftoa_engine+0x146>
    89b0:	70 33       	cpi	r23, 0x30	; 48
    89b2:	11 f4       	brne	.+4      	; 0x89b8 <__ftoa_engine+0x130>
    89b4:	8a 95       	dec	r24
    89b6:	e6 cf       	rjmp	.-52     	; 0x8984 <__ftoa_engine+0xfc>
    89b8:	e8 94       	clt
    89ba:	01 50       	subi	r16, 0x01	; 1
    89bc:	30 f0       	brcs	.+12     	; 0x89ca <__ftoa_engine+0x142>
    89be:	08 0f       	add	r16, r24
    89c0:	0a f4       	brpl	.+2      	; 0x89c4 <__ftoa_engine+0x13c>
    89c2:	00 27       	eor	r16, r16
    89c4:	02 17       	cp	r16, r18
    89c6:	08 f4       	brcc	.+2      	; 0x89ca <__ftoa_engine+0x142>
    89c8:	20 2f       	mov	r18, r16
    89ca:	23 95       	inc	r18
    89cc:	02 2f       	mov	r16, r18
    89ce:	7a 33       	cpi	r23, 0x3A	; 58
    89d0:	28 f0       	brcs	.+10     	; 0x89dc <__ftoa_engine+0x154>
    89d2:	79 e3       	ldi	r23, 0x39	; 57
    89d4:	7d 93       	st	X+, r23
    89d6:	2a 95       	dec	r18
    89d8:	e9 f7       	brne	.-6      	; 0x89d4 <__ftoa_engine+0x14c>
    89da:	10 c0       	rjmp	.+32     	; 0x89fc <__ftoa_engine+0x174>
    89dc:	7d 93       	st	X+, r23
    89de:	2a 95       	dec	r18
    89e0:	89 f6       	brne	.-94     	; 0x8984 <__ftoa_engine+0xfc>
    89e2:	06 94       	lsr	r0
    89e4:	97 95       	ror	r25
    89e6:	67 95       	ror	r22
    89e8:	37 95       	ror	r19
    89ea:	17 95       	ror	r17
    89ec:	17 94       	ror	r1
    89ee:	e1 18       	sub	r14, r1
    89f0:	f1 0a       	sbc	r15, r17
    89f2:	43 0b       	sbc	r20, r19
    89f4:	56 0b       	sbc	r21, r22
    89f6:	c9 0b       	sbc	r28, r25
    89f8:	d0 09       	sbc	r29, r0
    89fa:	98 f0       	brcs	.+38     	; 0x8a22 <__ftoa_engine+0x19a>
    89fc:	23 95       	inc	r18
    89fe:	7e 91       	ld	r23, -X
    8a00:	73 95       	inc	r23
    8a02:	7a 33       	cpi	r23, 0x3A	; 58
    8a04:	08 f0       	brcs	.+2      	; 0x8a08 <__ftoa_engine+0x180>
    8a06:	70 e3       	ldi	r23, 0x30	; 48
    8a08:	7c 93       	st	X, r23
    8a0a:	20 13       	cpse	r18, r16
    8a0c:	b8 f7       	brcc	.-18     	; 0x89fc <__ftoa_engine+0x174>
    8a0e:	7e 91       	ld	r23, -X
    8a10:	70 61       	ori	r23, 0x10	; 16
    8a12:	7d 93       	st	X+, r23
    8a14:	30 f0       	brcs	.+12     	; 0x8a22 <__ftoa_engine+0x19a>
    8a16:	83 95       	inc	r24
    8a18:	71 e3       	ldi	r23, 0x31	; 49
    8a1a:	7d 93       	st	X+, r23
    8a1c:	70 e3       	ldi	r23, 0x30	; 48
    8a1e:	2a 95       	dec	r18
    8a20:	e1 f7       	brne	.-8      	; 0x8a1a <__ftoa_engine+0x192>
    8a22:	11 24       	eor	r1, r1
    8a24:	ef 90       	pop	r14
    8a26:	ff 90       	pop	r15
    8a28:	0f 91       	pop	r16
    8a2a:	1f 91       	pop	r17
    8a2c:	cf 91       	pop	r28
    8a2e:	df 91       	pop	r29
    8a30:	99 27       	eor	r25, r25
    8a32:	87 fd       	sbrc	r24, 7
    8a34:	90 95       	com	r25
    8a36:	08 95       	ret

00008a38 <isspace>:
    8a38:	91 11       	cpse	r25, r1
    8a3a:	c2 c2       	rjmp	.+1412   	; 0x8fc0 <__ctype_isfalse>
    8a3c:	80 32       	cpi	r24, 0x20	; 32
    8a3e:	19 f0       	breq	.+6      	; 0x8a46 <isspace+0xe>
    8a40:	89 50       	subi	r24, 0x09	; 9
    8a42:	85 50       	subi	r24, 0x05	; 5
    8a44:	d0 f7       	brcc	.-12     	; 0x8a3a <isspace+0x2>
    8a46:	08 95       	ret

00008a48 <strcpy_P>:
    8a48:	fb 01       	movw	r30, r22
    8a4a:	dc 01       	movw	r26, r24
    8a4c:	05 90       	lpm	r0, Z+
    8a4e:	0d 92       	st	X+, r0
    8a50:	00 20       	and	r0, r0
    8a52:	e1 f7       	brne	.-8      	; 0x8a4c <strcpy_P+0x4>
    8a54:	08 95       	ret

00008a56 <strnlen_P>:
    8a56:	fc 01       	movw	r30, r24
    8a58:	05 90       	lpm	r0, Z+
    8a5a:	61 50       	subi	r22, 0x01	; 1
    8a5c:	70 40       	sbci	r23, 0x00	; 0
    8a5e:	01 10       	cpse	r0, r1
    8a60:	d8 f7       	brcc	.-10     	; 0x8a58 <strnlen_P+0x2>
    8a62:	80 95       	com	r24
    8a64:	90 95       	com	r25
    8a66:	8e 0f       	add	r24, r30
    8a68:	9f 1f       	adc	r25, r31
    8a6a:	08 95       	ret

00008a6c <strtok>:
    8a6c:	4a ed       	ldi	r20, 0xDA	; 218
    8a6e:	52 e0       	ldi	r21, 0x02	; 2
    8a70:	0e 94 56 45 	call	0x8aac	; 0x8aac <strtok_r>
    8a74:	08 95       	ret

00008a76 <strcmp>:
    8a76:	fb 01       	movw	r30, r22
    8a78:	dc 01       	movw	r26, r24
    8a7a:	8d 91       	ld	r24, X+
    8a7c:	01 90       	ld	r0, Z+
    8a7e:	80 19       	sub	r24, r0
    8a80:	01 10       	cpse	r0, r1
    8a82:	d9 f3       	breq	.-10     	; 0x8a7a <strcmp+0x4>
    8a84:	99 0b       	sbc	r25, r25
    8a86:	08 95       	ret

00008a88 <strcpy>:
    8a88:	fb 01       	movw	r30, r22
    8a8a:	dc 01       	movw	r26, r24
    8a8c:	01 90       	ld	r0, Z+
    8a8e:	0d 92       	st	X+, r0
    8a90:	00 20       	and	r0, r0
    8a92:	e1 f7       	brne	.-8      	; 0x8a8c <strcpy+0x4>
    8a94:	08 95       	ret

00008a96 <strnlen>:
    8a96:	fc 01       	movw	r30, r24
    8a98:	61 50       	subi	r22, 0x01	; 1
    8a9a:	70 40       	sbci	r23, 0x00	; 0
    8a9c:	01 90       	ld	r0, Z+
    8a9e:	01 10       	cpse	r0, r1
    8aa0:	d8 f7       	brcc	.-10     	; 0x8a98 <strnlen+0x2>
    8aa2:	80 95       	com	r24
    8aa4:	90 95       	com	r25
    8aa6:	8e 0f       	add	r24, r30
    8aa8:	9f 1f       	adc	r25, r31
    8aaa:	08 95       	ret

00008aac <strtok_r>:
    8aac:	fa 01       	movw	r30, r20
    8aae:	a1 91       	ld	r26, Z+
    8ab0:	b0 81       	ld	r27, Z
    8ab2:	00 97       	sbiw	r24, 0x00	; 0
    8ab4:	19 f4       	brne	.+6      	; 0x8abc <strtok_r+0x10>
    8ab6:	10 97       	sbiw	r26, 0x00	; 0
    8ab8:	e1 f0       	breq	.+56     	; 0x8af2 <strtok_r+0x46>
    8aba:	cd 01       	movw	r24, r26
    8abc:	dc 01       	movw	r26, r24
    8abe:	cd 01       	movw	r24, r26
    8ac0:	0d 90       	ld	r0, X+
    8ac2:	00 20       	and	r0, r0
    8ac4:	11 f4       	brne	.+4      	; 0x8aca <strtok_r+0x1e>
    8ac6:	c0 01       	movw	r24, r0
    8ac8:	13 c0       	rjmp	.+38     	; 0x8af0 <strtok_r+0x44>
    8aca:	fb 01       	movw	r30, r22
    8acc:	21 91       	ld	r18, Z+
    8ace:	22 23       	and	r18, r18
    8ad0:	19 f0       	breq	.+6      	; 0x8ad8 <strtok_r+0x2c>
    8ad2:	20 15       	cp	r18, r0
    8ad4:	d9 f7       	brne	.-10     	; 0x8acc <strtok_r+0x20>
    8ad6:	f3 cf       	rjmp	.-26     	; 0x8abe <strtok_r+0x12>
    8ad8:	fb 01       	movw	r30, r22
    8ada:	21 91       	ld	r18, Z+
    8adc:	20 15       	cp	r18, r0
    8ade:	19 f4       	brne	.+6      	; 0x8ae6 <strtok_r+0x3a>
    8ae0:	1e 92       	st	-X, r1
    8ae2:	11 96       	adiw	r26, 0x01	; 1
    8ae4:	06 c0       	rjmp	.+12     	; 0x8af2 <strtok_r+0x46>
    8ae6:	22 23       	and	r18, r18
    8ae8:	c1 f7       	brne	.-16     	; 0x8ada <strtok_r+0x2e>
    8aea:	0d 90       	ld	r0, X+
    8aec:	00 20       	and	r0, r0
    8aee:	a1 f7       	brne	.-24     	; 0x8ad8 <strtok_r+0x2c>
    8af0:	d0 01       	movw	r26, r0
    8af2:	fa 01       	movw	r30, r20
    8af4:	a1 93       	st	Z+, r26
    8af6:	b0 83       	st	Z, r27
    8af8:	08 95       	ret

00008afa <__mulhi_const_10>:
    8afa:	7a e0       	ldi	r23, 0x0A	; 10
    8afc:	97 9f       	mul	r25, r23
    8afe:	90 2d       	mov	r25, r0
    8b00:	87 9f       	mul	r24, r23
    8b02:	80 2d       	mov	r24, r0
    8b04:	91 0d       	add	r25, r1
    8b06:	11 24       	eor	r1, r1
    8b08:	08 95       	ret

00008b0a <fputc>:
    8b0a:	0f 93       	push	r16
    8b0c:	1f 93       	push	r17
    8b0e:	cf 93       	push	r28
    8b10:	df 93       	push	r29
    8b12:	8c 01       	movw	r16, r24
    8b14:	eb 01       	movw	r28, r22
    8b16:	8b 81       	ldd	r24, Y+3	; 0x03
    8b18:	81 ff       	sbrs	r24, 1
    8b1a:	1b c0       	rjmp	.+54     	; 0x8b52 <fputc+0x48>
    8b1c:	82 ff       	sbrs	r24, 2
    8b1e:	0d c0       	rjmp	.+26     	; 0x8b3a <fputc+0x30>
    8b20:	2e 81       	ldd	r18, Y+6	; 0x06
    8b22:	3f 81       	ldd	r19, Y+7	; 0x07
    8b24:	8c 81       	ldd	r24, Y+4	; 0x04
    8b26:	9d 81       	ldd	r25, Y+5	; 0x05
    8b28:	28 17       	cp	r18, r24
    8b2a:	39 07       	cpc	r19, r25
    8b2c:	64 f4       	brge	.+24     	; 0x8b46 <fputc+0x3c>
    8b2e:	e8 81       	ld	r30, Y
    8b30:	f9 81       	ldd	r31, Y+1	; 0x01
    8b32:	01 93       	st	Z+, r16
    8b34:	f9 83       	std	Y+1, r31	; 0x01
    8b36:	e8 83       	st	Y, r30
    8b38:	06 c0       	rjmp	.+12     	; 0x8b46 <fputc+0x3c>
    8b3a:	e8 85       	ldd	r30, Y+8	; 0x08
    8b3c:	f9 85       	ldd	r31, Y+9	; 0x09
    8b3e:	80 2f       	mov	r24, r16
    8b40:	09 95       	icall
    8b42:	89 2b       	or	r24, r25
    8b44:	31 f4       	brne	.+12     	; 0x8b52 <fputc+0x48>
    8b46:	8e 81       	ldd	r24, Y+6	; 0x06
    8b48:	9f 81       	ldd	r25, Y+7	; 0x07
    8b4a:	01 96       	adiw	r24, 0x01	; 1
    8b4c:	9f 83       	std	Y+7, r25	; 0x07
    8b4e:	8e 83       	std	Y+6, r24	; 0x06
    8b50:	02 c0       	rjmp	.+4      	; 0x8b56 <fputc+0x4c>
    8b52:	0f ef       	ldi	r16, 0xFF	; 255
    8b54:	1f ef       	ldi	r17, 0xFF	; 255
    8b56:	c8 01       	movw	r24, r16
    8b58:	df 91       	pop	r29
    8b5a:	cf 91       	pop	r28
    8b5c:	1f 91       	pop	r17
    8b5e:	0f 91       	pop	r16
    8b60:	08 95       	ret

00008b62 <sprintf>:
    8b62:	0f 93       	push	r16
    8b64:	1f 93       	push	r17
    8b66:	df 93       	push	r29
    8b68:	cf 93       	push	r28
    8b6a:	cd b7       	in	r28, 0x3d	; 61
    8b6c:	de b7       	in	r29, 0x3e	; 62
    8b6e:	2e 97       	sbiw	r28, 0x0e	; 14
    8b70:	0f b6       	in	r0, 0x3f	; 63
    8b72:	f8 94       	cli
    8b74:	de bf       	out	0x3e, r29	; 62
    8b76:	0f be       	out	0x3f, r0	; 63
    8b78:	cd bf       	out	0x3d, r28	; 61
    8b7a:	0d 89       	ldd	r16, Y+21	; 0x15
    8b7c:	1e 89       	ldd	r17, Y+22	; 0x16
    8b7e:	86 e0       	ldi	r24, 0x06	; 6
    8b80:	8c 83       	std	Y+4, r24	; 0x04
    8b82:	1a 83       	std	Y+2, r17	; 0x02
    8b84:	09 83       	std	Y+1, r16	; 0x01
    8b86:	8f ef       	ldi	r24, 0xFF	; 255
    8b88:	9f e7       	ldi	r25, 0x7F	; 127
    8b8a:	9e 83       	std	Y+6, r25	; 0x06
    8b8c:	8d 83       	std	Y+5, r24	; 0x05
    8b8e:	9e 01       	movw	r18, r28
    8b90:	27 5e       	subi	r18, 0xE7	; 231
    8b92:	3f 4f       	sbci	r19, 0xFF	; 255
    8b94:	ce 01       	movw	r24, r28
    8b96:	01 96       	adiw	r24, 0x01	; 1
    8b98:	6f 89       	ldd	r22, Y+23	; 0x17
    8b9a:	78 8d       	ldd	r23, Y+24	; 0x18
    8b9c:	a9 01       	movw	r20, r18
    8b9e:	0e 94 89 3b 	call	0x7712	; 0x7712 <vfprintf>
    8ba2:	2f 81       	ldd	r18, Y+7	; 0x07
    8ba4:	38 85       	ldd	r19, Y+8	; 0x08
    8ba6:	02 0f       	add	r16, r18
    8ba8:	13 1f       	adc	r17, r19
    8baa:	f8 01       	movw	r30, r16
    8bac:	10 82       	st	Z, r1
    8bae:	2e 96       	adiw	r28, 0x0e	; 14
    8bb0:	0f b6       	in	r0, 0x3f	; 63
    8bb2:	f8 94       	cli
    8bb4:	de bf       	out	0x3e, r29	; 62
    8bb6:	0f be       	out	0x3f, r0	; 63
    8bb8:	cd bf       	out	0x3d, r28	; 61
    8bba:	cf 91       	pop	r28
    8bbc:	df 91       	pop	r29
    8bbe:	1f 91       	pop	r17
    8bc0:	0f 91       	pop	r16
    8bc2:	08 95       	ret

00008bc4 <__ultoa_invert>:
    8bc4:	fa 01       	movw	r30, r20
    8bc6:	aa 27       	eor	r26, r26
    8bc8:	28 30       	cpi	r18, 0x08	; 8
    8bca:	51 f1       	breq	.+84     	; 0x8c20 <__ultoa_invert+0x5c>
    8bcc:	20 31       	cpi	r18, 0x10	; 16
    8bce:	81 f1       	breq	.+96     	; 0x8c30 <__ultoa_invert+0x6c>
    8bd0:	e8 94       	clt
    8bd2:	6f 93       	push	r22
    8bd4:	6e 7f       	andi	r22, 0xFE	; 254
    8bd6:	6e 5f       	subi	r22, 0xFE	; 254
    8bd8:	7f 4f       	sbci	r23, 0xFF	; 255
    8bda:	8f 4f       	sbci	r24, 0xFF	; 255
    8bdc:	9f 4f       	sbci	r25, 0xFF	; 255
    8bde:	af 4f       	sbci	r26, 0xFF	; 255
    8be0:	b1 e0       	ldi	r27, 0x01	; 1
    8be2:	3e d0       	rcall	.+124    	; 0x8c60 <__ultoa_invert+0x9c>
    8be4:	b4 e0       	ldi	r27, 0x04	; 4
    8be6:	3c d0       	rcall	.+120    	; 0x8c60 <__ultoa_invert+0x9c>
    8be8:	67 0f       	add	r22, r23
    8bea:	78 1f       	adc	r23, r24
    8bec:	89 1f       	adc	r24, r25
    8bee:	9a 1f       	adc	r25, r26
    8bf0:	a1 1d       	adc	r26, r1
    8bf2:	68 0f       	add	r22, r24
    8bf4:	79 1f       	adc	r23, r25
    8bf6:	8a 1f       	adc	r24, r26
    8bf8:	91 1d       	adc	r25, r1
    8bfa:	a1 1d       	adc	r26, r1
    8bfc:	6a 0f       	add	r22, r26
    8bfe:	71 1d       	adc	r23, r1
    8c00:	81 1d       	adc	r24, r1
    8c02:	91 1d       	adc	r25, r1
    8c04:	a1 1d       	adc	r26, r1
    8c06:	20 d0       	rcall	.+64     	; 0x8c48 <__ultoa_invert+0x84>
    8c08:	09 f4       	brne	.+2      	; 0x8c0c <__ultoa_invert+0x48>
    8c0a:	68 94       	set
    8c0c:	3f 91       	pop	r19
    8c0e:	2a e0       	ldi	r18, 0x0A	; 10
    8c10:	26 9f       	mul	r18, r22
    8c12:	11 24       	eor	r1, r1
    8c14:	30 19       	sub	r19, r0
    8c16:	30 5d       	subi	r19, 0xD0	; 208
    8c18:	31 93       	st	Z+, r19
    8c1a:	de f6       	brtc	.-74     	; 0x8bd2 <__ultoa_invert+0xe>
    8c1c:	cf 01       	movw	r24, r30
    8c1e:	08 95       	ret
    8c20:	46 2f       	mov	r20, r22
    8c22:	47 70       	andi	r20, 0x07	; 7
    8c24:	40 5d       	subi	r20, 0xD0	; 208
    8c26:	41 93       	st	Z+, r20
    8c28:	b3 e0       	ldi	r27, 0x03	; 3
    8c2a:	0f d0       	rcall	.+30     	; 0x8c4a <__ultoa_invert+0x86>
    8c2c:	c9 f7       	brne	.-14     	; 0x8c20 <__ultoa_invert+0x5c>
    8c2e:	f6 cf       	rjmp	.-20     	; 0x8c1c <__ultoa_invert+0x58>
    8c30:	46 2f       	mov	r20, r22
    8c32:	4f 70       	andi	r20, 0x0F	; 15
    8c34:	40 5d       	subi	r20, 0xD0	; 208
    8c36:	4a 33       	cpi	r20, 0x3A	; 58
    8c38:	18 f0       	brcs	.+6      	; 0x8c40 <__ultoa_invert+0x7c>
    8c3a:	49 5d       	subi	r20, 0xD9	; 217
    8c3c:	31 fd       	sbrc	r19, 1
    8c3e:	40 52       	subi	r20, 0x20	; 32
    8c40:	41 93       	st	Z+, r20
    8c42:	02 d0       	rcall	.+4      	; 0x8c48 <__ultoa_invert+0x84>
    8c44:	a9 f7       	brne	.-22     	; 0x8c30 <__ultoa_invert+0x6c>
    8c46:	ea cf       	rjmp	.-44     	; 0x8c1c <__ultoa_invert+0x58>
    8c48:	b4 e0       	ldi	r27, 0x04	; 4
    8c4a:	a6 95       	lsr	r26
    8c4c:	97 95       	ror	r25
    8c4e:	87 95       	ror	r24
    8c50:	77 95       	ror	r23
    8c52:	67 95       	ror	r22
    8c54:	ba 95       	dec	r27
    8c56:	c9 f7       	brne	.-14     	; 0x8c4a <__ultoa_invert+0x86>
    8c58:	00 97       	sbiw	r24, 0x00	; 0
    8c5a:	61 05       	cpc	r22, r1
    8c5c:	71 05       	cpc	r23, r1
    8c5e:	08 95       	ret
    8c60:	9b 01       	movw	r18, r22
    8c62:	ac 01       	movw	r20, r24
    8c64:	0a 2e       	mov	r0, r26
    8c66:	06 94       	lsr	r0
    8c68:	57 95       	ror	r21
    8c6a:	47 95       	ror	r20
    8c6c:	37 95       	ror	r19
    8c6e:	27 95       	ror	r18
    8c70:	ba 95       	dec	r27
    8c72:	c9 f7       	brne	.-14     	; 0x8c66 <__ultoa_invert+0xa2>
    8c74:	62 0f       	add	r22, r18
    8c76:	73 1f       	adc	r23, r19
    8c78:	84 1f       	adc	r24, r20
    8c7a:	95 1f       	adc	r25, r21
    8c7c:	a0 1d       	adc	r26, r0
    8c7e:	08 95       	ret

00008c80 <__eerd_block_m1284p>:
    8c80:	dc 01       	movw	r26, r24
    8c82:	cb 01       	movw	r24, r22

00008c84 <__eerd_blraw_m1284p>:
    8c84:	fc 01       	movw	r30, r24
    8c86:	f9 99       	sbic	0x1f, 1	; 31
    8c88:	fe cf       	rjmp	.-4      	; 0x8c86 <__eerd_blraw_m1284p+0x2>
    8c8a:	06 c0       	rjmp	.+12     	; 0x8c98 <__eerd_blraw_m1284p+0x14>
    8c8c:	f2 bd       	out	0x22, r31	; 34
    8c8e:	e1 bd       	out	0x21, r30	; 33
    8c90:	f8 9a       	sbi	0x1f, 0	; 31
    8c92:	31 96       	adiw	r30, 0x01	; 1
    8c94:	00 b4       	in	r0, 0x20	; 32
    8c96:	0d 92       	st	X+, r0
    8c98:	41 50       	subi	r20, 0x01	; 1
    8c9a:	50 40       	sbci	r21, 0x00	; 0
    8c9c:	b8 f7       	brcc	.-18     	; 0x8c8c <__eerd_blraw_m1284p+0x8>
    8c9e:	08 95       	ret

00008ca0 <__eeupd_block_m1284p>:
    8ca0:	dc 01       	movw	r26, r24
    8ca2:	a4 0f       	add	r26, r20
    8ca4:	b5 1f       	adc	r27, r21
    8ca6:	41 50       	subi	r20, 0x01	; 1
    8ca8:	50 40       	sbci	r21, 0x00	; 0
    8caa:	48 f0       	brcs	.+18     	; 0x8cbe <__eeupd_block_m1284p+0x1e>
    8cac:	cb 01       	movw	r24, r22
    8cae:	84 0f       	add	r24, r20
    8cb0:	95 1f       	adc	r25, r21
    8cb2:	2e 91       	ld	r18, -X
    8cb4:	0e 94 61 46 	call	0x8cc2	; 0x8cc2 <__eeupd_r18_m1284p>
    8cb8:	41 50       	subi	r20, 0x01	; 1
    8cba:	50 40       	sbci	r21, 0x00	; 0
    8cbc:	d0 f7       	brcc	.-12     	; 0x8cb2 <__eeupd_block_m1284p+0x12>
    8cbe:	08 95       	ret

00008cc0 <__eeupd_byte_m1284p>:
    8cc0:	26 2f       	mov	r18, r22

00008cc2 <__eeupd_r18_m1284p>:
    8cc2:	f9 99       	sbic	0x1f, 1	; 31
    8cc4:	fe cf       	rjmp	.-4      	; 0x8cc2 <__eeupd_r18_m1284p>
    8cc6:	92 bd       	out	0x22, r25	; 34
    8cc8:	81 bd       	out	0x21, r24	; 33
    8cca:	f8 9a       	sbi	0x1f, 0	; 31
    8ccc:	01 97       	sbiw	r24, 0x01	; 1
    8cce:	00 b4       	in	r0, 0x20	; 32
    8cd0:	02 16       	cp	r0, r18
    8cd2:	39 f0       	breq	.+14     	; 0x8ce2 <__eeupd_r18_m1284p+0x20>
    8cd4:	1f ba       	out	0x1f, r1	; 31
    8cd6:	20 bd       	out	0x20, r18	; 32
    8cd8:	0f b6       	in	r0, 0x3f	; 63
    8cda:	f8 94       	cli
    8cdc:	fa 9a       	sbi	0x1f, 2	; 31
    8cde:	f9 9a       	sbi	0x1f, 1	; 31
    8ce0:	0f be       	out	0x3f, r0	; 63
    8ce2:	08 95       	ret

00008ce4 <strtod>:
    8ce4:	8f 92       	push	r8
    8ce6:	9f 92       	push	r9
    8ce8:	af 92       	push	r10
    8cea:	bf 92       	push	r11
    8cec:	cf 92       	push	r12
    8cee:	df 92       	push	r13
    8cf0:	ef 92       	push	r14
    8cf2:	ff 92       	push	r15
    8cf4:	0f 93       	push	r16
    8cf6:	1f 93       	push	r17
    8cf8:	cf 93       	push	r28
    8cfa:	df 93       	push	r29
    8cfc:	ec 01       	movw	r28, r24
    8cfe:	5b 01       	movw	r10, r22
    8d00:	61 15       	cp	r22, r1
    8d02:	71 05       	cpc	r23, r1
    8d04:	19 f0       	breq	.+6      	; 0x8d0c <strtod+0x28>
    8d06:	fb 01       	movw	r30, r22
    8d08:	91 83       	std	Z+1, r25	; 0x01
    8d0a:	80 83       	st	Z, r24
    8d0c:	f9 90       	ld	r15, Y+
    8d0e:	8f 2d       	mov	r24, r15
    8d10:	90 e0       	ldi	r25, 0x00	; 0
    8d12:	0e 94 1c 45 	call	0x8a38	; 0x8a38 <isspace>
    8d16:	89 2b       	or	r24, r25
    8d18:	c9 f7       	brne	.-14     	; 0x8d0c <strtod+0x28>
    8d1a:	fd e2       	ldi	r31, 0x2D	; 45
    8d1c:	ff 16       	cp	r15, r31
    8d1e:	21 f4       	brne	.+8      	; 0x8d28 <strtod+0x44>
    8d20:	f9 90       	ld	r15, Y+
    8d22:	ee 24       	eor	r14, r14
    8d24:	e3 94       	inc	r14
    8d26:	05 c0       	rjmp	.+10     	; 0x8d32 <strtod+0x4e>
    8d28:	2b e2       	ldi	r18, 0x2B	; 43
    8d2a:	f2 16       	cp	r15, r18
    8d2c:	09 f4       	brne	.+2      	; 0x8d30 <strtod+0x4c>
    8d2e:	f9 90       	ld	r15, Y+
    8d30:	ee 24       	eor	r14, r14
    8d32:	8e 01       	movw	r16, r28
    8d34:	01 50       	subi	r16, 0x01	; 1
    8d36:	10 40       	sbci	r17, 0x00	; 0
    8d38:	c8 01       	movw	r24, r16
    8d3a:	62 e0       	ldi	r22, 0x02	; 2
    8d3c:	76 e0       	ldi	r23, 0x06	; 6
    8d3e:	43 e0       	ldi	r20, 0x03	; 3
    8d40:	50 e0       	ldi	r21, 0x00	; 0
    8d42:	0e 94 e3 47 	call	0x8fc6	; 0x8fc6 <strncasecmp_P>
    8d46:	89 2b       	or	r24, r25
    8d48:	01 f5       	brne	.+64     	; 0x8d8a <strtod+0xa6>
    8d4a:	8e 01       	movw	r16, r28
    8d4c:	0e 5f       	subi	r16, 0xFE	; 254
    8d4e:	1f 4f       	sbci	r17, 0xFF	; 255
    8d50:	c8 01       	movw	r24, r16
    8d52:	65 e0       	ldi	r22, 0x05	; 5
    8d54:	76 e0       	ldi	r23, 0x06	; 6
    8d56:	45 e0       	ldi	r20, 0x05	; 5
    8d58:	50 e0       	ldi	r21, 0x00	; 0
    8d5a:	0e 94 e3 47 	call	0x8fc6	; 0x8fc6 <strncasecmp_P>
    8d5e:	89 2b       	or	r24, r25
    8d60:	19 f4       	brne	.+6      	; 0x8d68 <strtod+0x84>
    8d62:	8e 01       	movw	r16, r28
    8d64:	09 5f       	subi	r16, 0xF9	; 249
    8d66:	1f 4f       	sbci	r17, 0xFF	; 255
    8d68:	a1 14       	cp	r10, r1
    8d6a:	b1 04       	cpc	r11, r1
    8d6c:	19 f0       	breq	.+6      	; 0x8d74 <strtod+0x90>
    8d6e:	f5 01       	movw	r30, r10
    8d70:	11 83       	std	Z+1, r17	; 0x01
    8d72:	00 83       	st	Z, r16
    8d74:	e0 fc       	sbrc	r14, 0
    8d76:	04 c0       	rjmp	.+8      	; 0x8d80 <strtod+0x9c>
    8d78:	70 e0       	ldi	r23, 0x00	; 0
    8d7a:	90 e0       	ldi	r25, 0x00	; 0
    8d7c:	80 e8       	ldi	r24, 0x80	; 128
    8d7e:	14 c0       	rjmp	.+40     	; 0x8da8 <strtod+0xc4>
    8d80:	70 e0       	ldi	r23, 0x00	; 0
    8d82:	90 e0       	ldi	r25, 0x00	; 0
    8d84:	80 e8       	ldi	r24, 0x80	; 128
    8d86:	6f ef       	ldi	r22, 0xFF	; 255
    8d88:	08 c1       	rjmp	.+528    	; 0x8f9a <strtod+0x2b6>
    8d8a:	c8 01       	movw	r24, r16
    8d8c:	6a e0       	ldi	r22, 0x0A	; 10
    8d8e:	76 e0       	ldi	r23, 0x06	; 6
    8d90:	43 e0       	ldi	r20, 0x03	; 3
    8d92:	50 e0       	ldi	r21, 0x00	; 0
    8d94:	0e 94 e3 47 	call	0x8fc6	; 0x8fc6 <strncasecmp_P>
    8d98:	89 2b       	or	r24, r25
    8d9a:	69 f4       	brne	.+26     	; 0x8db6 <strtod+0xd2>
    8d9c:	a1 14       	cp	r10, r1
    8d9e:	b1 04       	cpc	r11, r1
    8da0:	29 f4       	brne	.+10     	; 0x8dac <strtod+0xc8>
    8da2:	70 e0       	ldi	r23, 0x00	; 0
    8da4:	90 e0       	ldi	r25, 0x00	; 0
    8da6:	80 ec       	ldi	r24, 0xC0	; 192
    8da8:	6f e7       	ldi	r22, 0x7F	; 127
    8daa:	f7 c0       	rjmp	.+494    	; 0x8f9a <strtod+0x2b6>
    8dac:	22 96       	adiw	r28, 0x02	; 2
    8dae:	f5 01       	movw	r30, r10
    8db0:	d1 83       	std	Z+1, r29	; 0x01
    8db2:	c0 83       	st	Z, r28
    8db4:	f6 cf       	rjmp	.-20     	; 0x8da2 <strtod+0xbe>
    8db6:	88 24       	eor	r8, r8
    8db8:	99 24       	eor	r9, r9
    8dba:	40 e0       	ldi	r20, 0x00	; 0
    8dbc:	50 e0       	ldi	r21, 0x00	; 0
    8dbe:	60 e0       	ldi	r22, 0x00	; 0
    8dc0:	70 e0       	ldi	r23, 0x00	; 0
    8dc2:	ef 2d       	mov	r30, r15
    8dc4:	e0 53       	subi	r30, 0x30	; 48
    8dc6:	ea 30       	cpi	r30, 0x0A	; 10
    8dc8:	a0 f5       	brcc	.+104    	; 0x8e32 <strtod+0x14e>
    8dca:	f2 e0       	ldi	r31, 0x02	; 2
    8dcc:	ef 2a       	or	r14, r31
    8dce:	8e 2d       	mov	r24, r14
    8dd0:	90 e0       	ldi	r25, 0x00	; 0
    8dd2:	9c 01       	movw	r18, r24
    8dd4:	28 70       	andi	r18, 0x08	; 8
    8dd6:	30 70       	andi	r19, 0x00	; 0
    8dd8:	e2 fe       	sbrs	r14, 2
    8dda:	06 c0       	rjmp	.+12     	; 0x8de8 <strtod+0x104>
    8ddc:	23 2b       	or	r18, r19
    8dde:	79 f5       	brne	.+94     	; 0x8e3e <strtod+0x15a>
    8de0:	08 94       	sec
    8de2:	81 1c       	adc	r8, r1
    8de4:	91 1c       	adc	r9, r1
    8de6:	2b c0       	rjmp	.+86     	; 0x8e3e <strtod+0x15a>
    8de8:	23 2b       	or	r18, r19
    8dea:	19 f0       	breq	.+6      	; 0x8df2 <strtod+0x10e>
    8dec:	08 94       	sec
    8dee:	81 08       	sbc	r8, r1
    8df0:	91 08       	sbc	r9, r1
    8df2:	db 01       	movw	r26, r22
    8df4:	ca 01       	movw	r24, r20
    8df6:	12 e0       	ldi	r17, 0x02	; 2
    8df8:	88 0f       	add	r24, r24
    8dfa:	99 1f       	adc	r25, r25
    8dfc:	aa 1f       	adc	r26, r26
    8dfe:	bb 1f       	adc	r27, r27
    8e00:	1a 95       	dec	r17
    8e02:	d1 f7       	brne	.-12     	; 0x8df8 <strtod+0x114>
    8e04:	48 0f       	add	r20, r24
    8e06:	59 1f       	adc	r21, r25
    8e08:	6a 1f       	adc	r22, r26
    8e0a:	7b 1f       	adc	r23, r27
    8e0c:	44 0f       	add	r20, r20
    8e0e:	55 1f       	adc	r21, r21
    8e10:	66 1f       	adc	r22, r22
    8e12:	77 1f       	adc	r23, r23
    8e14:	4e 0f       	add	r20, r30
    8e16:	51 1d       	adc	r21, r1
    8e18:	61 1d       	adc	r22, r1
    8e1a:	71 1d       	adc	r23, r1
    8e1c:	48 39       	cpi	r20, 0x98	; 152
    8e1e:	29 e9       	ldi	r18, 0x99	; 153
    8e20:	52 07       	cpc	r21, r18
    8e22:	29 e9       	ldi	r18, 0x99	; 153
    8e24:	62 07       	cpc	r22, r18
    8e26:	29 e1       	ldi	r18, 0x19	; 25
    8e28:	72 07       	cpc	r23, r18
    8e2a:	48 f0       	brcs	.+18     	; 0x8e3e <strtod+0x15a>
    8e2c:	84 e0       	ldi	r24, 0x04	; 4
    8e2e:	e8 2a       	or	r14, r24
    8e30:	06 c0       	rjmp	.+12     	; 0x8e3e <strtod+0x15a>
    8e32:	ee 3f       	cpi	r30, 0xFE	; 254
    8e34:	31 f4       	brne	.+12     	; 0x8e42 <strtod+0x15e>
    8e36:	e3 fc       	sbrc	r14, 3
    8e38:	39 c0       	rjmp	.+114    	; 0x8eac <strtod+0x1c8>
    8e3a:	98 e0       	ldi	r25, 0x08	; 8
    8e3c:	e9 2a       	or	r14, r25
    8e3e:	f9 90       	ld	r15, Y+
    8e40:	c0 cf       	rjmp	.-128    	; 0x8dc2 <strtod+0xde>
    8e42:	e5 33       	cpi	r30, 0x35	; 53
    8e44:	11 f0       	breq	.+4      	; 0x8e4a <strtod+0x166>
    8e46:	e5 31       	cpi	r30, 0x15	; 21
    8e48:	89 f5       	brne	.+98     	; 0x8eac <strtod+0x1c8>
    8e4a:	29 91       	ld	r18, Y+
    8e4c:	2d 32       	cpi	r18, 0x2D	; 45
    8e4e:	19 f4       	brne	.+6      	; 0x8e56 <strtod+0x172>
    8e50:	e0 e1       	ldi	r30, 0x10	; 16
    8e52:	ee 2a       	or	r14, r30
    8e54:	05 c0       	rjmp	.+10     	; 0x8e60 <strtod+0x17c>
    8e56:	2b 32       	cpi	r18, 0x2B	; 43
    8e58:	19 f0       	breq	.+6      	; 0x8e60 <strtod+0x17c>
    8e5a:	81 e0       	ldi	r24, 0x01	; 1
    8e5c:	90 e0       	ldi	r25, 0x00	; 0
    8e5e:	03 c0       	rjmp	.+6      	; 0x8e66 <strtod+0x182>
    8e60:	29 91       	ld	r18, Y+
    8e62:	82 e0       	ldi	r24, 0x02	; 2
    8e64:	90 e0       	ldi	r25, 0x00	; 0
    8e66:	e2 2f       	mov	r30, r18
    8e68:	e0 53       	subi	r30, 0x30	; 48
    8e6a:	ea 30       	cpi	r30, 0x0A	; 10
    8e6c:	18 f0       	brcs	.+6      	; 0x8e74 <strtod+0x190>
    8e6e:	c8 1b       	sub	r28, r24
    8e70:	d9 0b       	sbc	r29, r25
    8e72:	1c c0       	rjmp	.+56     	; 0x8eac <strtod+0x1c8>
    8e74:	20 e0       	ldi	r18, 0x00	; 0
    8e76:	30 e0       	ldi	r19, 0x00	; 0
    8e78:	fc e0       	ldi	r31, 0x0C	; 12
    8e7a:	20 38       	cpi	r18, 0x80	; 128
    8e7c:	3f 07       	cpc	r19, r31
    8e7e:	5c f4       	brge	.+22     	; 0x8e96 <strtod+0x1b2>
    8e80:	c9 01       	movw	r24, r18
    8e82:	88 0f       	add	r24, r24
    8e84:	99 1f       	adc	r25, r25
    8e86:	88 0f       	add	r24, r24
    8e88:	99 1f       	adc	r25, r25
    8e8a:	28 0f       	add	r18, r24
    8e8c:	39 1f       	adc	r19, r25
    8e8e:	22 0f       	add	r18, r18
    8e90:	33 1f       	adc	r19, r19
    8e92:	2e 0f       	add	r18, r30
    8e94:	31 1d       	adc	r19, r1
    8e96:	e9 91       	ld	r30, Y+
    8e98:	e0 53       	subi	r30, 0x30	; 48
    8e9a:	ea 30       	cpi	r30, 0x0A	; 10
    8e9c:	68 f3       	brcs	.-38     	; 0x8e78 <strtod+0x194>
    8e9e:	e4 fe       	sbrs	r14, 4
    8ea0:	03 c0       	rjmp	.+6      	; 0x8ea8 <strtod+0x1c4>
    8ea2:	30 95       	com	r19
    8ea4:	21 95       	neg	r18
    8ea6:	3f 4f       	sbci	r19, 0xFF	; 255
    8ea8:	82 0e       	add	r8, r18
    8eaa:	93 1e       	adc	r9, r19
    8eac:	ce 2c       	mov	r12, r14
    8eae:	dd 24       	eor	r13, r13
    8eb0:	e1 fe       	sbrs	r14, 1
    8eb2:	07 c0       	rjmp	.+14     	; 0x8ec2 <strtod+0x1de>
    8eb4:	a1 14       	cp	r10, r1
    8eb6:	b1 04       	cpc	r11, r1
    8eb8:	21 f0       	breq	.+8      	; 0x8ec2 <strtod+0x1de>
    8eba:	21 97       	sbiw	r28, 0x01	; 1
    8ebc:	f5 01       	movw	r30, r10
    8ebe:	d1 83       	std	Z+1, r29	; 0x01
    8ec0:	c0 83       	st	Z, r28
    8ec2:	cb 01       	movw	r24, r22
    8ec4:	ba 01       	movw	r22, r20
    8ec6:	0e 94 3b 40 	call	0x8076	; 0x8076 <__floatunsisf>
    8eca:	7b 01       	movw	r14, r22
    8ecc:	8c 01       	movw	r16, r24
    8ece:	f3 e0       	ldi	r31, 0x03	; 3
    8ed0:	cf 22       	and	r12, r31
    8ed2:	dd 24       	eor	r13, r13
    8ed4:	23 e0       	ldi	r18, 0x03	; 3
    8ed6:	c2 16       	cp	r12, r18
    8ed8:	d1 04       	cpc	r13, r1
    8eda:	21 f4       	brne	.+8      	; 0x8ee4 <strtod+0x200>
    8edc:	17 fb       	bst	r17, 7
    8ede:	10 95       	com	r17
    8ee0:	17 f9       	bld	r17, 7
    8ee2:	10 95       	com	r17
    8ee4:	57 01       	movw	r10, r14
    8ee6:	68 01       	movw	r12, r16
    8ee8:	c8 01       	movw	r24, r16
    8eea:	b7 01       	movw	r22, r14
    8eec:	20 e0       	ldi	r18, 0x00	; 0
    8eee:	30 e0       	ldi	r19, 0x00	; 0
    8ef0:	40 e0       	ldi	r20, 0x00	; 0
    8ef2:	50 e0       	ldi	r21, 0x00	; 0
    8ef4:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <__cmpsf2>
    8ef8:	88 23       	and	r24, r24
    8efa:	09 f4       	brne	.+2      	; 0x8efe <strtod+0x21a>
    8efc:	4a c0       	rjmp	.+148    	; 0x8f92 <strtod+0x2ae>
    8efe:	97 fe       	sbrs	r9, 7
    8f00:	0d c0       	rjmp	.+26     	; 0x8f1c <strtod+0x238>
    8f02:	21 e2       	ldi	r18, 0x21	; 33
    8f04:	e2 2e       	mov	r14, r18
    8f06:	26 e0       	ldi	r18, 0x06	; 6
    8f08:	f2 2e       	mov	r15, r18
    8f0a:	90 94       	com	r9
    8f0c:	81 94       	neg	r8
    8f0e:	91 08       	sbc	r9, r1
    8f10:	93 94       	inc	r9
    8f12:	c0 e2       	ldi	r28, 0x20	; 32
    8f14:	d0 e0       	ldi	r29, 0x00	; 0
    8f16:	00 e0       	ldi	r16, 0x00	; 0
    8f18:	10 e0       	ldi	r17, 0x00	; 0
    8f1a:	12 c0       	rjmp	.+36     	; 0x8f40 <strtod+0x25c>
    8f1c:	99 e3       	ldi	r25, 0x39	; 57
    8f1e:	e9 2e       	mov	r14, r25
    8f20:	96 e0       	ldi	r25, 0x06	; 6
    8f22:	f9 2e       	mov	r15, r25
    8f24:	f6 cf       	rjmp	.-20     	; 0x8f12 <strtod+0x22e>
    8f26:	f7 01       	movw	r30, r14
    8f28:	25 91       	lpm	r18, Z+
    8f2a:	35 91       	lpm	r19, Z+
    8f2c:	45 91       	lpm	r20, Z+
    8f2e:	54 91       	lpm	r21, Z+
    8f30:	c6 01       	movw	r24, r12
    8f32:	b5 01       	movw	r22, r10
    8f34:	0e 94 44 41 	call	0x8288	; 0x8288 <__mulsf3>
    8f38:	5b 01       	movw	r10, r22
    8f3a:	6c 01       	movw	r12, r24
    8f3c:	8c 1a       	sub	r8, r28
    8f3e:	9d 0a       	sbc	r9, r29
    8f40:	8c 16       	cp	r8, r28
    8f42:	9d 06       	cpc	r9, r29
    8f44:	84 f7       	brge	.-32     	; 0x8f26 <strtod+0x242>
    8f46:	d5 95       	asr	r29
    8f48:	c7 95       	ror	r28
    8f4a:	0f 5f       	subi	r16, 0xFF	; 255
    8f4c:	1f 4f       	sbci	r17, 0xFF	; 255
    8f4e:	06 30       	cpi	r16, 0x06	; 6
    8f50:	11 05       	cpc	r17, r1
    8f52:	29 f0       	breq	.+10     	; 0x8f5e <strtod+0x27a>
    8f54:	8c ef       	ldi	r24, 0xFC	; 252
    8f56:	9f ef       	ldi	r25, 0xFF	; 255
    8f58:	e8 0e       	add	r14, r24
    8f5a:	f9 1e       	adc	r15, r25
    8f5c:	f1 cf       	rjmp	.-30     	; 0x8f40 <strtod+0x25c>
    8f5e:	c5 01       	movw	r24, r10
    8f60:	d6 01       	movw	r26, r12
    8f62:	7c 01       	movw	r14, r24
    8f64:	8d 01       	movw	r16, r26
    8f66:	8c 2d       	mov	r24, r12
    8f68:	88 0f       	add	r24, r24
    8f6a:	8d 2d       	mov	r24, r13
    8f6c:	88 1f       	adc	r24, r24
    8f6e:	8f 3f       	cpi	r24, 0xFF	; 255
    8f70:	51 f0       	breq	.+20     	; 0x8f86 <strtod+0x2a2>
    8f72:	c6 01       	movw	r24, r12
    8f74:	b5 01       	movw	r22, r10
    8f76:	20 e0       	ldi	r18, 0x00	; 0
    8f78:	30 e0       	ldi	r19, 0x00	; 0
    8f7a:	40 e0       	ldi	r20, 0x00	; 0
    8f7c:	50 e0       	ldi	r21, 0x00	; 0
    8f7e:	0e 94 9e 3f 	call	0x7f3c	; 0x7f3c <__cmpsf2>
    8f82:	88 23       	and	r24, r24
    8f84:	31 f4       	brne	.+12     	; 0x8f92 <strtod+0x2ae>
    8f86:	82 e2       	ldi	r24, 0x22	; 34
    8f88:	90 e0       	ldi	r25, 0x00	; 0
    8f8a:	90 93 9d 04 	sts	0x049D, r25
    8f8e:	80 93 9c 04 	sts	0x049C, r24
    8f92:	7e 2d       	mov	r23, r14
    8f94:	9f 2d       	mov	r25, r15
    8f96:	80 2f       	mov	r24, r16
    8f98:	61 2f       	mov	r22, r17
    8f9a:	27 2f       	mov	r18, r23
    8f9c:	39 2f       	mov	r19, r25
    8f9e:	48 2f       	mov	r20, r24
    8fa0:	56 2f       	mov	r21, r22
    8fa2:	b9 01       	movw	r22, r18
    8fa4:	ca 01       	movw	r24, r20
    8fa6:	df 91       	pop	r29
    8fa8:	cf 91       	pop	r28
    8faa:	1f 91       	pop	r17
    8fac:	0f 91       	pop	r16
    8fae:	ff 90       	pop	r15
    8fb0:	ef 90       	pop	r14
    8fb2:	df 90       	pop	r13
    8fb4:	cf 90       	pop	r12
    8fb6:	bf 90       	pop	r11
    8fb8:	af 90       	pop	r10
    8fba:	9f 90       	pop	r9
    8fbc:	8f 90       	pop	r8
    8fbe:	08 95       	ret

00008fc0 <__ctype_isfalse>:
    8fc0:	99 27       	eor	r25, r25
    8fc2:	88 27       	eor	r24, r24

00008fc4 <__ctype_istrue>:
    8fc4:	08 95       	ret

00008fc6 <strncasecmp_P>:
    8fc6:	fb 01       	movw	r30, r22
    8fc8:	dc 01       	movw	r26, r24
    8fca:	41 50       	subi	r20, 0x01	; 1
    8fcc:	50 40       	sbci	r21, 0x00	; 0
    8fce:	88 f0       	brcs	.+34     	; 0x8ff2 <strncasecmp_P+0x2c>
    8fd0:	8d 91       	ld	r24, X+
    8fd2:	81 34       	cpi	r24, 0x41	; 65
    8fd4:	1c f0       	brlt	.+6      	; 0x8fdc <strncasecmp_P+0x16>
    8fd6:	8b 35       	cpi	r24, 0x5B	; 91
    8fd8:	0c f4       	brge	.+2      	; 0x8fdc <strncasecmp_P+0x16>
    8fda:	80 5e       	subi	r24, 0xE0	; 224
    8fdc:	65 91       	lpm	r22, Z+
    8fde:	61 34       	cpi	r22, 0x41	; 65
    8fe0:	1c f0       	brlt	.+6      	; 0x8fe8 <strncasecmp_P+0x22>
    8fe2:	6b 35       	cpi	r22, 0x5B	; 91
    8fe4:	0c f4       	brge	.+2      	; 0x8fe8 <strncasecmp_P+0x22>
    8fe6:	60 5e       	subi	r22, 0xE0	; 224
    8fe8:	86 1b       	sub	r24, r22
    8fea:	61 11       	cpse	r22, r1
    8fec:	71 f3       	breq	.-36     	; 0x8fca <strncasecmp_P+0x4>
    8fee:	99 0b       	sbc	r25, r25
    8ff0:	08 95       	ret
    8ff2:	88 1b       	sub	r24, r24
    8ff4:	fc cf       	rjmp	.-8      	; 0x8fee <strncasecmp_P+0x28>

00008ff6 <__mulsi3>:
    8ff6:	62 9f       	mul	r22, r18
    8ff8:	d0 01       	movw	r26, r0
    8ffa:	73 9f       	mul	r23, r19
    8ffc:	f0 01       	movw	r30, r0
    8ffe:	82 9f       	mul	r24, r18
    9000:	e0 0d       	add	r30, r0
    9002:	f1 1d       	adc	r31, r1
    9004:	64 9f       	mul	r22, r20
    9006:	e0 0d       	add	r30, r0
    9008:	f1 1d       	adc	r31, r1
    900a:	92 9f       	mul	r25, r18
    900c:	f0 0d       	add	r31, r0
    900e:	83 9f       	mul	r24, r19
    9010:	f0 0d       	add	r31, r0
    9012:	74 9f       	mul	r23, r20
    9014:	f0 0d       	add	r31, r0
    9016:	65 9f       	mul	r22, r21
    9018:	f0 0d       	add	r31, r0
    901a:	99 27       	eor	r25, r25
    901c:	72 9f       	mul	r23, r18
    901e:	b0 0d       	add	r27, r0
    9020:	e1 1d       	adc	r30, r1
    9022:	f9 1f       	adc	r31, r25
    9024:	63 9f       	mul	r22, r19
    9026:	b0 0d       	add	r27, r0
    9028:	e1 1d       	adc	r30, r1
    902a:	f9 1f       	adc	r31, r25
    902c:	bd 01       	movw	r22, r26
    902e:	cf 01       	movw	r24, r30
    9030:	11 24       	eor	r1, r1
    9032:	08 95       	ret

00009034 <__udivmodsi4>:
    9034:	a1 e2       	ldi	r26, 0x21	; 33
    9036:	1a 2e       	mov	r1, r26
    9038:	aa 1b       	sub	r26, r26
    903a:	bb 1b       	sub	r27, r27
    903c:	fd 01       	movw	r30, r26
    903e:	0d c0       	rjmp	.+26     	; 0x905a <__udivmodsi4_ep>

00009040 <__udivmodsi4_loop>:
    9040:	aa 1f       	adc	r26, r26
    9042:	bb 1f       	adc	r27, r27
    9044:	ee 1f       	adc	r30, r30
    9046:	ff 1f       	adc	r31, r31
    9048:	a2 17       	cp	r26, r18
    904a:	b3 07       	cpc	r27, r19
    904c:	e4 07       	cpc	r30, r20
    904e:	f5 07       	cpc	r31, r21
    9050:	20 f0       	brcs	.+8      	; 0x905a <__udivmodsi4_ep>
    9052:	a2 1b       	sub	r26, r18
    9054:	b3 0b       	sbc	r27, r19
    9056:	e4 0b       	sbc	r30, r20
    9058:	f5 0b       	sbc	r31, r21

0000905a <__udivmodsi4_ep>:
    905a:	66 1f       	adc	r22, r22
    905c:	77 1f       	adc	r23, r23
    905e:	88 1f       	adc	r24, r24
    9060:	99 1f       	adc	r25, r25
    9062:	1a 94       	dec	r1
    9064:	69 f7       	brne	.-38     	; 0x9040 <__udivmodsi4_loop>
    9066:	60 95       	com	r22
    9068:	70 95       	com	r23
    906a:	80 95       	com	r24
    906c:	90 95       	com	r25
    906e:	9b 01       	movw	r18, r22
    9070:	ac 01       	movw	r20, r24
    9072:	bd 01       	movw	r22, r26
    9074:	cf 01       	movw	r24, r30
    9076:	08 95       	ret

00009078 <_exit>:
    9078:	f8 94       	cli

0000907a <__stop_program>:
    907a:	ff cf       	rjmp	.-2      	; 0x907a <__stop_program>
