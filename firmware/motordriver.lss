
motordriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000001d6  00800100  000090c8  0000917c  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000090c8  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001c8  008002d6  008002d6  00009352  2**0
                  ALLOC
  3 .eeprom       0000014b  00810000  00810000  00009352  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         0000759c  00000000  00000000  000094a0  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      000030b2  00000000  00000000  00010a3c  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 1f 03 	jmp	0x63e	; 0x63e <__ctors_end>
       4:	0c 94 d9 0d 	jmp	0x1bb2	; 0x1bb2 <__vector_1>
       8:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
       c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      10:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      14:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      18:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      1c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      20:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      24:	0c 94 b2 0f 	jmp	0x1f64	; 0x1f64 <__vector_9>
      28:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      2c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      30:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      34:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      38:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      3c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      40:	0c 94 82 0d 	jmp	0x1b04	; 0x1b04 <__vector_16>
      44:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      48:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      4c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      50:	0c 94 34 0d 	jmp	0x1a68	; 0x1a68 <__vector_20>
      54:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      58:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      5c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      60:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      64:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      68:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      6c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      70:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      74:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      78:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      7c:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      80:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      84:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      88:	0c 94 3e 03 	jmp	0x67c	; 0x67c <__bad_interrupt>
      8c:	fe 38       	cpi	r31, 0x8E	; 142
      8e:	ed 38       	cpi	r30, 0x8D	; 141
      90:	d5 38       	cpi	r29, 0x85	; 133
      92:	c8 38       	cpi	r28, 0x88	; 136
      94:	bb 38       	cpi	r27, 0x8B	; 139
      96:	b0 38       	cpi	r27, 0x80	; 128
      98:	a5 38       	cpi	r26, 0x85	; 133
      9a:	98 38       	cpi	r25, 0x88	; 136
      9c:	95 38       	cpi	r25, 0x85	; 133
      9e:	90 38       	cpi	r25, 0x80	; 128
      a0:	85 38       	cpi	r24, 0x85	; 133
      a2:	7a 38       	cpi	r23, 0x8A	; 138
      a4:	6f 38       	cpi	r22, 0x8F	; 143
      a6:	64 38       	cpi	r22, 0x84	; 132
      a8:	59 38       	cpi	r21, 0x89	; 137
      aa:	4e 38       	cpi	r20, 0x8E	; 142
      ac:	43 38       	cpi	r20, 0x83	; 131
      ae:	38 38       	cpi	r19, 0x88	; 136
      b0:	2d 38       	cpi	r18, 0x8D	; 141
      b2:	22 38       	cpi	r18, 0x82	; 130
      b4:	17 38       	cpi	r17, 0x87	; 135
      b6:	0c 38       	cpi	r16, 0x8C	; 140
      b8:	ff 37       	cpi	r31, 0x7F	; 127
      ba:	f9 37       	cpi	r31, 0x79	; 121
      bc:	ba 37       	cpi	r27, 0x7A	; 122
      be:	ad 37       	cpi	r26, 0x7D	; 125
      c0:	a2 37       	cpi	r26, 0x72	; 114
      c2:	8f 37       	cpi	r24, 0x7F	; 127
      c4:	86 37       	cpi	r24, 0x76	; 118
      c6:	83 37       	cpi	r24, 0x73	; 115
      c8:	76 37       	cpi	r23, 0x76	; 118
      ca:	6b 37       	cpi	r22, 0x7B	; 123
      cc:	60 37       	cpi	r22, 0x70	; 112
      ce:	55 37       	cpi	r21, 0x75	; 117
      d0:	4a 37       	cpi	r20, 0x7A	; 122
      d2:	02 39       	cpi	r16, 0x92	; 146

000000d4 <table>:
      d4:	00 00 00 00 ff ff 00 00 00 00 00 00 00 00 01 00     ................
      e4:	01 00 00 00 00 00 00 00 00 00 ff ff 00 00 00 00     ................

000000f4 <cmd_0_name>:
	...

000000f6 <cmd_0_>:
      f6:	f4 00 00 80                                         ....

000000fa <cmd_1_name>:
      fa:	2a 52 53 54 00 00                                   *RST..

00000100 <cmd_1_>:
     100:	fa 00 00 81                                         ....

00000104 <cmd_2_name>:
     104:	2a 49 44 4e 3f 00 00                                *IDN?..

0000010b <cmd_2_>:
     10b:	04 01 00 82                                         ....

0000010f <cmd_3_name>:
     10f:	2a 49 44 4e 00 00                                   *IDN..

00000115 <cmd_3_>:
     115:	0f 01 01 83                                         ....

00000119 <cmd_4_name>:
     119:	4d 4f 56 45 41 42 53 00 00                          MOVEABS..

00000122 <cmd_4_>:
     122:	19 01 03 84                                         ....

00000126 <cmd_5_name>:
     126:	4d 4f 56 45 52 45 4c 00 00                          MOVEREL..

0000012f <cmd_5_>:
     12f:	26 01 03 85                                         &...

00000133 <cmd_6_name>:
     133:	5a 45 52 4f 52 55 4e 00 00                          ZERORUN..

0000013c <cmd_6_>:
     13c:	33 01 01 86                                         3...

00000140 <cmd_7_name>:
     140:	45 4e 41 42 4c 45 00 00                             ENABLE..

00000148 <cmd_7_>:
     148:	40 01 02 87                                         @...

0000014c <cmd_8_name>:
     14c:	47 45 54 50 4f 53 00 00                             GETPOS..

00000154 <cmd_8_>:
     154:	4c 01 02 88                                         L...

00000158 <cmd_9_name>:
     158:	53 41 56 45 43 4f 4e 46 00 00                       SAVECONF..

00000162 <cmd_9_>:
     162:	58 01 00 89                                         X...

00000166 <cmd_10_name>:
     166:	4c 4f 41 44 43 4f 4e 46 00 00                       LOADCONF..

00000170 <cmd_10_>:
     170:	66 01 00 8a                                         f...

00000174 <cmd_11_name>:
     174:	49 53 4d 4f 56 49 4e 47 00 00                       ISMOVING..

0000017e <cmd_11_>:
     17e:	74 01 01 8b                                         t...

00000182 <cmd_12_name>:
     182:	47 45 54 41 4e 41 4c 4f 47 00 00                    GETANALOG..

0000018d <cmd_12_>:
     18d:	82 01 01 8c                                         ....

00000191 <cmd_13_name>:
     191:	47 45 54 5a 45 52 4f 50 4f 53 00 00                 GETZEROPOS..

0000019d <cmd_13_>:
     19d:	91 01 01 8d                                         ....

000001a1 <cmd_14_name>:
     1a1:	53 45 54 5a 45 52 4f 50 4f 53 00 00                 SETZEROPOS..

000001ad <cmd_14_>:
     1ad:	a1 01 02 8e                                         ....

000001b1 <cmd_15_name>:
     1b1:	47 45 54 47 45 41 52 52 41 54 49 4f 00 00           GETGEARRATIO..

000001bf <cmd_15_>:
     1bf:	b1 01 01 8f                                         ....

000001c3 <cmd_16_name>:
     1c3:	53 45 54 47 45 41 52 52 41 54 49 4f 00 00           SETGEARRATIO..

000001d1 <cmd_16_>:
     1d1:	c3 01 02 90                                         ....

000001d5 <cmd_17_name>:
     1d5:	47 45 54 46 55 4c 4c 52 4f 54 00 00                 GETFULLROT..

000001e1 <cmd_17_>:
     1e1:	d5 01 01 91                                         ....

000001e5 <cmd_18_name>:
     1e5:	53 45 54 46 55 4c 4c 52 4f 54 00 00                 SETFULLROT..

000001f1 <cmd_18_>:
     1f1:	e5 01 02 92                                         ....

000001f5 <cmd_19_name>:
     1f5:	47 45 54 53 55 42 53 54 45 50 53 00 00              GETSUBSTEPS..

00000202 <cmd_19_>:
     202:	f5 01 01 93                                         ....

00000206 <cmd_20_name>:
     206:	53 45 54 53 55 42 53 54 45 50 53 00 00              SETSUBSTEPS..

00000213 <cmd_20_>:
     213:	06 02 02 94                                         ....

00000217 <cmd_21_name>:
     217:	47 45 54 57 41 49 54 54 49 4d 45 00 00              GETWAITTIME..

00000224 <cmd_21_>:
     224:	17 02 01 95                                         ....

00000228 <cmd_22_name>:
     228:	53 45 54 57 41 49 54 54 49 4d 45 00 00              SETWAITTIME..

00000235 <cmd_22_>:
     235:	28 02 02 96                                         (...

00000239 <cmd_23_name>:
     239:	53 45 54 43 4f 4e 53 54 53 50 45 45 44 00 00        SETCONSTSPEED..

00000248 <cmd_23_>:
     248:	39 02 03 97                                         9...

0000024c <cmd_24_name>:
     24c:	46 41 43 54 4f 52 59 52 45 53 45 54 00 00           FACTORYRESET..

0000025a <cmd_24_>:
     25a:	4c 02 00 98                                         L...

0000025e <cmd_25_name>:
     25e:	53 54 4f 50 41 4c 4c 00 00                          STOPALL..

00000267 <cmd_25_>:
     267:	5e 02 00 99                                         ^...

0000026b <cmd_26_name>:
     26b:	53 45 54 46 4f 52 42 5a 4f 4e 45 00 00              SETFORBZONE..

00000278 <cmd_26_>:
     278:	6b 02 03 9a                                         k...

0000027c <cmd_27_name>:
     27c:	45 4e 41 42 46 4f 52 42 5a 4f 4e 45 00 00           ENABFORBZONE..

0000028a <cmd_27_>:
     28a:	7c 02 02 9b                                         |...

0000028e <cmd_28_name>:
     28e:	53 45 54 50 52 4f 47 53 54 45 50 00 00              SETPROGSTEP..

0000029b <cmd_28_>:
     29b:	8e 02 06 9c                                         ....

0000029f <cmd_29_name>:
     29f:	47 45 54 4d 4f 54 53 54 41 54 45 00 00              GETMOTSTATE..

000002ac <cmd_29_>:
     2ac:	9f 02 01 9d                                         ....

000002b0 <cmd_30_name>:
     2b0:	44 42 47 52 45 41 44 4f 55 54 00 00                 DBGREADOUT..

000002bc <cmd_30_>:
     2bc:	b0 02 00 9e                                         ....

000002c0 <cmd_31_name>:
     2c0:	4c 45 44 00 00                                      LED..

000002c5 <cmd_31_>:
     2c5:	c0 02 03 9f                                         ....

000002c9 <cmd_32_name>:
     2c9:	47 45 54 43 55 52 52 00 00                          GETCURR..

000002d2 <cmd_32_>:
     2d2:	c9 02 01 a0                                         ....

000002d6 <cmd_33_name>:
     2d6:	53 45 54 43 55 52 52 00 00                          SETCURR..

000002df <cmd_33_>:
     2df:	d6 02 02 a1                                         ....

000002e3 <cmd_34_name>:
     2e3:	47 45 54 44 45 43 41 59 00 00                       GETDECAY..

000002ed <cmd_34_>:
     2ed:	e3 02 01 a2                                         ....

000002f1 <cmd_35_name>:
     2f1:	53 45 54 44 45 43 41 59 00 00                       SETDECAY..

000002fb <cmd_35_>:
     2fb:	f1 02 02 a3                                         ....

000002ff <cmd_36_name>:
     2ff:	49 53 43 4f 4e 00 00                                ISCON..

00000306 <cmd_36_>:
     306:	ff 02 01 a4                                         ....

0000030a <commandList>:
     30a:	f6 00 00 01 0b 01 15 01 22 01 2f 01 3c 01 48 01     ........"./.<.H.
     31a:	54 01 62 01 70 01 7e 01 8d 01 9d 01 ad 01 bf 01     T.b.p.~.........
     32a:	d1 01 e1 01 f1 01 02 02 13 02 24 02 35 02 48 02     ..........$.5.H.
     33a:	5a 02 67 02 78 02 8a 02 9b 02 ac 02 bc 02 c5 02     Z.g.x...........
     34a:	d2 02 df 02 ed 02 fb 02 06 03                       ..........

00000354 <disp_0_text>:
     354:	4c 4b 2d 49 6e 73 74 72 75 6d 65 6e 74 73 0a 53     LK-Instruments.S
     364:	4d 43 34 32 34 32 00 00                             MC4242..

0000036c <disp_0_>:
     36c:	54 03 00                                            T..

0000036f <disp_1_text>:
     36f:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 70 6f 73     Change motor.pos
     37f:	69 74 69 6f 6e 00 00                                ition..

00000386 <disp_1_>:
     386:	6f 03 01                                            o..

00000389 <disp_2_text>:
     389:	53 65 74 20 73 74 65 70 0a 6d 75 6c 74 69 70 6c     Set step.multipl
     399:	69 65 72 00 00                                      ier..

0000039e <disp_2_>:
     39e:	89 03 02                                            ...

000003a1 <disp_3_text>:
     3a1:	43 68 61 6e 67 65 20 73 74 65 70 0a 75 6e 69 74     Change step.unit
	...

000003b3 <disp_3_>:
     3b3:	a1 03 03                                            ...

000003b6 <disp_4_text>:
     3b6:	52 75 6e 20 69 6e 74 65 72 6e 61 6c 0a 70 72 6f     Run internal.pro
     3c6:	67 72 61 6d 00 00                                   gram..

000003cc <disp_4_>:
     3cc:	b6 03 04                                            ...

000003cf <disp_5_text>:
     3cf:	52 75 6e 20 77 69 74 68 0a 63 6f 6e 73 74 61 6e     Run with.constan
     3df:	74 20 73 70 65 65 64 00 00                          t speed..

000003e8 <disp_5_>:
     3e8:	cf 03 05                                            ...

000003eb <disp_6_text>:
     3eb:	44 65 66 69 6e 65 20 7a 65 72 6f 0a 70 6f 73 69     Define zero.posi
     3fb:	74 69 6f 6e 00 00                                   tion..

00000401 <disp_6_>:
     401:	eb 03 06                                            ...

00000404 <disp_7_text>:
     404:	52 75 6e 20 7a 65 72 6f 0a 63 61 6c 69 62 72 61     Run zero.calibra
     414:	74 69 6f 6e 00 00                                   tion..

0000041a <disp_7_>:
     41a:	04 04 07                                            ...

0000041d <disp_8_text>:
     41d:	45 6e 74 65 72 0a 73 65 74 74 69 6e 67 73 20 6d     Enter.settings m
     42d:	65 6e 75 00 00                                      enu..

00000432 <disp_8_>:
     432:	1d 04 08                                            ...

00000435 <disp_9_text>:
     435:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     445:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
     455:	20 00 00                                             ..

00000458 <disp_9_>:
     458:	35 04 09                                            5..

0000045b <disp_10_text>:
     45b:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 73 75 62     Change motor.sub
     46b:	73 74 65 70 00 00                                   step..

00000471 <disp_10_>:
     471:	5b 04 0a                                            [..

00000474 <disp_11_text>:
     474:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 63 75 72     Change motor.cur
     484:	72 65 6e 74 00 00                                   rent..

0000048a <disp_11_>:
     48a:	74 04 0b                                            t..

0000048d <disp_12_text>:
     48d:	43 68 61 6e 67 65 20 73 74 65 70 0a 77 61 69 74     Change step.wait
     49d:	20 74 69 6d 65 00 00                                 time..

000004a4 <disp_12_>:
     4a4:	8d 04 0c                                            ...

000004a7 <disp_13_text>:
     4a7:	53 61 76 65 20 63 75 72 72 65 6e 74 0a 63 6f 6e     Save current.con
     4b7:	66 69 67 75 72 61 74 69 6f 6e 00 00                 figuration..

000004c3 <disp_13_>:
     4c3:	a7 04 0d                                            ...

000004c6 <disp_14_text>:
     4c6:	4c 6f 61 64 20 6c 61 73 74 0a 63 6f 6e 66 69 67     Load last.config
     4d6:	75 72 61 74 69 6f 6e 00 00                          uration..

000004df <disp_14_>:
     4df:	c6 04 0e                                            ...

000004e2 <menuList>:
     4e2:	6c 03 86 03 9e 03 b3 03 cc 03 e8 03 01 04 1a 04     l...............
     4f2:	32 04 58 04 71 04 8a 04 a4 04 c3 04 df 04           2.X.q.........

00000500 <__c.1790>:
     500:	6e 61 6e 00                                         nan.

00000504 <__c.1788>:
     504:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     514:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     524:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     534:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     544:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     554:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     564:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     574:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     584:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     594:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     5a4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     5b4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     5c4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     5d4:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     5e4:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     5f4:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000602 <pstr_inf>:
     602:	49 4e 46                                            INF

00000605 <pstr_inity>:
     605:	49 4e 49 54 59                                      INITY

0000060a <pstr_nan>:
     60a:	4e 41 4e                                            NAN

0000060d <pwr_m10>:
     60d:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     61d:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000625 <pwr_p10>:
     625:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     635:	ca 1b 0e 5a ae c5 9d 74 00                          ...Z...t.

0000063e <__ctors_end>:
     63e:	11 24       	eor	r1, r1
     640:	1f be       	out	0x3f, r1	; 63
     642:	cf ef       	ldi	r28, 0xFF	; 255
     644:	d0 e4       	ldi	r29, 0x40	; 64
     646:	de bf       	out	0x3e, r29	; 62
     648:	cd bf       	out	0x3d, r28	; 61

0000064a <__do_copy_data>:
     64a:	12 e0       	ldi	r17, 0x02	; 2
     64c:	a0 e0       	ldi	r26, 0x00	; 0
     64e:	b1 e0       	ldi	r27, 0x01	; 1
     650:	e8 ec       	ldi	r30, 0xC8	; 200
     652:	f0 e9       	ldi	r31, 0x90	; 144
     654:	00 e0       	ldi	r16, 0x00	; 0
     656:	0b bf       	out	0x3b, r16	; 59
     658:	02 c0       	rjmp	.+4      	; 0x65e <__do_copy_data+0x14>
     65a:	07 90       	elpm	r0, Z+
     65c:	0d 92       	st	X+, r0
     65e:	a6 3d       	cpi	r26, 0xD6	; 214
     660:	b1 07       	cpc	r27, r17
     662:	d9 f7       	brne	.-10     	; 0x65a <__do_copy_data+0x10>

00000664 <__do_clear_bss>:
     664:	14 e0       	ldi	r17, 0x04	; 4
     666:	a6 ed       	ldi	r26, 0xD6	; 214
     668:	b2 e0       	ldi	r27, 0x02	; 2
     66a:	01 c0       	rjmp	.+2      	; 0x66e <.do_clear_bss_start>

0000066c <.do_clear_bss_loop>:
     66c:	1d 92       	st	X+, r1

0000066e <.do_clear_bss_start>:
     66e:	ae 39       	cpi	r26, 0x9E	; 158
     670:	b1 07       	cpc	r27, r17
     672:	e1 f7       	brne	.-8      	; 0x66c <.do_clear_bss_loop>
     674:	0e 94 09 36 	call	0x6c12	; 0x6c12 <main>
     678:	0c 94 62 48 	jmp	0x90c4	; 0x90c4 <_exit>

0000067c <__bad_interrupt>:
     67c:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000680 <initDataStructs>:
====================================================================== */

/* ---------------------------------------------------------------------
    initialize the internal data memory
 --------------------------------------------------------------------- */
void initDataStructs(void){
     680:	2f 92       	push	r2
     682:	3f 92       	push	r3
     684:	4f 92       	push	r4
     686:	5f 92       	push	r5
     688:	6f 92       	push	r6
     68a:	7f 92       	push	r7
     68c:	8f 92       	push	r8
     68e:	9f 92       	push	r9
     690:	af 92       	push	r10
     692:	bf 92       	push	r11
     694:	cf 92       	push	r12
     696:	df 92       	push	r13
     698:	ef 92       	push	r14
     69a:	ff 92       	push	r15
     69c:	0f 93       	push	r16
     69e:	1f 93       	push	r17
     6a0:	40 e0       	ldi	r20, 0x00	; 0
     6a2:	50 e0       	ldi	r21, 0x00	; 0

  for(i = 0; i <= MAX_MOTOR; i++){
    motor[i].actualPosition       = 0;
    motor[i].desiredPosition      = 0;
    motor[i].opticalZeroPosition  = 0;
    motor[i].stepError            = 0.0f;
     6a4:	0f 2e       	mov	r0, r31
     6a6:	f0 e0       	ldi	r31, 0x00	; 0
     6a8:	6f 2e       	mov	r6, r31
     6aa:	f0 e0       	ldi	r31, 0x00	; 0
     6ac:	7f 2e       	mov	r7, r31
     6ae:	f0 e0       	ldi	r31, 0x00	; 0
     6b0:	8f 2e       	mov	r8, r31
     6b2:	f0 e0       	ldi	r31, 0x00	; 0
     6b4:	9f 2e       	mov	r9, r31
     6b6:	f0 2d       	mov	r31, r0
    motor[i].isMoving             = 0;
    motor[i].isTurnedOn           = 0;
    motor[i].isMovingInfinite     = MOTOR_MOVE_INFINITE_STOP;
    motor[i].gearRatio            = 60.0f/20.0f; /* TODO */
     6b8:	0f 2e       	mov	r0, r31
     6ba:	f0 e0       	ldi	r31, 0x00	; 0
     6bc:	2f 2e       	mov	r2, r31
     6be:	f0 e0       	ldi	r31, 0x00	; 0
     6c0:	3f 2e       	mov	r3, r31
     6c2:	f0 e4       	ldi	r31, 0x40	; 64
     6c4:	4f 2e       	mov	r4, r31
     6c6:	f0 e4       	ldi	r31, 0x40	; 64
     6c8:	5f 2e       	mov	r5, r31
     6ca:	f0 2d       	mov	r31, r0
    motor[i].stepsPerFullRotation = 400.0f;
    motor[i].subSteps             = 4.0f;
     6cc:	0f 2e       	mov	r0, r31
     6ce:	f0 e0       	ldi	r31, 0x00	; 0
     6d0:	af 2e       	mov	r10, r31
     6d2:	f0 e0       	ldi	r31, 0x00	; 0
     6d4:	bf 2e       	mov	r11, r31
     6d6:	f0 e8       	ldi	r31, 0x80	; 128
     6d8:	cf 2e       	mov	r12, r31
     6da:	f0 e4       	ldi	r31, 0x40	; 64
     6dc:	df 2e       	mov	r13, r31
     6de:	f0 2d       	mov	r31, r0
    motor[i].stepMultiplier       = 1.0f;
     6e0:	0f 2e       	mov	r0, r31
     6e2:	f0 e0       	ldi	r31, 0x00	; 0
     6e4:	ef 2e       	mov	r14, r31
     6e6:	f0 e0       	ldi	r31, 0x00	; 0
     6e8:	ff 2e       	mov	r15, r31
     6ea:	f0 e8       	ldi	r31, 0x80	; 128
     6ec:	0f 2f       	mov	r16, r31
     6ee:	ff e3       	ldi	r31, 0x3F	; 63
     6f0:	1f 2f       	mov	r17, r31
     6f2:	f0 2d       	mov	r31, r0
    motor[i].stepUnit             = MOTOR_STEP_UNIT_DEGREE;
    motor[i].waitBetweenSteps     = 3;
     6f4:	63 e0       	ldi	r22, 0x03	; 3
     6f6:	70 e0       	ldi	r23, 0x00	; 0
void initDataStructs(void){

  uint8_t i, j;

  for(i = 0; i <= MAX_MOTOR; i++){
    motor[i].actualPosition       = 0;
     6f8:	fa 01       	movw	r30, r20
     6fa:	ee 0f       	add	r30, r30
     6fc:	ff 1f       	adc	r31, r31
     6fe:	ee 0f       	add	r30, r30
     700:	ff 1f       	adc	r31, r31
     702:	ee 0f       	add	r30, r30
     704:	ff 1f       	adc	r31, r31
     706:	cf 01       	movw	r24, r30
     708:	88 0f       	add	r24, r24
     70a:	99 1f       	adc	r25, r25
     70c:	88 0f       	add	r24, r24
     70e:	99 1f       	adc	r25, r25
     710:	e8 0f       	add	r30, r24
     712:	f9 1f       	adc	r31, r25
     714:	e0 51       	subi	r30, 0x10	; 16
     716:	fc 4f       	sbci	r31, 0xFC	; 252
     718:	11 82       	std	Z+1, r1	; 0x01
     71a:	10 82       	st	Z, r1
    motor[i].desiredPosition      = 0;
     71c:	fa 01       	movw	r30, r20
     71e:	ee 0f       	add	r30, r30
     720:	ff 1f       	adc	r31, r31
     722:	ee 0f       	add	r30, r30
     724:	ff 1f       	adc	r31, r31
     726:	cf 01       	movw	r24, r30
     728:	88 0f       	add	r24, r24
     72a:	99 1f       	adc	r25, r25
     72c:	88 0f       	add	r24, r24
     72e:	99 1f       	adc	r25, r25
     730:	e8 0f       	add	r30, r24
     732:	f9 1f       	adc	r31, r25
     734:	ee 0f       	add	r30, r30
     736:	ff 1f       	adc	r31, r31
     738:	ee 50       	subi	r30, 0x0E	; 14
     73a:	fc 4f       	sbci	r31, 0xFC	; 252
     73c:	11 82       	std	Z+1, r1	; 0x01
     73e:	10 82       	st	Z, r1
    motor[i].opticalZeroPosition  = 0;
     740:	ca 01       	movw	r24, r20
     742:	fa 01       	movw	r30, r20
     744:	ee 0f       	add	r30, r30
     746:	ff 1f       	adc	r31, r31
     748:	ee 0f       	add	r30, r30
     74a:	ff 1f       	adc	r31, r31
     74c:	ee 0f       	add	r30, r30
     74e:	ff 1f       	adc	r31, r31
     750:	88 0f       	add	r24, r24
     752:	99 1f       	adc	r25, r25
     754:	e8 0f       	add	r30, r24
     756:	f9 1f       	adc	r31, r25
     758:	ee 0f       	add	r30, r30
     75a:	ff 1f       	adc	r31, r31
     75c:	ee 0f       	add	r30, r30
     75e:	ff 1f       	adc	r31, r31
     760:	ec 50       	subi	r30, 0x0C	; 12
     762:	fc 4f       	sbci	r31, 0xFC	; 252
     764:	11 82       	std	Z+1, r1	; 0x01
     766:	10 82       	st	Z, r1
    motor[i].stepError            = 0.0f;
     768:	fa 01       	movw	r30, r20
     76a:	ee 0f       	add	r30, r30
     76c:	ff 1f       	adc	r31, r31
     76e:	ee 0f       	add	r30, r30
     770:	ff 1f       	adc	r31, r31
     772:	ee 0f       	add	r30, r30
     774:	ff 1f       	adc	r31, r31
     776:	cf 01       	movw	r24, r30
     778:	88 0f       	add	r24, r24
     77a:	99 1f       	adc	r25, r25
     77c:	88 0f       	add	r24, r24
     77e:	99 1f       	adc	r25, r25
     780:	e8 0f       	add	r30, r24
     782:	f9 1f       	adc	r31, r25
     784:	e0 51       	subi	r30, 0x10	; 16
     786:	fc 4f       	sbci	r31, 0xFC	; 252
     788:	66 82       	std	Z+6, r6	; 0x06
     78a:	77 82       	std	Z+7, r7	; 0x07
     78c:	80 86       	std	Z+8, r8	; 0x08
     78e:	91 86       	std	Z+9, r9	; 0x09
    motor[i].isMoving             = 0;
     790:	fa 01       	movw	r30, r20
     792:	ee 0f       	add	r30, r30
     794:	ff 1f       	adc	r31, r31
     796:	ee 0f       	add	r30, r30
     798:	ff 1f       	adc	r31, r31
     79a:	ee 0f       	add	r30, r30
     79c:	ff 1f       	adc	r31, r31
     79e:	cf 01       	movw	r24, r30
     7a0:	88 0f       	add	r24, r24
     7a2:	99 1f       	adc	r25, r25
     7a4:	88 0f       	add	r24, r24
     7a6:	99 1f       	adc	r25, r25
     7a8:	e8 0f       	add	r30, r24
     7aa:	f9 1f       	adc	r31, r25
     7ac:	e0 51       	subi	r30, 0x10	; 16
     7ae:	fc 4f       	sbci	r31, 0xFC	; 252
     7b0:	12 86       	std	Z+10, r1	; 0x0a
    motor[i].isTurnedOn           = 0;
     7b2:	fa 01       	movw	r30, r20
     7b4:	ee 0f       	add	r30, r30
     7b6:	ff 1f       	adc	r31, r31
     7b8:	ee 0f       	add	r30, r30
     7ba:	ff 1f       	adc	r31, r31
     7bc:	ee 0f       	add	r30, r30
     7be:	ff 1f       	adc	r31, r31
     7c0:	cf 01       	movw	r24, r30
     7c2:	88 0f       	add	r24, r24
     7c4:	99 1f       	adc	r25, r25
     7c6:	88 0f       	add	r24, r24
     7c8:	99 1f       	adc	r25, r25
     7ca:	e8 0f       	add	r30, r24
     7cc:	f9 1f       	adc	r31, r25
     7ce:	e0 51       	subi	r30, 0x10	; 16
     7d0:	fc 4f       	sbci	r31, 0xFC	; 252
     7d2:	13 86       	std	Z+11, r1	; 0x0b
    motor[i].isMovingInfinite     = MOTOR_MOVE_INFINITE_STOP;
     7d4:	fa 01       	movw	r30, r20
     7d6:	ee 0f       	add	r30, r30
     7d8:	ff 1f       	adc	r31, r31
     7da:	ee 0f       	add	r30, r30
     7dc:	ff 1f       	adc	r31, r31
     7de:	ee 0f       	add	r30, r30
     7e0:	ff 1f       	adc	r31, r31
     7e2:	cf 01       	movw	r24, r30
     7e4:	88 0f       	add	r24, r24
     7e6:	99 1f       	adc	r25, r25
     7e8:	88 0f       	add	r24, r24
     7ea:	99 1f       	adc	r25, r25
     7ec:	e8 0f       	add	r30, r24
     7ee:	f9 1f       	adc	r31, r25
     7f0:	e0 51       	subi	r30, 0x10	; 16
     7f2:	fc 4f       	sbci	r31, 0xFC	; 252
     7f4:	14 86       	std	Z+12, r1	; 0x0c
    motor[i].gearRatio            = 60.0f/20.0f; /* TODO */
     7f6:	fa 01       	movw	r30, r20
     7f8:	ee 0f       	add	r30, r30
     7fa:	ff 1f       	adc	r31, r31
     7fc:	ee 0f       	add	r30, r30
     7fe:	ff 1f       	adc	r31, r31
     800:	ee 0f       	add	r30, r30
     802:	ff 1f       	adc	r31, r31
     804:	cf 01       	movw	r24, r30
     806:	88 0f       	add	r24, r24
     808:	99 1f       	adc	r25, r25
     80a:	88 0f       	add	r24, r24
     80c:	99 1f       	adc	r25, r25
     80e:	e8 0f       	add	r30, r24
     810:	f9 1f       	adc	r31, r25
     812:	e0 51       	subi	r30, 0x10	; 16
     814:	fc 4f       	sbci	r31, 0xFC	; 252
     816:	25 86       	std	Z+13, r2	; 0x0d
     818:	36 86       	std	Z+14, r3	; 0x0e
     81a:	47 86       	std	Z+15, r4	; 0x0f
     81c:	50 8a       	std	Z+16, r5	; 0x10
    motor[i].stepsPerFullRotation = 400.0f;
     81e:	fa 01       	movw	r30, r20
     820:	ee 0f       	add	r30, r30
     822:	ff 1f       	adc	r31, r31
     824:	ee 0f       	add	r30, r30
     826:	ff 1f       	adc	r31, r31
     828:	ee 0f       	add	r30, r30
     82a:	ff 1f       	adc	r31, r31
     82c:	cf 01       	movw	r24, r30
     82e:	88 0f       	add	r24, r24
     830:	99 1f       	adc	r25, r25
     832:	88 0f       	add	r24, r24
     834:	99 1f       	adc	r25, r25
     836:	e8 0f       	add	r30, r24
     838:	f9 1f       	adc	r31, r25
     83a:	e0 51       	subi	r30, 0x10	; 16
     83c:	fc 4f       	sbci	r31, 0xFC	; 252
     83e:	80 e0       	ldi	r24, 0x00	; 0
     840:	90 e0       	ldi	r25, 0x00	; 0
     842:	a8 ec       	ldi	r26, 0xC8	; 200
     844:	b3 e4       	ldi	r27, 0x43	; 67
     846:	81 8b       	std	Z+17, r24	; 0x11
     848:	92 8b       	std	Z+18, r25	; 0x12
     84a:	a3 8b       	std	Z+19, r26	; 0x13
     84c:	b4 8b       	std	Z+20, r27	; 0x14
    motor[i].subSteps             = 4.0f;
     84e:	fa 01       	movw	r30, r20
     850:	ee 0f       	add	r30, r30
     852:	ff 1f       	adc	r31, r31
     854:	ee 0f       	add	r30, r30
     856:	ff 1f       	adc	r31, r31
     858:	ee 0f       	add	r30, r30
     85a:	ff 1f       	adc	r31, r31
     85c:	cf 01       	movw	r24, r30
     85e:	88 0f       	add	r24, r24
     860:	99 1f       	adc	r25, r25
     862:	88 0f       	add	r24, r24
     864:	99 1f       	adc	r25, r25
     866:	e8 0f       	add	r30, r24
     868:	f9 1f       	adc	r31, r25
     86a:	e0 51       	subi	r30, 0x10	; 16
     86c:	fc 4f       	sbci	r31, 0xFC	; 252
     86e:	a5 8a       	std	Z+21, r10	; 0x15
     870:	b6 8a       	std	Z+22, r11	; 0x16
     872:	c7 8a       	std	Z+23, r12	; 0x17
     874:	d0 8e       	std	Z+24, r13	; 0x18
    motor[i].stepMultiplier       = 1.0f;
     876:	fa 01       	movw	r30, r20
     878:	ee 0f       	add	r30, r30
     87a:	ff 1f       	adc	r31, r31
     87c:	ee 0f       	add	r30, r30
     87e:	ff 1f       	adc	r31, r31
     880:	ee 0f       	add	r30, r30
     882:	ff 1f       	adc	r31, r31
     884:	cf 01       	movw	r24, r30
     886:	88 0f       	add	r24, r24
     888:	99 1f       	adc	r25, r25
     88a:	88 0f       	add	r24, r24
     88c:	99 1f       	adc	r25, r25
     88e:	e8 0f       	add	r30, r24
     890:	f9 1f       	adc	r31, r25
     892:	e0 51       	subi	r30, 0x10	; 16
     894:	fc 4f       	sbci	r31, 0xFC	; 252
     896:	e2 8e       	std	Z+26, r14	; 0x1a
     898:	f3 8e       	std	Z+27, r15	; 0x1b
     89a:	04 8f       	std	Z+28, r16	; 0x1c
     89c:	15 8f       	std	Z+29, r17	; 0x1d
    motor[i].stepUnit             = MOTOR_STEP_UNIT_DEGREE;
     89e:	fa 01       	movw	r30, r20
     8a0:	ee 0f       	add	r30, r30
     8a2:	ff 1f       	adc	r31, r31
     8a4:	ee 0f       	add	r30, r30
     8a6:	ff 1f       	adc	r31, r31
     8a8:	ee 0f       	add	r30, r30
     8aa:	ff 1f       	adc	r31, r31
     8ac:	cf 01       	movw	r24, r30
     8ae:	88 0f       	add	r24, r24
     8b0:	99 1f       	adc	r25, r25
     8b2:	88 0f       	add	r24, r24
     8b4:	99 1f       	adc	r25, r25
     8b6:	e8 0f       	add	r30, r24
     8b8:	f9 1f       	adc	r31, r25
     8ba:	e0 51       	subi	r30, 0x10	; 16
     8bc:	fc 4f       	sbci	r31, 0xFC	; 252
     8be:	91 e0       	ldi	r25, 0x01	; 1
     8c0:	91 8f       	std	Z+25, r25	; 0x19
    motor[i].waitBetweenSteps     = 3;
     8c2:	fa 01       	movw	r30, r20
     8c4:	ee 0f       	add	r30, r30
     8c6:	ff 1f       	adc	r31, r31
     8c8:	ee 0f       	add	r30, r30
     8ca:	ff 1f       	adc	r31, r31
     8cc:	ee 0f       	add	r30, r30
     8ce:	ff 1f       	adc	r31, r31
     8d0:	cf 01       	movw	r24, r30
     8d2:	88 0f       	add	r24, r24
     8d4:	99 1f       	adc	r25, r25
     8d6:	88 0f       	add	r24, r24
     8d8:	99 1f       	adc	r25, r25
     8da:	e8 0f       	add	r30, r24
     8dc:	f9 1f       	adc	r31, r25
     8de:	e0 51       	subi	r30, 0x10	; 16
     8e0:	fc 4f       	sbci	r31, 0xFC	; 252
     8e2:	77 8f       	std	Z+31, r23	; 0x1f
     8e4:	66 8f       	std	Z+30, r22	; 0x1e
    motor[i].delayCounter         = 2*motor[i].waitBetweenSteps-1;
     8e6:	fa 01       	movw	r30, r20
     8e8:	ee 0f       	add	r30, r30
     8ea:	ff 1f       	adc	r31, r31
     8ec:	ee 0f       	add	r30, r30
     8ee:	ff 1f       	adc	r31, r31
     8f0:	ee 0f       	add	r30, r30
     8f2:	ff 1f       	adc	r31, r31
     8f4:	cf 01       	movw	r24, r30
     8f6:	88 0f       	add	r24, r24
     8f8:	99 1f       	adc	r25, r25
     8fa:	88 0f       	add	r24, r24
     8fc:	99 1f       	adc	r25, r25
     8fe:	e8 0f       	add	r30, r24
     900:	f9 1f       	adc	r31, r25
     902:	e0 51       	subi	r30, 0x10	; 16
     904:	fc 4f       	sbci	r31, 0xFC	; 252
     906:	26 8d       	ldd	r18, Z+30	; 0x1e
     908:	37 8d       	ldd	r19, Z+31	; 0x1f
     90a:	22 0f       	add	r18, r18
     90c:	33 1f       	adc	r19, r19
     90e:	21 50       	subi	r18, 0x01	; 1
     910:	30 40       	sbci	r19, 0x00	; 0
     912:	fa 01       	movw	r30, r20
     914:	ee 0f       	add	r30, r30
     916:	ff 1f       	adc	r31, r31
     918:	ee 0f       	add	r30, r30
     91a:	ff 1f       	adc	r31, r31
     91c:	ee 0f       	add	r30, r30
     91e:	ff 1f       	adc	r31, r31
     920:	cf 01       	movw	r24, r30
     922:	88 0f       	add	r24, r24
     924:	99 1f       	adc	r25, r25
     926:	88 0f       	add	r24, r24
     928:	99 1f       	adc	r25, r25
     92a:	e8 0f       	add	r30, r24
     92c:	f9 1f       	adc	r31, r25
     92e:	e0 51       	subi	r30, 0x10	; 16
     930:	fc 4f       	sbci	r31, 0xFC	; 252
     932:	31 a3       	std	Z+33, r19	; 0x21
     934:	20 a3       	std	Z+32, r18	; 0x20
    motor[i].angularVelocity      = OFF;
     936:	fa 01       	movw	r30, r20
     938:	ee 0f       	add	r30, r30
     93a:	ff 1f       	adc	r31, r31
     93c:	ee 0f       	add	r30, r30
     93e:	ff 1f       	adc	r31, r31
     940:	ee 0f       	add	r30, r30
     942:	ff 1f       	adc	r31, r31
     944:	cf 01       	movw	r24, r30
     946:	88 0f       	add	r24, r24
     948:	99 1f       	adc	r25, r25
     94a:	88 0f       	add	r24, r24
     94c:	99 1f       	adc	r25, r25
     94e:	e8 0f       	add	r30, r24
     950:	f9 1f       	adc	r31, r25
     952:	e0 51       	subi	r30, 0x10	; 16
     954:	fc 4f       	sbci	r31, 0xFC	; 252
     956:	12 a2       	std	Z+34, r1	; 0x22
    motor[i].current              = 1.0;
     958:	fa 01       	movw	r30, r20
     95a:	ee 0f       	add	r30, r30
     95c:	ff 1f       	adc	r31, r31
     95e:	ee 0f       	add	r30, r30
     960:	ff 1f       	adc	r31, r31
     962:	ee 0f       	add	r30, r30
     964:	ff 1f       	adc	r31, r31
     966:	cf 01       	movw	r24, r30
     968:	88 0f       	add	r24, r24
     96a:	99 1f       	adc	r25, r25
     96c:	88 0f       	add	r24, r24
     96e:	99 1f       	adc	r25, r25
     970:	e8 0f       	add	r30, r24
     972:	f9 1f       	adc	r31, r25
     974:	e0 51       	subi	r30, 0x10	; 16
     976:	fc 4f       	sbci	r31, 0xFC	; 252
     978:	e3 a2       	std	Z+35, r14	; 0x23
     97a:	f4 a2       	std	Z+36, r15	; 0x24
     97c:	05 a3       	std	Z+37, r16	; 0x25
     97e:	16 a3       	std	Z+38, r17	; 0x26
    motor[i].decay                = 0;
     980:	fa 01       	movw	r30, r20
     982:	ee 0f       	add	r30, r30
     984:	ff 1f       	adc	r31, r31
     986:	ee 0f       	add	r30, r30
     988:	ff 1f       	adc	r31, r31
     98a:	ee 0f       	add	r30, r30
     98c:	ff 1f       	adc	r31, r31
     98e:	cf 01       	movw	r24, r30
     990:	88 0f       	add	r24, r24
     992:	99 1f       	adc	r25, r25
     994:	88 0f       	add	r24, r24
     996:	99 1f       	adc	r25, r25
     998:	e8 0f       	add	r30, r24
     99a:	f9 1f       	adc	r31, r25
     99c:	e0 51       	subi	r30, 0x10	; 16
     99e:	fc 4f       	sbci	r31, 0xFC	; 252
     9a0:	17 a2       	std	Z+39, r1	; 0x27
     9a2:	4f 5f       	subi	r20, 0xFF	; 255
     9a4:	5f 4f       	sbci	r21, 0xFF	; 255
 --------------------------------------------------------------------- */
void initDataStructs(void){

  uint8_t i, j;

  for(i = 0; i <= MAX_MOTOR; i++){
     9a6:	44 30       	cpi	r20, 0x04	; 4
     9a8:	51 05       	cpc	r21, r1
     9aa:	09 f0       	breq	.+2      	; 0x9ae <initDataStructs+0x32e>
     9ac:	a5 ce       	rjmp	.-694    	; 0x6f8 <initDataStructs+0x78>
    motor[i].angularVelocity      = OFF;
    motor[i].current              = 1.0;
    motor[i].decay                = 0;
  }

  rxString.charCount = 0;
     9ae:	10 92 f1 02 	sts	0x02F1, r1
  rxString.readyToProcess = 0;
     9b2:	10 92 f0 02 	sts	0x02F0, r1

  txString.charCount = 0;
     9b6:	10 92 ea 03 	sts	0x03EA, r1
  txString.readyToProcess = 0;
     9ba:	10 92 e9 03 	sts	0x03E9, r1

  status.status = 0;
     9be:	10 92 95 04 	sts	0x0495, r1
  status.inRemoteMode = 0;
     9c2:	10 92 96 04 	sts	0x0496, r1

  adc.ADCvalue = 0;
     9c6:	10 92 cc 03 	sts	0x03CC, r1
     9ca:	10 92 cb 03 	sts	0x03CB, r1
  adc.numberOfMeasurements = 8;
     9ce:	88 e0       	ldi	r24, 0x08	; 8
     9d0:	80 93 cd 03 	sts	0x03CD, r24

  menu.newDisplayedMenu = MENU_MAIN;
     9d4:	10 92 df 02 	sts	0x02DF, r1
  menu.currentDisplayedMenu = 42;
     9d8:	9a e2       	ldi	r25, 0x2A	; 42
     9da:	90 93 e0 02 	sts	0x02E0, r25
  menu.newMenuMode = MENU_SCROLL_MODE;
     9de:	82 e0       	ldi	r24, 0x02	; 2
     9e0:	80 93 e1 02 	sts	0x02E1, r24
  menu.fastMovingMode = OFF;
     9e4:	10 92 e2 02 	sts	0x02E2, r1
  menu.currentProgramStep = 0;
     9e8:	10 92 e3 02 	sts	0x02E3, r1
  menu.currentMenuMode = 42;
     9ec:	90 93 e4 02 	sts	0x02E4, r25
  menu.selectedMotor = NO_MOTOR|(1<<DUMMY_MOTOR);  /* DUMMY_MOTOR stays always selected */
     9f0:	80 e1       	ldi	r24, 0x10	; 16
     9f2:	80 93 e5 02 	sts	0x02E5, r24
  /* strings are initialized in main */

  buttonState.inputRegister = 0;
     9f6:	10 92 dc 02 	sts	0x02DC, r1
  buttonState.inDebouncingMode = 0;
     9fa:	10 92 dd 02 	sts	0x02DD, r1
  buttonState.readyToProcess = 0;
     9fe:	10 92 de 02 	sts	0x02DE, r1

  rotEnc.direction = NO_MOVE;
     a02:	10 92 ce 03 	sts	0x03CE, r1
  rotEnc.steps = 0;
     a06:	10 92 cf 03 	sts	0x03CF, r1
  rotEnc.readyToProcess = 0;
     a0a:	10 92 d0 03 	sts	0x03D0, r1
  rotEnc.buttonPressed = 0;
     a0e:	10 92 d1 03 	sts	0x03D1, r1
  rotEnc.buttonDebounce = 0;
     a12:	10 92 d2 03 	sts	0x03D2, r1

  IIC.operationInProgress = 0;
     a16:	10 92 ef 03 	sts	0x03EF, r1

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a1a:	10 92 d7 03 	sts	0x03D7, r1
    forbiddenZone[i].start  = 0;
     a1e:	10 92 d4 03 	sts	0x03D4, r1
     a22:	10 92 d3 03 	sts	0x03D3, r1
    forbiddenZone[i].stop   = 0;
     a26:	10 92 d6 03 	sts	0x03D6, r1
     a2a:	10 92 d5 03 	sts	0x03D5, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a2e:	10 92 dc 03 	sts	0x03DC, r1
    forbiddenZone[i].start  = 0;
     a32:	10 92 d9 03 	sts	0x03D9, r1
     a36:	10 92 d8 03 	sts	0x03D8, r1
    forbiddenZone[i].stop   = 0;
     a3a:	10 92 db 03 	sts	0x03DB, r1
     a3e:	10 92 da 03 	sts	0x03DA, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a42:	10 92 e1 03 	sts	0x03E1, r1
    forbiddenZone[i].start  = 0;
     a46:	10 92 de 03 	sts	0x03DE, r1
     a4a:	10 92 dd 03 	sts	0x03DD, r1
    forbiddenZone[i].stop   = 0;
     a4e:	10 92 e0 03 	sts	0x03E0, r1
     a52:	10 92 df 03 	sts	0x03DF, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a56:	10 92 e6 03 	sts	0x03E6, r1
    forbiddenZone[i].start  = 0;
     a5a:	10 92 e3 03 	sts	0x03E3, r1
     a5e:	10 92 e2 03 	sts	0x03E2, r1
    forbiddenZone[i].stop   = 0;
     a62:	10 92 e5 03 	sts	0x03E5, r1
     a66:	10 92 e4 03 	sts	0x03E4, r1
     a6a:	20 e0       	ldi	r18, 0x00	; 0
     a6c:	30 e0       	ldi	r19, 0x00	; 0
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    programList[i].isActive = 0;
    programList[i].absRel = PROG_RELATIVE_MOVEMENT;
     a6e:	41 e0       	ldi	r20, 0x01	; 1
    forbiddenZone[i].stop   = 0;
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    programList[i].isActive = 0;
     a70:	c9 01       	movw	r24, r18
     a72:	f9 01       	movw	r30, r18
     a74:	ee 0f       	add	r30, r30
     a76:	ff 1f       	adc	r31, r31
     a78:	ee 0f       	add	r30, r30
     a7a:	ff 1f       	adc	r31, r31
     a7c:	ee 0f       	add	r30, r30
     a7e:	ff 1f       	adc	r31, r31
     a80:	88 0f       	add	r24, r24
     a82:	99 1f       	adc	r25, r25
     a84:	e8 0f       	add	r30, r24
     a86:	f9 1f       	adc	r31, r25
     a88:	ed 50       	subi	r30, 0x0D	; 13
     a8a:	fd 4f       	sbci	r31, 0xFD	; 253
     a8c:	10 82       	st	Z, r1
    programList[i].absRel = PROG_RELATIVE_MOVEMENT;
     a8e:	c9 01       	movw	r24, r18
     a90:	f9 01       	movw	r30, r18
     a92:	ee 0f       	add	r30, r30
     a94:	ff 1f       	adc	r31, r31
     a96:	ee 0f       	add	r30, r30
     a98:	ff 1f       	adc	r31, r31
     a9a:	ee 0f       	add	r30, r30
     a9c:	ff 1f       	adc	r31, r31
     a9e:	88 0f       	add	r24, r24
     aa0:	99 1f       	adc	r25, r25
     aa2:	e8 0f       	add	r30, r24
     aa4:	f9 1f       	adc	r31, r25
     aa6:	ed 50       	subi	r30, 0x0D	; 13
     aa8:	fd 4f       	sbci	r31, 0xFD	; 253
     aaa:	41 87       	std	Z+9, r20	; 0x09
    for(j = 0; j <= MAX_MOTOR; j++){
      programList[i].position[j] = 0;
     aac:	c9 01       	movw	r24, r18
     aae:	f9 01       	movw	r30, r18
     ab0:	ee 0f       	add	r30, r30
     ab2:	ff 1f       	adc	r31, r31
     ab4:	ee 0f       	add	r30, r30
     ab6:	ff 1f       	adc	r31, r31
     ab8:	ee 0f       	add	r30, r30
     aba:	ff 1f       	adc	r31, r31
     abc:	88 0f       	add	r24, r24
     abe:	99 1f       	adc	r25, r25
     ac0:	e8 0f       	add	r30, r24
     ac2:	f9 1f       	adc	r31, r25
     ac4:	ed 50       	subi	r30, 0x0D	; 13
     ac6:	fd 4f       	sbci	r31, 0xFD	; 253
     ac8:	12 82       	std	Z+2, r1	; 0x02
     aca:	11 82       	std	Z+1, r1	; 0x01
     acc:	c9 01       	movw	r24, r18
     ace:	f9 01       	movw	r30, r18
     ad0:	ee 0f       	add	r30, r30
     ad2:	ff 1f       	adc	r31, r31
     ad4:	ee 0f       	add	r30, r30
     ad6:	ff 1f       	adc	r31, r31
     ad8:	ee 0f       	add	r30, r30
     ada:	ff 1f       	adc	r31, r31
     adc:	88 0f       	add	r24, r24
     ade:	99 1f       	adc	r25, r25
     ae0:	e8 0f       	add	r30, r24
     ae2:	f9 1f       	adc	r31, r25
     ae4:	ed 50       	subi	r30, 0x0D	; 13
     ae6:	fd 4f       	sbci	r31, 0xFD	; 253
     ae8:	14 82       	std	Z+4, r1	; 0x04
     aea:	13 82       	std	Z+3, r1	; 0x03
     aec:	c9 01       	movw	r24, r18
     aee:	f9 01       	movw	r30, r18
     af0:	ee 0f       	add	r30, r30
     af2:	ff 1f       	adc	r31, r31
     af4:	ee 0f       	add	r30, r30
     af6:	ff 1f       	adc	r31, r31
     af8:	ee 0f       	add	r30, r30
     afa:	ff 1f       	adc	r31, r31
     afc:	88 0f       	add	r24, r24
     afe:	99 1f       	adc	r25, r25
     b00:	e8 0f       	add	r30, r24
     b02:	f9 1f       	adc	r31, r25
     b04:	ed 50       	subi	r30, 0x0D	; 13
     b06:	fd 4f       	sbci	r31, 0xFD	; 253
     b08:	16 82       	std	Z+6, r1	; 0x06
     b0a:	15 82       	std	Z+5, r1	; 0x05
     b0c:	c9 01       	movw	r24, r18
     b0e:	f9 01       	movw	r30, r18
     b10:	ee 0f       	add	r30, r30
     b12:	ff 1f       	adc	r31, r31
     b14:	ee 0f       	add	r30, r30
     b16:	ff 1f       	adc	r31, r31
     b18:	ee 0f       	add	r30, r30
     b1a:	ff 1f       	adc	r31, r31
     b1c:	88 0f       	add	r24, r24
     b1e:	99 1f       	adc	r25, r25
     b20:	e8 0f       	add	r30, r24
     b22:	f9 1f       	adc	r31, r25
     b24:	ed 50       	subi	r30, 0x0D	; 13
     b26:	fd 4f       	sbci	r31, 0xFD	; 253
     b28:	10 86       	std	Z+8, r1	; 0x08
     b2a:	17 82       	std	Z+7, r1	; 0x07
     b2c:	2f 5f       	subi	r18, 0xFF	; 255
     b2e:	3f 4f       	sbci	r19, 0xFF	; 255
    forbiddenZone[i].start  = 0;
    forbiddenZone[i].stop   = 0;
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
     b30:	20 31       	cpi	r18, 0x10	; 16
     b32:	31 05       	cpc	r19, r1
     b34:	09 f0       	breq	.+2      	; 0xb38 <initDataStructs+0x4b8>
     b36:	9c cf       	rjmp	.-200    	; 0xa70 <initDataStructs+0x3f0>
    for(j = 0; j <= MAX_MOTOR; j++){
      programList[i].position[j] = 0;
    }
  }
  /* define home position on program step 0 */
  programList[0].isActive = 1;
     b38:	81 e0       	ldi	r24, 0x01	; 1
     b3a:	80 93 f3 02 	sts	0x02F3, r24

  return;
}
     b3e:	1f 91       	pop	r17
     b40:	0f 91       	pop	r16
     b42:	ff 90       	pop	r15
     b44:	ef 90       	pop	r14
     b46:	df 90       	pop	r13
     b48:	cf 90       	pop	r12
     b4a:	bf 90       	pop	r11
     b4c:	af 90       	pop	r10
     b4e:	9f 90       	pop	r9
     b50:	8f 90       	pop	r8
     b52:	7f 90       	pop	r7
     b54:	6f 90       	pop	r6
     b56:	5f 90       	pop	r5
     b58:	4f 90       	pop	r4
     b5a:	3f 90       	pop	r3
     b5c:	2f 90       	pop	r2
     b5e:	08 95       	ret

00000b60 <initUSART>:
   - 8 bit character size
   - no flow control
  */

  /* set baud rate registers */
  UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
     b60:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = (uint8_t)(UBRR_VALUE & 0xFF);
     b64:	85 e1       	ldi	r24, 0x15	; 21
     b66:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B |= (1<<TXEN0) | (1<<RXEN0)        /* enable RX and TX */
     b6a:	e1 ec       	ldi	r30, 0xC1	; 193
     b6c:	f0 e0       	ldi	r31, 0x00	; 0
     b6e:	80 81       	ld	r24, Z
     b70:	88 69       	ori	r24, 0x98	; 152
     b72:	80 83       	st	Z, r24
           |(1<<RXCIE0);                   /* enable RX interrupt */

  return;
}
     b74:	08 95       	ret

00000b76 <sendChar>:
====================================================================== */

/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){
     b76:	98 2f       	mov	r25, r24

  while(!(UCSR0A & (1<<UDRE0))){
     b78:	80 91 c0 00 	lds	r24, 0x00C0
     b7c:	85 ff       	sbrs	r24, 5
     b7e:	fc cf       	rjmp	.-8      	; 0xb78 <sendChar+0x2>
    ;
  }

  UDR0 = c;
     b80:	90 93 c6 00 	sts	0x00C6, r25

  return;
}
     b84:	08 95       	ret

00000b86 <initMotorDelayTimer>:

  /*
   * the 8-bit Timer/Counter2 is used for that
   */

  TCCR2A |= (1<<WGM21);   /* enable CTC */
     b86:	e0 eb       	ldi	r30, 0xB0	; 176
     b88:	f0 e0       	ldi	r31, 0x00	; 0
     b8a:	80 81       	ld	r24, Z
     b8c:	82 60       	ori	r24, 0x02	; 2
     b8e:	80 83       	st	Z, r24
  OCR2A   = 77;
     b90:	8d e4       	ldi	r24, 0x4D	; 77
     b92:	80 93 b3 00 	sts	0x00B3, r24
  TIMSK2 |= (1<<OCIE2A);  /* enable interrupt */
     b96:	e0 e7       	ldi	r30, 0x70	; 112
     b98:	f0 e0       	ldi	r31, 0x00	; 0
     b9a:	80 81       	ld	r24, Z
     b9c:	82 60       	ori	r24, 0x02	; 2
     b9e:	80 83       	st	Z, r24
  TCNT2   = 0;
     ba0:	10 92 b2 00 	sts	0x00B2, r1

  /* start the timer/counter */
  TCCR2B |= (1<<CS22)|(1<<CS20);  /* prescaler = 1024 --> 51.2 us per clock */
     ba4:	e1 eb       	ldi	r30, 0xB1	; 177
     ba6:	f0 e0       	ldi	r31, 0x00	; 0
     ba8:	80 81       	ld	r24, Z
     baa:	85 60       	ori	r24, 0x05	; 5
     bac:	80 83       	st	Z, r24

  return;
}
     bae:	08 95       	ret

00000bb0 <moveMotorRelative>:
/* ---------------------------------------------------------------------
    moveMotorBySteps: move motor <steps> steps forward or backward
    This is a relative movement to the actual position.
    NOTE: this function is only used by motorZeroRun()
 --------------------------------------------------------------------- */
void moveMotorRelative(uint8_t mot, int16_t steps){
     bb0:	ff 92       	push	r15
     bb2:	0f 93       	push	r16
     bb4:	1f 93       	push	r17

  int16_t  i;
  uint16_t j;

  /* set direction */
  if(steps == 0){
     bb6:	61 15       	cp	r22, r1
     bb8:	71 05       	cpc	r23, r1
     bba:	09 f4       	brne	.+2      	; 0xbbe <moveMotorRelative+0xe>
     bbc:	58 c0       	rjmp	.+176    	; 0xc6e <moveMotorRelative+0xbe>
    /* no move */
    return;
  }
  else if(steps < 0){
     bbe:	77 fd       	sbrc	r23, 7
     bc0:	5a c0       	rjmp	.+180    	; 0xc76 <moveMotorRelative+0xc6>
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
  }
  else{
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
     bc2:	42 b1       	in	r20, 0x02	; 2
     bc4:	e8 2f       	mov	r30, r24
     bc6:	f0 e0       	ldi	r31, 0x00	; 0
     bc8:	9f 01       	movw	r18, r30
     bca:	22 0f       	add	r18, r18
     bcc:	33 1f       	adc	r19, r19
     bce:	2f 5f       	subi	r18, 0xFF	; 255
     bd0:	3f 4f       	sbci	r19, 0xFF	; 255
     bd2:	81 e0       	ldi	r24, 0x01	; 1
     bd4:	90 e0       	ldi	r25, 0x00	; 0
     bd6:	02 c0       	rjmp	.+4      	; 0xbdc <moveMotorRelative+0x2c>
     bd8:	88 0f       	add	r24, r24
     bda:	99 1f       	adc	r25, r25
     bdc:	2a 95       	dec	r18
     bde:	e2 f7       	brpl	.-8      	; 0xbd8 <moveMotorRelative+0x28>
     be0:	80 95       	com	r24
     be2:	84 23       	and	r24, r20
     be4:	82 b9       	out	0x02, r24	; 2
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     be6:	77 fd       	sbrc	r23, 7
     be8:	59 c0       	rjmp	.+178    	; 0xc9c <moveMotorRelative+0xec>
     bea:	16 16       	cp	r1, r22
     bec:	17 06       	cpc	r1, r23
     bee:	0c f0       	brlt	.+2      	; 0xbf2 <moveMotorRelative+0x42>
     bf0:	3e c0       	rjmp	.+124    	; 0xc6e <moveMotorRelative+0xbe>
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
  }
  else{
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
     bf2:	ee 0f       	add	r30, r30
     bf4:	ff 1f       	adc	r31, r31
     bf6:	81 e0       	ldi	r24, 0x01	; 1
     bf8:	90 e0       	ldi	r25, 0x00	; 0
     bfa:	0e 2e       	mov	r0, r30
     bfc:	02 c0       	rjmp	.+4      	; 0xc02 <moveMotorRelative+0x52>
     bfe:	88 0f       	add	r24, r24
     c00:	99 1f       	adc	r25, r25
     c02:	0a 94       	dec	r0
     c04:	e2 f7       	brpl	.-8      	; 0xbfe <moveMotorRelative+0x4e>
     c06:	18 2f       	mov	r17, r24
     c08:	08 2f       	mov	r16, r24
     c0a:	00 95       	com	r16
     c0c:	a0 e0       	ldi	r26, 0x00	; 0
     c0e:	b0 e0       	ldi	r27, 0x00	; 0
     c10:	cf 01       	movw	r24, r30
     c12:	88 0f       	add	r24, r24
     c14:	99 1f       	adc	r25, r25
     c16:	88 0f       	add	r24, r24
     c18:	99 1f       	adc	r25, r25
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     c1a:	5d e0       	ldi	r21, 0x0D	; 13
     c1c:	f5 2e       	mov	r15, r21
  for (i = 0; i < abs(steps); i++){
    PORTA |= (1 << (2*mot));
    _delay_us(2); /* as specified in datasheet */
    PORTA &= ~(1 << (2*mot));

    for(j = 0; j < motor[mot].waitBetweenSteps; j++){
     c1e:	fc 01       	movw	r30, r24
     c20:	ee 0f       	add	r30, r30
     c22:	ff 1f       	adc	r31, r31
     c24:	ee 0f       	add	r30, r30
     c26:	ff 1f       	adc	r31, r31
     c28:	e8 0f       	add	r30, r24
     c2a:	f9 1f       	adc	r31, r25
     c2c:	e2 5f       	subi	r30, 0xF2	; 242
     c2e:	fb 4f       	sbci	r31, 0xFB	; 251
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c30:	48 e8       	ldi	r20, 0x88	; 136
     c32:	53 e1       	ldi	r21, 0x13	; 19
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
    PORTA |= (1 << (2*mot));
     c34:	82 b1       	in	r24, 0x02	; 2
     c36:	81 2b       	or	r24, r17
     c38:	82 b9       	out	0x02, r24	; 2
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     c3a:	8f 2d       	mov	r24, r15
     c3c:	8a 95       	dec	r24
     c3e:	f1 f7       	brne	.-4      	; 0xc3c <moveMotorRelative+0x8c>
    _delay_us(2); /* as specified in datasheet */
    PORTA &= ~(1 << (2*mot));
     c40:	82 b1       	in	r24, 0x02	; 2
     c42:	80 23       	and	r24, r16
     c44:	82 b9       	out	0x02, r24	; 2

    for(j = 0; j < motor[mot].waitBetweenSteps; j++){
     c46:	80 81       	ld	r24, Z
     c48:	91 81       	ldd	r25, Z+1	; 0x01
     c4a:	89 2b       	or	r24, r25
     c4c:	61 f0       	breq	.+24     	; 0xc66 <moveMotorRelative+0xb6>
     c4e:	20 e0       	ldi	r18, 0x00	; 0
     c50:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     c52:	ca 01       	movw	r24, r20
     c54:	01 97       	sbiw	r24, 0x01	; 1
     c56:	f1 f7       	brne	.-4      	; 0xc54 <moveMotorRelative+0xa4>
     c58:	2f 5f       	subi	r18, 0xFF	; 255
     c5a:	3f 4f       	sbci	r19, 0xFF	; 255
     c5c:	80 81       	ld	r24, Z
     c5e:	91 81       	ldd	r25, Z+1	; 0x01
     c60:	28 17       	cp	r18, r24
     c62:	39 07       	cpc	r19, r25
     c64:	b0 f3       	brcs	.-20     	; 0xc52 <moveMotorRelative+0xa2>
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     c66:	11 96       	adiw	r26, 0x01	; 1
     c68:	a6 17       	cp	r26, r22
     c6a:	b7 07       	cpc	r27, r23
     c6c:	1c f3       	brlt	.-58     	; 0xc34 <moveMotorRelative+0x84>
      _delay_ms(1);
    }
  }

  return;
}
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	08 95       	ret
    /* no move */
    return;
  }
  else if(steps < 0){
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
     c76:	42 b1       	in	r20, 0x02	; 2
     c78:	e8 2f       	mov	r30, r24
     c7a:	f0 e0       	ldi	r31, 0x00	; 0
     c7c:	9f 01       	movw	r18, r30
     c7e:	22 0f       	add	r18, r18
     c80:	33 1f       	adc	r19, r19
     c82:	2f 5f       	subi	r18, 0xFF	; 255
     c84:	3f 4f       	sbci	r19, 0xFF	; 255
     c86:	81 e0       	ldi	r24, 0x01	; 1
     c88:	90 e0       	ldi	r25, 0x00	; 0
     c8a:	02 c0       	rjmp	.+4      	; 0xc90 <moveMotorRelative+0xe0>
     c8c:	88 0f       	add	r24, r24
     c8e:	99 1f       	adc	r25, r25
     c90:	2a 95       	dec	r18
     c92:	e2 f7       	brpl	.-8      	; 0xc8c <moveMotorRelative+0xdc>
     c94:	48 2b       	or	r20, r24
     c96:	42 b9       	out	0x02, r20	; 2
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     c98:	77 ff       	sbrs	r23, 7
     c9a:	a7 cf       	rjmp	.-178    	; 0xbea <moveMotorRelative+0x3a>
     c9c:	70 95       	com	r23
     c9e:	61 95       	neg	r22
     ca0:	7f 4f       	sbci	r23, 0xFF	; 255
     ca2:	a3 cf       	rjmp	.-186    	; 0xbea <moveMotorRelative+0x3a>

00000ca4 <defineOpticalZeroPosition>:
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
     ca4:	a0 ef       	ldi	r26, 0xF0	; 240
     ca6:	b3 e0       	ldi	r27, 0x03	; 3
     ca8:	e8 2f       	mov	r30, r24
     caa:	f0 e0       	ldi	r31, 0x00	; 0
     cac:	ee 0f       	add	r30, r30
     cae:	ff 1f       	adc	r31, r31
     cb0:	ee 0f       	add	r30, r30
     cb2:	ff 1f       	adc	r31, r31
     cb4:	ee 0f       	add	r30, r30
     cb6:	ff 1f       	adc	r31, r31
     cb8:	9f 01       	movw	r18, r30
     cba:	22 0f       	add	r18, r18
     cbc:	33 1f       	adc	r19, r19
     cbe:	22 0f       	add	r18, r18
     cc0:	33 1f       	adc	r19, r19
     cc2:	e2 0f       	add	r30, r18
     cc4:	f3 1f       	adc	r31, r19
     cc6:	ea 0f       	add	r30, r26
     cc8:	fb 1f       	adc	r31, r27
     cca:	40 81       	ld	r20, Z
     ccc:	51 81       	ldd	r21, Z+1	; 0x01
     cce:	46 0f       	add	r20, r22
     cd0:	57 1f       	adc	r21, r23
     cd2:	e8 2f       	mov	r30, r24
     cd4:	f0 e0       	ldi	r31, 0x00	; 0
     cd6:	ee 0f       	add	r30, r30
     cd8:	ff 1f       	adc	r31, r31
     cda:	ee 0f       	add	r30, r30
     cdc:	ff 1f       	adc	r31, r31
     cde:	9f 01       	movw	r18, r30
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	22 0f       	add	r18, r18
     ce6:	33 1f       	adc	r19, r19
     ce8:	e2 0f       	add	r30, r18
     cea:	f3 1f       	adc	r31, r19
     cec:	31 96       	adiw	r30, 0x01	; 1
     cee:	ee 0f       	add	r30, r30
     cf0:	ff 1f       	adc	r31, r31
     cf2:	ea 0f       	add	r30, r26
     cf4:	fb 1f       	adc	r31, r27
     cf6:	51 83       	std	Z+1, r21	; 0x01
     cf8:	40 83       	st	Z, r20
  motor[i].opticalZeroPosition = motor[i].desiredPosition;
     cfa:	e8 2f       	mov	r30, r24
     cfc:	f0 e0       	ldi	r31, 0x00	; 0
     cfe:	ee 0f       	add	r30, r30
     d00:	ff 1f       	adc	r31, r31
     d02:	ee 0f       	add	r30, r30
     d04:	ff 1f       	adc	r31, r31
     d06:	9f 01       	movw	r18, r30
     d08:	22 0f       	add	r18, r18
     d0a:	33 1f       	adc	r19, r19
     d0c:	22 0f       	add	r18, r18
     d0e:	33 1f       	adc	r19, r19
     d10:	e2 0f       	add	r30, r18
     d12:	f3 1f       	adc	r31, r19
     d14:	31 96       	adiw	r30, 0x01	; 1
     d16:	ee 0f       	add	r30, r30
     d18:	ff 1f       	adc	r31, r31
     d1a:	ea 0f       	add	r30, r26
     d1c:	fb 1f       	adc	r31, r27
     d1e:	40 81       	ld	r20, Z
     d20:	51 81       	ldd	r21, Z+1	; 0x01
     d22:	28 2f       	mov	r18, r24
     d24:	30 e0       	ldi	r19, 0x00	; 0
     d26:	c9 01       	movw	r24, r18
     d28:	88 0f       	add	r24, r24
     d2a:	99 1f       	adc	r25, r25
     d2c:	88 0f       	add	r24, r24
     d2e:	99 1f       	adc	r25, r25
     d30:	88 0f       	add	r24, r24
     d32:	99 1f       	adc	r25, r25
     d34:	22 0f       	add	r18, r18
     d36:	33 1f       	adc	r19, r19
     d38:	82 0f       	add	r24, r18
     d3a:	93 1f       	adc	r25, r19
     d3c:	01 96       	adiw	r24, 0x01	; 1
     d3e:	88 0f       	add	r24, r24
     d40:	99 1f       	adc	r25, r25
     d42:	88 0f       	add	r24, r24
     d44:	99 1f       	adc	r25, r25
     d46:	a8 0f       	add	r26, r24
     d48:	b9 1f       	adc	r27, r25
     d4a:	11 96       	adiw	r26, 0x01	; 1
     d4c:	5c 93       	st	X, r21
     d4e:	4e 93       	st	-X, r20

  return;
}
     d50:	08 95       	ret

00000d52 <getADCvalue>:

  uint8_t i = 0;
  uint8_t lowByte, highByte;

  // select channel
  ADMUX = (ADMUX & ~(0x1F)) | (sensPin & 0x1F);
     d52:	90 91 7c 00 	lds	r25, 0x007C
     d56:	8f 71       	andi	r24, 0x1F	; 31
     d58:	90 7e       	andi	r25, 0xE0	; 224
     d5a:	89 2b       	or	r24, r25
     d5c:	80 93 7c 00 	sts	0x007C, r24

  // reset all values and counters before starting new conversion
  adc.ADCvalue = 0;
     d60:	10 92 cc 03 	sts	0x03CC, r1
     d64:	10 92 cb 03 	sts	0x03CB, r1

  // start the conversion
  for(i = 0; i < adc.numberOfMeasurements; i++){
     d68:	80 91 cd 03 	lds	r24, 0x03CD
     d6c:	88 23       	and	r24, r24
     d6e:	11 f1       	breq	.+68     	; 0xdb4 <getADCvalue+0x62>
     d70:	60 e0       	ldi	r22, 0x00	; 0
    ADCSRA |= (1<<ADSC);
     d72:	80 91 7a 00 	lds	r24, 0x007A
     d76:	80 64       	ori	r24, 0x40	; 64
     d78:	80 93 7a 00 	sts	0x007A, r24
    while(ADCSRA & (1<<ADSC)){
     d7c:	80 91 7a 00 	lds	r24, 0x007A
     d80:	86 fd       	sbrc	r24, 6
     d82:	fc cf       	rjmp	.-8      	; 0xd7c <getADCvalue+0x2a>
      ;
    }
    lowByte = ADCL;
     d84:	80 91 78 00 	lds	r24, 0x0078
    highByte = ADCH;
     d88:	20 91 79 00 	lds	r18, 0x0079
    adc.ADCvalue += (highByte<<8) | lowByte;
     d8c:	40 91 cb 03 	lds	r20, 0x03CB
     d90:	50 91 cc 03 	lds	r21, 0x03CC
     d94:	32 2f       	mov	r19, r18
     d96:	20 e0       	ldi	r18, 0x00	; 0
     d98:	90 e0       	ldi	r25, 0x00	; 0
     d9a:	82 2b       	or	r24, r18
     d9c:	93 2b       	or	r25, r19
     d9e:	84 0f       	add	r24, r20
     da0:	95 1f       	adc	r25, r21
     da2:	90 93 cc 03 	sts	0x03CC, r25
     da6:	80 93 cb 03 	sts	0x03CB, r24

  // reset all values and counters before starting new conversion
  adc.ADCvalue = 0;

  // start the conversion
  for(i = 0; i < adc.numberOfMeasurements; i++){
     daa:	6f 5f       	subi	r22, 0xFF	; 255
     dac:	80 91 cd 03 	lds	r24, 0x03CD
     db0:	68 17       	cp	r22, r24
     db2:	f8 f2       	brcs	.-66     	; 0xd72 <getADCvalue+0x20>
    lowByte = ADCL;
    highByte = ADCH;
    adc.ADCvalue += (highByte<<8) | lowByte;
  }

  return (adc.ADCvalue / adc.numberOfMeasurements);
     db4:	80 91 cb 03 	lds	r24, 0x03CB
     db8:	90 91 cc 03 	lds	r25, 0x03CC
     dbc:	60 91 cd 03 	lds	r22, 0x03CD
     dc0:	70 e0       	ldi	r23, 0x00	; 0
     dc2:	0e 94 ed 41 	call	0x83da	; 0x83da <__udivmodhi4>
     dc6:	cb 01       	movw	r24, r22
}
     dc8:	08 95       	ret

00000dca <changeButtonLED>:
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     dca:	82 30       	cpi	r24, 0x02	; 2
     dcc:	11 f1       	breq	.+68     	; 0xe12 <changeButtonLED+0x48>
     dce:	83 30       	cpi	r24, 0x03	; 3
     dd0:	78 f0       	brcs	.+30     	; 0xdf0 <changeButtonLED+0x26>
     dd2:	83 30       	cpi	r24, 0x03	; 3
     dd4:	a9 f1       	breq	.+106    	; 0xe40 <changeButtonLED+0x76>
     dd6:	84 30       	cpi	r24, 0x04	; 4
     dd8:	d9 f0       	breq	.+54     	; 0xe10 <changeButtonLED+0x46>
     dda:	a0 e0       	ldi	r26, 0x00	; 0
     ddc:	b0 e0       	ldi	r27, 0x00	; 0
     dde:	e3 e0       	ldi	r30, 0x03	; 3
     de0:	f0 e0       	ldi	r31, 0x00	; 0
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     de2:	ab 56       	subi	r26, 0x6B	; 107
     de4:	bc 4f       	sbci	r27, 0xFC	; 252
     de6:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     de8:	eb 56       	subi	r30, 0x6B	; 107
     dea:	fc 4f       	sbci	r31, 0xFC	; 252
     dec:	40 83       	st	Z, r20

  return;
}
     dee:	08 95       	ret
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     df0:	88 23       	and	r24, r24
     df2:	d1 f0       	breq	.+52     	; 0xe28 <changeButtonLED+0x5e>
     df4:	81 30       	cpi	r24, 0x01	; 1
     df6:	89 f7       	brne	.-30     	; 0xdda <changeButtonLED+0x10>
	case 0: chan = 6*2+color; break;
     df8:	6a 5f       	subi	r22, 0xFA	; 250
     dfa:	a6 2f       	mov	r26, r22
     dfc:	b0 e0       	ldi	r27, 0x00	; 0
     dfe:	fd 01       	movw	r30, r26
     e00:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e02:	ab 56       	subi	r26, 0x6B	; 107
     e04:	bc 4f       	sbci	r27, 0xFC	; 252
     e06:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e08:	eb 56       	subi	r30, 0x6B	; 107
     e0a:	fc 4f       	sbci	r31, 0xFC	; 252
     e0c:	40 83       	st	Z, r20

  return;
}
     e0e:	08 95       	ret
  
  switch(butt) {
	case 0: chan = 6*2+color; break;
	case 1: chan = 6*1+color; break;
	case 2: chan = 6*0+color; break;
	case 3: chan = 6*5+color; break;
     e10:	68 5e       	subi	r22, 0xE8	; 232
     e12:	a6 2f       	mov	r26, r22
     e14:	b0 e0       	ldi	r27, 0x00	; 0
     e16:	fd 01       	movw	r30, r26
     e18:	33 96       	adiw	r30, 0x03	; 3
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e1a:	ab 56       	subi	r26, 0x6B	; 107
     e1c:	bc 4f       	sbci	r27, 0xFC	; 252
     e1e:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e20:	eb 56       	subi	r30, 0x6B	; 107
     e22:	fc 4f       	sbci	r31, 0xFC	; 252
     e24:	40 83       	st	Z, r20

  return;
}
     e26:	08 95       	ret
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     e28:	64 5f       	subi	r22, 0xF4	; 244
     e2a:	a6 2f       	mov	r26, r22
     e2c:	b0 e0       	ldi	r27, 0x00	; 0
     e2e:	fd 01       	movw	r30, r26
     e30:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e32:	ab 56       	subi	r26, 0x6B	; 107
     e34:	bc 4f       	sbci	r27, 0xFC	; 252
     e36:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e38:	eb 56       	subi	r30, 0x6B	; 107
     e3a:	fc 4f       	sbci	r31, 0xFC	; 252
     e3c:	40 83       	st	Z, r20

  return;
}
     e3e:	08 95       	ret
  
  uint8_t chan = 0;
  
  switch(butt) {
	case 0: chan = 6*2+color; break;
	case 1: chan = 6*1+color; break;
     e40:	62 5e       	subi	r22, 0xE2	; 226
     e42:	a6 2f       	mov	r26, r22
     e44:	b0 e0       	ldi	r27, 0x00	; 0
     e46:	fd 01       	movw	r30, r26
     e48:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e4a:	ab 56       	subi	r26, 0x6B	; 107
     e4c:	bc 4f       	sbci	r27, 0xFC	; 252
     e4e:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e50:	eb 56       	subi	r30, 0x6B	; 107
     e52:	fc 4f       	sbci	r31, 0xFC	; 252
     e54:	40 83       	st	Z, r20

  return;
}
     e56:	08 95       	ret

00000e58 <updateLEDs>:

/* ---------------------------------------------------------------------
   update LEDs
 --------------------------------------------------------------------- */
void updateLEDs(void){
     e58:	6f e2       	ldi	r22, 0x2F	; 47
     e5a:	70 e0       	ldi	r23, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     e5c:	32 e4       	ldi	r19, 0x42	; 66
  //uint8_t  j = 0;
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
	data = buttLedData[i];
     e5e:	fb 01       	movw	r30, r22
     e60:	eb 56       	subi	r30, 0x6B	; 107
     e62:	fc 4f       	sbci	r31, 0xFC	; 252
     e64:	80 81       	ld	r24, Z
     e66:	48 2f       	mov	r20, r24
     e68:	50 e0       	ldi	r21, 0x00	; 0
     e6a:	27 e0       	ldi	r18, 0x07	; 7
     e6c:	0f c0       	rjmp	.+30     	; 0xe8c <updateLEDs+0x34>
    {
        outbyte = (data>>i) & 0x01;
        // Set the data pin to given value, and clk pin to 0
        if(outbyte)
        {
            PORTC |= (outbyte << WS2803_SDI);
     e6e:	46 9a       	sbi	0x08, 6	; 8
        }
        else
        {
            PORTC &= ~(outbyte << WS2803_SDI);
        }
        PORTC &= ~(1 << WS2803_CKI);
     e70:	47 98       	cbi	0x08, 7	; 8
     e72:	83 2f       	mov	r24, r19
     e74:	8a 95       	dec	r24
     e76:	f1 f7       	brne	.-4      	; 0xe74 <updateLEDs+0x1c>
        _delay_us(10);

        // Keep the data pin, and set clk pin to 1 (strobe)
        PORTC |= 1 << WS2803_CKI;
     e78:	47 9a       	sbi	0x08, 7	; 8
     e7a:	83 2f       	mov	r24, r19
     e7c:	8a 95       	dec	r24
     e7e:	f1 f7       	brne	.-4      	; 0xe7c <updateLEDs+0x24>
        _delay_us(10);

        // Zero both clk and data pins
        PORTC &= ~((1 << WS2803_SDI) | (1 << WS2803_CKI));
     e80:	88 b1       	in	r24, 0x08	; 8
     e82:	8f 73       	andi	r24, 0x3F	; 63
     e84:	88 b9       	out	0x08, r24	; 8
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
	data = buttLedData[i];
	for(uint8_t i=7; i<255; i--)
     e86:	21 50       	subi	r18, 0x01	; 1
     e88:	2f 3f       	cpi	r18, 0xFF	; 255
     e8a:	61 f0       	breq	.+24     	; 0xea4 <updateLEDs+0x4c>
    {
        outbyte = (data>>i) & 0x01;
        // Set the data pin to given value, and clk pin to 0
        if(outbyte)
     e8c:	ca 01       	movw	r24, r20
     e8e:	02 2e       	mov	r0, r18
     e90:	02 c0       	rjmp	.+4      	; 0xe96 <updateLEDs+0x3e>
     e92:	95 95       	asr	r25
     e94:	87 95       	ror	r24
     e96:	0a 94       	dec	r0
     e98:	e2 f7       	brpl	.-8      	; 0xe92 <updateLEDs+0x3a>
     e9a:	80 fd       	sbrc	r24, 0
     e9c:	e8 cf       	rjmp	.-48     	; 0xe6e <updateLEDs+0x16>
        {
            PORTC |= (outbyte << WS2803_SDI);
        }
        else
        {
            PORTC &= ~(outbyte << WS2803_SDI);
     e9e:	88 b1       	in	r24, 0x08	; 8
     ea0:	88 b9       	out	0x08, r24	; 8
     ea2:	e6 cf       	rjmp	.-52     	; 0xe70 <updateLEDs+0x18>
  uint16_t i = 0;
  //uint8_t  j = 0;
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
     ea4:	61 50       	subi	r22, 0x01	; 1
     ea6:	70 40       	sbci	r23, 0x00	; 0
     ea8:	8f ef       	ldi	r24, 0xFF	; 255
     eaa:	6f 3f       	cpi	r22, 0xFF	; 255
     eac:	78 07       	cpc	r23, r24
     eae:	b9 f6       	brne	.-82     	; 0xe5e <updateLEDs+0x6>
        PORTC &= ~((1 << WS2803_SDI) | (1 << WS2803_CKI));
    }
  }

  return;
}
     eb0:	08 95       	ret

00000eb2 <changeMotorButtonLED>:

/* ---------------------------------------------------------------------
   change motor button LED color/intensity
 --------------------------------------------------------------------- */
void changeMotorButtonLED(uint8_t motor, uint8_t enable){
     eb2:	1f 93       	push	r17
     eb4:	18 2f       	mov	r17, r24
    
  if(enable){ //button lights white
     eb6:	66 23       	and	r22, r22
     eb8:	81 f4       	brne	.+32     	; 0xeda <changeMotorButtonLED+0x28>
    changeButtonLED(motor, BLUE, 0x0F);
    changeButtonLED(motor, GREEN, 0x0F);
    changeButtonLED(motor, RED, 0x08);
  }
  else{ //button lights green
    changeButtonLED(motor, BLUE, 0x00);
     eba:	60 e0       	ldi	r22, 0x00	; 0
     ebc:	40 e0       	ldi	r20, 0x00	; 0
     ebe:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, GREEN, 0x0F);
     ec2:	81 2f       	mov	r24, r17
     ec4:	61 e0       	ldi	r22, 0x01	; 1
     ec6:	4f e0       	ldi	r20, 0x0F	; 15
     ec8:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, RED, 0x00);
     ecc:	81 2f       	mov	r24, r17
     ece:	62 e0       	ldi	r22, 0x02	; 2
     ed0:	40 e0       	ldi	r20, 0x00	; 0
     ed2:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
  }
  //updateLEDs();

  return;
}
     ed6:	1f 91       	pop	r17
     ed8:	08 95       	ret
   change motor button LED color/intensity
 --------------------------------------------------------------------- */
void changeMotorButtonLED(uint8_t motor, uint8_t enable){
    
  if(enable){ //button lights white
    changeButtonLED(motor, BLUE, 0x0F);
     eda:	60 e0       	ldi	r22, 0x00	; 0
     edc:	4f e0       	ldi	r20, 0x0F	; 15
     ede:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, GREEN, 0x0F);
     ee2:	81 2f       	mov	r24, r17
     ee4:	61 e0       	ldi	r22, 0x01	; 1
     ee6:	4f e0       	ldi	r20, 0x0F	; 15
     ee8:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, RED, 0x08);
     eec:	81 2f       	mov	r24, r17
     eee:	62 e0       	ldi	r22, 0x02	; 2
     ef0:	48 e0       	ldi	r20, 0x08	; 8
     ef2:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
    changeButtonLED(motor, RED, 0x00);
  }
  //updateLEDs();

  return;
}
     ef6:	1f 91       	pop	r17
     ef8:	08 95       	ret

00000efa <updateMotorButtonLEDs>:

/* ---------------------------------------------------------------------
   update motor button LEDs
 --------------------------------------------------------------------- */
void updateMotorButtonLEDs(void){
     efa:	cf 93       	push	r28
     efc:	df 93       	push	r29
     efe:	c0 e0       	ldi	r28, 0x00	; 0
     f00:	d0 e0       	ldi	r29, 0x00	; 0
  
  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    if(menu.selectedMotor & (1 << i)){
     f02:	80 91 e5 02 	lds	r24, 0x02E5
     f06:	90 e0       	ldi	r25, 0x00	; 0
     f08:	0c 2e       	mov	r0, r28
     f0a:	02 c0       	rjmp	.+4      	; 0xf10 <updateMotorButtonLEDs+0x16>
     f0c:	95 95       	asr	r25
     f0e:	87 95       	ror	r24
     f10:	0a 94       	dec	r0
     f12:	e2 f7       	brpl	.-8      	; 0xf0c <updateMotorButtonLEDs+0x12>
     f14:	80 ff       	sbrs	r24, 0
     f16:	0d c0       	rjmp	.+26     	; 0xf32 <updateMotorButtonLEDs+0x38>
      changeMotorButtonLED(i, 1);
     f18:	8c 2f       	mov	r24, r28
     f1a:	61 e0       	ldi	r22, 0x01	; 1
     f1c:	0e 94 59 07 	call	0xeb2	; 0xeb2 <changeMotorButtonLED>
    }
    else{
      changeMotorButtonLED(i, 0);
     f20:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void updateMotorButtonLEDs(void){
  
  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
     f22:	c4 30       	cpi	r28, 0x04	; 4
     f24:	d1 05       	cpc	r29, r1
     f26:	69 f7       	brne	.-38     	; 0xf02 <updateMotorButtonLEDs+0x8>
    }
    else{
      changeMotorButtonLED(i, 0);
    }
  }
  updateLEDs();
     f28:	0e 94 2c 07 	call	0xe58	; 0xe58 <updateLEDs>
  
  return;
}
     f2c:	df 91       	pop	r29
     f2e:	cf 91       	pop	r28
     f30:	08 95       	ret
  for(i = 0; i <= MAX_MOTOR; i++){
    if(menu.selectedMotor & (1 << i)){
      changeMotorButtonLED(i, 1);
    }
    else{
      changeMotorButtonLED(i, 0);
     f32:	8c 2f       	mov	r24, r28
     f34:	60 e0       	ldi	r22, 0x00	; 0
     f36:	0e 94 59 07 	call	0xeb2	; 0xeb2 <changeMotorButtonLED>
     f3a:	f2 cf       	rjmp	.-28     	; 0xf20 <updateMotorButtonLEDs+0x26>

00000f3c <stepsToDegree>:
}

/* ---------------------------------------------------------------------
   calculate degree from steps
 --------------------------------------------------------------------- */
double stepsToDegree(uint8_t mot, int16_t steps){
     f3c:	2f 92       	push	r2
     f3e:	3f 92       	push	r3
     f40:	4f 92       	push	r4
     f42:	5f 92       	push	r5
     f44:	6f 92       	push	r6
     f46:	7f 92       	push	r7
     f48:	8f 92       	push	r8
     f4a:	9f 92       	push	r9
     f4c:	af 92       	push	r10
     f4e:	bf 92       	push	r11
     f50:	cf 92       	push	r12
     f52:	df 92       	push	r13
     f54:	ef 92       	push	r14
     f56:	ff 92       	push	r15
     f58:	0f 93       	push	r16
     f5a:	1f 93       	push	r17
     f5c:	48 2f       	mov	r20, r24

  double radian = 0.0f;

  radian = (steps) * ( (360.0f)/(motor[mot].gearRatio
     f5e:	a0 ef       	ldi	r26, 0xF0	; 240
     f60:	b3 e0       	ldi	r27, 0x03	; 3
     f62:	e8 2f       	mov	r30, r24
     f64:	f0 e0       	ldi	r31, 0x00	; 0
     f66:	ee 0f       	add	r30, r30
     f68:	ff 1f       	adc	r31, r31
     f6a:	ee 0f       	add	r30, r30
     f6c:	ff 1f       	adc	r31, r31
     f6e:	ee 0f       	add	r30, r30
     f70:	ff 1f       	adc	r31, r31
     f72:	9f 01       	movw	r18, r30
     f74:	22 0f       	add	r18, r18
     f76:	33 1f       	adc	r19, r19
     f78:	22 0f       	add	r18, r18
     f7a:	33 1f       	adc	r19, r19
     f7c:	e2 0f       	add	r30, r18
     f7e:	f3 1f       	adc	r31, r19
     f80:	ea 0f       	add	r30, r26
     f82:	fb 1f       	adc	r31, r27
     f84:	25 84       	ldd	r2, Z+13	; 0x0d
     f86:	36 84       	ldd	r3, Z+14	; 0x0e
     f88:	47 84       	ldd	r4, Z+15	; 0x0f
     f8a:	50 88       	ldd	r5, Z+16	; 0x10
     f8c:	e4 2f       	mov	r30, r20
     f8e:	f0 e0       	ldi	r31, 0x00	; 0
     f90:	ee 0f       	add	r30, r30
     f92:	ff 1f       	adc	r31, r31
     f94:	ee 0f       	add	r30, r30
     f96:	ff 1f       	adc	r31, r31
     f98:	ee 0f       	add	r30, r30
     f9a:	ff 1f       	adc	r31, r31
     f9c:	9f 01       	movw	r18, r30
     f9e:	22 0f       	add	r18, r18
     fa0:	33 1f       	adc	r19, r19
     fa2:	22 0f       	add	r18, r18
     fa4:	33 1f       	adc	r19, r19
     fa6:	e2 0f       	add	r30, r18
     fa8:	f3 1f       	adc	r31, r19
     faa:	ea 0f       	add	r30, r26
     fac:	fb 1f       	adc	r31, r27
     fae:	65 88       	ldd	r6, Z+21	; 0x15
     fb0:	76 88       	ldd	r7, Z+22	; 0x16
     fb2:	87 88       	ldd	r8, Z+23	; 0x17
     fb4:	90 8c       	ldd	r9, Z+24	; 0x18
     fb6:	24 2f       	mov	r18, r20
     fb8:	30 e0       	ldi	r19, 0x00	; 0
     fba:	22 0f       	add	r18, r18
     fbc:	33 1f       	adc	r19, r19
     fbe:	22 0f       	add	r18, r18
     fc0:	33 1f       	adc	r19, r19
     fc2:	22 0f       	add	r18, r18
     fc4:	33 1f       	adc	r19, r19
     fc6:	a9 01       	movw	r20, r18
     fc8:	44 0f       	add	r20, r20
     fca:	55 1f       	adc	r21, r21
     fcc:	44 0f       	add	r20, r20
     fce:	55 1f       	adc	r21, r21
     fd0:	24 0f       	add	r18, r20
     fd2:	35 1f       	adc	r19, r21
     fd4:	a2 0f       	add	r26, r18
     fd6:	b3 1f       	adc	r27, r19
     fd8:	51 96       	adiw	r26, 0x11	; 17
     fda:	ed 90       	ld	r14, X+
     fdc:	fd 90       	ld	r15, X+
     fde:	0d 91       	ld	r16, X+
     fe0:	1c 91       	ld	r17, X
     fe2:	54 97       	sbiw	r26, 0x14	; 20
     fe4:	88 27       	eor	r24, r24
     fe6:	77 fd       	sbrc	r23, 7
     fe8:	80 95       	com	r24
     fea:	98 2f       	mov	r25, r24
     fec:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
     ff0:	5b 01       	movw	r10, r22
     ff2:	6c 01       	movw	r12, r24
     ff4:	c2 01       	movw	r24, r4
     ff6:	b1 01       	movw	r22, r2
     ff8:	a4 01       	movw	r20, r8
     ffa:	93 01       	movw	r18, r6
     ffc:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    1000:	a8 01       	movw	r20, r16
    1002:	97 01       	movw	r18, r14
    1004:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    1008:	9b 01       	movw	r18, r22
    100a:	ac 01       	movw	r20, r24
    100c:	60 e0       	ldi	r22, 0x00	; 0
    100e:	70 e0       	ldi	r23, 0x00	; 0
    1010:	84 eb       	ldi	r24, 0xB4	; 180
    1012:	93 e4       	ldi	r25, 0x43	; 67
    1014:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>
    1018:	9b 01       	movw	r18, r22
    101a:	ac 01       	movw	r20, r24
    101c:	c6 01       	movw	r24, r12
    101e:	b5 01       	movw	r22, r10
    1020:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
                                *motor[mot].subSteps
                                *motor[mot].stepsPerFullRotation) );

  return radian;
}
    1024:	1f 91       	pop	r17
    1026:	0f 91       	pop	r16
    1028:	ff 90       	pop	r15
    102a:	ef 90       	pop	r14
    102c:	df 90       	pop	r13
    102e:	cf 90       	pop	r12
    1030:	bf 90       	pop	r11
    1032:	af 90       	pop	r10
    1034:	9f 90       	pop	r9
    1036:	8f 90       	pop	r8
    1038:	7f 90       	pop	r7
    103a:	6f 90       	pop	r6
    103c:	5f 90       	pop	r5
    103e:	4f 90       	pop	r4
    1040:	3f 90       	pop	r3
    1042:	2f 90       	pop	r2
    1044:	08 95       	ret

00001046 <stepsToRadian>:
}

/* ---------------------------------------------------------------------
   calculate radians from steps
 --------------------------------------------------------------------- */
double stepsToRadian(uint8_t mot, int16_t steps){
    1046:	2f 92       	push	r2
    1048:	3f 92       	push	r3
    104a:	4f 92       	push	r4
    104c:	5f 92       	push	r5
    104e:	6f 92       	push	r6
    1050:	7f 92       	push	r7
    1052:	8f 92       	push	r8
    1054:	9f 92       	push	r9
    1056:	af 92       	push	r10
    1058:	bf 92       	push	r11
    105a:	cf 92       	push	r12
    105c:	df 92       	push	r13
    105e:	ef 92       	push	r14
    1060:	ff 92       	push	r15
    1062:	0f 93       	push	r16
    1064:	1f 93       	push	r17
    1066:	48 2f       	mov	r20, r24

  double radian = 0.0f;

  radian = (steps) * ( (2.0f)/(motor[mot].gearRatio
    1068:	a0 ef       	ldi	r26, 0xF0	; 240
    106a:	b3 e0       	ldi	r27, 0x03	; 3
    106c:	e8 2f       	mov	r30, r24
    106e:	f0 e0       	ldi	r31, 0x00	; 0
    1070:	ee 0f       	add	r30, r30
    1072:	ff 1f       	adc	r31, r31
    1074:	ee 0f       	add	r30, r30
    1076:	ff 1f       	adc	r31, r31
    1078:	ee 0f       	add	r30, r30
    107a:	ff 1f       	adc	r31, r31
    107c:	9f 01       	movw	r18, r30
    107e:	22 0f       	add	r18, r18
    1080:	33 1f       	adc	r19, r19
    1082:	22 0f       	add	r18, r18
    1084:	33 1f       	adc	r19, r19
    1086:	e2 0f       	add	r30, r18
    1088:	f3 1f       	adc	r31, r19
    108a:	ea 0f       	add	r30, r26
    108c:	fb 1f       	adc	r31, r27
    108e:	25 84       	ldd	r2, Z+13	; 0x0d
    1090:	36 84       	ldd	r3, Z+14	; 0x0e
    1092:	47 84       	ldd	r4, Z+15	; 0x0f
    1094:	50 88       	ldd	r5, Z+16	; 0x10
    1096:	e4 2f       	mov	r30, r20
    1098:	f0 e0       	ldi	r31, 0x00	; 0
    109a:	ee 0f       	add	r30, r30
    109c:	ff 1f       	adc	r31, r31
    109e:	ee 0f       	add	r30, r30
    10a0:	ff 1f       	adc	r31, r31
    10a2:	ee 0f       	add	r30, r30
    10a4:	ff 1f       	adc	r31, r31
    10a6:	9f 01       	movw	r18, r30
    10a8:	22 0f       	add	r18, r18
    10aa:	33 1f       	adc	r19, r19
    10ac:	22 0f       	add	r18, r18
    10ae:	33 1f       	adc	r19, r19
    10b0:	e2 0f       	add	r30, r18
    10b2:	f3 1f       	adc	r31, r19
    10b4:	ea 0f       	add	r30, r26
    10b6:	fb 1f       	adc	r31, r27
    10b8:	65 88       	ldd	r6, Z+21	; 0x15
    10ba:	76 88       	ldd	r7, Z+22	; 0x16
    10bc:	87 88       	ldd	r8, Z+23	; 0x17
    10be:	90 8c       	ldd	r9, Z+24	; 0x18
    10c0:	24 2f       	mov	r18, r20
    10c2:	30 e0       	ldi	r19, 0x00	; 0
    10c4:	22 0f       	add	r18, r18
    10c6:	33 1f       	adc	r19, r19
    10c8:	22 0f       	add	r18, r18
    10ca:	33 1f       	adc	r19, r19
    10cc:	22 0f       	add	r18, r18
    10ce:	33 1f       	adc	r19, r19
    10d0:	a9 01       	movw	r20, r18
    10d2:	44 0f       	add	r20, r20
    10d4:	55 1f       	adc	r21, r21
    10d6:	44 0f       	add	r20, r20
    10d8:	55 1f       	adc	r21, r21
    10da:	24 0f       	add	r18, r20
    10dc:	35 1f       	adc	r19, r21
    10de:	a2 0f       	add	r26, r18
    10e0:	b3 1f       	adc	r27, r19
    10e2:	51 96       	adiw	r26, 0x11	; 17
    10e4:	ed 90       	ld	r14, X+
    10e6:	fd 90       	ld	r15, X+
    10e8:	0d 91       	ld	r16, X+
    10ea:	1c 91       	ld	r17, X
    10ec:	54 97       	sbiw	r26, 0x14	; 20
    10ee:	88 27       	eor	r24, r24
    10f0:	77 fd       	sbrc	r23, 7
    10f2:	80 95       	com	r24
    10f4:	98 2f       	mov	r25, r24
    10f6:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    10fa:	5b 01       	movw	r10, r22
    10fc:	6c 01       	movw	r12, r24
    10fe:	c2 01       	movw	r24, r4
    1100:	b1 01       	movw	r22, r2
    1102:	a4 01       	movw	r20, r8
    1104:	93 01       	movw	r18, r6
    1106:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    110a:	a8 01       	movw	r20, r16
    110c:	97 01       	movw	r18, r14
    110e:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    1112:	9b 01       	movw	r18, r22
    1114:	ac 01       	movw	r20, r24
    1116:	60 e0       	ldi	r22, 0x00	; 0
    1118:	70 e0       	ldi	r23, 0x00	; 0
    111a:	80 e0       	ldi	r24, 0x00	; 0
    111c:	90 e4       	ldi	r25, 0x40	; 64
    111e:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>
    1122:	9b 01       	movw	r18, r22
    1124:	ac 01       	movw	r20, r24
    1126:	c6 01       	movw	r24, r12
    1128:	b5 01       	movw	r22, r10
    112a:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
                              *motor[mot].subSteps
                              *motor[mot].stepsPerFullRotation) );

  return radian;
}
    112e:	1f 91       	pop	r17
    1130:	0f 91       	pop	r16
    1132:	ff 90       	pop	r15
    1134:	ef 90       	pop	r14
    1136:	df 90       	pop	r13
    1138:	cf 90       	pop	r12
    113a:	bf 90       	pop	r11
    113c:	af 90       	pop	r10
    113e:	9f 90       	pop	r9
    1140:	8f 90       	pop	r8
    1142:	7f 90       	pop	r7
    1144:	6f 90       	pop	r6
    1146:	5f 90       	pop	r5
    1148:	4f 90       	pop	r4
    114a:	3f 90       	pop	r3
    114c:	2f 90       	pop	r2
    114e:	08 95       	ret

00001150 <setConstSpeed>:

/* ---------------------------------------------------------------------
   set constant angular velocity
 --------------------------------------------------------------------- */
void setConstSpeed(uint8_t i, uint8_t state){
    1150:	48 2f       	mov	r20, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1152:	f8 94       	cli

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    switch(state){
    1154:	61 30       	cpi	r22, 0x01	; 1
    1156:	09 f4       	brne	.+2      	; 0x115a <setConstSpeed+0xa>
    1158:	3d c0       	rjmp	.+122    	; 0x11d4 <setConstSpeed+0x84>
    115a:	61 30       	cpi	r22, 0x01	; 1
    115c:	08 f0       	brcs	.+2      	; 0x1160 <setConstSpeed+0x10>
    115e:	88 c0       	rjmp	.+272    	; 0x1270 <setConstSpeed+0x120>
      case MOTOR_MOVE_INFINITE_STOP:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    1160:	e8 2f       	mov	r30, r24
    1162:	f0 e0       	ldi	r31, 0x00	; 0
    1164:	ee 0f       	add	r30, r30
    1166:	ff 1f       	adc	r31, r31
    1168:	ee 0f       	add	r30, r30
    116a:	ff 1f       	adc	r31, r31
    116c:	ee 0f       	add	r30, r30
    116e:	ff 1f       	adc	r31, r31
    1170:	cf 01       	movw	r24, r30
    1172:	88 0f       	add	r24, r24
    1174:	99 1f       	adc	r25, r25
    1176:	88 0f       	add	r24, r24
    1178:	99 1f       	adc	r25, r25
    117a:	e8 0f       	add	r30, r24
    117c:	f9 1f       	adc	r31, r25
    117e:	e0 51       	subi	r30, 0x10	; 16
    1180:	fc 4f       	sbci	r31, 0xFC	; 252
    1182:	14 86       	std	Z+12, r1	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    1184:	e4 2f       	mov	r30, r20
    1186:	f0 e0       	ldi	r31, 0x00	; 0
    1188:	ee 0f       	add	r30, r30
    118a:	ff 1f       	adc	r31, r31
    118c:	ee 0f       	add	r30, r30
    118e:	ff 1f       	adc	r31, r31
    1190:	ee 0f       	add	r30, r30
    1192:	ff 1f       	adc	r31, r31
    1194:	cf 01       	movw	r24, r30
    1196:	88 0f       	add	r24, r24
    1198:	99 1f       	adc	r25, r25
    119a:	88 0f       	add	r24, r24
    119c:	99 1f       	adc	r25, r25
    119e:	e8 0f       	add	r30, r24
    11a0:	f9 1f       	adc	r31, r25
    11a2:	e0 51       	subi	r30, 0x10	; 16
    11a4:	fc 4f       	sbci	r31, 0xFC	; 252
    11a6:	20 81       	ld	r18, Z
    11a8:	31 81       	ldd	r19, Z+1	; 0x01
        break;

      case MOTOR_MOVE_INFINITE_CCW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
        motor[i].desiredPosition  = motor[i].actualPosition;
        motor[i].desiredPosition += -1;
    11aa:	e4 2f       	mov	r30, r20
    11ac:	f0 e0       	ldi	r31, 0x00	; 0
    11ae:	ee 0f       	add	r30, r30
    11b0:	ff 1f       	adc	r31, r31
    11b2:	ee 0f       	add	r30, r30
    11b4:	ff 1f       	adc	r31, r31
    11b6:	cf 01       	movw	r24, r30
    11b8:	88 0f       	add	r24, r24
    11ba:	99 1f       	adc	r25, r25
    11bc:	88 0f       	add	r24, r24
    11be:	99 1f       	adc	r25, r25
    11c0:	e8 0f       	add	r30, r24
    11c2:	f9 1f       	adc	r31, r25
    11c4:	ee 0f       	add	r30, r30
    11c6:	ff 1f       	adc	r31, r31
    11c8:	ee 50       	subi	r30, 0x0E	; 14
    11ca:	fc 4f       	sbci	r31, 0xFC	; 252
    11cc:	31 83       	std	Z+1, r19	; 0x01
    11ce:	20 83       	st	Z, r18
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    11d0:	78 94       	sei
        break;
    }
  }

  return;
}
    11d2:	08 95       	ret
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
        motor[i].desiredPosition  = motor[i].actualPosition;
        break;

      case MOTOR_MOVE_INFINITE_CW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CW;
    11d4:	e8 2f       	mov	r30, r24
    11d6:	f0 e0       	ldi	r31, 0x00	; 0
    11d8:	ee 0f       	add	r30, r30
    11da:	ff 1f       	adc	r31, r31
    11dc:	ee 0f       	add	r30, r30
    11de:	ff 1f       	adc	r31, r31
    11e0:	ee 0f       	add	r30, r30
    11e2:	ff 1f       	adc	r31, r31
    11e4:	cf 01       	movw	r24, r30
    11e6:	88 0f       	add	r24, r24
    11e8:	99 1f       	adc	r25, r25
    11ea:	88 0f       	add	r24, r24
    11ec:	99 1f       	adc	r25, r25
    11ee:	e8 0f       	add	r30, r24
    11f0:	f9 1f       	adc	r31, r25
    11f2:	e0 51       	subi	r30, 0x10	; 16
    11f4:	fc 4f       	sbci	r31, 0xFC	; 252
    11f6:	64 87       	std	Z+12, r22	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    11f8:	e4 2f       	mov	r30, r20
    11fa:	f0 e0       	ldi	r31, 0x00	; 0
    11fc:	ee 0f       	add	r30, r30
    11fe:	ff 1f       	adc	r31, r31
    1200:	ee 0f       	add	r30, r30
    1202:	ff 1f       	adc	r31, r31
    1204:	ee 0f       	add	r30, r30
    1206:	ff 1f       	adc	r31, r31
    1208:	cf 01       	movw	r24, r30
    120a:	88 0f       	add	r24, r24
    120c:	99 1f       	adc	r25, r25
    120e:	88 0f       	add	r24, r24
    1210:	99 1f       	adc	r25, r25
    1212:	e8 0f       	add	r30, r24
    1214:	f9 1f       	adc	r31, r25
    1216:	e0 51       	subi	r30, 0x10	; 16
    1218:	fc 4f       	sbci	r31, 0xFC	; 252
    121a:	20 81       	ld	r18, Z
    121c:	31 81       	ldd	r19, Z+1	; 0x01
    121e:	e4 2f       	mov	r30, r20
    1220:	f0 e0       	ldi	r31, 0x00	; 0
    1222:	ee 0f       	add	r30, r30
    1224:	ff 1f       	adc	r31, r31
    1226:	ee 0f       	add	r30, r30
    1228:	ff 1f       	adc	r31, r31
    122a:	cf 01       	movw	r24, r30
    122c:	88 0f       	add	r24, r24
    122e:	99 1f       	adc	r25, r25
    1230:	88 0f       	add	r24, r24
    1232:	99 1f       	adc	r25, r25
    1234:	e8 0f       	add	r30, r24
    1236:	f9 1f       	adc	r31, r25
    1238:	ee 0f       	add	r30, r30
    123a:	ff 1f       	adc	r31, r31
    123c:	ee 50       	subi	r30, 0x0E	; 14
    123e:	fc 4f       	sbci	r31, 0xFC	; 252
    1240:	31 83       	std	Z+1, r19	; 0x01
    1242:	20 83       	st	Z, r18
        motor[i].desiredPosition += 1;
    1244:	e4 2f       	mov	r30, r20
    1246:	f0 e0       	ldi	r31, 0x00	; 0
    1248:	ee 0f       	add	r30, r30
    124a:	ff 1f       	adc	r31, r31
    124c:	ee 0f       	add	r30, r30
    124e:	ff 1f       	adc	r31, r31
    1250:	cf 01       	movw	r24, r30
    1252:	88 0f       	add	r24, r24
    1254:	99 1f       	adc	r25, r25
    1256:	88 0f       	add	r24, r24
    1258:	99 1f       	adc	r25, r25
    125a:	e8 0f       	add	r30, r24
    125c:	f9 1f       	adc	r31, r25
    125e:	ee 0f       	add	r30, r30
    1260:	ff 1f       	adc	r31, r31
    1262:	ee 50       	subi	r30, 0x0E	; 14
    1264:	fc 4f       	sbci	r31, 0xFC	; 252
    1266:	20 81       	ld	r18, Z
    1268:	31 81       	ldd	r19, Z+1	; 0x01
    126a:	2f 5f       	subi	r18, 0xFF	; 255
    126c:	3f 4f       	sbci	r19, 0xFF	; 255
    126e:	9d cf       	rjmp	.-198    	; 0x11aa <setConstSpeed+0x5a>
   set constant angular velocity
 --------------------------------------------------------------------- */
void setConstSpeed(uint8_t i, uint8_t state){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    switch(state){
    1270:	62 30       	cpi	r22, 0x02	; 2
    1272:	09 f0       	breq	.+2      	; 0x1276 <setConstSpeed+0x126>
    1274:	ad cf       	rjmp	.-166    	; 0x11d0 <setConstSpeed+0x80>
        motor[i].desiredPosition  = motor[i].actualPosition;
        motor[i].desiredPosition += 1;
        break;

      case MOTOR_MOVE_INFINITE_CCW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
    1276:	e8 2f       	mov	r30, r24
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	ee 0f       	add	r30, r30
    127c:	ff 1f       	adc	r31, r31
    127e:	ee 0f       	add	r30, r30
    1280:	ff 1f       	adc	r31, r31
    1282:	ee 0f       	add	r30, r30
    1284:	ff 1f       	adc	r31, r31
    1286:	cf 01       	movw	r24, r30
    1288:	88 0f       	add	r24, r24
    128a:	99 1f       	adc	r25, r25
    128c:	88 0f       	add	r24, r24
    128e:	99 1f       	adc	r25, r25
    1290:	e8 0f       	add	r30, r24
    1292:	f9 1f       	adc	r31, r25
    1294:	e0 51       	subi	r30, 0x10	; 16
    1296:	fc 4f       	sbci	r31, 0xFC	; 252
    1298:	64 87       	std	Z+12, r22	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    129a:	e4 2f       	mov	r30, r20
    129c:	f0 e0       	ldi	r31, 0x00	; 0
    129e:	ee 0f       	add	r30, r30
    12a0:	ff 1f       	adc	r31, r31
    12a2:	ee 0f       	add	r30, r30
    12a4:	ff 1f       	adc	r31, r31
    12a6:	ee 0f       	add	r30, r30
    12a8:	ff 1f       	adc	r31, r31
    12aa:	cf 01       	movw	r24, r30
    12ac:	88 0f       	add	r24, r24
    12ae:	99 1f       	adc	r25, r25
    12b0:	88 0f       	add	r24, r24
    12b2:	99 1f       	adc	r25, r25
    12b4:	e8 0f       	add	r30, r24
    12b6:	f9 1f       	adc	r31, r25
    12b8:	e0 51       	subi	r30, 0x10	; 16
    12ba:	fc 4f       	sbci	r31, 0xFC	; 252
    12bc:	20 81       	ld	r18, Z
    12be:	31 81       	ldd	r19, Z+1	; 0x01
    12c0:	e4 2f       	mov	r30, r20
    12c2:	f0 e0       	ldi	r31, 0x00	; 0
    12c4:	ee 0f       	add	r30, r30
    12c6:	ff 1f       	adc	r31, r31
    12c8:	ee 0f       	add	r30, r30
    12ca:	ff 1f       	adc	r31, r31
    12cc:	cf 01       	movw	r24, r30
    12ce:	88 0f       	add	r24, r24
    12d0:	99 1f       	adc	r25, r25
    12d2:	88 0f       	add	r24, r24
    12d4:	99 1f       	adc	r25, r25
    12d6:	e8 0f       	add	r30, r24
    12d8:	f9 1f       	adc	r31, r25
    12da:	ee 0f       	add	r30, r30
    12dc:	ff 1f       	adc	r31, r31
    12de:	ee 50       	subi	r30, 0x0E	; 14
    12e0:	fc 4f       	sbci	r31, 0xFC	; 252
    12e2:	31 83       	std	Z+1, r19	; 0x01
    12e4:	20 83       	st	Z, r18
        motor[i].desiredPosition += -1;
    12e6:	e4 2f       	mov	r30, r20
    12e8:	f0 e0       	ldi	r31, 0x00	; 0
    12ea:	ee 0f       	add	r30, r30
    12ec:	ff 1f       	adc	r31, r31
    12ee:	ee 0f       	add	r30, r30
    12f0:	ff 1f       	adc	r31, r31
    12f2:	cf 01       	movw	r24, r30
    12f4:	88 0f       	add	r24, r24
    12f6:	99 1f       	adc	r25, r25
    12f8:	88 0f       	add	r24, r24
    12fa:	99 1f       	adc	r25, r25
    12fc:	e8 0f       	add	r30, r24
    12fe:	f9 1f       	adc	r31, r25
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	ee 50       	subi	r30, 0x0E	; 14
    1306:	fc 4f       	sbci	r31, 0xFC	; 252
    1308:	20 81       	ld	r18, Z
    130a:	31 81       	ldd	r19, Z+1	; 0x01
    130c:	21 50       	subi	r18, 0x01	; 1
    130e:	30 40       	sbci	r19, 0x00	; 0
    1310:	4c cf       	rjmp	.-360    	; 0x11aa <setConstSpeed+0x5a>

00001312 <initIIC>:
/* ---------------------------------------------------------------------
   initialize I2C system
 --------------------------------------------------------------------- */
void initIIC(void){

  TWBR = TWBR_VALUE;    /* see macro above */
    1312:	81 e1       	ldi	r24, 0x11	; 17
    1314:	80 93 b8 00 	sts	0x00B8, r24
  TWSR &= ~((1<<TWPS0) | (1<<TWPS1));
    1318:	e9 eb       	ldi	r30, 0xB9	; 185
    131a:	f0 e0       	ldi	r31, 0x00	; 0
    131c:	80 81       	ld	r24, Z
    131e:	8c 7f       	andi	r24, 0xFC	; 252
    1320:	80 83       	st	Z, r24
  TWCR = (1<<TWEN);
    1322:	84 e0       	ldi	r24, 0x04	; 4
    1324:	80 93 bc 00 	sts	0x00BC, r24

  return;
}
    1328:	08 95       	ret

0000132a <IICstart>:
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    132a:	84 ea       	ldi	r24, 0xA4	; 164
    132c:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    1330:	80 91 bc 00 	lds	r24, 0x00BC
    1334:	87 ff       	sbrs	r24, 7
    1336:	fc cf       	rjmp	.-8      	; 0x1330 <IICstart+0x6>

  return;
}
    1338:	08 95       	ret

0000133a <IICstop>:
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    133a:	84 e9       	ldi	r24, 0x94	; 148
    133c:	80 93 bc 00 	sts	0x00BC, r24

  return;
}
    1340:	08 95       	ret

00001342 <IICsendByte>:
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    1342:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);
    1346:	84 e8       	ldi	r24, 0x84	; 132
    1348:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    134c:	80 91 bc 00 	lds	r24, 0x00BC
    1350:	87 ff       	sbrs	r24, 7
    1352:	fc cf       	rjmp	.-8      	; 0x134c <IICsendByte+0xa>

  return;
}
    1354:	08 95       	ret

00001356 <IICreadACK>:
/* ---------------------------------------------------------------------
   read a single byte with ACK
 --------------------------------------------------------------------- */
uint8_t IICreadACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    1356:	84 ec       	ldi	r24, 0xC4	; 196
    1358:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    135c:	80 91 bc 00 	lds	r24, 0x00BC
    1360:	87 ff       	sbrs	r24, 7
    1362:	fc cf       	rjmp	.-8      	; 0x135c <IICreadACK+0x6>

  return TWDR;
    1364:	80 91 bb 00 	lds	r24, 0x00BB
}
    1368:	08 95       	ret

0000136a <IICreadNACK>:
/* ---------------------------------------------------------------------
   read a single byte with NACK
 --------------------------------------------------------------------- */
uint8_t IICreadNACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN);
    136a:	84 e8       	ldi	r24, 0x84	; 132
    136c:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));
    1370:	80 91 bc 00 	lds	r24, 0x00BC
    1374:	87 ff       	sbrs	r24, 7
    1376:	fc cf       	rjmp	.-8      	; 0x1370 <IICreadNACK+0x6>

  return TWDR;
    1378:	80 91 bb 00 	lds	r24, 0x00BB
}
    137c:	08 95       	ret

0000137e <IICgetStatus>:
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    137e:	80 91 b9 00 	lds	r24, 0x00B9

  return status;
}
    1382:	88 7f       	andi	r24, 0xF8	; 248
    1384:	08 95       	ret

00001386 <IICwrite>:

/* ---------------------------------------------------------------------
   send a number of bytes to I2C slave
 --------------------------------------------------------------------- */
void IICwrite(uint8_t addr, uint8_t* data, uint8_t numDat){
    1386:	98 2f       	mov	r25, r24
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    1388:	84 ea       	ldi	r24, 0xA4	; 164
    138a:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    138e:	80 91 bc 00 	lds	r24, 0x00BC
    1392:	87 ff       	sbrs	r24, 7
    1394:	fc cf       	rjmp	.-8      	; 0x138e <IICwrite+0x8>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    1396:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    139a:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    139e:	84 e8       	ldi	r24, 0x84	; 132
    13a0:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    13a4:	80 91 bc 00 	lds	r24, 0x00BC
    13a8:	87 ff       	sbrs	r24, 7
    13aa:	fc cf       	rjmp	.-8      	; 0x13a4 <IICwrite+0x1e>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    13ac:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_WRITE);
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    13b0:	44 23       	and	r20, r20
    13b2:	91 f0       	breq	.+36     	; 0x13d8 <IICwrite+0x52>
    13b4:	fb 01       	movw	r30, r22
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
  TWCR = (1<<TWINT) | (1<<TWEN);
    13b6:	94 e8       	ldi	r25, 0x84	; 132
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    IICsendByte(*data);
    13b8:	80 81       	ld	r24, Z
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    13ba:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);
    13be:	90 93 bc 00 	sts	0x00BC, r25
  while(!(TWCR & (1<<TWINT)));
    13c2:	80 91 bc 00 	lds	r24, 0x00BC
    13c6:	87 ff       	sbrs	r24, 7
    13c8:	fc cf       	rjmp	.-8      	; 0x13c2 <IICwrite+0x3c>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    13ca:	80 91 b9 00 	lds	r24, 0x00B9
    13ce:	31 96       	adiw	r30, 0x01	; 1
  IICsendByte(addr | TW_WRITE);
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    13d0:	8e 2f       	mov	r24, r30
    13d2:	86 1b       	sub	r24, r22
    13d4:	84 17       	cp	r24, r20
    13d6:	80 f3       	brcs	.-32     	; 0x13b8 <IICwrite+0x32>
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    13d8:	84 e9       	ldi	r24, 0x94	; 148
    13da:	80 93 bc 00 	sts	0x00BC, r24
  }

  IICstop();

  return;
}
    13de:	08 95       	ret

000013e0 <IICread>:

/* ---------------------------------------------------------------------
   read a number of bytes from an I2C slave
 --------------------------------------------------------------------- */
void IICread(uint8_t addr, uint8_t* data, uint8_t numDat){
    13e0:	98 2f       	mov	r25, r24
    13e2:	db 01       	movw	r26, r22
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    13e4:	84 ea       	ldi	r24, 0xA4	; 164
    13e6:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    13ea:	80 91 bc 00 	lds	r24, 0x00BC
    13ee:	87 ff       	sbrs	r24, 7
    13f0:	fc cf       	rjmp	.-8      	; 0x13ea <IICread+0xa>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    13f2:	80 91 b9 00 	lds	r24, 0x00B9
  IICstart();
  if(IICgetStatus() != TW_START){
    /* error handling */
  }

  IICsendByte(addr | TW_READ);
    13f6:	91 60       	ori	r25, 0x01	; 1
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    13f8:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    13fc:	84 e8       	ldi	r24, 0x84	; 132
    13fe:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    1402:	80 91 bc 00 	lds	r24, 0x00BC
    1406:	87 ff       	sbrs	r24, 7
    1408:	fc cf       	rjmp	.-8      	; 0x1402 <IICread+0x22>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    140a:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_READ);
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    140e:	50 e0       	ldi	r21, 0x00	; 0
    1410:	41 50       	subi	r20, 0x01	; 1
    1412:	50 40       	sbci	r21, 0x00	; 0
    1414:	14 16       	cp	r1, r20
    1416:	15 06       	cpc	r1, r21
    1418:	a4 f4       	brge	.+40     	; 0x1442 <IICread+0x62>
    141a:	fd 01       	movw	r30, r26
/* ---------------------------------------------------------------------
   read a single byte with ACK
 --------------------------------------------------------------------- */
uint8_t IICreadACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    141c:	24 ec       	ldi	r18, 0xC4	; 196
    141e:	20 93 bc 00 	sts	0x00BC, r18
  while(!(TWCR & (1<<TWINT)));
    1422:	80 91 bc 00 	lds	r24, 0x00BC
    1426:	87 ff       	sbrs	r24, 7
    1428:	fc cf       	rjmp	.-8      	; 0x1422 <IICread+0x42>

  return TWDR;
    142a:	80 91 bb 00 	lds	r24, 0x00BB
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    *data = IICreadACK();
    142e:	81 93       	st	Z+, r24
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    1430:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_READ);
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    1434:	8e 2f       	mov	r24, r30
    1436:	8a 1b       	sub	r24, r26
    1438:	90 e0       	ldi	r25, 0x00	; 0
    143a:	84 17       	cp	r24, r20
    143c:	95 07       	cpc	r25, r21
    143e:	7c f3       	brlt	.-34     	; 0x141e <IICread+0x3e>
    1440:	df 01       	movw	r26, r30
/* ---------------------------------------------------------------------
   read a single byte with NACK
 --------------------------------------------------------------------- */
uint8_t IICreadNACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN);
    1442:	84 e8       	ldi	r24, 0x84	; 132
    1444:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));
    1448:	80 91 bc 00 	lds	r24, 0x00BC
    144c:	87 ff       	sbrs	r24, 7
    144e:	fc cf       	rjmp	.-8      	; 0x1448 <IICread+0x68>

  return TWDR;
    1450:	80 91 bb 00 	lds	r24, 0x00BB
      /* error handling */
    }
    data++;
  }

  *data = IICreadNACK();
    1454:	8c 93       	st	X, r24
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    1456:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    145a:	84 e9       	ldi	r24, 0x94	; 148
    145c:	80 93 bc 00 	sts	0x00BC, r24
  }

  IICstop();

  return;
}
    1460:	08 95       	ret

00001462 <getPortExpanderAddress>:
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1462:	81 30       	cpi	r24, 0x01	; 1
    1464:	61 f0       	breq	.+24     	; 0x147e <getPortExpanderAddress+0x1c>
    1466:	81 30       	cpi	r24, 0x01	; 1
    1468:	30 f0       	brcs	.+12     	; 0x1476 <getPortExpanderAddress+0x14>
    146a:	82 30       	cpi	r24, 0x02	; 2
    146c:	51 f0       	breq	.+20     	; 0x1482 <getPortExpanderAddress+0x20>
    146e:	83 30       	cpi	r24, 0x03	; 3
    1470:	21 f0       	breq	.+8      	; 0x147a <getPortExpanderAddress+0x18>
      addr = IIC_MOTOR2_PORTEXP_ADDR;
      break;

    case MOTOR3:
      addr = IIC_MOTOR3_PORTEXP_ADDR;
      break;
    1472:	80 e0       	ldi	r24, 0x00	; 0
    default:
      addr = 0;
  }

  return addr;
}
    1474:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1476:	82 e4       	ldi	r24, 0x42	; 66
    1478:	08 95       	ret
      addr = IIC_MOTOR1_PORTEXP_ADDR;
      break;

    case MOTOR2:
      addr = IIC_MOTOR2_PORTEXP_ADDR;
      break;
    147a:	88 e4       	ldi	r24, 0x48	; 72
    147c:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    147e:	84 e4       	ldi	r24, 0x44	; 68
    1480:	08 95       	ret
    1482:	86 e4       	ldi	r24, 0x46	; 70
    1484:	08 95       	ret

00001486 <getDACAddress>:
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1486:	81 30       	cpi	r24, 0x01	; 1
    1488:	61 f0       	breq	.+24     	; 0x14a2 <getDACAddress+0x1c>
    148a:	81 30       	cpi	r24, 0x01	; 1
    148c:	30 f0       	brcs	.+12     	; 0x149a <getDACAddress+0x14>
    148e:	82 30       	cpi	r24, 0x02	; 2
    1490:	51 f0       	breq	.+20     	; 0x14a6 <getDACAddress+0x20>
    1492:	83 30       	cpi	r24, 0x03	; 3
    1494:	21 f0       	breq	.+8      	; 0x149e <getDACAddress+0x18>
      addr = IIC_MOTOR2_DAC_ADDR;
      break;

    case MOTOR3:
      addr = IIC_MOTOR3_DAC_ADDR;
      break;
    1496:	80 e0       	ldi	r24, 0x00	; 0
    default:
      addr = 0;
  }

  return addr;
}
    1498:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    149a:	82 e1       	ldi	r24, 0x12	; 18
    149c:	08 95       	ret
      addr = IIC_MOTOR1_DAC_ADDR;
      break;

    case MOTOR2:
      addr = IIC_MOTOR2_DAC_ADDR;
      break;
    149e:	8c e9       	ldi	r24, 0x9C	; 156
    14a0:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    14a2:	84 e1       	ldi	r24, 0x14	; 20
    14a4:	08 95       	ret
    14a6:	8a e9       	ldi	r24, 0x9A	; 154
    14a8:	08 95       	ret

000014aa <initPortExpander>:
====================================================================== */

/* ---------------------------------------------------------------------
   initialize I2C port expanders in byte mode
 --------------------------------------------------------------------- */
void initPortExpander(uint8_t addr){
    14aa:	0f 93       	push	r16
    14ac:	1f 93       	push	r17
    14ae:	18 2f       	mov	r17, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    14b0:	f8 94       	cli

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    /*  register addr  |  register value   |       send it        */
    IIC.data[0] = IOCONA; IIC.data[1] = 0x20; IICwrite(addr, IIC.data, 2);
    14b2:	e0 91 ed 03 	lds	r30, 0x03ED
    14b6:	f0 91 ee 03 	lds	r31, 0x03EE
    14ba:	8a e0       	ldi	r24, 0x0A	; 10
    14bc:	80 83       	st	Z, r24
    14be:	e0 91 ed 03 	lds	r30, 0x03ED
    14c2:	f0 91 ee 03 	lds	r31, 0x03EE
    14c6:	80 e2       	ldi	r24, 0x20	; 32
    14c8:	81 83       	std	Z+1, r24	; 0x01
    14ca:	60 91 ed 03 	lds	r22, 0x03ED
    14ce:	70 91 ee 03 	lds	r23, 0x03EE
    14d2:	81 2f       	mov	r24, r17
    14d4:	42 e0       	ldi	r20, 0x02	; 2
    14d6:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>

    IIC.data[0] = IODIRA; IIC.data[1] = 0x00; IICwrite(addr, IIC.data, 2);
    14da:	e0 91 ed 03 	lds	r30, 0x03ED
    14de:	f0 91 ee 03 	lds	r31, 0x03EE
    14e2:	10 82       	st	Z, r1
    14e4:	e0 91 ed 03 	lds	r30, 0x03ED
    14e8:	f0 91 ee 03 	lds	r31, 0x03EE
    14ec:	11 82       	std	Z+1, r1	; 0x01
    14ee:	60 91 ed 03 	lds	r22, 0x03ED
    14f2:	70 91 ee 03 	lds	r23, 0x03EE
    14f6:	81 2f       	mov	r24, r17
    14f8:	42 e0       	ldi	r20, 0x02	; 2
    14fa:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>
    IIC.data[0] = IODIRB; IIC.data[1] = 0xFF; IICwrite(addr, IIC.data, 2);
    14fe:	e0 91 ed 03 	lds	r30, 0x03ED
    1502:	f0 91 ee 03 	lds	r31, 0x03EE
    1506:	81 e0       	ldi	r24, 0x01	; 1
    1508:	80 83       	st	Z, r24
    150a:	e0 91 ed 03 	lds	r30, 0x03ED
    150e:	f0 91 ee 03 	lds	r31, 0x03EE
    1512:	8f ef       	ldi	r24, 0xFF	; 255
    1514:	81 83       	std	Z+1, r24	; 0x01
    1516:	60 91 ed 03 	lds	r22, 0x03ED
    151a:	70 91 ee 03 	lds	r23, 0x03EE
    151e:	81 2f       	mov	r24, r17
    1520:	42 e0       	ldi	r20, 0x02	; 2
    1522:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>
    IIC.data[0] = GPINTENB; IIC.data[1] = 0x1D; IICwrite(addr, IIC.data, 2);
    1526:	e0 91 ed 03 	lds	r30, 0x03ED
    152a:	f0 91 ee 03 	lds	r31, 0x03EE
    152e:	85 e0       	ldi	r24, 0x05	; 5
    1530:	80 83       	st	Z, r24
    1532:	e0 91 ed 03 	lds	r30, 0x03ED
    1536:	f0 91 ee 03 	lds	r31, 0x03EE
    153a:	8d e1       	ldi	r24, 0x1D	; 29
    153c:	81 83       	std	Z+1, r24	; 0x01
    153e:	60 91 ed 03 	lds	r22, 0x03ED
    1542:	70 91 ee 03 	lds	r23, 0x03EE
    1546:	81 2f       	mov	r24, r17
    1548:	42 e0       	ldi	r20, 0x02	; 2
    154a:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>
    IIC.data[0] = DEFVALB; IIC.data[1] = 0x03; IICwrite(addr, IIC.data, 2);
    154e:	e0 91 ed 03 	lds	r30, 0x03ED
    1552:	f0 91 ee 03 	lds	r31, 0x03EE
    1556:	87 e0       	ldi	r24, 0x07	; 7
    1558:	80 83       	st	Z, r24
    155a:	e0 91 ed 03 	lds	r30, 0x03ED
    155e:	f0 91 ee 03 	lds	r31, 0x03EE
    1562:	03 e0       	ldi	r16, 0x03	; 3
    1564:	01 83       	std	Z+1, r16	; 0x01
    1566:	60 91 ed 03 	lds	r22, 0x03ED
    156a:	70 91 ee 03 	lds	r23, 0x03EE
    156e:	81 2f       	mov	r24, r17
    1570:	42 e0       	ldi	r20, 0x02	; 2
    1572:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>
    IIC.data[0] = INTCONB; IIC.data[1] = 0x03; IICwrite(addr, IIC.data, 2);
    1576:	e0 91 ed 03 	lds	r30, 0x03ED
    157a:	f0 91 ee 03 	lds	r31, 0x03EE
    157e:	89 e0       	ldi	r24, 0x09	; 9
    1580:	80 83       	st	Z, r24
    1582:	e0 91 ed 03 	lds	r30, 0x03ED
    1586:	f0 91 ee 03 	lds	r31, 0x03EE
    158a:	01 83       	std	Z+1, r16	; 0x01
    158c:	60 91 ed 03 	lds	r22, 0x03ED
    1590:	70 91 ee 03 	lds	r23, 0x03EE
    1594:	81 2f       	mov	r24, r17
    1596:	42 e0       	ldi	r20, 0x02	; 2
    1598:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>
    IIC.data[0] = GPIOA; IIC.data[1] = 0x78; IICwrite(addr, IIC.data, 2);
    159c:	e0 91 ed 03 	lds	r30, 0x03ED
    15a0:	f0 91 ee 03 	lds	r31, 0x03EE
    15a4:	82 e1       	ldi	r24, 0x12	; 18
    15a6:	80 83       	st	Z, r24
    15a8:	e0 91 ed 03 	lds	r30, 0x03ED
    15ac:	f0 91 ee 03 	lds	r31, 0x03EE
    15b0:	88 e7       	ldi	r24, 0x78	; 120
    15b2:	81 83       	std	Z+1, r24	; 0x01
    15b4:	60 91 ed 03 	lds	r22, 0x03ED
    15b8:	70 91 ee 03 	lds	r23, 0x03EE
    15bc:	81 2f       	mov	r24, r17
    15be:	42 e0       	ldi	r20, 0x02	; 2
    15c0:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    15c4:	78 94       	sei
  }

  return;
}
    15c6:	1f 91       	pop	r17
    15c8:	0f 91       	pop	r16
    15ca:	08 95       	ret

000015cc <writePortExpanderRegister>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    15cc:	f8 94       	cli
   write port expander register
 --------------------------------------------------------------------- */
void writePortExpanderRegister(uint8_t addr, uint8_t reg, uint8_t val){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    IIC.data[0] = reg; IIC.data[1] = val;
    15ce:	e0 91 ed 03 	lds	r30, 0x03ED
    15d2:	f0 91 ee 03 	lds	r31, 0x03EE
    15d6:	60 83       	st	Z, r22
    15d8:	e0 91 ed 03 	lds	r30, 0x03ED
    15dc:	f0 91 ee 03 	lds	r31, 0x03EE
    15e0:	41 83       	std	Z+1, r20	; 0x01
    IICwrite(addr, IIC.data, 2);
    15e2:	60 91 ed 03 	lds	r22, 0x03ED
    15e6:	70 91 ee 03 	lds	r23, 0x03EE
    15ea:	42 e0       	ldi	r20, 0x02	; 2
    15ec:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    15f0:	78 94       	sei
  }

  return;
}
    15f2:	08 95       	ret

000015f4 <readPortExpanderRegister>:

/* ---------------------------------------------------------------------
   read port expander register
 --------------------------------------------------------------------- */
uint8_t readPortExpanderRegister(uint8_t addr, uint8_t reg){
    15f4:	98 2f       	mov	r25, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    15f6:	f8 94       	cli
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    15f8:	84 ea       	ldi	r24, 0xA4	; 164
    15fa:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    15fe:	80 91 bc 00 	lds	r24, 0x00BC
    1602:	87 ff       	sbrs	r24, 7
    1604:	fc cf       	rjmp	.-8      	; 0x15fe <readPortExpanderRegister+0xa>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    1606:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    160a:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    160e:	84 e8       	ldi	r24, 0x84	; 132
    1610:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    1614:	80 91 bc 00 	lds	r24, 0x00BC
    1618:	87 ff       	sbrs	r24, 7
    161a:	fc cf       	rjmp	.-8      	; 0x1614 <readPortExpanderRegister+0x20>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    161c:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    1620:	60 93 bb 00 	sts	0x00BB, r22
  TWCR = (1<<TWINT) | (1<<TWEN);
    1624:	84 e8       	ldi	r24, 0x84	; 132
    1626:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    162a:	80 91 bc 00 	lds	r24, 0x00BC
    162e:	87 ff       	sbrs	r24, 7
    1630:	fc cf       	rjmp	.-8      	; 0x162a <readPortExpanderRegister+0x36>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    1632:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    1636:	84 ea       	ldi	r24, 0xA4	; 164
    1638:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    163c:	80 91 bc 00 	lds	r24, 0x00BC
    1640:	87 ff       	sbrs	r24, 7
    1642:	fc cf       	rjmp	.-8      	; 0x163c <readPortExpanderRegister+0x48>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    1644:	80 91 b9 00 	lds	r24, 0x00B9
    IICstart();
    if(IICgetStatus() != TW_START){
      /* error handling */
    }

    IICsendByte(addr | TW_READ);
    1648:	91 60       	ori	r25, 0x01	; 1
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    164a:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    164e:	84 e8       	ldi	r24, 0x84	; 132
    1650:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    1654:	80 91 bc 00 	lds	r24, 0x00BC
    1658:	87 ff       	sbrs	r24, 7
    165a:	fc cf       	rjmp	.-8      	; 0x1654 <readPortExpanderRegister+0x60>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    165c:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   read a single byte with NACK
 --------------------------------------------------------------------- */
uint8_t IICreadNACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN);
    1660:	84 e8       	ldi	r24, 0x84	; 132
    1662:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));
    1666:	80 91 bc 00 	lds	r24, 0x00BC
    166a:	87 ff       	sbrs	r24, 7
    166c:	fc cf       	rjmp	.-8      	; 0x1666 <readPortExpanderRegister+0x72>

  return TWDR;
    166e:	80 91 bb 00 	lds	r24, 0x00BB
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    1672:	90 91 b9 00 	lds	r25, 0x00B9
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    1676:	94 e9       	ldi	r25, 0x94	; 148
    1678:	90 93 bc 00 	sts	0x00BC, r25
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    167c:	78 94       	sei

    IICstop();
  }

  return val;
}
    167e:	08 95       	ret

00001680 <reverseBitOrder>:
   because of reversed bit order :'-(
   ... shit happens
 --------------------------------------------------------------------- */
uint8_t reverseBitOrder(uint8_t b){

  b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    1680:	28 2f       	mov	r18, r24
    1682:	22 95       	swap	r18
    1684:	2f 70       	andi	r18, 0x0F	; 15
    1686:	82 95       	swap	r24
    1688:	80 7f       	andi	r24, 0xF0	; 240
    168a:	28 2b       	or	r18, r24
  b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    168c:	30 e0       	ldi	r19, 0x00	; 0
    168e:	c9 01       	movw	r24, r18
    1690:	83 73       	andi	r24, 0x33	; 51
    1692:	90 70       	andi	r25, 0x00	; 0
    1694:	88 0f       	add	r24, r24
    1696:	99 1f       	adc	r25, r25
    1698:	88 0f       	add	r24, r24
    169a:	99 1f       	adc	r25, r25
    169c:	2c 7c       	andi	r18, 0xCC	; 204
    169e:	30 70       	andi	r19, 0x00	; 0
    16a0:	35 95       	asr	r19
    16a2:	27 95       	ror	r18
    16a4:	35 95       	asr	r19
    16a6:	27 95       	ror	r18
    16a8:	82 2b       	or	r24, r18
  b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    16aa:	28 2f       	mov	r18, r24
    16ac:	30 e0       	ldi	r19, 0x00	; 0
    16ae:	c9 01       	movw	r24, r18
    16b0:	85 75       	andi	r24, 0x55	; 85
    16b2:	90 70       	andi	r25, 0x00	; 0
    16b4:	88 0f       	add	r24, r24
    16b6:	99 1f       	adc	r25, r25
    16b8:	2a 7a       	andi	r18, 0xAA	; 170
    16ba:	30 70       	andi	r19, 0x00	; 0
    16bc:	35 95       	asr	r19
    16be:	27 95       	ror	r18

  return b;
}
    16c0:	82 2b       	or	r24, r18
    16c2:	08 95       	ret

000016c4 <setSubSteps>:

/* ---------------------------------------------------------------------
   sets the desired motor substeps
   function takes a value 1...32   
 --------------------------------------------------------------------- */
void setSubSteps(uint8_t mot, uint8_t steps){
    16c4:	af 92       	push	r10
    16c6:	bf 92       	push	r11
    16c8:	cf 92       	push	r12
    16ca:	df 92       	push	r13
    16cc:	ef 92       	push	r14
    16ce:	ff 92       	push	r15
    16d0:	0f 93       	push	r16
    16d2:	1f 93       	push	r17
    16d4:	a8 2e       	mov	r10, r24
    16d6:	06 2f       	mov	r16, r22
  if(steps > 5){
    steps = 5;
  }
  */
  
  if(steps > 32){
    16d8:	61 32       	cpi	r22, 0x21	; 33
    16da:	08 f4       	brcc	.+2      	; 0x16de <setSubSteps+0x1a>
    16dc:	49 c0       	rjmp	.+146    	; 0x1770 <setSubSteps+0xac>
    16de:	80 e2       	ldi	r24, 0x20	; 32
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    16e0:	00 e0       	ldi	r16, 0x00	; 0
    tmp_steps = tmp_steps >> 1;
    16e2:	86 95       	lsr	r24
	steps++ ;
    16e4:	0f 5f       	subi	r16, 0xFF	; 255
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    16e6:	81 30       	cpi	r24, 0x01	; 1
    16e8:	e1 f7       	brne	.-8      	; 0x16e2 <setSubSteps+0x1e>
    16ea:	61 e0       	ldi	r22, 0x01	; 1
    16ec:	70 e0       	ldi	r23, 0x00	; 0
    16ee:	00 2e       	mov	r0, r16
    16f0:	02 c0       	rjmp	.+4      	; 0x16f6 <setSubSteps+0x32>
    16f2:	66 0f       	add	r22, r22
    16f4:	77 1f       	adc	r23, r23
    16f6:	0a 94       	dec	r0
    16f8:	e2 f7       	brpl	.-8      	; 0x16f2 <setSubSteps+0x2e>
    16fa:	88 27       	eor	r24, r24
    16fc:	77 fd       	sbrc	r23, 7
    16fe:	80 95       	com	r24
    1700:	98 2f       	mov	r25, r24
    1702:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    1706:	6b 01       	movw	r12, r22
    1708:	7c 01       	movw	r14, r24
    tmp_steps = tmp_steps >> 1;
	steps++ ;
  }
  
  addr = getPortExpanderAddress(mot);
    170a:	8a 2d       	mov	r24, r10
    170c:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
    1710:	b8 2e       	mov	r11, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    1712:	62 e1       	ldi	r22, 0x12	; 18
    1714:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>
    1718:	18 2f       	mov	r17, r24

  regval &= 0xF8;

  regval |= (reverseBitOrder(steps) & 0xE0) >> 5;
    171a:	80 2f       	mov	r24, r16
    171c:	0e 94 40 0b 	call	0x1680	; 0x1680 <reverseBitOrder>
    1720:	18 7f       	andi	r17, 0xF8	; 248
    1722:	82 95       	swap	r24
    1724:	86 95       	lsr	r24
    1726:	87 70       	andi	r24, 0x07	; 7
    1728:	18 2b       	or	r17, r24
  writePortExpanderRegister(addr, GPIOA, regval);
    172a:	8b 2d       	mov	r24, r11
    172c:	62 e1       	ldi	r22, 0x12	; 18
    172e:	41 2f       	mov	r20, r17
    1730:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  
  motor[mot].subSteps = (1<<steps);
    1734:	ea 2d       	mov	r30, r10
    1736:	f0 e0       	ldi	r31, 0x00	; 0
    1738:	ee 0f       	add	r30, r30
    173a:	ff 1f       	adc	r31, r31
    173c:	ee 0f       	add	r30, r30
    173e:	ff 1f       	adc	r31, r31
    1740:	ee 0f       	add	r30, r30
    1742:	ff 1f       	adc	r31, r31
    1744:	cf 01       	movw	r24, r30
    1746:	88 0f       	add	r24, r24
    1748:	99 1f       	adc	r25, r25
    174a:	88 0f       	add	r24, r24
    174c:	99 1f       	adc	r25, r25
    174e:	e8 0f       	add	r30, r24
    1750:	f9 1f       	adc	r31, r25
    1752:	e0 51       	subi	r30, 0x10	; 16
    1754:	fc 4f       	sbci	r31, 0xFC	; 252
    1756:	c5 8a       	std	Z+21, r12	; 0x15
    1758:	d6 8a       	std	Z+22, r13	; 0x16
    175a:	e7 8a       	std	Z+23, r14	; 0x17
    175c:	f0 8e       	std	Z+24, r15	; 0x18

  return;
}
    175e:	1f 91       	pop	r17
    1760:	0f 91       	pop	r16
    1762:	ff 90       	pop	r15
    1764:	ef 90       	pop	r14
    1766:	df 90       	pop	r13
    1768:	cf 90       	pop	r12
    176a:	bf 90       	pop	r11
    176c:	af 90       	pop	r10
    176e:	08 95       	ret
  */
  
  if(steps > 32){
    steps = 32;
  }
  if(steps < 1){
    1770:	66 23       	and	r22, r22
    1772:	59 f4       	brne	.+22     	; 0x178a <setSubSteps+0xc6>
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    1774:	0f 2e       	mov	r0, r31
    1776:	f0 e0       	ldi	r31, 0x00	; 0
    1778:	cf 2e       	mov	r12, r31
    177a:	f0 e0       	ldi	r31, 0x00	; 0
    177c:	df 2e       	mov	r13, r31
    177e:	f0 e8       	ldi	r31, 0x80	; 128
    1780:	ef 2e       	mov	r14, r31
    1782:	ff e3       	ldi	r31, 0x3F	; 63
    1784:	ff 2e       	mov	r15, r31
    1786:	f0 2d       	mov	r31, r0
    1788:	c0 cf       	rjmp	.-128    	; 0x170a <setSubSteps+0x46>
    178a:	61 30       	cpi	r22, 0x01	; 1
    178c:	11 f0       	breq	.+4      	; 0x1792 <setSubSteps+0xce>
    178e:	86 2f       	mov	r24, r22
    1790:	a7 cf       	rjmp	.-178    	; 0x16e0 <setSubSteps+0x1c>
    1792:	00 e0       	ldi	r16, 0x00	; 0
    1794:	ef cf       	rjmp	.-34     	; 0x1774 <setSubSteps+0xb0>

00001796 <getSubSteps>:
uint8_t getSubSteps(uint8_t mot){

  uint8_t steps = 0;

  return steps;
}
    1796:	80 e0       	ldi	r24, 0x00	; 0
    1798:	08 95       	ret

0000179a <setMotorState>:

/* ---------------------------------------------------------------------
    setMotorState: turns motor on/off
    nENBL: active low
 --------------------------------------------------------------------- */
void setMotorState(uint8_t mot, uint8_t state){
    179a:	ff 92       	push	r15
    179c:	0f 93       	push	r16
    179e:	1f 93       	push	r17
    17a0:	08 2f       	mov	r16, r24
    17a2:	f6 2e       	mov	r15, r22

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    17a4:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
    17a8:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    17aa:	62 e1       	ldi	r22, 0x12	; 18
    17ac:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>

  if(state){
    17b0:	ff 20       	and	r15, r15
    17b2:	e1 f4       	brne	.+56     	; 0x17ec <setMotorState+0x52>
    regval &= ~(1<<PORTEXP_MOTOR_ENABLE);
  }
  else{
    regval |= (1<<PORTEXP_MOTOR_ENABLE);
    17b4:	48 2f       	mov	r20, r24
    17b6:	48 60       	ori	r20, 0x08	; 8
  }

  writePortExpanderRegister(addr, GPIOA, regval);
    17b8:	81 2f       	mov	r24, r17
    17ba:	62 e1       	ldi	r22, 0x12	; 18
    17bc:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  motor[mot].isTurnedOn = state;
    17c0:	e0 2f       	mov	r30, r16
    17c2:	f0 e0       	ldi	r31, 0x00	; 0
    17c4:	ee 0f       	add	r30, r30
    17c6:	ff 1f       	adc	r31, r31
    17c8:	ee 0f       	add	r30, r30
    17ca:	ff 1f       	adc	r31, r31
    17cc:	ee 0f       	add	r30, r30
    17ce:	ff 1f       	adc	r31, r31
    17d0:	cf 01       	movw	r24, r30
    17d2:	88 0f       	add	r24, r24
    17d4:	99 1f       	adc	r25, r25
    17d6:	88 0f       	add	r24, r24
    17d8:	99 1f       	adc	r25, r25
    17da:	e8 0f       	add	r30, r24
    17dc:	f9 1f       	adc	r31, r25
    17de:	e0 51       	subi	r30, 0x10	; 16
    17e0:	fc 4f       	sbci	r31, 0xFC	; 252
    17e2:	f3 86       	std	Z+11, r15	; 0x0b

  return;
}
    17e4:	1f 91       	pop	r17
    17e6:	0f 91       	pop	r16
    17e8:	ff 90       	pop	r15
    17ea:	08 95       	ret

  addr = getPortExpanderAddress(mot);
  regval = readPortExpanderRegister(addr, GPIOA);

  if(state){
    regval &= ~(1<<PORTEXP_MOTOR_ENABLE);
    17ec:	48 2f       	mov	r20, r24
    17ee:	47 7f       	andi	r20, 0xF7	; 247
    17f0:	e3 cf       	rjmp	.-58     	; 0x17b8 <setMotorState+0x1e>

000017f2 <prepareReset>:
  */

  /* turn off all available motors */
  uint8_t i;
  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorState(i, OFF);
    17f2:	80 e0       	ldi	r24, 0x00	; 0
    17f4:	60 e0       	ldi	r22, 0x00	; 0
    17f6:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
    17fa:	81 e0       	ldi	r24, 0x01	; 1
    17fc:	60 e0       	ldi	r22, 0x00	; 0
    17fe:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
    1802:	82 e0       	ldi	r24, 0x02	; 2
    1804:	60 e0       	ldi	r22, 0x00	; 0
    1806:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
    180a:	83 e0       	ldi	r24, 0x03	; 3
    180c:	60 e0       	ldi	r22, 0x00	; 0
    180e:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
  }

  /* stop polling timer for manual operating system */
  TCCR0B = 0;
    1812:	15 bc       	out	0x25, r1	; 37

  /* stop motor movement timer */
  TCCR2B = 0;
    1814:	10 92 b1 00 	sts	0x00B1, r1

  return;
}
    1818:	08 95       	ret

0000181a <setMotorDecay>:
}

/* ---------------------------------------------------------------------
     sets the motor decay (SLOW = 0, FAST = 1, MIXED = 2)
 --------------------------------------------------------------------- */
void setMotorDecay(uint8_t mot, uint8_t state){
    181a:	ff 92       	push	r15
    181c:	0f 93       	push	r16
    181e:	1f 93       	push	r17
    1820:	f6 2e       	mov	r15, r22

  uint8_t addr = 0;
  uint8_t regval = 0;
  uint8_t iodir = 0;

  addr = getPortExpanderAddress(mot);
    1822:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
    1826:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    1828:	62 e1       	ldi	r22, 0x12	; 18
    182a:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>
    182e:	08 2f       	mov	r16, r24
  iodir = readPortExpanderRegister(addr, IODIRA);
    1830:	81 2f       	mov	r24, r17
    1832:	60 e0       	ldi	r22, 0x00	; 0
    1834:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>

  if(state == 1){ //fast decay
    1838:	91 e0       	ldi	r25, 0x01	; 1
    183a:	f9 16       	cp	r15, r25
    183c:	a9 f0       	breq	.+42     	; 0x1868 <setMotorDecay+0x4e>
    regval |= (1<<PORTEXP_MOTOR_DECAY);
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
  }
  else if(state == 2){ //mixed decay
    183e:	92 e0       	ldi	r25, 0x02	; 2
    1840:	f9 16       	cp	r15, r25
    1842:	b9 f0       	breq	.+46     	; 0x1872 <setMotorDecay+0x58>
    iodir  |= (1<<PORTEXP_MOTOR_DECAY); //set as input so pin is "open"
  }
  else{ //slow decay
    regval &= ~(1<<PORTEXP_MOTOR_DECAY);
    1844:	0f 7e       	andi	r16, 0xEF	; 239
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
    1846:	9f ee       	ldi	r25, 0xEF	; 239
    1848:	f9 2e       	mov	r15, r25
    184a:	f8 22       	and	r15, r24
  }

  writePortExpanderRegister(addr, GPIOA, regval);
    184c:	81 2f       	mov	r24, r17
    184e:	62 e1       	ldi	r22, 0x12	; 18
    1850:	40 2f       	mov	r20, r16
    1852:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  writePortExpanderRegister(addr, IODIRA, iodir);
    1856:	81 2f       	mov	r24, r17
    1858:	60 e0       	ldi	r22, 0x00	; 0
    185a:	4f 2d       	mov	r20, r15
    185c:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>

  return;
}
    1860:	1f 91       	pop	r17
    1862:	0f 91       	pop	r16
    1864:	ff 90       	pop	r15
    1866:	08 95       	ret
  addr = getPortExpanderAddress(mot);
  regval = readPortExpanderRegister(addr, GPIOA);
  iodir = readPortExpanderRegister(addr, IODIRA);

  if(state == 1){ //fast decay
    regval |= (1<<PORTEXP_MOTOR_DECAY);
    1868:	00 61       	ori	r16, 0x10	; 16
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
    186a:	3f ee       	ldi	r19, 0xEF	; 239
    186c:	f3 2e       	mov	r15, r19
    186e:	f8 22       	and	r15, r24
    1870:	ed cf       	rjmp	.-38     	; 0x184c <setMotorDecay+0x32>
  }
  else if(state == 2){ //mixed decay
    iodir  |= (1<<PORTEXP_MOTOR_DECAY); //set as input so pin is "open"
    1872:	20 e1       	ldi	r18, 0x10	; 16
    1874:	f2 2e       	mov	r15, r18
    1876:	f8 2a       	or	r15, r24
    1878:	e9 cf       	rjmp	.-46     	; 0x184c <setMotorDecay+0x32>

0000187a <resetMotorLogic>:
     resets the internal motor logic (active LOW):
     - step table
     - home position
     - disables H-bridges
 --------------------------------------------------------------------- */
void resetMotorLogic(uint8_t mot){
    187a:	0f 93       	push	r16
    187c:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    187e:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
    1882:	08 2f       	mov	r16, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    1884:	62 e1       	ldi	r22, 0x12	; 18
    1886:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>

  regval &= ~(1<<PORTEXP_MOTOR_RESET);
    188a:	18 2f       	mov	r17, r24
    188c:	1f 7b       	andi	r17, 0xBF	; 191
  writePortExpanderRegister(addr, GPIOA, regval);
    188e:	80 2f       	mov	r24, r16
    1890:	62 e1       	ldi	r22, 0x12	; 18
    1892:	41 2f       	mov	r20, r17
    1894:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  regval |= (1<<PORTEXP_MOTOR_RESET);
  writePortExpanderRegister(addr, GPIOA, regval);
    1898:	10 64       	ori	r17, 0x40	; 64
    189a:	80 2f       	mov	r24, r16
    189c:	62 e1       	ldi	r22, 0x12	; 18
    189e:	41 2f       	mov	r20, r17
    18a0:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>

  return;
}
    18a4:	1f 91       	pop	r17
    18a6:	0f 91       	pop	r16
    18a8:	08 95       	ret

000018aa <setMotorSleep>:

/* ---------------------------------------------------------------------
     send motor to bed (active LOW)
 --------------------------------------------------------------------- */
void setMotorSleep(uint8_t mot){
    18aa:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    18ac:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
    18b0:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    18b2:	62 e1       	ldi	r22, 0x12	; 18
    18b4:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>

  regval &= ~(1<<PORTEXP_MOTOR_SLEEP);

  writePortExpanderRegister(addr, GPIOA, regval);
    18b8:	48 2f       	mov	r20, r24
    18ba:	4f 7d       	andi	r20, 0xDF	; 223
    18bc:	81 2f       	mov	r24, r17
    18be:	62 e1       	ldi	r22, 0x12	; 18
    18c0:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>

  return;
}
    18c4:	1f 91       	pop	r17
    18c6:	08 95       	ret

000018c8 <wakeMotorUp>:

/* ---------------------------------------------------------------------
     get motor out of bed
 --------------------------------------------------------------------- */
void wakeMotorUp(uint8_t mot){
    18c8:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    18ca:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
    18ce:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    18d0:	62 e1       	ldi	r22, 0x12	; 18
    18d2:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>

  regval |= (1<<PORTEXP_MOTOR_SLEEP);

  writePortExpanderRegister(addr, GPIOA, regval);
    18d6:	48 2f       	mov	r20, r24
    18d8:	40 62       	ori	r20, 0x20	; 32
    18da:	81 2f       	mov	r24, r17
    18dc:	62 e1       	ldi	r22, 0x12	; 18
    18de:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    18e2:	80 e1       	ldi	r24, 0x10	; 16
    18e4:	97 e2       	ldi	r25, 0x27	; 39
    18e6:	01 97       	sbiw	r24, 0x01	; 1
    18e8:	f1 f7       	brne	.-4      	; 0x18e6 <wakeMotorUp+0x1e>
  _delay_ms(2);

  return;
}
    18ea:	1f 91       	pop	r17
    18ec:	08 95       	ret

000018ee <getMotorSens>:

/* ---------------------------------------------------------------------
     read motor port expander input pin
 --------------------------------------------------------------------- */
uint8_t getMotorSens(uint8_t mot, uint8_t sens){
    18ee:	1f 93       	push	r17
    18f0:	16 2f       	mov	r17, r22

  uint8_t addr = 0;
  uint8_t regval = 0;
  uint8_t state = 0;

  addr = getPortExpanderAddress(mot);
    18f2:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
  regval = readPortExpanderRegister(addr, GPIOB);
    18f6:	63 e1       	ldi	r22, 0x13	; 19
    18f8:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>
    18fc:	21 e0       	ldi	r18, 0x01	; 1
    18fe:	30 e0       	ldi	r19, 0x00	; 0
    1900:	02 c0       	rjmp	.+4      	; 0x1906 <getMotorSens+0x18>
    1902:	22 0f       	add	r18, r18
    1904:	33 1f       	adc	r19, r19
    1906:	1a 95       	dec	r17
    1908:	e2 f7       	brpl	.-8      	; 0x1902 <getMotorSens+0x14>
    190a:	82 23       	and	r24, r18
    190c:	09 f0       	breq	.+2      	; 0x1910 <getMotorSens+0x22>
    190e:	81 e0       	ldi	r24, 0x01	; 1
  else{
    state = 0;
  }

  return state;
}
    1910:	1f 91       	pop	r17
    1912:	08 95       	ret

00001914 <initDAC>:
 --------------------------------------------------------------------- */
void initDAC(uint8_t mot){

  uint8_t addr = 0;

  addr = getDACAddress(mot);
    1914:	0e 94 43 0a 	call	0x1486	; 0x1486 <getDACAddress>
  IIC.data[0] = 0x00; IIC.data[1] = 0x00;
    1918:	e0 91 ed 03 	lds	r30, 0x03ED
    191c:	f0 91 ee 03 	lds	r31, 0x03EE
    1920:	10 82       	st	Z, r1
    1922:	e0 91 ed 03 	lds	r30, 0x03ED
    1926:	f0 91 ee 03 	lds	r31, 0x03EE
    192a:	11 82       	std	Z+1, r1	; 0x01
  IICwrite(addr, IIC.data, 2);
    192c:	60 91 ed 03 	lds	r22, 0x03ED
    1930:	70 91 ee 03 	lds	r23, 0x03EE
    1934:	42 e0       	ldi	r20, 0x02	; 2
    1936:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>

  return;
}
    193a:	08 95       	ret

0000193c <getMotorCurrent>:
  float curr = 0.0;
  uint8_t addr = 0;
  uint16_t data = 0;
  uint8_t val = 0;

  addr = getDACAddress(mot);
    193c:	0e 94 43 0a 	call	0x1486	; 0x1486 <getDACAddress>

  IICread(addr, IIC.data, 2);
    1940:	60 91 ed 03 	lds	r22, 0x03ED
    1944:	70 91 ee 03 	lds	r23, 0x03EE
    1948:	42 e0       	ldi	r20, 0x02	; 2
    194a:	0e 94 f0 09 	call	0x13e0	; 0x13e0 <IICread>

  data |= (uint16_t)((IIC.data[0] << 8) & 0xFF00);  /* high byte */
    194e:	e0 91 ed 03 	lds	r30, 0x03ED
    1952:	f0 91 ee 03 	lds	r31, 0x03EE
  data |= (uint16_t)((IIC.data[1]) & 0x00FF);       /* low byte  */
    1956:	a0 91 ed 03 	lds	r26, 0x03ED
    195a:	b0 91 ee 03 	lds	r27, 0x03EE
    195e:	70 81       	ld	r23, Z
    1960:	60 e0       	ldi	r22, 0x00	; 0
    1962:	11 96       	adiw	r26, 0x01	; 1
    1964:	2c 91       	ld	r18, X
    1966:	30 e0       	ldi	r19, 0x00	; 0
    1968:	62 2b       	or	r22, r18
    196a:	73 2b       	or	r23, r19
    196c:	72 95       	swap	r23
    196e:	62 95       	swap	r22
    1970:	6f 70       	andi	r22, 0x0F	; 15
    1972:	67 27       	eor	r22, r23
    1974:	7f 70       	andi	r23, 0x0F	; 15
    1976:	67 27       	eor	r22, r23
    1978:	70 e0       	ldi	r23, 0x00	; 0
    197a:	80 e0       	ldi	r24, 0x00	; 0
    197c:	90 e0       	ldi	r25, 0x00	; 0
    197e:	0e 94 61 40 	call	0x80c2	; 0x80c2 <__floatunsisf>
    1982:	26 e6       	ldi	r18, 0x66	; 102
    1984:	36 e6       	ldi	r19, 0x66	; 102
    1986:	4a e9       	ldi	r20, 0x9A	; 154
    1988:	52 e4       	ldi	r21, 0x42	; 66
    198a:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>

  /* according to setMotorCurrent() max(val) = 193 */
  curr = ((float)val) / 77.2;

  return curr;
}
    198e:	08 95       	ret

00001990 <initManualOperatingButtons>:
   initializes all buttons and turns on the required interrupts
 --------------------------------------------------------------------- */
void initManualOperatingButtons(void){

  /* only for rotary encoder + its button */
  PORTC |= (1<<PC5)|(1<<PC4)|(1<<PC3);   /* set internal pull-ups */
    1990:	88 b1       	in	r24, 0x08	; 8
    1992:	88 63       	ori	r24, 0x38	; 56
    1994:	88 b9       	out	0x08, r24	; 8
  /* init port expander for buttons
   *
   * http://www.gammon.com.au/forum/?id=10945
   *
   */
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IOCON, 0x22);
    1996:	80 e4       	ldi	r24, 0x40	; 64
    1998:	65 e0       	ldi	r22, 0x05	; 5
    199a:	42 e2       	ldi	r20, 0x22	; 34
    199c:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IODIR, 0xFF);
    19a0:	80 e4       	ldi	r24, 0x40	; 64
    19a2:	60 e0       	ldi	r22, 0x00	; 0
    19a4:	4f ef       	ldi	r20, 0xFF	; 255
    19a6:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IPOL, 0xFF);
    19aa:	80 e4       	ldi	r24, 0x40	; 64
    19ac:	61 e0       	ldi	r22, 0x01	; 1
    19ae:	4f ef       	ldi	r20, 0xFF	; 255
    19b0:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPINTEN, 0xF8);
    19b4:	80 e4       	ldi	r24, 0x40	; 64
    19b6:	62 e0       	ldi	r22, 0x02	; 2
    19b8:	48 ef       	ldi	r20, 0xF8	; 248
    19ba:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, DEFVAL, 0x03);
    19be:	80 e4       	ldi	r24, 0x40	; 64
    19c0:	63 e0       	ldi	r22, 0x03	; 3
    19c2:	43 e0       	ldi	r20, 0x03	; 3
    19c4:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, INTCON, 0x00);
    19c8:	80 e4       	ldi	r24, 0x40	; 64
    19ca:	64 e0       	ldi	r22, 0x04	; 4
    19cc:	40 e0       	ldi	r20, 0x00	; 0
    19ce:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPPU, 0xFF);
    19d2:	80 e4       	ldi	r24, 0x40	; 64
    19d4:	66 e0       	ldi	r22, 0x06	; 6
    19d6:	4f ef       	ldi	r20, 0xFF	; 255
    19d8:	0e 94 e6 0a 	call	0x15cc	; 0x15cc <writePortExpanderRegister>
  
  //read GPIO register to clear the interrupt
  uint8_t tmp = 0;
  tmp = readPortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPIO);
    19dc:	80 e4       	ldi	r24, 0x40	; 64
    19de:	69 e0       	ldi	r22, 0x09	; 9
    19e0:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>

  /* activate interrupt on INT0 (PD2) */
  EICRA |= (1<<ISC01)|(1<<ISC00);  /* rising edge causes interrupt */
    19e4:	e9 e6       	ldi	r30, 0x69	; 105
    19e6:	f0 e0       	ldi	r31, 0x00	; 0
    19e8:	80 81       	ld	r24, Z
    19ea:	83 60       	ori	r24, 0x03	; 3
    19ec:	80 83       	st	Z, r24
  EIMSK |= (1<<INT0);   /* enable interrupt pin INT0 */
    19ee:	e8 9a       	sbi	0x1d, 0	; 29

  /* set up a timer for button/rotary_encoder polling
   *
   * the 8-bit Timer/Counter0 is used for that
   */
  TCCR0A |= (1<<WGM01);   /* enable CTC */
    19f0:	84 b5       	in	r24, 0x24	; 36
    19f2:	82 60       	ori	r24, 0x02	; 2
    19f4:	84 bd       	out	0x24, r24	; 36
  OCR0A   = 40;           /* 40 is an empirical value for best behavior of the rotEnc. */
    19f6:	88 e2       	ldi	r24, 0x28	; 40
    19f8:	87 bd       	out	0x27, r24	; 39
  TIMSK0 |= (1<<OCIE0A);  /* enable interrupt */
    19fa:	ee e6       	ldi	r30, 0x6E	; 110
    19fc:	f0 e0       	ldi	r31, 0x00	; 0
    19fe:	80 81       	ld	r24, Z
    1a00:	82 60       	ori	r24, 0x02	; 2
    1a02:	80 83       	st	Z, r24
  TCNT0   = 0;
    1a04:	16 bc       	out	0x26, r1	; 38

  /* start the timer/counter */
  TCCR0B |= (1<<CS02)|(1<<CS00);  /* prescaler = 1024 --> 51.2 us per cycle */
    1a06:	85 b5       	in	r24, 0x25	; 37
    1a08:	85 60       	ori	r24, 0x05	; 5
    1a0a:	85 bd       	out	0x25, r24	; 37

  return;
}
    1a0c:	08 95       	ret

00001a0e <getButtonEvent>:
uint8_t getButtonEvent(void){

  uint8_t state = 0;
  uint8_t button = NO_BUTTON;

  if(buttonState.readyToProcess){
    1a0e:	80 91 de 02 	lds	r24, 0x02DE
    1a12:	88 23       	and	r24, r24
    1a14:	a1 f0       	breq	.+40     	; 0x1a3e <getButtonEvent+0x30>
    /* a button has been pressed */
    state = buttonState.inputRegister;
    1a16:	90 91 dc 02 	lds	r25, 0x02DC
	
	if(rotEnc.buttonPressed){
    1a1a:	80 91 d1 03 	lds	r24, 0x03D1
    1a1e:	88 23       	and	r24, r24
    1a20:	61 f4       	brne	.+24     	; 0x1a3a <getButtonEvent+0x2c>
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
    1a22:	97 fd       	sbrc	r25, 7
    1a24:	10 c0       	rjmp	.+32     	; 0x1a46 <getButtonEvent+0x38>
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
    1a26:	96 fd       	sbrc	r25, 6
    1a28:	0c c0       	rjmp	.+24     	; 0x1a42 <getButtonEvent+0x34>
      button = BUTTON_MOTOR1;
    }
    else if(state & (1<<BUTTON_MOTOR2)){
    1a2a:	95 fd       	sbrc	r25, 5
    1a2c:	0e c0       	rjmp	.+28     	; 0x1a4a <getButtonEvent+0x3c>
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
    1a2e:	94 fd       	sbrc	r25, 4
    1a30:	0e c0       	rjmp	.+28     	; 0x1a4e <getButtonEvent+0x40>
      button = BUTTON_MOTOR3;
    }
    else if(state & (1<<BUTTON_MENUESCAPE)){
    1a32:	93 ff       	sbrs	r25, 3
    1a34:	04 c0       	rjmp	.+8      	; 0x1a3e <getButtonEvent+0x30>
    1a36:	83 e0       	ldi	r24, 0x03	; 3
    1a38:	08 95       	ret

  if(buttonState.readyToProcess){
    /* a button has been pressed */
    state = buttonState.inputRegister;
	
	if(rotEnc.buttonPressed){
    1a3a:	88 e0       	ldi	r24, 0x08	; 8
    1a3c:	08 95       	ret
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
      button = BUTTON_MOTOR3;
    }
    else if(state & (1<<BUTTON_MENUESCAPE)){
    1a3e:	8a e2       	ldi	r24, 0x2A	; 42
      button = NO_BUTTON;
    }
  }

  return button;
}
    1a40:	08 95       	ret
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
    1a42:	86 e0       	ldi	r24, 0x06	; 6
    1a44:	08 95       	ret
    state = buttonState.inputRegister;
	
	if(rotEnc.buttonPressed){
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
    1a46:	87 e0       	ldi	r24, 0x07	; 7
    1a48:	08 95       	ret
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
      button = BUTTON_MOTOR1;
    }
    else if(state & (1<<BUTTON_MOTOR2)){
    1a4a:	85 e0       	ldi	r24, 0x05	; 5
    1a4c:	08 95       	ret
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
    1a4e:	84 e0       	ldi	r24, 0x04	; 4
    1a50:	08 95       	ret

00001a52 <getRotaryEncoderEvent>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1a52:	f8 94       	cli
   */

  int8_t steps = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(rotEnc.readyToProcess){
    1a54:	80 91 d0 03 	lds	r24, 0x03D0
    1a58:	88 23       	and	r24, r24
    1a5a:	21 f0       	breq	.+8      	; 0x1a64 <getRotaryEncoderEvent+0x12>
      steps = rotEnc.steps;
    1a5c:	80 91 cf 03 	lds	r24, 0x03CF
      rotEnc.steps = 0;
    1a60:	10 92 cf 03 	sts	0x03CF, r1
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1a64:	78 94       	sei
    }
  }
  return steps;
}
    1a66:	08 95       	ret

00001a68 <__vector_20>:
    A character in the USART receive buffer is ready for fetch.
    Build up the command string for parsing here. If the
    rxSerial.readyToProcess is NOT zero, the actual command
    in the buffer is not parsed yet. In this case refuse the new char.
 --------------------------------------------------------------------- */
ISR(USART0_RX_vect){
    1a68:	1f 92       	push	r1
    1a6a:	0f 92       	push	r0
    1a6c:	0f b6       	in	r0, 0x3f	; 63
    1a6e:	0f 92       	push	r0
    1a70:	0b b6       	in	r0, 0x3b	; 59
    1a72:	0f 92       	push	r0
    1a74:	11 24       	eor	r1, r1
    1a76:	8f 93       	push	r24
    1a78:	9f 93       	push	r25
    1a7a:	ef 93       	push	r30
    1a7c:	ff 93       	push	r31

  uint8_t c;

  c = UDR0;
    1a7e:	90 91 c6 00 	lds	r25, 0x00C6

  if(rxString.readyToProcess == 0){ /* actual rxString in buffer not parsed yet */
    1a82:	80 91 f0 02 	lds	r24, 0x02F0
    1a86:	88 23       	and	r24, r24
    1a88:	e1 f4       	brne	.+56     	; 0x1ac2 <__vector_20+0x5a>
    if(c == '\r'){
    1a8a:	9d 30       	cpi	r25, 0x0D	; 13
    1a8c:	09 f1       	breq	.+66     	; 0x1ad0 <__vector_20+0x68>
      /* get rid of windoze line ending overhead bullshit */
      return;
    }
    if((c != '\n') && (rxString.charCount < SERIAL_BUFFERSIZE)){
    1a8e:	9a 30       	cpi	r25, 0x0A	; 10
    1a90:	21 f0       	breq	.+8      	; 0x1a9a <__vector_20+0x32>
    1a92:	80 91 f1 02 	lds	r24, 0x02F1
    1a96:	80 34       	cpi	r24, 0x40	; 64
    1a98:	30 f1       	brcs	.+76     	; 0x1ae6 <__vector_20+0x7e>
      rxString.buffer[rxString.charCount] = c;
      rxString.charCount++;
    }
    else{
      /* end of command */
      rxString.buffer[rxString.charCount] = '\0';
    1a9a:	e0 91 ee 02 	lds	r30, 0x02EE
    1a9e:	f0 91 ef 02 	lds	r31, 0x02EF
    1aa2:	80 91 f1 02 	lds	r24, 0x02F1
    1aa6:	e8 0f       	add	r30, r24
    1aa8:	f1 1d       	adc	r31, r1
    1aaa:	10 82       	st	Z, r1
      rxString.readyToProcess = 1;
    1aac:	81 e0       	ldi	r24, 0x01	; 1
    1aae:	80 93 f0 02 	sts	0x02F0, r24
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    1ab2:	80 91 c0 00 	lds	r24, 0x00C0
    1ab6:	85 ff       	sbrs	r24, 5
    1ab8:	fc cf       	rjmp	.-8      	; 0x1ab2 <__vector_20+0x4a>
    ;
  }

  UDR0 = c;
    1aba:	86 e0       	ldi	r24, 0x06	; 6
    1abc:	80 93 c6 00 	sts	0x00C6, r24
    1ac0:	07 c0       	rjmp	.+14     	; 0x1ad0 <__vector_20+0x68>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    1ac2:	80 91 c0 00 	lds	r24, 0x00C0
    1ac6:	85 ff       	sbrs	r24, 5
    1ac8:	fc cf       	rjmp	.-8      	; 0x1ac2 <__vector_20+0x5a>
    ;
  }

  UDR0 = c;
    1aca:	85 e1       	ldi	r24, 0x15	; 21
    1acc:	80 93 c6 00 	sts	0x00C6, r24
  else{ /* actual command in buffer is not processed yet */
    sendChar(0x15);   /* send a NAK */
  }

  return;
}
    1ad0:	ff 91       	pop	r31
    1ad2:	ef 91       	pop	r30
    1ad4:	9f 91       	pop	r25
    1ad6:	8f 91       	pop	r24
    1ad8:	0f 90       	pop	r0
    1ada:	0b be       	out	0x3b, r0	; 59
    1adc:	0f 90       	pop	r0
    1ade:	0f be       	out	0x3f, r0	; 63
    1ae0:	0f 90       	pop	r0
    1ae2:	1f 90       	pop	r1
    1ae4:	18 95       	reti
    if(c == '\r'){
      /* get rid of windoze line ending overhead bullshit */
      return;
    }
    if((c != '\n') && (rxString.charCount < SERIAL_BUFFERSIZE)){
      rxString.buffer[rxString.charCount] = c;
    1ae6:	e0 91 ee 02 	lds	r30, 0x02EE
    1aea:	f0 91 ef 02 	lds	r31, 0x02EF
    1aee:	80 91 f1 02 	lds	r24, 0x02F1
    1af2:	e8 0f       	add	r30, r24
    1af4:	f1 1d       	adc	r31, r1
    1af6:	90 83       	st	Z, r25
      rxString.charCount++;
    1af8:	80 91 f1 02 	lds	r24, 0x02F1
    1afc:	8f 5f       	subi	r24, 0xFF	; 255
    1afe:	80 93 f1 02 	sts	0x02F1, r24
    1b02:	e6 cf       	rjmp	.-52     	; 0x1ad0 <__vector_20+0x68>

00001b04 <__vector_16>:

/* ---------------------------------------------------------------------
    if any button is pressed or turned, this interrupt will
    handle the reaction
 --------------------------------------------------------------------- */
ISR(TIMER0_COMPA_vect){
    1b04:	1f 92       	push	r1
    1b06:	0f 92       	push	r0
    1b08:	0f b6       	in	r0, 0x3f	; 63
    1b0a:	0f 92       	push	r0
    1b0c:	0b b6       	in	r0, 0x3b	; 59
    1b0e:	0f 92       	push	r0
    1b10:	11 24       	eor	r1, r1
    1b12:	8f 93       	push	r24
    1b14:	ef 93       	push	r30
    1b16:	ff 93       	push	r31

  uint8_t inputReg = 0;
  static int16_t last = 0;  /* save old rotEnc value */

  inputReg = PINC;  /* rotEnc is connected to PORTC */
    1b18:	86 b1       	in	r24, 0x06	; 6

  /* handle rotEnc's button */
  if((inputReg^0xFF) & (1<<BUTTON_ROT_ENC)){
    1b1a:	80 95       	com	r24
    1b1c:	83 ff       	sbrs	r24, 3
    1b1e:	3a c0       	rjmp	.+116    	; 0x1b94 <__vector_16+0x90>
    /* button was pressed */
    if(rotEnc.buttonDebounce == 0){
    1b20:	80 91 d2 03 	lds	r24, 0x03D2
    1b24:	88 23       	and	r24, r24
    1b26:	09 f4       	brne	.+2      	; 0x1b2a <__vector_16+0x26>
    1b28:	40 c0       	rjmp	.+128    	; 0x1baa <__vector_16+0xa6>
  /* now care about the rotary encoder rotations
   *
   * code from:
   * http://www.mikrocontroller.net/articles/Drehgeber
   */
  last = (last << 2) & 0x0F;
    1b2a:	e0 91 d8 02 	lds	r30, 0x02D8
    1b2e:	f0 91 d9 02 	lds	r31, 0x02D9
    1b32:	ee 0f       	add	r30, r30
    1b34:	ff 1f       	adc	r31, r31
    1b36:	ee 0f       	add	r30, r30
    1b38:	ff 1f       	adc	r31, r31
    1b3a:	ef 70       	andi	r30, 0x0F	; 15
    1b3c:	f0 70       	andi	r31, 0x00	; 0
    1b3e:	f0 93 d9 02 	sts	0x02D9, r31
    1b42:	e0 93 d8 02 	sts	0x02D8, r30
  if(PHASE_A){
    1b46:	35 9b       	sbis	0x06, 5	; 6
    1b48:	05 c0       	rjmp	.+10     	; 0x1b54 <__vector_16+0x50>
    last |= 2;
    1b4a:	e2 60       	ori	r30, 0x02	; 2
    1b4c:	f0 93 d9 02 	sts	0x02D9, r31
    1b50:	e0 93 d8 02 	sts	0x02D8, r30
  }
  if(PHASE_B){
    1b54:	34 9b       	sbis	0x06, 4	; 6
    1b56:	05 c0       	rjmp	.+10     	; 0x1b62 <__vector_16+0x5e>
    last |= 1;
    1b58:	e1 60       	ori	r30, 0x01	; 1
    1b5a:	f0 93 d9 02 	sts	0x02D9, r31
    1b5e:	e0 93 d8 02 	sts	0x02D8, r30
  }
  if(pgm_read_byte(&table[last])){
    1b62:	ee 0f       	add	r30, r30
    1b64:	ff 1f       	adc	r31, r31
    1b66:	ec 52       	subi	r30, 0x2C	; 44
    1b68:	ff 4f       	sbci	r31, 0xFF	; 255
    1b6a:	e4 91       	lpm	r30, Z+
    1b6c:	ee 23       	and	r30, r30
    1b6e:	41 f0       	breq	.+16     	; 0x1b80 <__vector_16+0x7c>
    rotEnc.steps += pgm_read_byte(&table[last]);
    1b70:	80 91 cf 03 	lds	r24, 0x03CF
    1b74:	e8 0f       	add	r30, r24
    1b76:	e0 93 cf 03 	sts	0x03CF, r30
    rotEnc.readyToProcess = 1;
    1b7a:	81 e0       	ldi	r24, 0x01	; 1
    1b7c:	80 93 d0 03 	sts	0x03D0, r24
  }
}
    1b80:	ff 91       	pop	r31
    1b82:	ef 91       	pop	r30
    1b84:	8f 91       	pop	r24
    1b86:	0f 90       	pop	r0
    1b88:	0b be       	out	0x3b, r0	; 59
    1b8a:	0f 90       	pop	r0
    1b8c:	0f be       	out	0x3f, r0	; 63
    1b8e:	0f 90       	pop	r0
    1b90:	1f 90       	pop	r1
    1b92:	18 95       	reti
	  rotEnc.buttonDebounce = 1;
    }
  }
  else{
      /* button is no longer pressed ...*/
      if(rotEnc.buttonDebounce == 1){
    1b94:	80 91 d2 03 	lds	r24, 0x03D2
    1b98:	81 30       	cpi	r24, 0x01	; 1
    1b9a:	39 f6       	brne	.-114    	; 0x1b2a <__vector_16+0x26>
        /* ... and we are already in debouncing mode -> generate event */
        rotEnc.buttonPressed = 1;
    1b9c:	80 93 d1 03 	sts	0x03D1, r24
        rotEnc.buttonDebounce = 0;
    1ba0:	10 92 d2 03 	sts	0x03D2, r1
        buttonState.readyToProcess = 1;
    1ba4:	80 93 de 02 	sts	0x02DE, r24
    1ba8:	c0 cf       	rjmp	.-128    	; 0x1b2a <__vector_16+0x26>
  /* handle rotEnc's button */
  if((inputReg^0xFF) & (1<<BUTTON_ROT_ENC)){
    /* button was pressed */
    if(rotEnc.buttonDebounce == 0){
      // enter debouncing mode
	  rotEnc.buttonDebounce = 1;
    1baa:	81 e0       	ldi	r24, 0x01	; 1
    1bac:	80 93 d2 03 	sts	0x03D2, r24
    1bb0:	bc cf       	rjmp	.-136    	; 0x1b2a <__vector_16+0x26>

00001bb2 <__vector_1>:
}

/* ---------------------------------------------------------------------
    a button seems to be pressed ;-)
 --------------------------------------------------------------------- */
ISR(INT0_vect){
    1bb2:	1f 92       	push	r1
    1bb4:	0f 92       	push	r0
    1bb6:	0f b6       	in	r0, 0x3f	; 63
    1bb8:	0f 92       	push	r0
    1bba:	0b b6       	in	r0, 0x3b	; 59
    1bbc:	0f 92       	push	r0
    1bbe:	11 24       	eor	r1, r1
    1bc0:	2f 93       	push	r18
    1bc2:	3f 93       	push	r19
    1bc4:	4f 93       	push	r20
    1bc6:	5f 93       	push	r21
    1bc8:	6f 93       	push	r22
    1bca:	7f 93       	push	r23
    1bcc:	8f 93       	push	r24
    1bce:	9f 93       	push	r25
    1bd0:	af 93       	push	r26
    1bd2:	bf 93       	push	r27
    1bd4:	ef 93       	push	r30
    1bd6:	ff 93       	push	r31
   
  //sendText("INT0");
  
  uint8_t regVal = 0;
  
  regVal = readPortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, INTCAP);
    1bd8:	80 e4       	ldi	r24, 0x40	; 64
    1bda:	68 e0       	ldi	r22, 0x08	; 8
    1bdc:	0e 94 fa 0a 	call	0x15f4	; 0x15f4 <readPortExpanderRegister>
    1be0:	98 2f       	mov	r25, r24
  
  /* check if a button is actually in process */
  if(buttonState.readyToProcess){
    1be2:	80 91 de 02 	lds	r24, 0x02DE
    1be6:	88 23       	and	r24, r24
    1be8:	29 f4       	brne	.+10     	; 0x1bf4 <__vector_1+0x42>
    return;
  }
  else{
    buttonState.inputRegister = regVal;
    1bea:	90 93 dc 02 	sts	0x02DC, r25
    buttonState.readyToProcess = 1;
    1bee:	81 e0       	ldi	r24, 0x01	; 1
    1bf0:	80 93 de 02 	sts	0x02DE, r24
  }

}
    1bf4:	ff 91       	pop	r31
    1bf6:	ef 91       	pop	r30
    1bf8:	bf 91       	pop	r27
    1bfa:	af 91       	pop	r26
    1bfc:	9f 91       	pop	r25
    1bfe:	8f 91       	pop	r24
    1c00:	7f 91       	pop	r23
    1c02:	6f 91       	pop	r22
    1c04:	5f 91       	pop	r21
    1c06:	4f 91       	pop	r20
    1c08:	3f 91       	pop	r19
    1c0a:	2f 91       	pop	r18
    1c0c:	0f 90       	pop	r0
    1c0e:	0b be       	out	0x3b, r0	; 59
    1c10:	0f 90       	pop	r0
    1c12:	0f be       	out	0x3f, r0	; 63
    1c14:	0f 90       	pop	r0
    1c16:	1f 90       	pop	r1
    1c18:	18 95       	reti

00001c1a <loadConfigFromEEPROM>:
}

/* ---------------------------------------------------------------------
    load last stored motor configuration from EEPROM
 --------------------------------------------------------------------- */
void loadConfigFromEEPROM(void){
    1c1a:	7f 92       	push	r7
    1c1c:	8f 92       	push	r8
    1c1e:	9f 92       	push	r9
    1c20:	af 92       	push	r10
    1c22:	bf 92       	push	r11
    1c24:	cf 92       	push	r12
    1c26:	df 92       	push	r13
    1c28:	ef 92       	push	r14
    1c2a:	ff 92       	push	r15
    1c2c:	0f 93       	push	r16
    1c2e:	1f 93       	push	r17
    1c30:	cf 93       	push	r28
    1c32:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1c34:	f8 94       	cli
    1c36:	cc 24       	eor	r12, r12
    1c38:	dd 24       	eor	r13, r13
    1c3a:	88 24       	eor	r8, r8
    1c3c:	99 24       	eor	r9, r9
    1c3e:	aa 24       	eor	r10, r10
    1c40:	bb 24       	eor	r11, r11
      eeprom_read_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
      eeprom_read_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));

      /* activate forbidden zone if necessary */
      if(forbiddenZone[i].start != forbiddenZone[i].stop){
        forbiddenZone[i].active = 1;
    1c42:	77 24       	eor	r7, r7
    1c44:	73 94       	inc	r7

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
      eeprom_read_block(&(motor[i].opticalZeroPosition), &(opticalZeroPositionEE[i]), sizeof(int16_t));
    1c46:	c6 01       	movw	r24, r12
    1c48:	88 0f       	add	r24, r24
    1c4a:	99 1f       	adc	r25, r25
    1c4c:	86 01       	movw	r16, r12
    1c4e:	00 0f       	add	r16, r16
    1c50:	11 1f       	adc	r17, r17
    1c52:	00 0f       	add	r16, r16
    1c54:	11 1f       	adc	r17, r17
    1c56:	00 0f       	add	r16, r16
    1c58:	11 1f       	adc	r17, r17
    1c5a:	80 0f       	add	r24, r16
    1c5c:	91 1f       	adc	r25, r17
    1c5e:	88 0f       	add	r24, r24
    1c60:	99 1f       	adc	r25, r25
    1c62:	88 0f       	add	r24, r24
    1c64:	99 1f       	adc	r25, r25
    1c66:	b4 01       	movw	r22, r8
    1c68:	6d 5c       	subi	r22, 0xCD	; 205
    1c6a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c6c:	8c 50       	subi	r24, 0x0C	; 12
    1c6e:	9c 4f       	sbci	r25, 0xFC	; 252
    1c70:	42 e0       	ldi	r20, 0x02	; 2
    1c72:	50 e0       	ldi	r21, 0x00	; 0
    1c74:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].gearRatio), &(gearRatioEE[i]), sizeof(double));
    1c78:	78 01       	movw	r14, r16
    1c7a:	ee 0c       	add	r14, r14
    1c7c:	ff 1c       	adc	r15, r15
    1c7e:	ee 0c       	add	r14, r14
    1c80:	ff 1c       	adc	r15, r15
    1c82:	e0 0e       	add	r14, r16
    1c84:	f1 1e       	adc	r15, r17
    1c86:	b5 01       	movw	r22, r10
    1c88:	65 5c       	subi	r22, 0xC5	; 197
    1c8a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c8c:	c7 01       	movw	r24, r14
    1c8e:	83 50       	subi	r24, 0x03	; 3
    1c90:	9c 4f       	sbci	r25, 0xFC	; 252
    1c92:	44 e0       	ldi	r20, 0x04	; 4
    1c94:	50 e0       	ldi	r21, 0x00	; 0
    1c96:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepsPerFullRotation), &(stepsPerFullRotationEE[i]), sizeof(double));
    1c9a:	b5 01       	movw	r22, r10
    1c9c:	65 5b       	subi	r22, 0xB5	; 181
    1c9e:	7f 4f       	sbci	r23, 0xFF	; 255
    1ca0:	c7 01       	movw	r24, r14
    1ca2:	8f 5f       	subi	r24, 0xFF	; 255
    1ca4:	9b 4f       	sbci	r25, 0xFB	; 251
    1ca6:	44 e0       	ldi	r20, 0x04	; 4
    1ca8:	50 e0       	ldi	r21, 0x00	; 0
    1caa:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].subSteps), &(subStepsEE[i]), sizeof(double));
    1cae:	b5 01       	movw	r22, r10
    1cb0:	65 5a       	subi	r22, 0xA5	; 165
    1cb2:	7f 4f       	sbci	r23, 0xFF	; 255
    1cb4:	c7 01       	movw	r24, r14
    1cb6:	8b 5f       	subi	r24, 0xFB	; 251
    1cb8:	9b 4f       	sbci	r25, 0xFB	; 251
    1cba:	44 e0       	ldi	r20, 0x04	; 4
    1cbc:	50 e0       	ldi	r21, 0x00	; 0
    1cbe:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepMultiplier), &(stepMultiplierEE[i]), sizeof(double));
    1cc2:	b5 01       	movw	r22, r10
    1cc4:	65 59       	subi	r22, 0x95	; 149
    1cc6:	7f 4f       	sbci	r23, 0xFF	; 255
    1cc8:	c7 01       	movw	r24, r14
    1cca:	86 5f       	subi	r24, 0xF6	; 246
    1ccc:	9b 4f       	sbci	r25, 0xFB	; 251
    1cce:	44 e0       	ldi	r20, 0x04	; 4
    1cd0:	50 e0       	ldi	r21, 0x00	; 0
    1cd2:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
	    eeprom_read_block(&(motor[i].current), &(currentEE[i]), sizeof(double));
    1cd6:	b5 01       	movw	r22, r10
    1cd8:	65 58       	subi	r22, 0x85	; 133
    1cda:	7f 4f       	sbci	r23, 0xFF	; 255
    1cdc:	c7 01       	movw	r24, r14
    1cde:	8d 5e       	subi	r24, 0xED	; 237
    1ce0:	9b 4f       	sbci	r25, 0xFB	; 251
    1ce2:	44 e0       	ldi	r20, 0x04	; 4
    1ce4:	50 e0       	ldi	r21, 0x00	; 0
    1ce6:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].decay), &(decayEE[i]), sizeof(int8_t));
    1cea:	b6 01       	movw	r22, r12
    1cec:	65 57       	subi	r22, 0x75	; 117
    1cee:	7f 4f       	sbci	r23, 0xFF	; 255
    1cf0:	c7 01       	movw	r24, r14
    1cf2:	89 5e       	subi	r24, 0xE9	; 233
    1cf4:	9b 4f       	sbci	r25, 0xFB	; 251
    1cf6:	41 e0       	ldi	r20, 0x01	; 1
    1cf8:	50 e0       	ldi	r21, 0x00	; 0
    1cfa:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepUnit), &(stepUnitEE[i]), sizeof(int8_t));
    1cfe:	b6 01       	movw	r22, r12
    1d00:	61 57       	subi	r22, 0x71	; 113
    1d02:	7f 4f       	sbci	r23, 0xFF	; 255
    1d04:	c7 01       	movw	r24, r14
    1d06:	87 5f       	subi	r24, 0xF7	; 247
    1d08:	9b 4f       	sbci	r25, 0xFB	; 251
    1d0a:	41 e0       	ldi	r20, 0x01	; 1
    1d0c:	50 e0       	ldi	r21, 0x00	; 0
    1d0e:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].waitBetweenSteps), &(waitBetweenStepsEE[i]), sizeof(int16_t));
    1d12:	b4 01       	movw	r22, r8
    1d14:	6d 56       	subi	r22, 0x6D	; 109
    1d16:	7f 4f       	sbci	r23, 0xFF	; 255
    1d18:	c7 01       	movw	r24, r14
    1d1a:	82 5f       	subi	r24, 0xF2	; 242
    1d1c:	9b 4f       	sbci	r25, 0xFB	; 251
    1d1e:	42 e0       	ldi	r20, 0x02	; 2
    1d20:	50 e0       	ldi	r21, 0x00	; 0
    1d22:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>

      eeprom_read_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
    1d26:	86 01       	movw	r16, r12
    1d28:	00 0f       	add	r16, r16
    1d2a:	11 1f       	adc	r17, r17
    1d2c:	00 0f       	add	r16, r16
    1d2e:	11 1f       	adc	r17, r17
    1d30:	0c 0d       	add	r16, r12
    1d32:	1d 1d       	adc	r17, r13
    1d34:	e8 01       	movw	r28, r16
    1d36:	cd 52       	subi	r28, 0x2D	; 45
    1d38:	dc 4f       	sbci	r29, 0xFC	; 252
    1d3a:	b4 01       	movw	r22, r8
    1d3c:	65 56       	subi	r22, 0x65	; 101
    1d3e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d40:	ce 01       	movw	r24, r28
    1d42:	42 e0       	ldi	r20, 0x02	; 2
    1d44:	50 e0       	ldi	r21, 0x00	; 0
    1d46:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
      eeprom_read_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    1d4a:	b4 01       	movw	r22, r8
    1d4c:	6d 55       	subi	r22, 0x5D	; 93
    1d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    1d50:	c8 01       	movw	r24, r16
    1d52:	8b 52       	subi	r24, 0x2B	; 43
    1d54:	9c 4f       	sbci	r25, 0xFC	; 252
    1d56:	42 e0       	ldi	r20, 0x02	; 2
    1d58:	50 e0       	ldi	r21, 0x00	; 0
    1d5a:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>

      /* activate forbidden zone if necessary */
      if(forbiddenZone[i].start != forbiddenZone[i].stop){
    1d5e:	28 81       	ld	r18, Y
    1d60:	39 81       	ldd	r19, Y+1	; 0x01
    1d62:	8a 81       	ldd	r24, Y+2	; 0x02
    1d64:	9b 81       	ldd	r25, Y+3	; 0x03
    1d66:	28 17       	cp	r18, r24
    1d68:	39 07       	cpc	r19, r25
    1d6a:	09 f0       	breq	.+2      	; 0x1d6e <loadConfigFromEEPROM+0x154>
        forbiddenZone[i].active = 1;
    1d6c:	7c 82       	std	Y+4, r7	; 0x04
    1d6e:	08 94       	sec
    1d70:	c1 1c       	adc	r12, r1
    1d72:	d1 1c       	adc	r13, r1
    1d74:	82 e0       	ldi	r24, 0x02	; 2
    1d76:	90 e0       	ldi	r25, 0x00	; 0
    1d78:	88 0e       	add	r8, r24
    1d7a:	99 1e       	adc	r9, r25
    1d7c:	84 e0       	ldi	r24, 0x04	; 4
    1d7e:	90 e0       	ldi	r25, 0x00	; 0
    1d80:	a8 0e       	add	r10, r24
    1d82:	b9 1e       	adc	r11, r25
void loadConfigFromEEPROM(void){

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
    1d84:	94 e0       	ldi	r25, 0x04	; 4
    1d86:	c9 16       	cp	r12, r25
    1d88:	d1 04       	cpc	r13, r1
    1d8a:	09 f0       	breq	.+2      	; 0x1d8e <loadConfigFromEEPROM+0x174>
    1d8c:	5c cf       	rjmp	.-328    	; 0x1c46 <loadConfigFromEEPROM+0x2c>
    1d8e:	c0 e0       	ldi	r28, 0x00	; 0
    1d90:	d0 e0       	ldi	r29, 0x00	; 0
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* load internal stores programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
      eeprom_read_block(&(programList[i]), &(programListEE[i]), sizeof(progStep));
    1d92:	be 01       	movw	r22, r28
    1d94:	65 55       	subi	r22, 0x55	; 85
    1d96:	7f 4f       	sbci	r23, 0xFF	; 255
    1d98:	ce 01       	movw	r24, r28
    1d9a:	8d 50       	subi	r24, 0x0D	; 13
    1d9c:	9d 4f       	sbci	r25, 0xFD	; 253
    1d9e:	4a e0       	ldi	r20, 0x0A	; 10
    1da0:	50 e0       	ldi	r21, 0x00	; 0
    1da2:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
    1da6:	2a 96       	adiw	r28, 0x0a	; 10
      }
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* load internal stores programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    1da8:	c0 3a       	cpi	r28, 0xA0	; 160
    1daa:	d1 05       	cpc	r29, r1
    1dac:	91 f7       	brne	.-28     	; 0x1d92 <loadConfigFromEEPROM+0x178>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1dae:	78 94       	sei
#endif

  }

  return;
}
    1db0:	df 91       	pop	r29
    1db2:	cf 91       	pop	r28
    1db4:	1f 91       	pop	r17
    1db6:	0f 91       	pop	r16
    1db8:	ff 90       	pop	r15
    1dba:	ef 90       	pop	r14
    1dbc:	df 90       	pop	r13
    1dbe:	cf 90       	pop	r12
    1dc0:	bf 90       	pop	r11
    1dc2:	af 90       	pop	r10
    1dc4:	9f 90       	pop	r9
    1dc6:	8f 90       	pop	r8
    1dc8:	7f 90       	pop	r7
    1dca:	08 95       	ret

00001dcc <saveConfigToEEPROM>:
}

/* ---------------------------------------------------------------------
    save current motor configuration to EEPROM
 --------------------------------------------------------------------- */
void saveConfigToEEPROM(void){
    1dcc:	af 92       	push	r10
    1dce:	bf 92       	push	r11
    1dd0:	cf 92       	push	r12
    1dd2:	df 92       	push	r13
    1dd4:	ef 92       	push	r14
    1dd6:	ff 92       	push	r15
    1dd8:	0f 93       	push	r16
    1dda:	1f 93       	push	r17
    1ddc:	cf 93       	push	r28
    1dde:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1de0:	f8 94       	cli
    1de2:	c0 e0       	ldi	r28, 0x00	; 0
    1de4:	d0 e0       	ldi	r29, 0x00	; 0
    1de6:	aa 24       	eor	r10, r10
    1de8:	bb 24       	eor	r11, r11
    1dea:	cc 24       	eor	r12, r12
    1dec:	dd 24       	eor	r13, r13

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
      eeprom_update_block(&(motor[i].opticalZeroPosition), &(opticalZeroPositionEE[i]), sizeof(int16_t));
    1dee:	ce 01       	movw	r24, r28
    1df0:	88 0f       	add	r24, r24
    1df2:	99 1f       	adc	r25, r25
    1df4:	8e 01       	movw	r16, r28
    1df6:	00 0f       	add	r16, r16
    1df8:	11 1f       	adc	r17, r17
    1dfa:	00 0f       	add	r16, r16
    1dfc:	11 1f       	adc	r17, r17
    1dfe:	00 0f       	add	r16, r16
    1e00:	11 1f       	adc	r17, r17
    1e02:	80 0f       	add	r24, r16
    1e04:	91 1f       	adc	r25, r17
    1e06:	88 0f       	add	r24, r24
    1e08:	99 1f       	adc	r25, r25
    1e0a:	88 0f       	add	r24, r24
    1e0c:	99 1f       	adc	r25, r25
    1e0e:	b5 01       	movw	r22, r10
    1e10:	6d 5c       	subi	r22, 0xCD	; 205
    1e12:	7f 4f       	sbci	r23, 0xFF	; 255
    1e14:	8c 50       	subi	r24, 0x0C	; 12
    1e16:	9c 4f       	sbci	r25, 0xFC	; 252
    1e18:	42 e0       	ldi	r20, 0x02	; 2
    1e1a:	50 e0       	ldi	r21, 0x00	; 0
    1e1c:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].gearRatio), &(gearRatioEE[i]), sizeof(double));
    1e20:	78 01       	movw	r14, r16
    1e22:	ee 0c       	add	r14, r14
    1e24:	ff 1c       	adc	r15, r15
    1e26:	ee 0c       	add	r14, r14
    1e28:	ff 1c       	adc	r15, r15
    1e2a:	e0 0e       	add	r14, r16
    1e2c:	f1 1e       	adc	r15, r17
    1e2e:	b6 01       	movw	r22, r12
    1e30:	65 5c       	subi	r22, 0xC5	; 197
    1e32:	7f 4f       	sbci	r23, 0xFF	; 255
    1e34:	c7 01       	movw	r24, r14
    1e36:	83 50       	subi	r24, 0x03	; 3
    1e38:	9c 4f       	sbci	r25, 0xFC	; 252
    1e3a:	44 e0       	ldi	r20, 0x04	; 4
    1e3c:	50 e0       	ldi	r21, 0x00	; 0
    1e3e:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepsPerFullRotation), &(stepsPerFullRotationEE[i]), sizeof(double));
    1e42:	b6 01       	movw	r22, r12
    1e44:	65 5b       	subi	r22, 0xB5	; 181
    1e46:	7f 4f       	sbci	r23, 0xFF	; 255
    1e48:	c7 01       	movw	r24, r14
    1e4a:	8f 5f       	subi	r24, 0xFF	; 255
    1e4c:	9b 4f       	sbci	r25, 0xFB	; 251
    1e4e:	44 e0       	ldi	r20, 0x04	; 4
    1e50:	50 e0       	ldi	r21, 0x00	; 0
    1e52:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].subSteps), &(subStepsEE[i]), sizeof(double));
    1e56:	b6 01       	movw	r22, r12
    1e58:	65 5a       	subi	r22, 0xA5	; 165
    1e5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e5c:	c7 01       	movw	r24, r14
    1e5e:	8b 5f       	subi	r24, 0xFB	; 251
    1e60:	9b 4f       	sbci	r25, 0xFB	; 251
    1e62:	44 e0       	ldi	r20, 0x04	; 4
    1e64:	50 e0       	ldi	r21, 0x00	; 0
    1e66:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepMultiplier), &(stepMultiplierEE[i]), sizeof(double));
    1e6a:	b6 01       	movw	r22, r12
    1e6c:	65 59       	subi	r22, 0x95	; 149
    1e6e:	7f 4f       	sbci	r23, 0xFF	; 255
    1e70:	c7 01       	movw	r24, r14
    1e72:	86 5f       	subi	r24, 0xF6	; 246
    1e74:	9b 4f       	sbci	r25, 0xFB	; 251
    1e76:	44 e0       	ldi	r20, 0x04	; 4
    1e78:	50 e0       	ldi	r21, 0x00	; 0
    1e7a:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
	    eeprom_update_block(&(motor[i].current), &(currentEE[i]), sizeof(double));
    1e7e:	b6 01       	movw	r22, r12
    1e80:	65 58       	subi	r22, 0x85	; 133
    1e82:	7f 4f       	sbci	r23, 0xFF	; 255
    1e84:	c7 01       	movw	r24, r14
    1e86:	8d 5e       	subi	r24, 0xED	; 237
    1e88:	9b 4f       	sbci	r25, 0xFB	; 251
    1e8a:	44 e0       	ldi	r20, 0x04	; 4
    1e8c:	50 e0       	ldi	r21, 0x00	; 0
    1e8e:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].decay), &(decayEE[i]), sizeof(int8_t));
    1e92:	be 01       	movw	r22, r28
    1e94:	65 57       	subi	r22, 0x75	; 117
    1e96:	7f 4f       	sbci	r23, 0xFF	; 255
    1e98:	c7 01       	movw	r24, r14
    1e9a:	89 5e       	subi	r24, 0xE9	; 233
    1e9c:	9b 4f       	sbci	r25, 0xFB	; 251
    1e9e:	41 e0       	ldi	r20, 0x01	; 1
    1ea0:	50 e0       	ldi	r21, 0x00	; 0
    1ea2:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepUnit), &(stepUnitEE[i]), sizeof(int8_t));
    1ea6:	be 01       	movw	r22, r28
    1ea8:	61 57       	subi	r22, 0x71	; 113
    1eaa:	7f 4f       	sbci	r23, 0xFF	; 255
    1eac:	c7 01       	movw	r24, r14
    1eae:	87 5f       	subi	r24, 0xF7	; 247
    1eb0:	9b 4f       	sbci	r25, 0xFB	; 251
    1eb2:	41 e0       	ldi	r20, 0x01	; 1
    1eb4:	50 e0       	ldi	r21, 0x00	; 0
    1eb6:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].waitBetweenSteps), &(waitBetweenStepsEE[i]), sizeof(int16_t));
    1eba:	b5 01       	movw	r22, r10
    1ebc:	6d 56       	subi	r22, 0x6D	; 109
    1ebe:	7f 4f       	sbci	r23, 0xFF	; 255
    1ec0:	c7 01       	movw	r24, r14
    1ec2:	82 5f       	subi	r24, 0xF2	; 242
    1ec4:	9b 4f       	sbci	r25, 0xFB	; 251
    1ec6:	42 e0       	ldi	r20, 0x02	; 2
    1ec8:	50 e0       	ldi	r21, 0x00	; 0
    1eca:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>

      eeprom_update_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
    1ece:	8e 01       	movw	r16, r28
    1ed0:	00 0f       	add	r16, r16
    1ed2:	11 1f       	adc	r17, r17
    1ed4:	00 0f       	add	r16, r16
    1ed6:	11 1f       	adc	r17, r17
    1ed8:	0c 0f       	add	r16, r28
    1eda:	1d 1f       	adc	r17, r29
    1edc:	b5 01       	movw	r22, r10
    1ede:	65 56       	subi	r22, 0x65	; 101
    1ee0:	7f 4f       	sbci	r23, 0xFF	; 255
    1ee2:	c8 01       	movw	r24, r16
    1ee4:	8d 52       	subi	r24, 0x2D	; 45
    1ee6:	9c 4f       	sbci	r25, 0xFC	; 252
    1ee8:	42 e0       	ldi	r20, 0x02	; 2
    1eea:	50 e0       	ldi	r21, 0x00	; 0
    1eec:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
      eeprom_update_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    1ef0:	b5 01       	movw	r22, r10
    1ef2:	6d 55       	subi	r22, 0x5D	; 93
    1ef4:	7f 4f       	sbci	r23, 0xFF	; 255
    1ef6:	c8 01       	movw	r24, r16
    1ef8:	8b 52       	subi	r24, 0x2B	; 43
    1efa:	9c 4f       	sbci	r25, 0xFC	; 252
    1efc:	42 e0       	ldi	r20, 0x02	; 2
    1efe:	50 e0       	ldi	r21, 0x00	; 0
    1f00:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
    1f04:	21 96       	adiw	r28, 0x01	; 1
    1f06:	82 e0       	ldi	r24, 0x02	; 2
    1f08:	90 e0       	ldi	r25, 0x00	; 0
    1f0a:	a8 0e       	add	r10, r24
    1f0c:	b9 1e       	adc	r11, r25
    1f0e:	84 e0       	ldi	r24, 0x04	; 4
    1f10:	90 e0       	ldi	r25, 0x00	; 0
    1f12:	c8 0e       	add	r12, r24
    1f14:	d9 1e       	adc	r13, r25
void saveConfigToEEPROM(void){

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
    1f16:	c4 30       	cpi	r28, 0x04	; 4
    1f18:	d1 05       	cpc	r29, r1
    1f1a:	09 f0       	breq	.+2      	; 0x1f1e <saveConfigToEEPROM+0x152>
    1f1c:	68 cf       	rjmp	.-304    	; 0x1dee <saveConfigToEEPROM+0x22>
    1f1e:	c0 e0       	ldi	r28, 0x00	; 0
    1f20:	d0 e0       	ldi	r29, 0x00	; 0
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* save internal stored programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
      eeprom_update_block(&(programList[i]), &(programListEE[i]), sizeof(progStep));
    1f22:	be 01       	movw	r22, r28
    1f24:	65 55       	subi	r22, 0x55	; 85
    1f26:	7f 4f       	sbci	r23, 0xFF	; 255
    1f28:	ce 01       	movw	r24, r28
    1f2a:	8d 50       	subi	r24, 0x0D	; 13
    1f2c:	9d 4f       	sbci	r25, 0xFD	; 253
    1f2e:	4a e0       	ldi	r20, 0x0A	; 10
    1f30:	50 e0       	ldi	r21, 0x00	; 0
    1f32:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
    1f36:	2a 96       	adiw	r28, 0x0a	; 10
      eeprom_update_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* save internal stored programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    1f38:	c0 3a       	cpi	r28, 0xA0	; 160
    1f3a:	d1 05       	cpc	r29, r1
    1f3c:	91 f7       	brne	.-28     	; 0x1f22 <saveConfigToEEPROM+0x156>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1f3e:	78 94       	sei
#endif

  }

  return;
}
    1f40:	df 91       	pop	r29
    1f42:	cf 91       	pop	r28
    1f44:	1f 91       	pop	r17
    1f46:	0f 91       	pop	r16
    1f48:	ff 90       	pop	r15
    1f4a:	ef 90       	pop	r14
    1f4c:	df 90       	pop	r13
    1f4e:	cf 90       	pop	r12
    1f50:	bf 90       	pop	r11
    1f52:	af 90       	pop	r10
    1f54:	08 95       	ret

00001f56 <commandFactoryReset>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1f56:	f8 94       	cli
    sets the whole system back to factory reset
 --------------------------------------------------------------------- */
void commandFactoryReset(void){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    initDataStructs();
    1f58:	0e 94 40 03 	call	0x680	; 0x680 <initDataStructs>
    saveConfigToEEPROM();
    1f5c:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <saveConfigToEEPROM>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1f60:	78 94       	sei
  }

  return;
}
    1f62:	08 95       	ret

00001f64 <__vector_9>:
}

/* ---------------------------------------------------------------------
    handles all motor movement
 --------------------------------------------------------------------- */
ISR(TIMER2_COMPA_vect){
    1f64:	1f 92       	push	r1
    1f66:	0f 92       	push	r0
    1f68:	0f b6       	in	r0, 0x3f	; 63
    1f6a:	0f 92       	push	r0
    1f6c:	0b b6       	in	r0, 0x3b	; 59
    1f6e:	0f 92       	push	r0
    1f70:	11 24       	eor	r1, r1
    1f72:	2f 92       	push	r2
    1f74:	3f 92       	push	r3
    1f76:	4f 92       	push	r4
    1f78:	5f 92       	push	r5
    1f7a:	6f 92       	push	r6
    1f7c:	7f 92       	push	r7
    1f7e:	8f 92       	push	r8
    1f80:	9f 92       	push	r9
    1f82:	af 92       	push	r10
    1f84:	bf 92       	push	r11
    1f86:	cf 92       	push	r12
    1f88:	df 92       	push	r13
    1f8a:	ef 92       	push	r14
    1f8c:	ff 92       	push	r15
    1f8e:	0f 93       	push	r16
    1f90:	1f 93       	push	r17
    1f92:	2f 93       	push	r18
    1f94:	3f 93       	push	r19
    1f96:	4f 93       	push	r20
    1f98:	5f 93       	push	r21
    1f9a:	6f 93       	push	r22
    1f9c:	7f 93       	push	r23
    1f9e:	8f 93       	push	r24
    1fa0:	9f 93       	push	r25
    1fa2:	af 93       	push	r26
    1fa4:	bf 93       	push	r27
    1fa6:	ef 93       	push	r30
    1fa8:	ff 93       	push	r31
    1faa:	df 93       	push	r29
    1fac:	cf 93       	push	r28
    1fae:	cd b7       	in	r28, 0x3d	; 61
    1fb0:	de b7       	in	r29, 0x3e	; 62
    1fb2:	a0 97       	sbiw	r28, 0x20	; 32
    1fb4:	de bf       	out	0x3e, r29	; 62
    1fb6:	cd bf       	out	0x3d, r28	; 61
    1fb8:	9e 01       	movw	r18, r28
    1fba:	27 5f       	subi	r18, 0xF7	; 247
    1fbc:	3f 4f       	sbci	r19, 0xFF	; 255
    1fbe:	3c 8f       	std	Y+28, r19	; 0x1c
    1fc0:	2b 8f       	std	Y+27, r18	; 0x1b
    1fc2:	3a 8f       	std	Y+26, r19	; 0x1a
    1fc4:	29 8f       	std	Y+25, r18	; 0x19
    1fc6:	18 a2       	std	Y+32, r1	; 0x20
    1fc8:	1f 8e       	std	Y+31, r1	; 0x1f
    1fca:	66 24       	eor	r6, r6
    1fcc:	77 24       	eor	r7, r7
    1fce:	1e 8e       	std	Y+30, r1	; 0x1e
    1fd0:	1d 8e       	std	Y+29, r1	; 0x1d
  uint8_t outputStep = 0;

  double stepsPerFullRotation[MAX_MOTOR + 1];

  for(i = 0; i <= MAX_MOTOR; i++){
    stepDiff[i] = motor[i].desiredPosition - motor[i].actualPosition;
    1fd2:	23 01       	movw	r4, r6
    1fd4:	44 0c       	add	r4, r4
    1fd6:	55 1c       	adc	r5, r5
    1fd8:	44 0c       	add	r4, r4
    1fda:	55 1c       	adc	r5, r5
    1fdc:	42 01       	movw	r8, r4
    1fde:	88 0c       	add	r8, r8
    1fe0:	99 1c       	adc	r9, r9
    1fe2:	88 0c       	add	r8, r8
    1fe4:	99 1c       	adc	r9, r9
    1fe6:	84 0c       	add	r8, r4
    1fe8:	95 1c       	adc	r9, r5
    1fea:	88 0c       	add	r8, r8
    1fec:	99 1c       	adc	r9, r9
    1fee:	82 ef       	ldi	r24, 0xF2	; 242
    1ff0:	93 e0       	ldi	r25, 0x03	; 3
    1ff2:	88 0e       	add	r8, r24
    1ff4:	99 1e       	adc	r9, r25
    1ff6:	d4 01       	movw	r26, r8
    1ff8:	ad 90       	ld	r10, X+
    1ffa:	bc 90       	ld	r11, X
    1ffc:	13 01       	movw	r2, r6
    1ffe:	22 0c       	add	r2, r2
    2000:	33 1c       	adc	r3, r3
    2002:	22 0c       	add	r2, r2
    2004:	33 1c       	adc	r3, r3
    2006:	22 0c       	add	r2, r2
    2008:	33 1c       	adc	r3, r3
    200a:	61 01       	movw	r12, r2
    200c:	cc 0c       	add	r12, r12
    200e:	dd 1c       	adc	r13, r13
    2010:	cc 0c       	add	r12, r12
    2012:	dd 1c       	adc	r13, r13
    2014:	c2 0c       	add	r12, r2
    2016:	d3 1c       	adc	r13, r3
    2018:	e0 ef       	ldi	r30, 0xF0	; 240
    201a:	f3 e0       	ldi	r31, 0x03	; 3
    201c:	ce 0e       	add	r12, r30
    201e:	df 1e       	adc	r13, r31
    2020:	d6 01       	movw	r26, r12
    2022:	8d 91       	ld	r24, X+
    2024:	9c 91       	ld	r25, X
    2026:	11 97       	sbiw	r26, 0x01	; 1
    2028:	a8 1a       	sub	r10, r24
    202a:	b9 0a       	sbc	r11, r25
    202c:	e1 e0       	ldi	r30, 0x01	; 1
    202e:	f0 e0       	ldi	r31, 0x00	; 0
    2030:	ec 0f       	add	r30, r28
    2032:	fd 1f       	adc	r31, r29
    2034:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2036:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2038:	e2 0f       	add	r30, r18
    203a:	f3 1f       	adc	r31, r19
    203c:	b1 82       	std	Z+1, r11	; 0x01
    203e:	a0 82       	st	Z, r10

    stepsPerFullRotation[i] =  motor[i].gearRatio
    2040:	1d 96       	adiw	r26, 0x0d	; 13
    2042:	6d 91       	ld	r22, X+
    2044:	7d 91       	ld	r23, X+
    2046:	8d 91       	ld	r24, X+
    2048:	9c 91       	ld	r25, X
    204a:	50 97       	sbiw	r26, 0x10	; 16
    204c:	51 96       	adiw	r26, 0x11	; 17
    204e:	2d 91       	ld	r18, X+
    2050:	3d 91       	ld	r19, X+
    2052:	4d 91       	ld	r20, X+
    2054:	5c 91       	ld	r21, X
    2056:	54 97       	sbiw	r26, 0x14	; 20
    2058:	55 96       	adiw	r26, 0x15	; 21
    205a:	ed 90       	ld	r14, X+
    205c:	fd 90       	ld	r15, X+
    205e:	0d 91       	ld	r16, X+
    2060:	1c 91       	ld	r17, X
    2062:	58 97       	sbiw	r26, 0x18	; 24
    2064:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2068:	a8 01       	movw	r20, r16
    206a:	97 01       	movw	r18, r14
    206c:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2070:	a9 8d       	ldd	r26, Y+25	; 0x19
    2072:	ba 8d       	ldd	r27, Y+26	; 0x1a
    2074:	6d 93       	st	X+, r22
    2076:	7d 93       	st	X+, r23
    2078:	8d 93       	st	X+, r24
    207a:	9c 93       	st	X, r25
    207c:	13 97       	sbiw	r26, 0x03	; 3
                              *motor[i].stepsPerFullRotation
                              *motor[i].subSteps;

    if(stepDiff[i] == 0){
    207e:	a1 14       	cp	r10, r1
    2080:	b1 04       	cpc	r11, r1
    2082:	09 f4       	brne	.+2      	; 0x2086 <__vector_9+0x122>
    2084:	4c c0       	rjmp	.+152    	; 0x211e <__vector_9+0x1ba>
      /* no motor movement required */
      continue;
    }
    else{
      /* check if the wait-time between two steps is over */
      if(motor[i].delayCounter){
    2086:	f6 01       	movw	r30, r12
    2088:	80 a1       	ldd	r24, Z+32	; 0x20
    208a:	91 a1       	ldd	r25, Z+33	; 0x21
    208c:	89 2b       	or	r24, r25
    208e:	09 f4       	brne	.+2      	; 0x2092 <__vector_9+0x12e>
    2090:	69 c1       	rjmp	.+722    	; 0x2364 <__vector_9+0x400>
        /* seems not to be, so decrement */
        motor[i].delayCounter--;
    2092:	80 a1       	ldd	r24, Z+32	; 0x20
    2094:	91 a1       	ldd	r25, Z+33	; 0x21
    2096:	01 97       	sbiw	r24, 0x01	; 1
    2098:	91 a3       	std	Z+33, r25	; 0x21
    209a:	80 a3       	std	Z+32, r24	; 0x20

        /* and we also got time here to correct motor step error */
        if(motor[i].stepError > 1.0f){
    209c:	66 81       	ldd	r22, Z+6	; 0x06
    209e:	77 81       	ldd	r23, Z+7	; 0x07
    20a0:	80 85       	ldd	r24, Z+8	; 0x08
    20a2:	91 85       	ldd	r25, Z+9	; 0x09
    20a4:	20 e0       	ldi	r18, 0x00	; 0
    20a6:	30 e0       	ldi	r19, 0x00	; 0
    20a8:	40 e8       	ldi	r20, 0x80	; 128
    20aa:	5f e3       	ldi	r21, 0x3F	; 63
    20ac:	0e 94 66 41 	call	0x82cc	; 0x82cc <__gesf2>
    20b0:	18 16       	cp	r1, r24
    20b2:	d4 f4       	brge	.+52     	; 0x20e8 <__vector_9+0x184>
          motor[i].desiredPosition += 1;
    20b4:	d4 01       	movw	r26, r8
    20b6:	8d 91       	ld	r24, X+
    20b8:	9c 91       	ld	r25, X
    20ba:	11 97       	sbiw	r26, 0x01	; 1
    20bc:	01 96       	adiw	r24, 0x01	; 1
    20be:	11 96       	adiw	r26, 0x01	; 1
    20c0:	9c 93       	st	X, r25
    20c2:	8e 93       	st	-X, r24
          motor[i].stepError -= 1.0f;
    20c4:	f6 01       	movw	r30, r12
    20c6:	66 81       	ldd	r22, Z+6	; 0x06
    20c8:	77 81       	ldd	r23, Z+7	; 0x07
    20ca:	80 85       	ldd	r24, Z+8	; 0x08
    20cc:	91 85       	ldd	r25, Z+9	; 0x09
    20ce:	20 e0       	ldi	r18, 0x00	; 0
    20d0:	30 e0       	ldi	r19, 0x00	; 0
    20d2:	40 e8       	ldi	r20, 0x80	; 128
    20d4:	5f e3       	ldi	r21, 0x3F	; 63
    20d6:	0e 94 5f 3f 	call	0x7ebe	; 0x7ebe <__subsf3>
    20da:	d6 01       	movw	r26, r12
    20dc:	16 96       	adiw	r26, 0x06	; 6
    20de:	6d 93       	st	X+, r22
    20e0:	7d 93       	st	X+, r23
    20e2:	8d 93       	st	X+, r24
    20e4:	9c 93       	st	X, r25
    20e6:	19 97       	sbiw	r26, 0x09	; 9
        }
        if(motor[i].stepError < -1.0f){
    20e8:	61 01       	movw	r12, r2
    20ea:	cc 0c       	add	r12, r12
    20ec:	dd 1c       	adc	r13, r13
    20ee:	cc 0c       	add	r12, r12
    20f0:	dd 1c       	adc	r13, r13
    20f2:	c2 0c       	add	r12, r2
    20f4:	d3 1c       	adc	r13, r3
    20f6:	e0 ef       	ldi	r30, 0xF0	; 240
    20f8:	f3 e0       	ldi	r31, 0x03	; 3
    20fa:	ce 0e       	add	r12, r30
    20fc:	df 1e       	adc	r13, r31
    20fe:	d6 01       	movw	r26, r12
    2100:	16 96       	adiw	r26, 0x06	; 6
    2102:	6d 91       	ld	r22, X+
    2104:	7d 91       	ld	r23, X+
    2106:	8d 91       	ld	r24, X+
    2108:	9c 91       	ld	r25, X
    210a:	19 97       	sbiw	r26, 0x09	; 9
    210c:	20 e0       	ldi	r18, 0x00	; 0
    210e:	30 e0       	ldi	r19, 0x00	; 0
    2110:	40 e8       	ldi	r20, 0x80	; 128
    2112:	5f eb       	ldi	r21, 0xBF	; 191
    2114:	0e 94 c4 3f 	call	0x7f88	; 0x7f88 <__cmpsf2>
    2118:	88 23       	and	r24, r24
    211a:	0c f4       	brge	.+2      	; 0x211e <__vector_9+0x1ba>
    211c:	0c c2       	rjmp	.+1048   	; 0x2536 <__vector_9+0x5d2>
          else{
            outputStep |= (1 << (2*i));
          }
        }
        /* so we will move and therefore set back the delay counter */
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    211e:	08 94       	sec
    2120:	61 1c       	adc	r6, r1
    2122:	71 1c       	adc	r7, r1
    2124:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2126:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2128:	2e 5f       	subi	r18, 0xFE	; 254
    212a:	3f 4f       	sbci	r19, 0xFF	; 255
    212c:	3e 8f       	std	Y+30, r19	; 0x1e
    212e:	2d 8f       	std	Y+29, r18	; 0x1d
    2130:	89 8d       	ldd	r24, Y+25	; 0x19
    2132:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2134:	04 96       	adiw	r24, 0x04	; 4
    2136:	9a 8f       	std	Y+26, r25	; 0x1a
    2138:	89 8f       	std	Y+25, r24	; 0x19
  uint8_t outputDir  = 0;
  uint8_t outputStep = 0;

  double stepsPerFullRotation[MAX_MOTOR + 1];

  for(i = 0; i <= MAX_MOTOR; i++){
    213a:	94 e0       	ldi	r25, 0x04	; 4
    213c:	69 16       	cp	r6, r25
    213e:	71 04       	cpc	r7, r1
    2140:	09 f0       	breq	.+2      	; 0x2144 <__vector_9+0x1e0>
    2142:	47 cf       	rjmp	.-370    	; 0x1fd2 <__vector_9+0x6e>
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
      }
    }
  }

  PORTA |= outputDir;     /* set direction */
    2144:	82 b1       	in	r24, 0x02	; 2
    2146:	a8 a1       	ldd	r26, Y+32	; 0x20
    2148:	a8 2b       	or	r26, r24
    214a:	a2 b9       	out	0x02, r26	; 2
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    214c:	96 e0       	ldi	r25, 0x06	; 6
    214e:	89 2f       	mov	r24, r25
    2150:	8a 95       	dec	r24
    2152:	f1 f7       	brne	.-4      	; 0x2150 <__vector_9+0x1ec>
  _delay_us(1.0);         /* sync */
  PORTA |= outputStep;    /* make exactly one step */
    2154:	82 b1       	in	r24, 0x02	; 2
    2156:	bf 8d       	ldd	r27, Y+31	; 0x1f
    2158:	8b 2b       	or	r24, r27
    215a:	82 b9       	out	0x02, r24	; 2
    215c:	8d e0       	ldi	r24, 0x0D	; 13
    215e:	8a 95       	dec	r24
    2160:	f1 f7       	brne	.-4      	; 0x215e <__vector_9+0x1fa>
  _delay_us(2.0);         /* sync */
  PORTA &= ~outputStep;
    2162:	82 b1       	in	r24, 0x02	; 2
    2164:	b0 95       	com	r27
    2166:	b8 23       	and	r27, r24
    2168:	b2 b9       	out	0x02, r27	; 2
    216a:	9a 95       	dec	r25
    216c:	f1 f7       	brne	.-4      	; 0x216a <__vector_9+0x206>
  _delay_us(1.0);
  PORTA = 0;
    216e:	12 b8       	out	0x02, r1	; 2
    2170:	3e 01       	movw	r6, r28
    2172:	08 94       	sec
    2174:	61 1c       	adc	r6, r1
    2176:	71 1c       	adc	r7, r1
    2178:	cc 24       	eor	r12, r12
    217a:	dd 24       	eor	r13, r13
    217c:	ec 2c       	mov	r14, r12
    217e:	5d 2c       	mov	r5, r13

  /* update motor positions */
  for(i = 0; i <= MAX_MOTOR; i++){
    if(motor[i].isMoving){
    2180:	f6 01       	movw	r30, r12
    2182:	ee 0f       	add	r30, r30
    2184:	ff 1f       	adc	r31, r31
    2186:	ee 0f       	add	r30, r30
    2188:	ff 1f       	adc	r31, r31
    218a:	ee 0f       	add	r30, r30
    218c:	ff 1f       	adc	r31, r31
    218e:	cf 01       	movw	r24, r30
    2190:	88 0f       	add	r24, r24
    2192:	99 1f       	adc	r25, r25
    2194:	88 0f       	add	r24, r24
    2196:	99 1f       	adc	r25, r25
    2198:	e8 0f       	add	r30, r24
    219a:	f9 1f       	adc	r31, r25
    219c:	e0 51       	subi	r30, 0x10	; 16
    219e:	fc 4f       	sbci	r31, 0xFC	; 252
    21a0:	82 85       	ldd	r24, Z+10	; 0x0a
    21a2:	88 23       	and	r24, r24
    21a4:	09 f4       	brne	.+2      	; 0x21a8 <__vector_9+0x244>
    21a6:	a4 c0       	rjmp	.+328    	; 0x22f0 <__vector_9+0x38c>
      if(stepDiff[i] > 0){
    21a8:	f3 01       	movw	r30, r6
    21aa:	80 81       	ld	r24, Z
    21ac:	91 81       	ldd	r25, Z+1	; 0x01
    21ae:	18 16       	cp	r1, r24
    21b0:	19 06       	cpc	r1, r25
    21b2:	0c f0       	brlt	.+2      	; 0x21b6 <__vector_9+0x252>
    21b4:	01 c1       	rjmp	.+514    	; 0x23b8 <__vector_9+0x454>
        /* check if we got one full rotation */
        if(((motor[i].actualPosition) + 1) > stepsPerFullRotation[i]){
    21b6:	f6 01       	movw	r30, r12
    21b8:	ee 0f       	add	r30, r30
    21ba:	ff 1f       	adc	r31, r31
    21bc:	ee 0f       	add	r30, r30
    21be:	ff 1f       	adc	r31, r31
    21c0:	ee 0f       	add	r30, r30
    21c2:	ff 1f       	adc	r31, r31
    21c4:	cf 01       	movw	r24, r30
    21c6:	88 0f       	add	r24, r24
    21c8:	99 1f       	adc	r25, r25
    21ca:	88 0f       	add	r24, r24
    21cc:	99 1f       	adc	r25, r25
    21ce:	e8 0f       	add	r30, r24
    21d0:	f9 1f       	adc	r31, r25
    21d2:	e0 51       	subi	r30, 0x10	; 16
    21d4:	fc 4f       	sbci	r31, 0xFC	; 252
    21d6:	60 81       	ld	r22, Z
    21d8:	71 81       	ldd	r23, Z+1	; 0x01
    21da:	ab 8d       	ldd	r26, Y+27	; 0x1b
    21dc:	bc 8d       	ldd	r27, Y+28	; 0x1c
    21de:	8d 90       	ld	r8, X+
    21e0:	9d 90       	ld	r9, X+
    21e2:	ad 90       	ld	r10, X+
    21e4:	bc 90       	ld	r11, X
    21e6:	6f 5f       	subi	r22, 0xFF	; 255
    21e8:	7f 4f       	sbci	r23, 0xFF	; 255
    21ea:	88 27       	eor	r24, r24
    21ec:	77 fd       	sbrc	r23, 7
    21ee:	80 95       	com	r24
    21f0:	98 2f       	mov	r25, r24
    21f2:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    21f6:	a5 01       	movw	r20, r10
    21f8:	94 01       	movw	r18, r8
    21fa:	0e 94 66 41 	call	0x82cc	; 0x82cc <__gesf2>
    21fe:	18 16       	cp	r1, r24
    2200:	0c f4       	brge	.+2      	; 0x2204 <__vector_9+0x2a0>
    2202:	5a c1       	rjmp	.+692    	; 0x24b8 <__vector_9+0x554>
          /* so set back to 0 */
          motor[i].actualPosition = 0;
          /* correct desired motor position */
          motor[i].desiredPosition -= (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition++;
    2204:	ee 2d       	mov	r30, r14
    2206:	f5 2d       	mov	r31, r5
    2208:	ee 0f       	add	r30, r30
    220a:	ff 1f       	adc	r31, r31
    220c:	ee 0f       	add	r30, r30
    220e:	ff 1f       	adc	r31, r31
    2210:	ee 0f       	add	r30, r30
    2212:	ff 1f       	adc	r31, r31
    2214:	cf 01       	movw	r24, r30
    2216:	88 0f       	add	r24, r24
    2218:	99 1f       	adc	r25, r25
    221a:	88 0f       	add	r24, r24
    221c:	99 1f       	adc	r25, r25
    221e:	e8 0f       	add	r30, r24
    2220:	f9 1f       	adc	r31, r25
    2222:	e0 51       	subi	r30, 0x10	; 16
    2224:	fc 4f       	sbci	r31, 0xFC	; 252
    2226:	20 81       	ld	r18, Z
    2228:	31 81       	ldd	r19, Z+1	; 0x01
    222a:	2f 5f       	subi	r18, 0xFF	; 255
    222c:	3f 4f       	sbci	r19, 0xFF	; 255
    222e:	ee 2d       	mov	r30, r14
    2230:	f5 2d       	mov	r31, r5
    2232:	ee 0f       	add	r30, r30
    2234:	ff 1f       	adc	r31, r31
    2236:	ee 0f       	add	r30, r30
    2238:	ff 1f       	adc	r31, r31
    223a:	ee 0f       	add	r30, r30
    223c:	ff 1f       	adc	r31, r31
    223e:	cf 01       	movw	r24, r30
    2240:	88 0f       	add	r24, r24
    2242:	99 1f       	adc	r25, r25
    2244:	88 0f       	add	r24, r24
    2246:	99 1f       	adc	r25, r25
    2248:	e8 0f       	add	r30, r24
    224a:	f9 1f       	adc	r31, r25
    224c:	e0 51       	subi	r30, 0x10	; 16
    224e:	fc 4f       	sbci	r31, 0xFC	; 252
    2250:	31 83       	std	Z+1, r19	; 0x01
    2252:	20 83       	st	Z, r18
        if(motor[i].isMovingInfinite){
    2254:	ee 2d       	mov	r30, r14
    2256:	f5 2d       	mov	r31, r5
    2258:	ee 0f       	add	r30, r30
    225a:	ff 1f       	adc	r31, r31
    225c:	ee 0f       	add	r30, r30
    225e:	ff 1f       	adc	r31, r31
    2260:	ee 0f       	add	r30, r30
    2262:	ff 1f       	adc	r31, r31
    2264:	cf 01       	movw	r24, r30
    2266:	88 0f       	add	r24, r24
    2268:	99 1f       	adc	r25, r25
    226a:	88 0f       	add	r24, r24
    226c:	99 1f       	adc	r25, r25
    226e:	e8 0f       	add	r30, r24
    2270:	f9 1f       	adc	r31, r25
    2272:	e0 51       	subi	r30, 0x10	; 16
    2274:	fc 4f       	sbci	r31, 0xFC	; 252
    2276:	84 85       	ldd	r24, Z+12	; 0x0c
    2278:	88 23       	and	r24, r24
    227a:	41 f1       	breq	.+80     	; 0x22cc <__vector_9+0x368>
          motor[i].desiredPosition += 1;
    227c:	ee 2d       	mov	r30, r14
    227e:	f5 2d       	mov	r31, r5
    2280:	ee 0f       	add	r30, r30
    2282:	ff 1f       	adc	r31, r31
    2284:	ee 0f       	add	r30, r30
    2286:	ff 1f       	adc	r31, r31
    2288:	cf 01       	movw	r24, r30
    228a:	88 0f       	add	r24, r24
    228c:	99 1f       	adc	r25, r25
    228e:	88 0f       	add	r24, r24
    2290:	99 1f       	adc	r25, r25
    2292:	e8 0f       	add	r30, r24
    2294:	f9 1f       	adc	r31, r25
    2296:	ee 0f       	add	r30, r30
    2298:	ff 1f       	adc	r31, r31
    229a:	ee 50       	subi	r30, 0x0E	; 14
    229c:	fc 4f       	sbci	r31, 0xFC	; 252
    229e:	20 81       	ld	r18, Z
    22a0:	31 81       	ldd	r19, Z+1	; 0x01
    22a2:	2f 5f       	subi	r18, 0xFF	; 255
    22a4:	3f 4f       	sbci	r19, 0xFF	; 255
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition--;
        if(motor[i].isMovingInfinite){
          motor[i].desiredPosition += -1;
    22a6:	ee 2d       	mov	r30, r14
    22a8:	f5 2d       	mov	r31, r5
    22aa:	ee 0f       	add	r30, r30
    22ac:	ff 1f       	adc	r31, r31
    22ae:	ee 0f       	add	r30, r30
    22b0:	ff 1f       	adc	r31, r31
    22b2:	cf 01       	movw	r24, r30
    22b4:	88 0f       	add	r24, r24
    22b6:	99 1f       	adc	r25, r25
    22b8:	88 0f       	add	r24, r24
    22ba:	99 1f       	adc	r25, r25
    22bc:	e8 0f       	add	r30, r24
    22be:	f9 1f       	adc	r31, r25
    22c0:	ee 0f       	add	r30, r30
    22c2:	ff 1f       	adc	r31, r31
    22c4:	ee 50       	subi	r30, 0x0E	; 14
    22c6:	fc 4f       	sbci	r31, 0xFC	; 252
    22c8:	31 83       	std	Z+1, r19	; 0x01
    22ca:	20 83       	st	Z, r18
        }
      }
      motor[i].isMoving = 0;
    22cc:	ee 2d       	mov	r30, r14
    22ce:	f5 2d       	mov	r31, r5
    22d0:	ee 0f       	add	r30, r30
    22d2:	ff 1f       	adc	r31, r31
    22d4:	ee 0f       	add	r30, r30
    22d6:	ff 1f       	adc	r31, r31
    22d8:	ee 0f       	add	r30, r30
    22da:	ff 1f       	adc	r31, r31
    22dc:	cf 01       	movw	r24, r30
    22de:	88 0f       	add	r24, r24
    22e0:	99 1f       	adc	r25, r25
    22e2:	88 0f       	add	r24, r24
    22e4:	99 1f       	adc	r25, r25
    22e6:	e8 0f       	add	r30, r24
    22e8:	f9 1f       	adc	r31, r25
    22ea:	e0 51       	subi	r30, 0x10	; 16
    22ec:	fc 4f       	sbci	r31, 0xFC	; 252
    22ee:	12 86       	std	Z+10, r1	; 0x0a
    22f0:	08 94       	sec
    22f2:	c1 1c       	adc	r12, r1
    22f4:	d1 1c       	adc	r13, r1
    22f6:	2b 8d       	ldd	r18, Y+27	; 0x1b
    22f8:	3c 8d       	ldd	r19, Y+28	; 0x1c
    22fa:	2c 5f       	subi	r18, 0xFC	; 252
    22fc:	3f 4f       	sbci	r19, 0xFF	; 255
    22fe:	3c 8f       	std	Y+28, r19	; 0x1c
    2300:	2b 8f       	std	Y+27, r18	; 0x1b
    2302:	82 e0       	ldi	r24, 0x02	; 2
    2304:	90 e0       	ldi	r25, 0x00	; 0
    2306:	68 0e       	add	r6, r24
    2308:	79 1e       	adc	r7, r25
  PORTA &= ~outputStep;
  _delay_us(1.0);
  PORTA = 0;

  /* update motor positions */
  for(i = 0; i <= MAX_MOTOR; i++){
    230a:	94 e0       	ldi	r25, 0x04	; 4
    230c:	c9 16       	cp	r12, r25
    230e:	d1 04       	cpc	r13, r1
    2310:	09 f0       	breq	.+2      	; 0x2314 <__vector_9+0x3b0>
    2312:	34 cf       	rjmp	.-408    	; 0x217c <__vector_9+0x218>
        }
      }
      motor[i].isMoving = 0;
    }
  }
}
    2314:	a0 96       	adiw	r28, 0x20	; 32
    2316:	de bf       	out	0x3e, r29	; 62
    2318:	cd bf       	out	0x3d, r28	; 61
    231a:	cf 91       	pop	r28
    231c:	df 91       	pop	r29
    231e:	ff 91       	pop	r31
    2320:	ef 91       	pop	r30
    2322:	bf 91       	pop	r27
    2324:	af 91       	pop	r26
    2326:	9f 91       	pop	r25
    2328:	8f 91       	pop	r24
    232a:	7f 91       	pop	r23
    232c:	6f 91       	pop	r22
    232e:	5f 91       	pop	r21
    2330:	4f 91       	pop	r20
    2332:	3f 91       	pop	r19
    2334:	2f 91       	pop	r18
    2336:	1f 91       	pop	r17
    2338:	0f 91       	pop	r16
    233a:	ff 90       	pop	r15
    233c:	ef 90       	pop	r14
    233e:	df 90       	pop	r13
    2340:	cf 90       	pop	r12
    2342:	bf 90       	pop	r11
    2344:	af 90       	pop	r10
    2346:	9f 90       	pop	r9
    2348:	8f 90       	pop	r8
    234a:	7f 90       	pop	r7
    234c:	6f 90       	pop	r6
    234e:	5f 90       	pop	r5
    2350:	4f 90       	pop	r4
    2352:	3f 90       	pop	r3
    2354:	2f 90       	pop	r2
    2356:	0f 90       	pop	r0
    2358:	0b be       	out	0x3b, r0	; 59
    235a:	0f 90       	pop	r0
    235c:	0f be       	out	0x3f, r0	; 63
    235e:	0f 90       	pop	r0
    2360:	1f 90       	pop	r1
    2362:	18 95       	reti
          motor[i].stepError += 1.0f;
        }
      }
      else{
        /* here we just waited the specified time between two steps */
        motor[i].isMoving = 1;
    2364:	21 e0       	ldi	r18, 0x01	; 1
    2366:	f6 01       	movw	r30, r12
    2368:	22 87       	std	Z+10, r18	; 0x0a

        if(stepDiff[i] < 0){
    236a:	b7 fc       	sbrc	r11, 7
    236c:	07 c1       	rjmp	.+526    	; 0x257c <__vector_9+0x618>
          }
        }
        else{
          /* moving CW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    236e:	f2 01       	movw	r30, r4
    2370:	e6 0d       	add	r30, r6
    2372:	f7 1d       	adc	r31, r7
    2374:	ed 52       	subi	r30, 0x2D	; 45
    2376:	fc 4f       	sbci	r31, 0xFC	; 252
    2378:	84 81       	ldd	r24, Z+4	; 0x04
    237a:	88 23       	and	r24, r24
    237c:	09 f0       	breq	.+2      	; 0x2380 <__vector_9+0x41c>
    237e:	88 c0       	rjmp	.+272    	; 0x2490 <__vector_9+0x52c>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].start)){
            motor[i].desiredPosition = motor[i].actualPosition;
            motor[i].isMoving = 0;
          }
          else{
            outputStep |= (1 << (2*i));
    2380:	81 e0       	ldi	r24, 0x01	; 1
    2382:	90 e0       	ldi	r25, 0x00	; 0
    2384:	0d 8c       	ldd	r0, Y+29	; 0x1d
    2386:	02 c0       	rjmp	.+4      	; 0x238c <__vector_9+0x428>
    2388:	88 0f       	add	r24, r24
    238a:	99 1f       	adc	r25, r25
    238c:	0a 94       	dec	r0
    238e:	e2 f7       	brpl	.-8      	; 0x2388 <__vector_9+0x424>
    2390:	ff 8d       	ldd	r31, Y+31	; 0x1f
    2392:	f8 2b       	or	r31, r24
    2394:	ff 8f       	std	Y+31, r31	; 0x1f
          }
        }
        /* so we will move and therefore set back the delay counter */
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    2396:	f1 01       	movw	r30, r2
    2398:	ee 0f       	add	r30, r30
    239a:	ff 1f       	adc	r31, r31
    239c:	ee 0f       	add	r30, r30
    239e:	ff 1f       	adc	r31, r31
    23a0:	e2 0d       	add	r30, r2
    23a2:	f3 1d       	adc	r31, r3
    23a4:	e0 51       	subi	r30, 0x10	; 16
    23a6:	fc 4f       	sbci	r31, 0xFC	; 252
    23a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    23aa:	97 8d       	ldd	r25, Z+31	; 0x1f
    23ac:	88 0f       	add	r24, r24
    23ae:	99 1f       	adc	r25, r25
    23b0:	01 97       	sbiw	r24, 0x01	; 1
    23b2:	91 a3       	std	Z+33, r25	; 0x21
    23b4:	80 a3       	std	Z+32, r24	; 0x20
    23b6:	b3 ce       	rjmp	.-666    	; 0x211e <__vector_9+0x1ba>
        motor[i].actualPosition++;
        if(motor[i].isMovingInfinite){
          motor[i].desiredPosition += 1;
        }
      }
      else if(stepDiff[i] < 0){
    23b8:	89 2b       	or	r24, r25
    23ba:	09 f4       	brne	.+2      	; 0x23be <__vector_9+0x45a>
    23bc:	87 cf       	rjmp	.-242    	; 0x22cc <__vector_9+0x368>
      /* check if we got one full rotation */
        if(((motor[i].actualPosition) - 1) < 0){
    23be:	f6 01       	movw	r30, r12
    23c0:	ee 0f       	add	r30, r30
    23c2:	ff 1f       	adc	r31, r31
    23c4:	ee 0f       	add	r30, r30
    23c6:	ff 1f       	adc	r31, r31
    23c8:	ee 0f       	add	r30, r30
    23ca:	ff 1f       	adc	r31, r31
    23cc:	cf 01       	movw	r24, r30
    23ce:	88 0f       	add	r24, r24
    23d0:	99 1f       	adc	r25, r25
    23d2:	88 0f       	add	r24, r24
    23d4:	99 1f       	adc	r25, r25
    23d6:	e8 0f       	add	r30, r24
    23d8:	f9 1f       	adc	r31, r25
    23da:	e0 51       	subi	r30, 0x10	; 16
    23dc:	fc 4f       	sbci	r31, 0xFC	; 252
    23de:	80 81       	ld	r24, Z
    23e0:	91 81       	ldd	r25, Z+1	; 0x01
    23e2:	18 16       	cp	r1, r24
    23e4:	19 06       	cpc	r1, r25
    23e6:	0c f0       	brlt	.+2      	; 0x23ea <__vector_9+0x486>
    23e8:	fd c0       	rjmp	.+506    	; 0x25e4 <__vector_9+0x680>
          /* so set back to max steps per round */
          motor[i].actualPosition = (int16_t)round(stepsPerFullRotation[i]);
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition--;
    23ea:	ee 2d       	mov	r30, r14
    23ec:	f5 2d       	mov	r31, r5
    23ee:	ee 0f       	add	r30, r30
    23f0:	ff 1f       	adc	r31, r31
    23f2:	ee 0f       	add	r30, r30
    23f4:	ff 1f       	adc	r31, r31
    23f6:	ee 0f       	add	r30, r30
    23f8:	ff 1f       	adc	r31, r31
    23fa:	cf 01       	movw	r24, r30
    23fc:	88 0f       	add	r24, r24
    23fe:	99 1f       	adc	r25, r25
    2400:	88 0f       	add	r24, r24
    2402:	99 1f       	adc	r25, r25
    2404:	e8 0f       	add	r30, r24
    2406:	f9 1f       	adc	r31, r25
    2408:	e0 51       	subi	r30, 0x10	; 16
    240a:	fc 4f       	sbci	r31, 0xFC	; 252
    240c:	20 81       	ld	r18, Z
    240e:	31 81       	ldd	r19, Z+1	; 0x01
    2410:	21 50       	subi	r18, 0x01	; 1
    2412:	30 40       	sbci	r19, 0x00	; 0
    2414:	ee 2d       	mov	r30, r14
    2416:	f5 2d       	mov	r31, r5
    2418:	ee 0f       	add	r30, r30
    241a:	ff 1f       	adc	r31, r31
    241c:	ee 0f       	add	r30, r30
    241e:	ff 1f       	adc	r31, r31
    2420:	ee 0f       	add	r30, r30
    2422:	ff 1f       	adc	r31, r31
    2424:	cf 01       	movw	r24, r30
    2426:	88 0f       	add	r24, r24
    2428:	99 1f       	adc	r25, r25
    242a:	88 0f       	add	r24, r24
    242c:	99 1f       	adc	r25, r25
    242e:	e8 0f       	add	r30, r24
    2430:	f9 1f       	adc	r31, r25
    2432:	e0 51       	subi	r30, 0x10	; 16
    2434:	fc 4f       	sbci	r31, 0xFC	; 252
    2436:	31 83       	std	Z+1, r19	; 0x01
    2438:	20 83       	st	Z, r18
        if(motor[i].isMovingInfinite){
    243a:	ee 2d       	mov	r30, r14
    243c:	f5 2d       	mov	r31, r5
    243e:	ee 0f       	add	r30, r30
    2440:	ff 1f       	adc	r31, r31
    2442:	ee 0f       	add	r30, r30
    2444:	ff 1f       	adc	r31, r31
    2446:	ee 0f       	add	r30, r30
    2448:	ff 1f       	adc	r31, r31
    244a:	cf 01       	movw	r24, r30
    244c:	88 0f       	add	r24, r24
    244e:	99 1f       	adc	r25, r25
    2450:	88 0f       	add	r24, r24
    2452:	99 1f       	adc	r25, r25
    2454:	e8 0f       	add	r30, r24
    2456:	f9 1f       	adc	r31, r25
    2458:	e0 51       	subi	r30, 0x10	; 16
    245a:	fc 4f       	sbci	r31, 0xFC	; 252
    245c:	84 85       	ldd	r24, Z+12	; 0x0c
    245e:	88 23       	and	r24, r24
    2460:	09 f4       	brne	.+2      	; 0x2464 <__vector_9+0x500>
    2462:	34 cf       	rjmp	.-408    	; 0x22cc <__vector_9+0x368>
          motor[i].desiredPosition += -1;
    2464:	ee 2d       	mov	r30, r14
    2466:	f5 2d       	mov	r31, r5
    2468:	ee 0f       	add	r30, r30
    246a:	ff 1f       	adc	r31, r31
    246c:	ee 0f       	add	r30, r30
    246e:	ff 1f       	adc	r31, r31
    2470:	cf 01       	movw	r24, r30
    2472:	88 0f       	add	r24, r24
    2474:	99 1f       	adc	r25, r25
    2476:	88 0f       	add	r24, r24
    2478:	99 1f       	adc	r25, r25
    247a:	e8 0f       	add	r30, r24
    247c:	f9 1f       	adc	r31, r25
    247e:	ee 0f       	add	r30, r30
    2480:	ff 1f       	adc	r31, r31
    2482:	ee 50       	subi	r30, 0x0E	; 14
    2484:	fc 4f       	sbci	r31, 0xFC	; 252
    2486:	20 81       	ld	r18, Z
    2488:	31 81       	ldd	r19, Z+1	; 0x01
    248a:	21 50       	subi	r18, 0x01	; 1
    248c:	30 40       	sbci	r19, 0x00	; 0
    248e:	0b cf       	rjmp	.-490    	; 0x22a6 <__vector_9+0x342>
          }
        }
        else{
          /* moving CW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    2490:	d6 01       	movw	r26, r12
    2492:	8d 91       	ld	r24, X+
    2494:	9c 91       	ld	r25, X
    2496:	11 97       	sbiw	r26, 0x01	; 1
    2498:	20 81       	ld	r18, Z
    249a:	31 81       	ldd	r19, Z+1	; 0x01
    249c:	01 96       	adiw	r24, 0x01	; 1
    249e:	82 17       	cp	r24, r18
    24a0:	93 07       	cpc	r25, r19
    24a2:	09 f0       	breq	.+2      	; 0x24a6 <__vector_9+0x542>
    24a4:	6d cf       	rjmp	.-294    	; 0x2380 <__vector_9+0x41c>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].start)){
            motor[i].desiredPosition = motor[i].actualPosition;
    24a6:	8d 91       	ld	r24, X+
    24a8:	9c 91       	ld	r25, X
    24aa:	11 97       	sbiw	r26, 0x01	; 1
    24ac:	f4 01       	movw	r30, r8
    24ae:	91 83       	std	Z+1, r25	; 0x01
    24b0:	80 83       	st	Z, r24
            motor[i].isMoving = 0;
    24b2:	1a 96       	adiw	r26, 0x0a	; 10
    24b4:	1c 92       	st	X, r1
    24b6:	6f cf       	rjmp	.-290    	; 0x2396 <__vector_9+0x432>
    if(motor[i].isMoving){
      if(stepDiff[i] > 0){
        /* check if we got one full rotation */
        if(((motor[i].actualPosition) + 1) > stepsPerFullRotation[i]){
          /* so set back to 0 */
          motor[i].actualPosition = 0;
    24b8:	f6 01       	movw	r30, r12
    24ba:	ee 0f       	add	r30, r30
    24bc:	ff 1f       	adc	r31, r31
    24be:	ee 0f       	add	r30, r30
    24c0:	ff 1f       	adc	r31, r31
    24c2:	ee 0f       	add	r30, r30
    24c4:	ff 1f       	adc	r31, r31
    24c6:	cf 01       	movw	r24, r30
    24c8:	88 0f       	add	r24, r24
    24ca:	99 1f       	adc	r25, r25
    24cc:	88 0f       	add	r24, r24
    24ce:	99 1f       	adc	r25, r25
    24d0:	e8 0f       	add	r30, r24
    24d2:	f9 1f       	adc	r31, r25
    24d4:	e0 51       	subi	r30, 0x10	; 16
    24d6:	fc 4f       	sbci	r31, 0xFC	; 252
    24d8:	11 82       	std	Z+1, r1	; 0x01
    24da:	10 82       	st	Z, r1
          /* correct desired motor position */
          motor[i].desiredPosition -= (int16_t)round(stepsPerFullRotation[i]);
    24dc:	f6 01       	movw	r30, r12
    24de:	ee 0f       	add	r30, r30
    24e0:	ff 1f       	adc	r31, r31
    24e2:	ee 0f       	add	r30, r30
    24e4:	ff 1f       	adc	r31, r31
    24e6:	cf 01       	movw	r24, r30
    24e8:	88 0f       	add	r24, r24
    24ea:	99 1f       	adc	r25, r25
    24ec:	88 0f       	add	r24, r24
    24ee:	99 1f       	adc	r25, r25
    24f0:	e8 0f       	add	r30, r24
    24f2:	f9 1f       	adc	r31, r25
    24f4:	ee 0f       	add	r30, r30
    24f6:	ff 1f       	adc	r31, r31
    24f8:	ee 50       	subi	r30, 0x0E	; 14
    24fa:	fc 4f       	sbci	r31, 0xFC	; 252
    24fc:	00 81       	ld	r16, Z
    24fe:	11 81       	ldd	r17, Z+1	; 0x01
    2500:	c5 01       	movw	r24, r10
    2502:	b4 01       	movw	r22, r8
    2504:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    2508:	0e 94 30 40 	call	0x8060	; 0x8060 <__fixsfsi>
    250c:	06 1b       	sub	r16, r22
    250e:	17 0b       	sbc	r17, r23
    2510:	f6 01       	movw	r30, r12
    2512:	ee 0f       	add	r30, r30
    2514:	ff 1f       	adc	r31, r31
    2516:	ee 0f       	add	r30, r30
    2518:	ff 1f       	adc	r31, r31
    251a:	cf 01       	movw	r24, r30
    251c:	88 0f       	add	r24, r24
    251e:	99 1f       	adc	r25, r25
    2520:	88 0f       	add	r24, r24
    2522:	99 1f       	adc	r25, r25
    2524:	e8 0f       	add	r30, r24
    2526:	f9 1f       	adc	r31, r25
    2528:	ee 0f       	add	r30, r30
    252a:	ff 1f       	adc	r31, r31
    252c:	ee 50       	subi	r30, 0x0E	; 14
    252e:	fc 4f       	sbci	r31, 0xFC	; 252
    2530:	11 83       	std	Z+1, r17	; 0x01
    2532:	00 83       	st	Z, r16
    2534:	67 ce       	rjmp	.-818    	; 0x2204 <__vector_9+0x2a0>
        if(motor[i].stepError > 1.0f){
          motor[i].desiredPosition += 1;
          motor[i].stepError -= 1.0f;
        }
        if(motor[i].stepError < -1.0f){
          motor[i].desiredPosition += -1;
    2536:	f2 01       	movw	r30, r4
    2538:	ee 0f       	add	r30, r30
    253a:	ff 1f       	adc	r31, r31
    253c:	ee 0f       	add	r30, r30
    253e:	ff 1f       	adc	r31, r31
    2540:	e4 0d       	add	r30, r4
    2542:	f5 1d       	adc	r31, r5
    2544:	ee 0f       	add	r30, r30
    2546:	ff 1f       	adc	r31, r31
    2548:	ee 50       	subi	r30, 0x0E	; 14
    254a:	fc 4f       	sbci	r31, 0xFC	; 252
    254c:	80 81       	ld	r24, Z
    254e:	91 81       	ldd	r25, Z+1	; 0x01
    2550:	01 97       	sbiw	r24, 0x01	; 1
    2552:	91 83       	std	Z+1, r25	; 0x01
    2554:	80 83       	st	Z, r24
          motor[i].stepError += 1.0f;
    2556:	f6 01       	movw	r30, r12
    2558:	66 81       	ldd	r22, Z+6	; 0x06
    255a:	77 81       	ldd	r23, Z+7	; 0x07
    255c:	80 85       	ldd	r24, Z+8	; 0x08
    255e:	91 85       	ldd	r25, Z+9	; 0x09
    2560:	20 e0       	ldi	r18, 0x00	; 0
    2562:	30 e0       	ldi	r19, 0x00	; 0
    2564:	40 e8       	ldi	r20, 0x80	; 128
    2566:	5f e3       	ldi	r21, 0x3F	; 63
    2568:	0e 94 60 3f 	call	0x7ec0	; 0x7ec0 <__addsf3>
    256c:	d6 01       	movw	r26, r12
    256e:	16 96       	adiw	r26, 0x06	; 6
    2570:	6d 93       	st	X+, r22
    2572:	7d 93       	st	X+, r23
    2574:	8d 93       	st	X+, r24
    2576:	9c 93       	st	X, r25
    2578:	19 97       	sbiw	r26, 0x09	; 9
    257a:	d1 cd       	rjmp	.-1118   	; 0x211e <__vector_9+0x1ba>
        motor[i].isMoving = 1;

        if(stepDiff[i] < 0){
          /* moving CCW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    257c:	f2 01       	movw	r30, r4
    257e:	e6 0d       	add	r30, r6
    2580:	f7 1d       	adc	r31, r7
    2582:	ed 52       	subi	r30, 0x2D	; 45
    2584:	fc 4f       	sbci	r31, 0xFC	; 252
    2586:	84 81       	ldd	r24, Z+4	; 0x04
    2588:	88 23       	and	r24, r24
    258a:	09 f5       	brne	.+66     	; 0x25ce <__vector_9+0x66a>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].stop)){
            motor[i].desiredPosition = motor[i].actualPosition;
            motor[i].isMoving = 0;
          }
          else{
            outputDir  |= (1 << (2*i + 1)); /* 1 = CCW, 0 = CW */
    258c:	2d 8d       	ldd	r18, Y+29	; 0x1d
    258e:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2590:	2f 5f       	subi	r18, 0xFF	; 255
    2592:	3f 4f       	sbci	r19, 0xFF	; 255
    2594:	3e 8f       	std	Y+30, r19	; 0x1e
    2596:	2d 8f       	std	Y+29, r18	; 0x1d
    2598:	81 e0       	ldi	r24, 0x01	; 1
    259a:	90 e0       	ldi	r25, 0x00	; 0
    259c:	0d 8c       	ldd	r0, Y+29	; 0x1d
    259e:	02 c0       	rjmp	.+4      	; 0x25a4 <__vector_9+0x640>
    25a0:	88 0f       	add	r24, r24
    25a2:	99 1f       	adc	r25, r25
    25a4:	0a 94       	dec	r0
    25a6:	e2 f7       	brpl	.-8      	; 0x25a0 <__vector_9+0x63c>
    25a8:	21 50       	subi	r18, 0x01	; 1
    25aa:	30 40       	sbci	r19, 0x00	; 0
    25ac:	3e 8f       	std	Y+30, r19	; 0x1e
    25ae:	2d 8f       	std	Y+29, r18	; 0x1d
    25b0:	38 a1       	ldd	r19, Y+32	; 0x20
    25b2:	38 2b       	or	r19, r24
    25b4:	38 a3       	std	Y+32, r19	; 0x20
            outputStep |= (1 << (2*i));
    25b6:	81 e0       	ldi	r24, 0x01	; 1
    25b8:	90 e0       	ldi	r25, 0x00	; 0
    25ba:	0d 8c       	ldd	r0, Y+29	; 0x1d
    25bc:	02 c0       	rjmp	.+4      	; 0x25c2 <__vector_9+0x65e>
    25be:	88 0f       	add	r24, r24
    25c0:	99 1f       	adc	r25, r25
    25c2:	0a 94       	dec	r0
    25c4:	e2 f7       	brpl	.-8      	; 0x25be <__vector_9+0x65a>
    25c6:	af 8d       	ldd	r26, Y+31	; 0x1f
    25c8:	a8 2b       	or	r26, r24
    25ca:	af 8f       	std	Y+31, r26	; 0x1f
    25cc:	e4 ce       	rjmp	.-568    	; 0x2396 <__vector_9+0x432>
        motor[i].isMoving = 1;

        if(stepDiff[i] < 0){
          /* moving CCW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    25ce:	d6 01       	movw	r26, r12
    25d0:	8d 91       	ld	r24, X+
    25d2:	9c 91       	ld	r25, X
    25d4:	11 97       	sbiw	r26, 0x01	; 1
    25d6:	22 81       	ldd	r18, Z+2	; 0x02
    25d8:	33 81       	ldd	r19, Z+3	; 0x03
    25da:	01 96       	adiw	r24, 0x01	; 1
    25dc:	82 17       	cp	r24, r18
    25de:	93 07       	cpc	r25, r19
    25e0:	a9 f6       	brne	.-86     	; 0x258c <__vector_9+0x628>
    25e2:	61 cf       	rjmp	.-318    	; 0x24a6 <__vector_9+0x542>
      }
      else if(stepDiff[i] < 0){
      /* check if we got one full rotation */
        if(((motor[i].actualPosition) - 1) < 0){
          /* so set back to max steps per round */
          motor[i].actualPosition = (int16_t)round(stepsPerFullRotation[i]);
    25e4:	eb 8d       	ldd	r30, Y+27	; 0x1b
    25e6:	fc 8d       	ldd	r31, Y+28	; 0x1c
    25e8:	60 81       	ld	r22, Z
    25ea:	71 81       	ldd	r23, Z+1	; 0x01
    25ec:	82 81       	ldd	r24, Z+2	; 0x02
    25ee:	93 81       	ldd	r25, Z+3	; 0x03
    25f0:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    25f4:	0e 94 30 40 	call	0x8060	; 0x8060 <__fixsfsi>
    25f8:	ab 01       	movw	r20, r22
    25fa:	f6 01       	movw	r30, r12
    25fc:	ee 0f       	add	r30, r30
    25fe:	ff 1f       	adc	r31, r31
    2600:	ee 0f       	add	r30, r30
    2602:	ff 1f       	adc	r31, r31
    2604:	ee 0f       	add	r30, r30
    2606:	ff 1f       	adc	r31, r31
    2608:	9f 01       	movw	r18, r30
    260a:	22 0f       	add	r18, r18
    260c:	33 1f       	adc	r19, r19
    260e:	22 0f       	add	r18, r18
    2610:	33 1f       	adc	r19, r19
    2612:	e2 0f       	add	r30, r18
    2614:	f3 1f       	adc	r31, r19
    2616:	e0 51       	subi	r30, 0x10	; 16
    2618:	fc 4f       	sbci	r31, 0xFC	; 252
    261a:	71 83       	std	Z+1, r23	; 0x01
    261c:	60 83       	st	Z, r22
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
    261e:	f6 01       	movw	r30, r12
    2620:	ee 0f       	add	r30, r30
    2622:	ff 1f       	adc	r31, r31
    2624:	ee 0f       	add	r30, r30
    2626:	ff 1f       	adc	r31, r31
    2628:	cf 01       	movw	r24, r30
    262a:	88 0f       	add	r24, r24
    262c:	99 1f       	adc	r25, r25
    262e:	88 0f       	add	r24, r24
    2630:	99 1f       	adc	r25, r25
    2632:	e8 0f       	add	r30, r24
    2634:	f9 1f       	adc	r31, r25
    2636:	ee 0f       	add	r30, r30
    2638:	ff 1f       	adc	r31, r31
    263a:	ee 50       	subi	r30, 0x0E	; 14
    263c:	fc 4f       	sbci	r31, 0xFC	; 252
    263e:	80 81       	ld	r24, Z
    2640:	91 81       	ldd	r25, Z+1	; 0x01
    2642:	48 0f       	add	r20, r24
    2644:	59 1f       	adc	r21, r25
    2646:	f6 01       	movw	r30, r12
    2648:	ee 0f       	add	r30, r30
    264a:	ff 1f       	adc	r31, r31
    264c:	ee 0f       	add	r30, r30
    264e:	ff 1f       	adc	r31, r31
    2650:	cf 01       	movw	r24, r30
    2652:	88 0f       	add	r24, r24
    2654:	99 1f       	adc	r25, r25
    2656:	88 0f       	add	r24, r24
    2658:	99 1f       	adc	r25, r25
    265a:	e8 0f       	add	r30, r24
    265c:	f9 1f       	adc	r31, r25
    265e:	ee 0f       	add	r30, r30
    2660:	ff 1f       	adc	r31, r31
    2662:	ee 50       	subi	r30, 0x0E	; 14
    2664:	fc 4f       	sbci	r31, 0xFC	; 252
    2666:	51 83       	std	Z+1, r21	; 0x01
    2668:	40 83       	st	Z, r20
    266a:	bf ce       	rjmp	.-642    	; 0x23ea <__vector_9+0x486>

0000266c <radiansToSteps>:
}

/* ---------------------------------------------------------------------
   set desired motor position if unit is radian
 --------------------------------------------------------------------- */
void radiansToSteps(uint8_t mot, double rad, double multiply){
    266c:	2f 92       	push	r2
    266e:	3f 92       	push	r3
    2670:	4f 92       	push	r4
    2672:	5f 92       	push	r5
    2674:	6f 92       	push	r6
    2676:	7f 92       	push	r7
    2678:	8f 92       	push	r8
    267a:	9f 92       	push	r9
    267c:	bf 92       	push	r11
    267e:	cf 92       	push	r12
    2680:	df 92       	push	r13
    2682:	ef 92       	push	r14
    2684:	ff 92       	push	r15
    2686:	0f 93       	push	r16
    2688:	1f 93       	push	r17
    268a:	df 93       	push	r29
    268c:	cf 93       	push	r28
    268e:	00 d0       	rcall	.+0      	; 0x2690 <radiansToSteps+0x24>
    2690:	00 d0       	rcall	.+0      	; 0x2692 <radiansToSteps+0x26>
    2692:	cd b7       	in	r28, 0x3d	; 61
    2694:	de b7       	in	r29, 0x3e	; 62
    2696:	b8 2e       	mov	r11, r24

  double roundedSteps = 0.0f;

  roundedSteps = round(rad * multiply *
    2698:	cb 01       	movw	r24, r22
    269a:	ba 01       	movw	r22, r20
    269c:	a9 01       	movw	r20, r18
    269e:	98 01       	movw	r18, r16
    26a0:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    26a4:	69 83       	std	Y+1, r22	; 0x01
    26a6:	7a 83       	std	Y+2, r23	; 0x02
    26a8:	8b 83       	std	Y+3, r24	; 0x03
    26aa:	9c 83       	std	Y+4, r25	; 0x04
    26ac:	e0 ef       	ldi	r30, 0xF0	; 240
    26ae:	ce 2e       	mov	r12, r30
    26b0:	e3 e0       	ldi	r30, 0x03	; 3
    26b2:	de 2e       	mov	r13, r30
    26b4:	eb 2d       	mov	r30, r11
    26b6:	f0 e0       	ldi	r31, 0x00	; 0
    26b8:	ee 0f       	add	r30, r30
    26ba:	ff 1f       	adc	r31, r31
    26bc:	ee 0f       	add	r30, r30
    26be:	ff 1f       	adc	r31, r31
    26c0:	ee 0f       	add	r30, r30
    26c2:	ff 1f       	adc	r31, r31
    26c4:	cf 01       	movw	r24, r30
    26c6:	88 0f       	add	r24, r24
    26c8:	99 1f       	adc	r25, r25
    26ca:	88 0f       	add	r24, r24
    26cc:	99 1f       	adc	r25, r25
    26ce:	e8 0f       	add	r30, r24
    26d0:	f9 1f       	adc	r31, r25
    26d2:	ec 0d       	add	r30, r12
    26d4:	fd 1d       	adc	r31, r13
    26d6:	61 89       	ldd	r22, Z+17	; 0x11
    26d8:	72 89       	ldd	r23, Z+18	; 0x12
    26da:	83 89       	ldd	r24, Z+19	; 0x13
    26dc:	94 89       	ldd	r25, Z+20	; 0x14
    26de:	eb 2d       	mov	r30, r11
    26e0:	f0 e0       	ldi	r31, 0x00	; 0
    26e2:	ee 0f       	add	r30, r30
    26e4:	ff 1f       	adc	r31, r31
    26e6:	ee 0f       	add	r30, r30
    26e8:	ff 1f       	adc	r31, r31
    26ea:	ee 0f       	add	r30, r30
    26ec:	ff 1f       	adc	r31, r31
    26ee:	9f 01       	movw	r18, r30
    26f0:	22 0f       	add	r18, r18
    26f2:	33 1f       	adc	r19, r19
    26f4:	22 0f       	add	r18, r18
    26f6:	33 1f       	adc	r19, r19
    26f8:	e2 0f       	add	r30, r18
    26fa:	f3 1f       	adc	r31, r19
    26fc:	ec 0d       	add	r30, r12
    26fe:	fd 1d       	adc	r31, r13
    2700:	25 85       	ldd	r18, Z+13	; 0x0d
    2702:	36 85       	ldd	r19, Z+14	; 0x0e
    2704:	47 85       	ldd	r20, Z+15	; 0x0f
    2706:	50 89       	ldd	r21, Z+16	; 0x10
    2708:	eb 2d       	mov	r30, r11
    270a:	f0 e0       	ldi	r31, 0x00	; 0
    270c:	ee 0f       	add	r30, r30
    270e:	ff 1f       	adc	r31, r31
    2710:	ee 0f       	add	r30, r30
    2712:	ff 1f       	adc	r31, r31
    2714:	ee 0f       	add	r30, r30
    2716:	ff 1f       	adc	r31, r31
    2718:	df 01       	movw	r26, r30
    271a:	aa 0f       	add	r26, r26
    271c:	bb 1f       	adc	r27, r27
    271e:	aa 0f       	add	r26, r26
    2720:	bb 1f       	adc	r27, r27
    2722:	ea 0f       	add	r30, r26
    2724:	fb 1f       	adc	r31, r27
    2726:	ec 0d       	add	r30, r12
    2728:	fd 1d       	adc	r31, r13
    272a:	e5 88       	ldd	r14, Z+21	; 0x15
    272c:	f6 88       	ldd	r15, Z+22	; 0x16
    272e:	07 89       	ldd	r16, Z+23	; 0x17
    2730:	10 8d       	ldd	r17, Z+24	; 0x18
    2732:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2736:	a8 01       	movw	r20, r16
    2738:	97 01       	movw	r18, r14
    273a:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    273e:	20 e0       	ldi	r18, 0x00	; 0
    2740:	30 e0       	ldi	r19, 0x00	; 0
    2742:	40 e0       	ldi	r20, 0x00	; 0
    2744:	5f e3       	ldi	r21, 0x3F	; 63
    2746:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    274a:	9b 01       	movw	r18, r22
    274c:	ac 01       	movw	r20, r24
    274e:	69 81       	ldd	r22, Y+1	; 0x01
    2750:	7a 81       	ldd	r23, Y+2	; 0x02
    2752:	8b 81       	ldd	r24, Y+3	; 0x03
    2754:	9c 81       	ldd	r25, Y+4	; 0x04
    2756:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    275a:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    275e:	1b 01       	movw	r2, r22
    2760:	2c 01       	movw	r4, r24
          ((motor[mot].stepsPerFullRotation
           *motor[mot].gearRatio
           *motor[mot].subSteps)/(2.0f)));

  motor[mot].desiredPosition += (int16_t)roundedSteps;
    2762:	eb 2d       	mov	r30, r11
    2764:	f0 e0       	ldi	r31, 0x00	; 0
    2766:	ee 0f       	add	r30, r30
    2768:	ff 1f       	adc	r31, r31
    276a:	ee 0f       	add	r30, r30
    276c:	ff 1f       	adc	r31, r31
    276e:	cf 01       	movw	r24, r30
    2770:	88 0f       	add	r24, r24
    2772:	99 1f       	adc	r25, r25
    2774:	88 0f       	add	r24, r24
    2776:	99 1f       	adc	r25, r25
    2778:	e8 0f       	add	r30, r24
    277a:	f9 1f       	adc	r31, r25
    277c:	31 96       	adiw	r30, 0x01	; 1
    277e:	ee 0f       	add	r30, r30
    2780:	ff 1f       	adc	r31, r31
    2782:	ec 0d       	add	r30, r12
    2784:	fd 1d       	adc	r31, r13
    2786:	00 81       	ld	r16, Z
    2788:	11 81       	ldd	r17, Z+1	; 0x01
    278a:	c2 01       	movw	r24, r4
    278c:	b1 01       	movw	r22, r2
    278e:	0e 94 30 40 	call	0x8060	; 0x8060 <__fixsfsi>
    2792:	60 0f       	add	r22, r16
    2794:	71 1f       	adc	r23, r17
    2796:	eb 2d       	mov	r30, r11
    2798:	f0 e0       	ldi	r31, 0x00	; 0
    279a:	ee 0f       	add	r30, r30
    279c:	ff 1f       	adc	r31, r31
    279e:	ee 0f       	add	r30, r30
    27a0:	ff 1f       	adc	r31, r31
    27a2:	9f 01       	movw	r18, r30
    27a4:	22 0f       	add	r18, r18
    27a6:	33 1f       	adc	r19, r19
    27a8:	22 0f       	add	r18, r18
    27aa:	33 1f       	adc	r19, r19
    27ac:	e2 0f       	add	r30, r18
    27ae:	f3 1f       	adc	r31, r19
    27b0:	31 96       	adiw	r30, 0x01	; 1
    27b2:	ee 0f       	add	r30, r30
    27b4:	ff 1f       	adc	r31, r31
    27b6:	ec 0d       	add	r30, r12
    27b8:	fd 1d       	adc	r31, r13
    27ba:	71 83       	std	Z+1, r23	; 0x01
    27bc:	60 83       	st	Z, r22

  /* calculate rounding-error */
  motor[mot].stepError +=
    27be:	eb 2d       	mov	r30, r11
    27c0:	f0 e0       	ldi	r31, 0x00	; 0
    27c2:	ee 0f       	add	r30, r30
    27c4:	ff 1f       	adc	r31, r31
    27c6:	ee 0f       	add	r30, r30
    27c8:	ff 1f       	adc	r31, r31
    27ca:	ee 0f       	add	r30, r30
    27cc:	ff 1f       	adc	r31, r31
    27ce:	cf 01       	movw	r24, r30
    27d0:	88 0f       	add	r24, r24
    27d2:	99 1f       	adc	r25, r25
    27d4:	88 0f       	add	r24, r24
    27d6:	99 1f       	adc	r25, r25
    27d8:	e8 0f       	add	r30, r24
    27da:	f9 1f       	adc	r31, r25
    27dc:	ec 0d       	add	r30, r12
    27de:	fd 1d       	adc	r31, r13
    27e0:	66 80       	ldd	r6, Z+6	; 0x06
    27e2:	77 80       	ldd	r7, Z+7	; 0x07
    27e4:	80 84       	ldd	r8, Z+8	; 0x08
    27e6:	91 84       	ldd	r9, Z+9	; 0x09
    27e8:	eb 2d       	mov	r30, r11
    27ea:	f0 e0       	ldi	r31, 0x00	; 0
    27ec:	ee 0f       	add	r30, r30
    27ee:	ff 1f       	adc	r31, r31
    27f0:	ee 0f       	add	r30, r30
    27f2:	ff 1f       	adc	r31, r31
    27f4:	ee 0f       	add	r30, r30
    27f6:	ff 1f       	adc	r31, r31
    27f8:	cf 01       	movw	r24, r30
    27fa:	88 0f       	add	r24, r24
    27fc:	99 1f       	adc	r25, r25
    27fe:	88 0f       	add	r24, r24
    2800:	99 1f       	adc	r25, r25
    2802:	e8 0f       	add	r30, r24
    2804:	f9 1f       	adc	r31, r25
    2806:	ec 0d       	add	r30, r12
    2808:	fd 1d       	adc	r31, r13
    280a:	61 89       	ldd	r22, Z+17	; 0x11
    280c:	72 89       	ldd	r23, Z+18	; 0x12
    280e:	83 89       	ldd	r24, Z+19	; 0x13
    2810:	94 89       	ldd	r25, Z+20	; 0x14
    2812:	eb 2d       	mov	r30, r11
    2814:	f0 e0       	ldi	r31, 0x00	; 0
    2816:	ee 0f       	add	r30, r30
    2818:	ff 1f       	adc	r31, r31
    281a:	ee 0f       	add	r30, r30
    281c:	ff 1f       	adc	r31, r31
    281e:	ee 0f       	add	r30, r30
    2820:	ff 1f       	adc	r31, r31
    2822:	9f 01       	movw	r18, r30
    2824:	22 0f       	add	r18, r18
    2826:	33 1f       	adc	r19, r19
    2828:	22 0f       	add	r18, r18
    282a:	33 1f       	adc	r19, r19
    282c:	e2 0f       	add	r30, r18
    282e:	f3 1f       	adc	r31, r19
    2830:	ec 0d       	add	r30, r12
    2832:	fd 1d       	adc	r31, r13
    2834:	25 85       	ldd	r18, Z+13	; 0x0d
    2836:	36 85       	ldd	r19, Z+14	; 0x0e
    2838:	47 85       	ldd	r20, Z+15	; 0x0f
    283a:	50 89       	ldd	r21, Z+16	; 0x10
    283c:	eb 2d       	mov	r30, r11
    283e:	f0 e0       	ldi	r31, 0x00	; 0
    2840:	ee 0f       	add	r30, r30
    2842:	ff 1f       	adc	r31, r31
    2844:	ee 0f       	add	r30, r30
    2846:	ff 1f       	adc	r31, r31
    2848:	ee 0f       	add	r30, r30
    284a:	ff 1f       	adc	r31, r31
    284c:	df 01       	movw	r26, r30
    284e:	aa 0f       	add	r26, r26
    2850:	bb 1f       	adc	r27, r27
    2852:	aa 0f       	add	r26, r26
    2854:	bb 1f       	adc	r27, r27
    2856:	ea 0f       	add	r30, r26
    2858:	fb 1f       	adc	r31, r27
    285a:	ec 0d       	add	r30, r12
    285c:	fd 1d       	adc	r31, r13
    285e:	e5 88       	ldd	r14, Z+21	; 0x15
    2860:	f6 88       	ldd	r15, Z+22	; 0x16
    2862:	07 89       	ldd	r16, Z+23	; 0x17
    2864:	10 8d       	ldd	r17, Z+24	; 0x18
    2866:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    286a:	a8 01       	movw	r20, r16
    286c:	97 01       	movw	r18, r14
    286e:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	30 e0       	ldi	r19, 0x00	; 0
    2876:	40 e0       	ldi	r20, 0x00	; 0
    2878:	5f e3       	ldi	r21, 0x3F	; 63
    287a:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    287e:	9b 01       	movw	r18, r22
    2880:	ac 01       	movw	r20, r24
    2882:	69 81       	ldd	r22, Y+1	; 0x01
    2884:	7a 81       	ldd	r23, Y+2	; 0x02
    2886:	8b 81       	ldd	r24, Y+3	; 0x03
    2888:	9c 81       	ldd	r25, Y+4	; 0x04
    288a:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    288e:	a2 01       	movw	r20, r4
    2890:	91 01       	movw	r18, r2
    2892:	0e 94 5f 3f 	call	0x7ebe	; 0x7ebe <__subsf3>
    2896:	9b 01       	movw	r18, r22
    2898:	ac 01       	movw	r20, r24
    289a:	c4 01       	movw	r24, r8
    289c:	b3 01       	movw	r22, r6
    289e:	0e 94 60 3f 	call	0x7ec0	; 0x7ec0 <__addsf3>
    28a2:	2b 2d       	mov	r18, r11
    28a4:	30 e0       	ldi	r19, 0x00	; 0
    28a6:	22 0f       	add	r18, r18
    28a8:	33 1f       	adc	r19, r19
    28aa:	22 0f       	add	r18, r18
    28ac:	33 1f       	adc	r19, r19
    28ae:	22 0f       	add	r18, r18
    28b0:	33 1f       	adc	r19, r19
    28b2:	a9 01       	movw	r20, r18
    28b4:	44 0f       	add	r20, r20
    28b6:	55 1f       	adc	r21, r21
    28b8:	44 0f       	add	r20, r20
    28ba:	55 1f       	adc	r21, r21
    28bc:	24 0f       	add	r18, r20
    28be:	35 1f       	adc	r19, r21
    28c0:	c2 0e       	add	r12, r18
    28c2:	d3 1e       	adc	r13, r19
    28c4:	f6 01       	movw	r30, r12
    28c6:	66 83       	std	Z+6, r22	; 0x06
    28c8:	77 83       	std	Z+7, r23	; 0x07
    28ca:	80 87       	std	Z+8, r24	; 0x08
    28cc:	91 87       	std	Z+9, r25	; 0x09
       *motor[mot].gearRatio
       *motor[mot].subSteps)/(2.0f))
       - roundedSteps;

  return;
}
    28ce:	0f 90       	pop	r0
    28d0:	0f 90       	pop	r0
    28d2:	0f 90       	pop	r0
    28d4:	0f 90       	pop	r0
    28d6:	cf 91       	pop	r28
    28d8:	df 91       	pop	r29
    28da:	1f 91       	pop	r17
    28dc:	0f 91       	pop	r16
    28de:	ff 90       	pop	r15
    28e0:	ef 90       	pop	r14
    28e2:	df 90       	pop	r13
    28e4:	cf 90       	pop	r12
    28e6:	bf 90       	pop	r11
    28e8:	9f 90       	pop	r9
    28ea:	8f 90       	pop	r8
    28ec:	7f 90       	pop	r7
    28ee:	6f 90       	pop	r6
    28f0:	5f 90       	pop	r5
    28f2:	4f 90       	pop	r4
    28f4:	3f 90       	pop	r3
    28f6:	2f 90       	pop	r2
    28f8:	08 95       	ret

000028fa <degreeToSteps>:
}

/* ---------------------------------------------------------------------
   set desired motor position if unit is degree
 --------------------------------------------------------------------- */
void degreeToSteps(uint8_t mot, double degree, double multiply){
    28fa:	2f 92       	push	r2
    28fc:	3f 92       	push	r3
    28fe:	4f 92       	push	r4
    2900:	5f 92       	push	r5
    2902:	6f 92       	push	r6
    2904:	7f 92       	push	r7
    2906:	8f 92       	push	r8
    2908:	9f 92       	push	r9
    290a:	bf 92       	push	r11
    290c:	cf 92       	push	r12
    290e:	df 92       	push	r13
    2910:	ef 92       	push	r14
    2912:	ff 92       	push	r15
    2914:	0f 93       	push	r16
    2916:	1f 93       	push	r17
    2918:	df 93       	push	r29
    291a:	cf 93       	push	r28
    291c:	00 d0       	rcall	.+0      	; 0x291e <degreeToSteps+0x24>
    291e:	00 d0       	rcall	.+0      	; 0x2920 <degreeToSteps+0x26>
    2920:	cd b7       	in	r28, 0x3d	; 61
    2922:	de b7       	in	r29, 0x3e	; 62
    2924:	b8 2e       	mov	r11, r24

  double roundedSteps = 0.0;

  roundedSteps = round(degree * multiply *
    2926:	cb 01       	movw	r24, r22
    2928:	ba 01       	movw	r22, r20
    292a:	a9 01       	movw	r20, r18
    292c:	98 01       	movw	r18, r16
    292e:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2932:	69 83       	std	Y+1, r22	; 0x01
    2934:	7a 83       	std	Y+2, r23	; 0x02
    2936:	8b 83       	std	Y+3, r24	; 0x03
    2938:	9c 83       	std	Y+4, r25	; 0x04
    293a:	e0 ef       	ldi	r30, 0xF0	; 240
    293c:	ce 2e       	mov	r12, r30
    293e:	e3 e0       	ldi	r30, 0x03	; 3
    2940:	de 2e       	mov	r13, r30
    2942:	eb 2d       	mov	r30, r11
    2944:	f0 e0       	ldi	r31, 0x00	; 0
    2946:	ee 0f       	add	r30, r30
    2948:	ff 1f       	adc	r31, r31
    294a:	ee 0f       	add	r30, r30
    294c:	ff 1f       	adc	r31, r31
    294e:	ee 0f       	add	r30, r30
    2950:	ff 1f       	adc	r31, r31
    2952:	cf 01       	movw	r24, r30
    2954:	88 0f       	add	r24, r24
    2956:	99 1f       	adc	r25, r25
    2958:	88 0f       	add	r24, r24
    295a:	99 1f       	adc	r25, r25
    295c:	e8 0f       	add	r30, r24
    295e:	f9 1f       	adc	r31, r25
    2960:	ec 0d       	add	r30, r12
    2962:	fd 1d       	adc	r31, r13
    2964:	61 89       	ldd	r22, Z+17	; 0x11
    2966:	72 89       	ldd	r23, Z+18	; 0x12
    2968:	83 89       	ldd	r24, Z+19	; 0x13
    296a:	94 89       	ldd	r25, Z+20	; 0x14
    296c:	eb 2d       	mov	r30, r11
    296e:	f0 e0       	ldi	r31, 0x00	; 0
    2970:	ee 0f       	add	r30, r30
    2972:	ff 1f       	adc	r31, r31
    2974:	ee 0f       	add	r30, r30
    2976:	ff 1f       	adc	r31, r31
    2978:	ee 0f       	add	r30, r30
    297a:	ff 1f       	adc	r31, r31
    297c:	9f 01       	movw	r18, r30
    297e:	22 0f       	add	r18, r18
    2980:	33 1f       	adc	r19, r19
    2982:	22 0f       	add	r18, r18
    2984:	33 1f       	adc	r19, r19
    2986:	e2 0f       	add	r30, r18
    2988:	f3 1f       	adc	r31, r19
    298a:	ec 0d       	add	r30, r12
    298c:	fd 1d       	adc	r31, r13
    298e:	25 85       	ldd	r18, Z+13	; 0x0d
    2990:	36 85       	ldd	r19, Z+14	; 0x0e
    2992:	47 85       	ldd	r20, Z+15	; 0x0f
    2994:	50 89       	ldd	r21, Z+16	; 0x10
    2996:	eb 2d       	mov	r30, r11
    2998:	f0 e0       	ldi	r31, 0x00	; 0
    299a:	ee 0f       	add	r30, r30
    299c:	ff 1f       	adc	r31, r31
    299e:	ee 0f       	add	r30, r30
    29a0:	ff 1f       	adc	r31, r31
    29a2:	ee 0f       	add	r30, r30
    29a4:	ff 1f       	adc	r31, r31
    29a6:	df 01       	movw	r26, r30
    29a8:	aa 0f       	add	r26, r26
    29aa:	bb 1f       	adc	r27, r27
    29ac:	aa 0f       	add	r26, r26
    29ae:	bb 1f       	adc	r27, r27
    29b0:	ea 0f       	add	r30, r26
    29b2:	fb 1f       	adc	r31, r27
    29b4:	ec 0d       	add	r30, r12
    29b6:	fd 1d       	adc	r31, r13
    29b8:	e5 88       	ldd	r14, Z+21	; 0x15
    29ba:	f6 88       	ldd	r15, Z+22	; 0x16
    29bc:	07 89       	ldd	r16, Z+23	; 0x17
    29be:	10 8d       	ldd	r17, Z+24	; 0x18
    29c0:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    29c4:	a8 01       	movw	r20, r16
    29c6:	97 01       	movw	r18, r14
    29c8:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    29cc:	20 e0       	ldi	r18, 0x00	; 0
    29ce:	30 e0       	ldi	r19, 0x00	; 0
    29d0:	44 eb       	ldi	r20, 0xB4	; 180
    29d2:	53 e4       	ldi	r21, 0x43	; 67
    29d4:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>
    29d8:	9b 01       	movw	r18, r22
    29da:	ac 01       	movw	r20, r24
    29dc:	69 81       	ldd	r22, Y+1	; 0x01
    29de:	7a 81       	ldd	r23, Y+2	; 0x02
    29e0:	8b 81       	ldd	r24, Y+3	; 0x03
    29e2:	9c 81       	ldd	r25, Y+4	; 0x04
    29e4:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    29e8:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    29ec:	1b 01       	movw	r2, r22
    29ee:	2c 01       	movw	r4, r24
          ((motor[mot].stepsPerFullRotation
           *motor[mot].gearRatio
           *motor[mot].subSteps)/(360.0f)));

  motor[mot].desiredPosition += (int16_t)roundedSteps;
    29f0:	eb 2d       	mov	r30, r11
    29f2:	f0 e0       	ldi	r31, 0x00	; 0
    29f4:	ee 0f       	add	r30, r30
    29f6:	ff 1f       	adc	r31, r31
    29f8:	ee 0f       	add	r30, r30
    29fa:	ff 1f       	adc	r31, r31
    29fc:	cf 01       	movw	r24, r30
    29fe:	88 0f       	add	r24, r24
    2a00:	99 1f       	adc	r25, r25
    2a02:	88 0f       	add	r24, r24
    2a04:	99 1f       	adc	r25, r25
    2a06:	e8 0f       	add	r30, r24
    2a08:	f9 1f       	adc	r31, r25
    2a0a:	31 96       	adiw	r30, 0x01	; 1
    2a0c:	ee 0f       	add	r30, r30
    2a0e:	ff 1f       	adc	r31, r31
    2a10:	ec 0d       	add	r30, r12
    2a12:	fd 1d       	adc	r31, r13
    2a14:	00 81       	ld	r16, Z
    2a16:	11 81       	ldd	r17, Z+1	; 0x01
    2a18:	c2 01       	movw	r24, r4
    2a1a:	b1 01       	movw	r22, r2
    2a1c:	0e 94 30 40 	call	0x8060	; 0x8060 <__fixsfsi>
    2a20:	60 0f       	add	r22, r16
    2a22:	71 1f       	adc	r23, r17
    2a24:	eb 2d       	mov	r30, r11
    2a26:	f0 e0       	ldi	r31, 0x00	; 0
    2a28:	ee 0f       	add	r30, r30
    2a2a:	ff 1f       	adc	r31, r31
    2a2c:	ee 0f       	add	r30, r30
    2a2e:	ff 1f       	adc	r31, r31
    2a30:	9f 01       	movw	r18, r30
    2a32:	22 0f       	add	r18, r18
    2a34:	33 1f       	adc	r19, r19
    2a36:	22 0f       	add	r18, r18
    2a38:	33 1f       	adc	r19, r19
    2a3a:	e2 0f       	add	r30, r18
    2a3c:	f3 1f       	adc	r31, r19
    2a3e:	31 96       	adiw	r30, 0x01	; 1
    2a40:	ee 0f       	add	r30, r30
    2a42:	ff 1f       	adc	r31, r31
    2a44:	ec 0d       	add	r30, r12
    2a46:	fd 1d       	adc	r31, r13
    2a48:	71 83       	std	Z+1, r23	; 0x01
    2a4a:	60 83       	st	Z, r22

  /* calculate rounding-error */
  motor[mot].stepError +=
    2a4c:	eb 2d       	mov	r30, r11
    2a4e:	f0 e0       	ldi	r31, 0x00	; 0
    2a50:	ee 0f       	add	r30, r30
    2a52:	ff 1f       	adc	r31, r31
    2a54:	ee 0f       	add	r30, r30
    2a56:	ff 1f       	adc	r31, r31
    2a58:	ee 0f       	add	r30, r30
    2a5a:	ff 1f       	adc	r31, r31
    2a5c:	cf 01       	movw	r24, r30
    2a5e:	88 0f       	add	r24, r24
    2a60:	99 1f       	adc	r25, r25
    2a62:	88 0f       	add	r24, r24
    2a64:	99 1f       	adc	r25, r25
    2a66:	e8 0f       	add	r30, r24
    2a68:	f9 1f       	adc	r31, r25
    2a6a:	ec 0d       	add	r30, r12
    2a6c:	fd 1d       	adc	r31, r13
    2a6e:	66 80       	ldd	r6, Z+6	; 0x06
    2a70:	77 80       	ldd	r7, Z+7	; 0x07
    2a72:	80 84       	ldd	r8, Z+8	; 0x08
    2a74:	91 84       	ldd	r9, Z+9	; 0x09
    2a76:	eb 2d       	mov	r30, r11
    2a78:	f0 e0       	ldi	r31, 0x00	; 0
    2a7a:	ee 0f       	add	r30, r30
    2a7c:	ff 1f       	adc	r31, r31
    2a7e:	ee 0f       	add	r30, r30
    2a80:	ff 1f       	adc	r31, r31
    2a82:	ee 0f       	add	r30, r30
    2a84:	ff 1f       	adc	r31, r31
    2a86:	cf 01       	movw	r24, r30
    2a88:	88 0f       	add	r24, r24
    2a8a:	99 1f       	adc	r25, r25
    2a8c:	88 0f       	add	r24, r24
    2a8e:	99 1f       	adc	r25, r25
    2a90:	e8 0f       	add	r30, r24
    2a92:	f9 1f       	adc	r31, r25
    2a94:	ec 0d       	add	r30, r12
    2a96:	fd 1d       	adc	r31, r13
    2a98:	61 89       	ldd	r22, Z+17	; 0x11
    2a9a:	72 89       	ldd	r23, Z+18	; 0x12
    2a9c:	83 89       	ldd	r24, Z+19	; 0x13
    2a9e:	94 89       	ldd	r25, Z+20	; 0x14
    2aa0:	eb 2d       	mov	r30, r11
    2aa2:	f0 e0       	ldi	r31, 0x00	; 0
    2aa4:	ee 0f       	add	r30, r30
    2aa6:	ff 1f       	adc	r31, r31
    2aa8:	ee 0f       	add	r30, r30
    2aaa:	ff 1f       	adc	r31, r31
    2aac:	ee 0f       	add	r30, r30
    2aae:	ff 1f       	adc	r31, r31
    2ab0:	9f 01       	movw	r18, r30
    2ab2:	22 0f       	add	r18, r18
    2ab4:	33 1f       	adc	r19, r19
    2ab6:	22 0f       	add	r18, r18
    2ab8:	33 1f       	adc	r19, r19
    2aba:	e2 0f       	add	r30, r18
    2abc:	f3 1f       	adc	r31, r19
    2abe:	ec 0d       	add	r30, r12
    2ac0:	fd 1d       	adc	r31, r13
    2ac2:	25 85       	ldd	r18, Z+13	; 0x0d
    2ac4:	36 85       	ldd	r19, Z+14	; 0x0e
    2ac6:	47 85       	ldd	r20, Z+15	; 0x0f
    2ac8:	50 89       	ldd	r21, Z+16	; 0x10
    2aca:	eb 2d       	mov	r30, r11
    2acc:	f0 e0       	ldi	r31, 0x00	; 0
    2ace:	ee 0f       	add	r30, r30
    2ad0:	ff 1f       	adc	r31, r31
    2ad2:	ee 0f       	add	r30, r30
    2ad4:	ff 1f       	adc	r31, r31
    2ad6:	ee 0f       	add	r30, r30
    2ad8:	ff 1f       	adc	r31, r31
    2ada:	df 01       	movw	r26, r30
    2adc:	aa 0f       	add	r26, r26
    2ade:	bb 1f       	adc	r27, r27
    2ae0:	aa 0f       	add	r26, r26
    2ae2:	bb 1f       	adc	r27, r27
    2ae4:	ea 0f       	add	r30, r26
    2ae6:	fb 1f       	adc	r31, r27
    2ae8:	ec 0d       	add	r30, r12
    2aea:	fd 1d       	adc	r31, r13
    2aec:	e5 88       	ldd	r14, Z+21	; 0x15
    2aee:	f6 88       	ldd	r15, Z+22	; 0x16
    2af0:	07 89       	ldd	r16, Z+23	; 0x17
    2af2:	10 8d       	ldd	r17, Z+24	; 0x18
    2af4:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2af8:	a8 01       	movw	r20, r16
    2afa:	97 01       	movw	r18, r14
    2afc:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2b00:	20 e0       	ldi	r18, 0x00	; 0
    2b02:	30 e0       	ldi	r19, 0x00	; 0
    2b04:	44 eb       	ldi	r20, 0xB4	; 180
    2b06:	53 e4       	ldi	r21, 0x43	; 67
    2b08:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>
    2b0c:	9b 01       	movw	r18, r22
    2b0e:	ac 01       	movw	r20, r24
    2b10:	69 81       	ldd	r22, Y+1	; 0x01
    2b12:	7a 81       	ldd	r23, Y+2	; 0x02
    2b14:	8b 81       	ldd	r24, Y+3	; 0x03
    2b16:	9c 81       	ldd	r25, Y+4	; 0x04
    2b18:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2b1c:	a2 01       	movw	r20, r4
    2b1e:	91 01       	movw	r18, r2
    2b20:	0e 94 5f 3f 	call	0x7ebe	; 0x7ebe <__subsf3>
    2b24:	9b 01       	movw	r18, r22
    2b26:	ac 01       	movw	r20, r24
    2b28:	c4 01       	movw	r24, r8
    2b2a:	b3 01       	movw	r22, r6
    2b2c:	0e 94 60 3f 	call	0x7ec0	; 0x7ec0 <__addsf3>
    2b30:	2b 2d       	mov	r18, r11
    2b32:	30 e0       	ldi	r19, 0x00	; 0
    2b34:	22 0f       	add	r18, r18
    2b36:	33 1f       	adc	r19, r19
    2b38:	22 0f       	add	r18, r18
    2b3a:	33 1f       	adc	r19, r19
    2b3c:	22 0f       	add	r18, r18
    2b3e:	33 1f       	adc	r19, r19
    2b40:	a9 01       	movw	r20, r18
    2b42:	44 0f       	add	r20, r20
    2b44:	55 1f       	adc	r21, r21
    2b46:	44 0f       	add	r20, r20
    2b48:	55 1f       	adc	r21, r21
    2b4a:	24 0f       	add	r18, r20
    2b4c:	35 1f       	adc	r19, r21
    2b4e:	c2 0e       	add	r12, r18
    2b50:	d3 1e       	adc	r13, r19
    2b52:	f6 01       	movw	r30, r12
    2b54:	66 83       	std	Z+6, r22	; 0x06
    2b56:	77 83       	std	Z+7, r23	; 0x07
    2b58:	80 87       	std	Z+8, r24	; 0x08
    2b5a:	91 87       	std	Z+9, r25	; 0x09
       *motor[mot].gearRatio
       *motor[mot].subSteps)/(360.0f))
       - roundedSteps;

  return;
}
    2b5c:	0f 90       	pop	r0
    2b5e:	0f 90       	pop	r0
    2b60:	0f 90       	pop	r0
    2b62:	0f 90       	pop	r0
    2b64:	cf 91       	pop	r28
    2b66:	df 91       	pop	r29
    2b68:	1f 91       	pop	r17
    2b6a:	0f 91       	pop	r16
    2b6c:	ff 90       	pop	r15
    2b6e:	ef 90       	pop	r14
    2b70:	df 90       	pop	r13
    2b72:	cf 90       	pop	r12
    2b74:	bf 90       	pop	r11
    2b76:	9f 90       	pop	r9
    2b78:	8f 90       	pop	r8
    2b7a:	7f 90       	pop	r7
    2b7c:	6f 90       	pop	r6
    2b7e:	5f 90       	pop	r5
    2b80:	4f 90       	pop	r4
    2b82:	3f 90       	pop	r3
    2b84:	2f 90       	pop	r2
    2b86:	08 95       	ret

00002b88 <motorZeroRun>:
/* ---------------------------------------------------------------------
    zero run: position calibration for the motor.
    After zero run motor will have the fast axis position of any
    wave plate.
 --------------------------------------------------------------------- */
void motorZeroRun(uint8_t i){
    2b88:	2f 92       	push	r2
    2b8a:	3f 92       	push	r3
    2b8c:	4f 92       	push	r4
    2b8e:	5f 92       	push	r5
    2b90:	6f 92       	push	r6
    2b92:	7f 92       	push	r7
    2b94:	8f 92       	push	r8
    2b96:	9f 92       	push	r9
    2b98:	bf 92       	push	r11
    2b9a:	cf 92       	push	r12
    2b9c:	df 92       	push	r13
    2b9e:	ef 92       	push	r14
    2ba0:	ff 92       	push	r15
    2ba2:	0f 93       	push	r16
    2ba4:	1f 93       	push	r17
    2ba6:	cf 93       	push	r28
    2ba8:	df 93       	push	r29
    2baa:	b8 2e       	mov	r11, r24
  uint16_t keepWaitTime = 0;
  double stepsPerRound = 0.0f;
  //uint16_t thres = 50;  /* threshold for the ADC reading of the Hall sensor */
  uint16_t j = 0;

  if(forbiddenZone[i].active){
    2bac:	88 2e       	mov	r8, r24
    2bae:	99 24       	eor	r9, r9
    2bb0:	24 01       	movw	r4, r8
    2bb2:	44 0c       	add	r4, r4
    2bb4:	55 1c       	adc	r5, r5
    2bb6:	44 0c       	add	r4, r4
    2bb8:	55 1c       	adc	r5, r5
    2bba:	f2 01       	movw	r30, r4
    2bbc:	e8 0d       	add	r30, r8
    2bbe:	f9 1d       	adc	r31, r9
    2bc0:	ed 52       	subi	r30, 0x2D	; 45
    2bc2:	fc 4f       	sbci	r31, 0xFC	; 252
    2bc4:	84 81       	ldd	r24, Z+4	; 0x04
    2bc6:	88 23       	and	r24, r24
    2bc8:	09 f0       	breq	.+2      	; 0x2bcc <motorZeroRun+0x44>
    2bca:	c8 c0       	rjmp	.+400    	; 0x2d5c <motorZeroRun+0x1d4>
    /* zerorun not allowed if forbidden zone is active */
    return;
  }

  /* stop any motor movements (stop timer/counter2) */
  TCCR2B &= ~0x07;
    2bcc:	80 91 b1 00 	lds	r24, 0x00B1
    2bd0:	88 7f       	andi	r24, 0xF8	; 248
    2bd2:	80 93 b1 00 	sts	0x00B1, r24

  keepWaitTime = motor[i].waitBetweenSteps;
    2bd6:	34 01       	movw	r6, r8
    2bd8:	66 0c       	add	r6, r6
    2bda:	77 1c       	adc	r7, r7
    2bdc:	66 0c       	add	r6, r6
    2bde:	77 1c       	adc	r7, r7
    2be0:	66 0c       	add	r6, r6
    2be2:	77 1c       	adc	r7, r7
    2be4:	83 01       	movw	r16, r6
    2be6:	00 0f       	add	r16, r16
    2be8:	11 1f       	adc	r17, r17
    2bea:	00 0f       	add	r16, r16
    2bec:	11 1f       	adc	r17, r17
    2bee:	06 0d       	add	r16, r6
    2bf0:	17 1d       	adc	r17, r7
    2bf2:	00 51       	subi	r16, 0x10	; 16
    2bf4:	1c 4f       	sbci	r17, 0xFC	; 252
    2bf6:	f8 01       	movw	r30, r16
    2bf8:	26 8c       	ldd	r2, Z+30	; 0x1e
    2bfa:	37 8c       	ldd	r3, Z+31	; 0x1f

  stepsPerRound = motor[i].stepsPerFullRotation
    2bfc:	61 89       	ldd	r22, Z+17	; 0x11
    2bfe:	72 89       	ldd	r23, Z+18	; 0x12
    2c00:	83 89       	ldd	r24, Z+19	; 0x13
    2c02:	94 89       	ldd	r25, Z+20	; 0x14
    2c04:	25 85       	ldd	r18, Z+13	; 0x0d
    2c06:	36 85       	ldd	r19, Z+14	; 0x0e
    2c08:	47 85       	ldd	r20, Z+15	; 0x0f
    2c0a:	50 89       	ldd	r21, Z+16	; 0x10
    2c0c:	c5 88       	ldd	r12, Z+21	; 0x15
    2c0e:	d6 88       	ldd	r13, Z+22	; 0x16
    2c10:	e7 88       	ldd	r14, Z+23	; 0x17
    2c12:	f0 8c       	ldd	r15, Z+24	; 0x18
    2c14:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2c18:	a7 01       	movw	r20, r14
    2c1a:	96 01       	movw	r18, r12
    2c1c:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2c20:	6b 01       	movw	r12, r22
    2c22:	7c 01       	movw	r14, r24
                  * motor[i].subSteps;

  /* fist step:
   * move 360 degree to find the roughly position of the magnetic zero point.
   * this will be done with fast moving */
  motor[i].waitBetweenSteps = 1;    /* set 1 ms for fast moving */
    2c24:	81 e0       	ldi	r24, 0x01	; 1
    2c26:	90 e0       	ldi	r25, 0x00	; 0
    2c28:	f8 01       	movw	r30, r16
    2c2a:	97 8f       	std	Z+31, r25	; 0x1f
    2c2c:	86 8f       	std	Z+30, r24	; 0x1e
    2c2e:	05 c0       	rjmp	.+10     	; 0x2c3a <motorZeroRun+0xb2>

  /* in case we are at any possible zero position: move out */
  //while(getADCvalue(i) < thres){
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, -200);
    2c30:	8b 2d       	mov	r24, r11
    2c32:	68 e3       	ldi	r22, 0x38	; 56
    2c34:	7f ef       	ldi	r23, 0xFF	; 255
    2c36:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
   * this will be done with fast moving */
  motor[i].waitBetweenSteps = 1;    /* set 1 ms for fast moving */

  /* in case we are at any possible zero position: move out */
  //while(getADCvalue(i) < thres){
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    2c3a:	8b 2d       	mov	r24, r11
    2c3c:	64 e0       	ldi	r22, 0x04	; 4
    2c3e:	0e 94 77 0c 	call	0x18ee	; 0x18ee <getMotorSens>
    2c42:	88 23       	and	r24, r24
    2c44:	a9 f7       	brne	.-22     	; 0x2c30 <motorZeroRun+0xa8>
/* ---------------------------------------------------------------------
    zero run: position calibration for the motor.
    After zero run motor will have the fast axis position of any
    wave plate.
 --------------------------------------------------------------------- */
void motorZeroRun(uint8_t i){
    2c46:	c7 01       	movw	r24, r14
    2c48:	b6 01       	movw	r22, r12
    2c4a:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    2c4e:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
    2c52:	8b 01       	movw	r16, r22
    2c54:	c0 e0       	ldi	r28, 0x00	; 0
    2c56:	d0 e0       	ldi	r29, 0x00	; 0
    2c58:	0c c0       	rjmp	.+24     	; 0x2c72 <motorZeroRun+0xea>
    moveMotorRelative(i, -200);
  }

  /* start first search for zero point */
  for(j = 0; j < (uint16_t)round(stepsPerRound); j++){
    moveMotorRelative(i, 1);
    2c5a:	8b 2d       	mov	r24, r11
    2c5c:	61 e0       	ldi	r22, 0x01	; 1
    2c5e:	70 e0       	ldi	r23, 0x00	; 0
    2c60:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
    //if(getADCvalue(i) < thres){
	if(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    2c64:	8b 2d       	mov	r24, r11
    2c66:	64 e0       	ldi	r22, 0x04	; 4
    2c68:	0e 94 77 0c 	call	0x18ee	; 0x18ee <getMotorSens>
    2c6c:	88 23       	and	r24, r24
    2c6e:	21 f4       	brne	.+8      	; 0x2c78 <motorZeroRun+0xf0>
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, -200);
  }

  /* start first search for zero point */
  for(j = 0; j < (uint16_t)round(stepsPerRound); j++){
    2c70:	21 96       	adiw	r28, 0x01	; 1
    2c72:	c0 17       	cp	r28, r16
    2c74:	d1 07       	cpc	r29, r17
    2c76:	88 f3       	brcs	.-30     	; 0x2c5a <motorZeroRun+0xd2>
      break;
    }
  }

  /* move 90 degree forward */
  moveMotorRelative(i, (int16_t)round(0.25*stepsPerRound));
    2c78:	c7 01       	movw	r24, r14
    2c7a:	b6 01       	movw	r22, r12
    2c7c:	20 e0       	ldi	r18, 0x00	; 0
    2c7e:	30 e0       	ldi	r19, 0x00	; 0
    2c80:	40 e8       	ldi	r20, 0x80	; 128
    2c82:	5e e3       	ldi	r21, 0x3E	; 62
    2c84:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2c88:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    2c8c:	0e 94 30 40 	call	0x8060	; 0x8060 <__fixsfsi>
    2c90:	9b 01       	movw	r18, r22
    2c92:	ac 01       	movw	r20, r24
    2c94:	8b 2d       	mov	r24, r11
    2c96:	b9 01       	movw	r22, r18
    2c98:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
  /* second step:
   * move again to 200 steps before the former found zero position fast.
   * then move slowly to find the exact magnetic zero position. */

  /* now move till 200 steps before the zero-position */
  moveMotorRelative(i, (int16_t)round(0.75*stepsPerRound) - 200);
    2c9c:	c7 01       	movw	r24, r14
    2c9e:	b6 01       	movw	r22, r12
    2ca0:	20 e0       	ldi	r18, 0x00	; 0
    2ca2:	30 e0       	ldi	r19, 0x00	; 0
    2ca4:	40 e4       	ldi	r20, 0x40	; 64
    2ca6:	5f e3       	ldi	r21, 0x3F	; 63
    2ca8:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    2cac:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    2cb0:	0e 94 30 40 	call	0x8060	; 0x8060 <__fixsfsi>
    2cb4:	9b 01       	movw	r18, r22
    2cb6:	ac 01       	movw	r20, r24
    2cb8:	28 5c       	subi	r18, 0xC8	; 200
    2cba:	30 40       	sbci	r19, 0x00	; 0
    2cbc:	8b 2d       	mov	r24, r11
    2cbe:	b9 01       	movw	r22, r18
    2cc0:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>

  /* now get slow to find zero position precisely */
  motor[i].waitBetweenSteps = 5;
    2cc4:	f3 01       	movw	r30, r6
    2cc6:	ee 0f       	add	r30, r30
    2cc8:	ff 1f       	adc	r31, r31
    2cca:	ee 0f       	add	r30, r30
    2ccc:	ff 1f       	adc	r31, r31
    2cce:	e6 0d       	add	r30, r6
    2cd0:	f7 1d       	adc	r31, r7
    2cd2:	e0 51       	subi	r30, 0x10	; 16
    2cd4:	fc 4f       	sbci	r31, 0xFC	; 252
    2cd6:	85 e0       	ldi	r24, 0x05	; 5
    2cd8:	90 e0       	ldi	r25, 0x00	; 0
    2cda:	97 8f       	std	Z+31, r25	; 0x1f
    2cdc:	86 8f       	std	Z+30, r24	; 0x1e
    2cde:	05 c0       	rjmp	.+10     	; 0x2cea <motorZeroRun+0x162>

  /* and move till the threshold is reached */
  //while(getADCvalue(i) > thres){
  while(!getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, 1);
    2ce0:	8b 2d       	mov	r24, r11
    2ce2:	61 e0       	ldi	r22, 0x01	; 1
    2ce4:	70 e0       	ldi	r23, 0x00	; 0
    2ce6:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>
  /* now get slow to find zero position precisely */
  motor[i].waitBetweenSteps = 5;

  /* and move till the threshold is reached */
  //while(getADCvalue(i) > thres){
  while(!getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    2cea:	8b 2d       	mov	r24, r11
    2cec:	64 e0       	ldi	r22, 0x04	; 4
    2cee:	0e 94 77 0c 	call	0x18ee	; 0x18ee <getMotorSens>
    2cf2:	88 23       	and	r24, r24
    2cf4:	a9 f3       	breq	.-22     	; 0x2ce0 <motorZeroRun+0x158>
  }
  /* and here we found our magnetic zero position :-) */

  /* third step:
   * go to the internal saved optical zero position */
  motor[i].waitBetweenSteps = keepWaitTime;
    2cf6:	83 01       	movw	r16, r6
    2cf8:	00 0f       	add	r16, r16
    2cfa:	11 1f       	adc	r17, r17
    2cfc:	00 0f       	add	r16, r16
    2cfe:	11 1f       	adc	r17, r17
    2d00:	06 0d       	add	r16, r6
    2d02:	17 1d       	adc	r17, r7
    2d04:	00 51       	subi	r16, 0x10	; 16
    2d06:	1c 4f       	sbci	r17, 0xFC	; 252
    2d08:	f8 01       	movw	r30, r16
    2d0a:	37 8e       	std	Z+31, r3	; 0x1f
    2d0c:	26 8e       	std	Z+30, r2	; 0x1e
  moveMotorRelative(i, motor[i].opticalZeroPosition);
    2d0e:	88 0c       	add	r8, r8
    2d10:	99 1c       	adc	r9, r9
    2d12:	86 0c       	add	r8, r6
    2d14:	97 1c       	adc	r9, r7
    2d16:	88 0c       	add	r8, r8
    2d18:	99 1c       	adc	r9, r9
    2d1a:	88 0c       	add	r8, r8
    2d1c:	99 1c       	adc	r9, r9
    2d1e:	84 ef       	ldi	r24, 0xF4	; 244
    2d20:	93 e0       	ldi	r25, 0x03	; 3
    2d22:	88 0e       	add	r8, r24
    2d24:	99 1e       	adc	r9, r25
    2d26:	f4 01       	movw	r30, r8
    2d28:	60 81       	ld	r22, Z
    2d2a:	71 81       	ldd	r23, Z+1	; 0x01
    2d2c:	8b 2d       	mov	r24, r11
    2d2e:	0e 94 d8 05 	call	0xbb0	; 0xbb0 <moveMotorRelative>

  /* now set motor into a defined state */
  motor[i].actualPosition = 0;
    2d32:	f8 01       	movw	r30, r16
    2d34:	11 82       	std	Z+1, r1	; 0x01
    2d36:	10 82       	st	Z, r1
  motor[i].desiredPosition = 0;
    2d38:	f2 01       	movw	r30, r4
    2d3a:	ee 0f       	add	r30, r30
    2d3c:	ff 1f       	adc	r31, r31
    2d3e:	ee 0f       	add	r30, r30
    2d40:	ff 1f       	adc	r31, r31
    2d42:	e4 0d       	add	r30, r4
    2d44:	f5 1d       	adc	r31, r5
    2d46:	ee 0f       	add	r30, r30
    2d48:	ff 1f       	adc	r31, r31
    2d4a:	ee 50       	subi	r30, 0x0E	; 14
    2d4c:	fc 4f       	sbci	r31, 0xFC	; 252
    2d4e:	11 82       	std	Z+1, r1	; 0x01
    2d50:	10 82       	st	Z, r1

  resetMotorLogic(i);
    2d52:	8b 2d       	mov	r24, r11
    2d54:	0e 94 3d 0c 	call	0x187a	; 0x187a <resetMotorLogic>

  /* allow motor movements again */
  initMotorDelayTimer();
    2d58:	0e 94 c3 05 	call	0xb86	; 0xb86 <initMotorDelayTimer>

  return;
}
    2d5c:	df 91       	pop	r29
    2d5e:	cf 91       	pop	r28
    2d60:	1f 91       	pop	r17
    2d62:	0f 91       	pop	r16
    2d64:	ff 90       	pop	r15
    2d66:	ef 90       	pop	r14
    2d68:	df 90       	pop	r13
    2d6a:	cf 90       	pop	r12
    2d6c:	bf 90       	pop	r11
    2d6e:	9f 90       	pop	r9
    2d70:	8f 90       	pop	r8
    2d72:	7f 90       	pop	r7
    2d74:	6f 90       	pop	r6
    2d76:	5f 90       	pop	r5
    2d78:	4f 90       	pop	r4
    2d7a:	3f 90       	pop	r3
    2d7c:	2f 90       	pop	r2
    2d7e:	08 95       	ret

00002d80 <commandEnable>:
}

/* ---------------------------------------------------------------------
    enables/disables a motor
 --------------------------------------------------------------------- */
void commandEnable(char* param0, char* param1){
    2d80:	0f 93       	push	r16
    2d82:	df 93       	push	r29
    2d84:	cf 93       	push	r28
    2d86:	00 d0       	rcall	.+0      	; 0x2d88 <commandEnable+0x8>
    2d88:	cd b7       	in	r28, 0x3d	; 61
    2d8a:	de b7       	in	r29, 0x3e	; 62
    2d8c:	7a 83       	std	Y+2, r23	; 0x02
    2d8e:	69 83       	std	Y+1, r22	; 0x01

  uint8_t i   = 0;
  uint8_t val = 0;

  i   = (uint8_t)strtol(param0, (char **)NULL, 10);
    2d90:	60 e0       	ldi	r22, 0x00	; 0
    2d92:	70 e0       	ldi	r23, 0x00	; 0
    2d94:	4a e0       	ldi	r20, 0x0A	; 10
    2d96:	50 e0       	ldi	r21, 0x00	; 0
    2d98:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    2d9c:	06 2f       	mov	r16, r22
  val = (uint8_t)strtol(param1, (char **)NULL, 10);
    2d9e:	89 81       	ldd	r24, Y+1	; 0x01
    2da0:	9a 81       	ldd	r25, Y+2	; 0x02
    2da2:	60 e0       	ldi	r22, 0x00	; 0
    2da4:	70 e0       	ldi	r23, 0x00	; 0
    2da6:	4a e0       	ldi	r20, 0x0A	; 10
    2da8:	50 e0       	ldi	r21, 0x00	; 0
    2daa:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>



  if(i > MAX_MOTOR){
    2dae:	04 30       	cpi	r16, 0x04	; 4
    2db0:	30 f4       	brcc	.+12     	; 0x2dbe <commandEnable+0x3e>
    return;
  }
  else{
    if(val){
    2db2:	66 23       	and	r22, r22
    2db4:	51 f4       	brne	.+20     	; 0x2dca <commandEnable+0x4a>
      setMotorState(i, ON);
    }
    else{
      setMotorState(i, OFF);
    2db6:	80 2f       	mov	r24, r16
    2db8:	60 e0       	ldi	r22, 0x00	; 0
    2dba:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
      //sendChar('a');
    }
  }

  return;
}
    2dbe:	0f 90       	pop	r0
    2dc0:	0f 90       	pop	r0
    2dc2:	cf 91       	pop	r28
    2dc4:	df 91       	pop	r29
    2dc6:	0f 91       	pop	r16
    2dc8:	08 95       	ret
  if(i > MAX_MOTOR){
    return;
  }
  else{
    if(val){
      setMotorState(i, ON);
    2dca:	80 2f       	mov	r24, r16
    2dcc:	61 e0       	ldi	r22, 0x01	; 1
    2dce:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
      //sendChar('a');
    }
  }

  return;
}
    2dd2:	0f 90       	pop	r0
    2dd4:	0f 90       	pop	r0
    2dd6:	cf 91       	pop	r28
    2dd8:	df 91       	pop	r29
    2dda:	0f 91       	pop	r16
    2ddc:	08 95       	ret

00002dde <commandGetMotorDecay>:
 --------------------------------------------------------------------- */
char* commandGetMotorDecay(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2dde:	60 e0       	ldi	r22, 0x00	; 0
    2de0:	70 e0       	ldi	r23, 0x00	; 0
    2de2:	4a e0       	ldi	r20, 0x0A	; 10
    2de4:	50 e0       	ldi	r21, 0x00	; 0
    2de6:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    2dea:	64 30       	cpi	r22, 0x04	; 4
    2dec:	d8 f5       	brcc	.+118    	; 0x2e64 <commandGetMotorDecay+0x86>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].decay);
    2dee:	40 91 e7 03 	lds	r20, 0x03E7
    2df2:	50 91 e8 03 	lds	r21, 0x03E8
    2df6:	e6 2f       	mov	r30, r22
    2df8:	f0 e0       	ldi	r31, 0x00	; 0
    2dfa:	ee 0f       	add	r30, r30
    2dfc:	ff 1f       	adc	r31, r31
    2dfe:	ee 0f       	add	r30, r30
    2e00:	ff 1f       	adc	r31, r31
    2e02:	ee 0f       	add	r30, r30
    2e04:	ff 1f       	adc	r31, r31
    2e06:	cf 01       	movw	r24, r30
    2e08:	88 0f       	add	r24, r24
    2e0a:	99 1f       	adc	r25, r25
    2e0c:	88 0f       	add	r24, r24
    2e0e:	99 1f       	adc	r25, r25
    2e10:	e8 0f       	add	r30, r24
    2e12:	f9 1f       	adc	r31, r25
    2e14:	e0 51       	subi	r30, 0x10	; 16
    2e16:	fc 4f       	sbci	r31, 0xFC	; 252
    2e18:	27 a1       	ldd	r18, Z+39	; 0x27
    2e1a:	00 d0       	rcall	.+0      	; 0x2e1c <commandGetMotorDecay+0x3e>
    2e1c:	00 d0       	rcall	.+0      	; 0x2e1e <commandGetMotorDecay+0x40>
    2e1e:	00 d0       	rcall	.+0      	; 0x2e20 <commandGetMotorDecay+0x42>
    2e20:	ed b7       	in	r30, 0x3d	; 61
    2e22:	fe b7       	in	r31, 0x3e	; 62
    2e24:	31 96       	adiw	r30, 0x01	; 1
    2e26:	ad b7       	in	r26, 0x3d	; 61
    2e28:	be b7       	in	r27, 0x3e	; 62
    2e2a:	12 96       	adiw	r26, 0x02	; 2
    2e2c:	5c 93       	st	X, r21
    2e2e:	4e 93       	st	-X, r20
    2e30:	11 97       	sbiw	r26, 0x01	; 1
    2e32:	87 e1       	ldi	r24, 0x17	; 23
    2e34:	91 e0       	ldi	r25, 0x01	; 1
    2e36:	93 83       	std	Z+3, r25	; 0x03
    2e38:	82 83       	std	Z+2, r24	; 0x02
    2e3a:	33 27       	eor	r19, r19
    2e3c:	27 fd       	sbrc	r18, 7
    2e3e:	30 95       	com	r19
    2e40:	35 83       	std	Z+5, r19	; 0x05
    2e42:	24 83       	std	Z+4, r18	; 0x04
    2e44:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    2e48:	8d b7       	in	r24, 0x3d	; 61
    2e4a:	9e b7       	in	r25, 0x3e	; 62
    2e4c:	06 96       	adiw	r24, 0x06	; 6
    2e4e:	0f b6       	in	r0, 0x3f	; 63
    2e50:	f8 94       	cli
    2e52:	9e bf       	out	0x3e, r25	; 62
    2e54:	0f be       	out	0x3f, r0	; 63
    2e56:	8d bf       	out	0x3d, r24	; 61
  }
  
  return txString.buffer;
    2e58:	20 91 e7 03 	lds	r18, 0x03E7
    2e5c:	30 91 e8 03 	lds	r19, 0x03E8
}
    2e60:	c9 01       	movw	r24, r18
    2e62:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2e64:	80 91 e7 03 	lds	r24, 0x03E7
    2e68:	90 91 e8 03 	lds	r25, 0x03E8
    2e6c:	00 d0       	rcall	.+0      	; 0x2e6e <commandGetMotorDecay+0x90>
    2e6e:	00 d0       	rcall	.+0      	; 0x2e70 <commandGetMotorDecay+0x92>
    2e70:	00 d0       	rcall	.+0      	; 0x2e72 <commandGetMotorDecay+0x94>
    2e72:	ed b7       	in	r30, 0x3d	; 61
    2e74:	fe b7       	in	r31, 0x3e	; 62
    2e76:	31 96       	adiw	r30, 0x01	; 1
    2e78:	ad b7       	in	r26, 0x3d	; 61
    2e7a:	be b7       	in	r27, 0x3e	; 62
    2e7c:	12 96       	adiw	r26, 0x02	; 2
    2e7e:	9c 93       	st	X, r25
    2e80:	8e 93       	st	-X, r24
    2e82:	11 97       	sbiw	r26, 0x01	; 1
    2e84:	80 e0       	ldi	r24, 0x00	; 0
    2e86:	91 e0       	ldi	r25, 0x01	; 1
    2e88:	93 83       	std	Z+3, r25	; 0x03
    2e8a:	82 83       	std	Z+2, r24	; 0x02
    2e8c:	64 83       	std	Z+4, r22	; 0x04
    2e8e:	15 82       	std	Z+5, r1	; 0x05
    2e90:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    2e94:	8d b7       	in	r24, 0x3d	; 61
    2e96:	9e b7       	in	r25, 0x3e	; 62
    2e98:	06 96       	adiw	r24, 0x06	; 6
    2e9a:	0f b6       	in	r0, 0x3f	; 63
    2e9c:	f8 94       	cli
    2e9e:	9e bf       	out	0x3e, r25	; 62
    2ea0:	0f be       	out	0x3f, r0	; 63
    2ea2:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].decay);
  }
  
  return txString.buffer;
    2ea4:	20 91 e7 03 	lds	r18, 0x03E7
    2ea8:	30 91 e8 03 	lds	r19, 0x03E8
}
    2eac:	c9 01       	movw	r24, r18
    2eae:	08 95       	ret

00002eb0 <commandGetMotorCurrent>:
char* commandGetMotorCurrent(char* param0){

  uint8_t i = 0;
  double curr = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2eb0:	60 e0       	ldi	r22, 0x00	; 0
    2eb2:	70 e0       	ldi	r23, 0x00	; 0
    2eb4:	4a e0       	ldi	r20, 0x0A	; 10
    2eb6:	50 e0       	ldi	r21, 0x00	; 0
    2eb8:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    2ebc:	64 30       	cpi	r22, 0x04	; 4
    2ebe:	78 f5       	brcc	.+94     	; 0x2f1e <commandGetMotorCurrent+0x6e>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    curr = getMotorCurrent(i);
    2ec0:	86 2f       	mov	r24, r22
    2ec2:	0e 94 9e 0c 	call	0x193c	; 0x193c <getMotorCurrent>
    sprintf(txString.buffer, "%f", curr);
    2ec6:	20 91 e7 03 	lds	r18, 0x03E7
    2eca:	30 91 e8 03 	lds	r19, 0x03E8
    2ece:	ad b7       	in	r26, 0x3d	; 61
    2ed0:	be b7       	in	r27, 0x3e	; 62
    2ed2:	18 97       	sbiw	r26, 0x08	; 8
    2ed4:	0f b6       	in	r0, 0x3f	; 63
    2ed6:	f8 94       	cli
    2ed8:	be bf       	out	0x3e, r27	; 62
    2eda:	0f be       	out	0x3f, r0	; 63
    2edc:	ad bf       	out	0x3d, r26	; 61
    2ede:	ed b7       	in	r30, 0x3d	; 61
    2ee0:	fe b7       	in	r31, 0x3e	; 62
    2ee2:	31 96       	adiw	r30, 0x01	; 1
    2ee4:	12 96       	adiw	r26, 0x02	; 2
    2ee6:	3c 93       	st	X, r19
    2ee8:	2e 93       	st	-X, r18
    2eea:	11 97       	sbiw	r26, 0x01	; 1
    2eec:	2a e1       	ldi	r18, 0x1A	; 26
    2eee:	31 e0       	ldi	r19, 0x01	; 1
    2ef0:	33 83       	std	Z+3, r19	; 0x03
    2ef2:	22 83       	std	Z+2, r18	; 0x02
    2ef4:	64 83       	std	Z+4, r22	; 0x04
    2ef6:	75 83       	std	Z+5, r23	; 0x05
    2ef8:	86 83       	std	Z+6, r24	; 0x06
    2efa:	97 83       	std	Z+7, r25	; 0x07
    2efc:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    2f00:	4d b7       	in	r20, 0x3d	; 61
    2f02:	5e b7       	in	r21, 0x3e	; 62
    2f04:	48 5f       	subi	r20, 0xF8	; 248
    2f06:	5f 4f       	sbci	r21, 0xFF	; 255
    2f08:	0f b6       	in	r0, 0x3f	; 63
    2f0a:	f8 94       	cli
    2f0c:	5e bf       	out	0x3e, r21	; 62
    2f0e:	0f be       	out	0x3f, r0	; 63
    2f10:	4d bf       	out	0x3d, r20	; 61
  }
  
  return txString.buffer;
    2f12:	20 91 e7 03 	lds	r18, 0x03E7
    2f16:	30 91 e8 03 	lds	r19, 0x03E8
}
    2f1a:	c9 01       	movw	r24, r18
    2f1c:	08 95       	ret
  double curr = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2f1e:	80 91 e7 03 	lds	r24, 0x03E7
    2f22:	90 91 e8 03 	lds	r25, 0x03E8
    2f26:	00 d0       	rcall	.+0      	; 0x2f28 <commandGetMotorCurrent+0x78>
    2f28:	00 d0       	rcall	.+0      	; 0x2f2a <commandGetMotorCurrent+0x7a>
    2f2a:	00 d0       	rcall	.+0      	; 0x2f2c <commandGetMotorCurrent+0x7c>
    2f2c:	ed b7       	in	r30, 0x3d	; 61
    2f2e:	fe b7       	in	r31, 0x3e	; 62
    2f30:	31 96       	adiw	r30, 0x01	; 1
    2f32:	ad b7       	in	r26, 0x3d	; 61
    2f34:	be b7       	in	r27, 0x3e	; 62
    2f36:	12 96       	adiw	r26, 0x02	; 2
    2f38:	9c 93       	st	X, r25
    2f3a:	8e 93       	st	-X, r24
    2f3c:	11 97       	sbiw	r26, 0x01	; 1
    2f3e:	80 e0       	ldi	r24, 0x00	; 0
    2f40:	91 e0       	ldi	r25, 0x01	; 1
    2f42:	93 83       	std	Z+3, r25	; 0x03
    2f44:	82 83       	std	Z+2, r24	; 0x02
    2f46:	64 83       	std	Z+4, r22	; 0x04
    2f48:	15 82       	std	Z+5, r1	; 0x05
    2f4a:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    2f4e:	4d b7       	in	r20, 0x3d	; 61
    2f50:	5e b7       	in	r21, 0x3e	; 62
    2f52:	4a 5f       	subi	r20, 0xFA	; 250
    2f54:	5f 4f       	sbci	r21, 0xFF	; 255
    2f56:	0f b6       	in	r0, 0x3f	; 63
    2f58:	f8 94       	cli
    2f5a:	5e bf       	out	0x3e, r21	; 62
    2f5c:	0f be       	out	0x3f, r0	; 63
    2f5e:	4d bf       	out	0x3d, r20	; 61
  else{
    curr = getMotorCurrent(i);
    sprintf(txString.buffer, "%f", curr);
  }
  
  return txString.buffer;
    2f60:	20 91 e7 03 	lds	r18, 0x03E7
    2f64:	30 91 e8 03 	lds	r19, 0x03E8
}
    2f68:	c9 01       	movw	r24, r18
    2f6a:	08 95       	ret

00002f6c <commandGetWaitTime>:
 --------------------------------------------------------------------- */
char* commandGetWaitTime(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2f6c:	60 e0       	ldi	r22, 0x00	; 0
    2f6e:	70 e0       	ldi	r23, 0x00	; 0
    2f70:	4a e0       	ldi	r20, 0x0A	; 10
    2f72:	50 e0       	ldi	r21, 0x00	; 0
    2f74:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    2f78:	64 30       	cpi	r22, 0x04	; 4
    2f7a:	c8 f5       	brcc	.+114    	; 0x2fee <commandGetWaitTime+0x82>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].waitBetweenSteps);
    2f7c:	40 91 e7 03 	lds	r20, 0x03E7
    2f80:	50 91 e8 03 	lds	r21, 0x03E8
    2f84:	e6 2f       	mov	r30, r22
    2f86:	f0 e0       	ldi	r31, 0x00	; 0
    2f88:	ee 0f       	add	r30, r30
    2f8a:	ff 1f       	adc	r31, r31
    2f8c:	ee 0f       	add	r30, r30
    2f8e:	ff 1f       	adc	r31, r31
    2f90:	ee 0f       	add	r30, r30
    2f92:	ff 1f       	adc	r31, r31
    2f94:	cf 01       	movw	r24, r30
    2f96:	88 0f       	add	r24, r24
    2f98:	99 1f       	adc	r25, r25
    2f9a:	88 0f       	add	r24, r24
    2f9c:	99 1f       	adc	r25, r25
    2f9e:	e8 0f       	add	r30, r24
    2fa0:	f9 1f       	adc	r31, r25
    2fa2:	e0 51       	subi	r30, 0x10	; 16
    2fa4:	fc 4f       	sbci	r31, 0xFC	; 252
    2fa6:	26 8d       	ldd	r18, Z+30	; 0x1e
    2fa8:	37 8d       	ldd	r19, Z+31	; 0x1f
    2faa:	00 d0       	rcall	.+0      	; 0x2fac <commandGetWaitTime+0x40>
    2fac:	00 d0       	rcall	.+0      	; 0x2fae <commandGetWaitTime+0x42>
    2fae:	00 d0       	rcall	.+0      	; 0x2fb0 <commandGetWaitTime+0x44>
    2fb0:	ed b7       	in	r30, 0x3d	; 61
    2fb2:	fe b7       	in	r31, 0x3e	; 62
    2fb4:	31 96       	adiw	r30, 0x01	; 1
    2fb6:	ad b7       	in	r26, 0x3d	; 61
    2fb8:	be b7       	in	r27, 0x3e	; 62
    2fba:	12 96       	adiw	r26, 0x02	; 2
    2fbc:	5c 93       	st	X, r21
    2fbe:	4e 93       	st	-X, r20
    2fc0:	11 97       	sbiw	r26, 0x01	; 1
    2fc2:	87 e1       	ldi	r24, 0x17	; 23
    2fc4:	91 e0       	ldi	r25, 0x01	; 1
    2fc6:	93 83       	std	Z+3, r25	; 0x03
    2fc8:	82 83       	std	Z+2, r24	; 0x02
    2fca:	35 83       	std	Z+5, r19	; 0x05
    2fcc:	24 83       	std	Z+4, r18	; 0x04
    2fce:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    2fd2:	8d b7       	in	r24, 0x3d	; 61
    2fd4:	9e b7       	in	r25, 0x3e	; 62
    2fd6:	06 96       	adiw	r24, 0x06	; 6
    2fd8:	0f b6       	in	r0, 0x3f	; 63
    2fda:	f8 94       	cli
    2fdc:	9e bf       	out	0x3e, r25	; 62
    2fde:	0f be       	out	0x3f, r0	; 63
    2fe0:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    2fe2:	20 91 e7 03 	lds	r18, 0x03E7
    2fe6:	30 91 e8 03 	lds	r19, 0x03E8
}
    2fea:	c9 01       	movw	r24, r18
    2fec:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2fee:	80 91 e7 03 	lds	r24, 0x03E7
    2ff2:	90 91 e8 03 	lds	r25, 0x03E8
    2ff6:	00 d0       	rcall	.+0      	; 0x2ff8 <commandGetWaitTime+0x8c>
    2ff8:	00 d0       	rcall	.+0      	; 0x2ffa <commandGetWaitTime+0x8e>
    2ffa:	00 d0       	rcall	.+0      	; 0x2ffc <commandGetWaitTime+0x90>
    2ffc:	ed b7       	in	r30, 0x3d	; 61
    2ffe:	fe b7       	in	r31, 0x3e	; 62
    3000:	31 96       	adiw	r30, 0x01	; 1
    3002:	ad b7       	in	r26, 0x3d	; 61
    3004:	be b7       	in	r27, 0x3e	; 62
    3006:	12 96       	adiw	r26, 0x02	; 2
    3008:	9c 93       	st	X, r25
    300a:	8e 93       	st	-X, r24
    300c:	11 97       	sbiw	r26, 0x01	; 1
    300e:	80 e0       	ldi	r24, 0x00	; 0
    3010:	91 e0       	ldi	r25, 0x01	; 1
    3012:	93 83       	std	Z+3, r25	; 0x03
    3014:	82 83       	std	Z+2, r24	; 0x02
    3016:	64 83       	std	Z+4, r22	; 0x04
    3018:	15 82       	std	Z+5, r1	; 0x05
    301a:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    301e:	8d b7       	in	r24, 0x3d	; 61
    3020:	9e b7       	in	r25, 0x3e	; 62
    3022:	06 96       	adiw	r24, 0x06	; 6
    3024:	0f b6       	in	r0, 0x3f	; 63
    3026:	f8 94       	cli
    3028:	9e bf       	out	0x3e, r25	; 62
    302a:	0f be       	out	0x3f, r0	; 63
    302c:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].waitBetweenSteps);
  }

  return txString.buffer;
    302e:	20 91 e7 03 	lds	r18, 0x03E7
    3032:	30 91 e8 03 	lds	r19, 0x03E8
}
    3036:	c9 01       	movw	r24, r18
    3038:	08 95       	ret

0000303a <commandGetSubSteps>:
 --------------------------------------------------------------------- */
char* commandGetSubSteps(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    303a:	60 e0       	ldi	r22, 0x00	; 0
    303c:	70 e0       	ldi	r23, 0x00	; 0
    303e:	4a e0       	ldi	r20, 0x0A	; 10
    3040:	50 e0       	ldi	r21, 0x00	; 0
    3042:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    3046:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    3048:	64 30       	cpi	r22, 0x04	; 4
    304a:	08 f0       	brcs	.+2      	; 0x304e <commandGetSubSteps+0x14>
    304c:	40 c0       	rjmp	.+128    	; 0x30ce <commandGetSubSteps+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].subSteps);
    304e:	60 91 e7 03 	lds	r22, 0x03E7
    3052:	70 91 e8 03 	lds	r23, 0x03E8
    3056:	e2 2f       	mov	r30, r18
    3058:	f0 e0       	ldi	r31, 0x00	; 0
    305a:	ee 0f       	add	r30, r30
    305c:	ff 1f       	adc	r31, r31
    305e:	ee 0f       	add	r30, r30
    3060:	ff 1f       	adc	r31, r31
    3062:	ee 0f       	add	r30, r30
    3064:	ff 1f       	adc	r31, r31
    3066:	cf 01       	movw	r24, r30
    3068:	88 0f       	add	r24, r24
    306a:	99 1f       	adc	r25, r25
    306c:	88 0f       	add	r24, r24
    306e:	99 1f       	adc	r25, r25
    3070:	e8 0f       	add	r30, r24
    3072:	f9 1f       	adc	r31, r25
    3074:	e0 51       	subi	r30, 0x10	; 16
    3076:	fc 4f       	sbci	r31, 0xFC	; 252
    3078:	25 89       	ldd	r18, Z+21	; 0x15
    307a:	36 89       	ldd	r19, Z+22	; 0x16
    307c:	47 89       	ldd	r20, Z+23	; 0x17
    307e:	50 8d       	ldd	r21, Z+24	; 0x18
    3080:	ad b7       	in	r26, 0x3d	; 61
    3082:	be b7       	in	r27, 0x3e	; 62
    3084:	18 97       	sbiw	r26, 0x08	; 8
    3086:	0f b6       	in	r0, 0x3f	; 63
    3088:	f8 94       	cli
    308a:	be bf       	out	0x3e, r27	; 62
    308c:	0f be       	out	0x3f, r0	; 63
    308e:	ad bf       	out	0x3d, r26	; 61
    3090:	ed b7       	in	r30, 0x3d	; 61
    3092:	fe b7       	in	r31, 0x3e	; 62
    3094:	31 96       	adiw	r30, 0x01	; 1
    3096:	12 96       	adiw	r26, 0x02	; 2
    3098:	7c 93       	st	X, r23
    309a:	6e 93       	st	-X, r22
    309c:	11 97       	sbiw	r26, 0x01	; 1
    309e:	8d e1       	ldi	r24, 0x1D	; 29
    30a0:	91 e0       	ldi	r25, 0x01	; 1
    30a2:	93 83       	std	Z+3, r25	; 0x03
    30a4:	82 83       	std	Z+2, r24	; 0x02
    30a6:	24 83       	std	Z+4, r18	; 0x04
    30a8:	35 83       	std	Z+5, r19	; 0x05
    30aa:	46 83       	std	Z+6, r20	; 0x06
    30ac:	57 83       	std	Z+7, r21	; 0x07
    30ae:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    30b2:	8d b7       	in	r24, 0x3d	; 61
    30b4:	9e b7       	in	r25, 0x3e	; 62
    30b6:	08 96       	adiw	r24, 0x08	; 8
    30b8:	0f b6       	in	r0, 0x3f	; 63
    30ba:	f8 94       	cli
    30bc:	9e bf       	out	0x3e, r25	; 62
    30be:	0f be       	out	0x3f, r0	; 63
    30c0:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    30c2:	20 91 e7 03 	lds	r18, 0x03E7
    30c6:	30 91 e8 03 	lds	r19, 0x03E8
}
    30ca:	c9 01       	movw	r24, r18
    30cc:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    30ce:	80 91 e7 03 	lds	r24, 0x03E7
    30d2:	90 91 e8 03 	lds	r25, 0x03E8
    30d6:	00 d0       	rcall	.+0      	; 0x30d8 <commandGetSubSteps+0x9e>
    30d8:	00 d0       	rcall	.+0      	; 0x30da <commandGetSubSteps+0xa0>
    30da:	00 d0       	rcall	.+0      	; 0x30dc <commandGetSubSteps+0xa2>
    30dc:	ed b7       	in	r30, 0x3d	; 61
    30de:	fe b7       	in	r31, 0x3e	; 62
    30e0:	31 96       	adiw	r30, 0x01	; 1
    30e2:	ad b7       	in	r26, 0x3d	; 61
    30e4:	be b7       	in	r27, 0x3e	; 62
    30e6:	12 96       	adiw	r26, 0x02	; 2
    30e8:	9c 93       	st	X, r25
    30ea:	8e 93       	st	-X, r24
    30ec:	11 97       	sbiw	r26, 0x01	; 1
    30ee:	80 e0       	ldi	r24, 0x00	; 0
    30f0:	91 e0       	ldi	r25, 0x01	; 1
    30f2:	93 83       	std	Z+3, r25	; 0x03
    30f4:	82 83       	std	Z+2, r24	; 0x02
    30f6:	24 83       	std	Z+4, r18	; 0x04
    30f8:	15 82       	std	Z+5, r1	; 0x05
    30fa:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    30fe:	8d b7       	in	r24, 0x3d	; 61
    3100:	9e b7       	in	r25, 0x3e	; 62
    3102:	06 96       	adiw	r24, 0x06	; 6
    3104:	0f b6       	in	r0, 0x3f	; 63
    3106:	f8 94       	cli
    3108:	9e bf       	out	0x3e, r25	; 62
    310a:	0f be       	out	0x3f, r0	; 63
    310c:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].subSteps);
  }

  return txString.buffer;
    310e:	20 91 e7 03 	lds	r18, 0x03E7
    3112:	30 91 e8 03 	lds	r19, 0x03E8
}
    3116:	c9 01       	movw	r24, r18
    3118:	08 95       	ret

0000311a <commandGetFullRotation>:
 --------------------------------------------------------------------- */
char* commandGetFullRotation(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    311a:	60 e0       	ldi	r22, 0x00	; 0
    311c:	70 e0       	ldi	r23, 0x00	; 0
    311e:	4a e0       	ldi	r20, 0x0A	; 10
    3120:	50 e0       	ldi	r21, 0x00	; 0
    3122:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    3126:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    3128:	64 30       	cpi	r22, 0x04	; 4
    312a:	08 f0       	brcs	.+2      	; 0x312e <commandGetFullRotation+0x14>
    312c:	40 c0       	rjmp	.+128    	; 0x31ae <commandGetFullRotation+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].stepsPerFullRotation);
    312e:	60 91 e7 03 	lds	r22, 0x03E7
    3132:	70 91 e8 03 	lds	r23, 0x03E8
    3136:	e2 2f       	mov	r30, r18
    3138:	f0 e0       	ldi	r31, 0x00	; 0
    313a:	ee 0f       	add	r30, r30
    313c:	ff 1f       	adc	r31, r31
    313e:	ee 0f       	add	r30, r30
    3140:	ff 1f       	adc	r31, r31
    3142:	ee 0f       	add	r30, r30
    3144:	ff 1f       	adc	r31, r31
    3146:	cf 01       	movw	r24, r30
    3148:	88 0f       	add	r24, r24
    314a:	99 1f       	adc	r25, r25
    314c:	88 0f       	add	r24, r24
    314e:	99 1f       	adc	r25, r25
    3150:	e8 0f       	add	r30, r24
    3152:	f9 1f       	adc	r31, r25
    3154:	e0 51       	subi	r30, 0x10	; 16
    3156:	fc 4f       	sbci	r31, 0xFC	; 252
    3158:	21 89       	ldd	r18, Z+17	; 0x11
    315a:	32 89       	ldd	r19, Z+18	; 0x12
    315c:	43 89       	ldd	r20, Z+19	; 0x13
    315e:	54 89       	ldd	r21, Z+20	; 0x14
    3160:	ad b7       	in	r26, 0x3d	; 61
    3162:	be b7       	in	r27, 0x3e	; 62
    3164:	18 97       	sbiw	r26, 0x08	; 8
    3166:	0f b6       	in	r0, 0x3f	; 63
    3168:	f8 94       	cli
    316a:	be bf       	out	0x3e, r27	; 62
    316c:	0f be       	out	0x3f, r0	; 63
    316e:	ad bf       	out	0x3d, r26	; 61
    3170:	ed b7       	in	r30, 0x3d	; 61
    3172:	fe b7       	in	r31, 0x3e	; 62
    3174:	31 96       	adiw	r30, 0x01	; 1
    3176:	12 96       	adiw	r26, 0x02	; 2
    3178:	7c 93       	st	X, r23
    317a:	6e 93       	st	-X, r22
    317c:	11 97       	sbiw	r26, 0x01	; 1
    317e:	8d e1       	ldi	r24, 0x1D	; 29
    3180:	91 e0       	ldi	r25, 0x01	; 1
    3182:	93 83       	std	Z+3, r25	; 0x03
    3184:	82 83       	std	Z+2, r24	; 0x02
    3186:	24 83       	std	Z+4, r18	; 0x04
    3188:	35 83       	std	Z+5, r19	; 0x05
    318a:	46 83       	std	Z+6, r20	; 0x06
    318c:	57 83       	std	Z+7, r21	; 0x07
    318e:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3192:	8d b7       	in	r24, 0x3d	; 61
    3194:	9e b7       	in	r25, 0x3e	; 62
    3196:	08 96       	adiw	r24, 0x08	; 8
    3198:	0f b6       	in	r0, 0x3f	; 63
    319a:	f8 94       	cli
    319c:	9e bf       	out	0x3e, r25	; 62
    319e:	0f be       	out	0x3f, r0	; 63
    31a0:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    31a2:	20 91 e7 03 	lds	r18, 0x03E7
    31a6:	30 91 e8 03 	lds	r19, 0x03E8
}
    31aa:	c9 01       	movw	r24, r18
    31ac:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    31ae:	80 91 e7 03 	lds	r24, 0x03E7
    31b2:	90 91 e8 03 	lds	r25, 0x03E8
    31b6:	00 d0       	rcall	.+0      	; 0x31b8 <commandGetFullRotation+0x9e>
    31b8:	00 d0       	rcall	.+0      	; 0x31ba <commandGetFullRotation+0xa0>
    31ba:	00 d0       	rcall	.+0      	; 0x31bc <commandGetFullRotation+0xa2>
    31bc:	ed b7       	in	r30, 0x3d	; 61
    31be:	fe b7       	in	r31, 0x3e	; 62
    31c0:	31 96       	adiw	r30, 0x01	; 1
    31c2:	ad b7       	in	r26, 0x3d	; 61
    31c4:	be b7       	in	r27, 0x3e	; 62
    31c6:	12 96       	adiw	r26, 0x02	; 2
    31c8:	9c 93       	st	X, r25
    31ca:	8e 93       	st	-X, r24
    31cc:	11 97       	sbiw	r26, 0x01	; 1
    31ce:	80 e0       	ldi	r24, 0x00	; 0
    31d0:	91 e0       	ldi	r25, 0x01	; 1
    31d2:	93 83       	std	Z+3, r25	; 0x03
    31d4:	82 83       	std	Z+2, r24	; 0x02
    31d6:	24 83       	std	Z+4, r18	; 0x04
    31d8:	15 82       	std	Z+5, r1	; 0x05
    31da:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    31de:	8d b7       	in	r24, 0x3d	; 61
    31e0:	9e b7       	in	r25, 0x3e	; 62
    31e2:	06 96       	adiw	r24, 0x06	; 6
    31e4:	0f b6       	in	r0, 0x3f	; 63
    31e6:	f8 94       	cli
    31e8:	9e bf       	out	0x3e, r25	; 62
    31ea:	0f be       	out	0x3f, r0	; 63
    31ec:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].stepsPerFullRotation);
  }

  return txString.buffer;
    31ee:	20 91 e7 03 	lds	r18, 0x03E7
    31f2:	30 91 e8 03 	lds	r19, 0x03E8
}
    31f6:	c9 01       	movw	r24, r18
    31f8:	08 95       	ret

000031fa <commandGetGearRatio>:
 --------------------------------------------------------------------- */
char* commandGetGearRatio(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    31fa:	60 e0       	ldi	r22, 0x00	; 0
    31fc:	70 e0       	ldi	r23, 0x00	; 0
    31fe:	4a e0       	ldi	r20, 0x0A	; 10
    3200:	50 e0       	ldi	r21, 0x00	; 0
    3202:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    3206:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    3208:	64 30       	cpi	r22, 0x04	; 4
    320a:	08 f0       	brcs	.+2      	; 0x320e <commandGetGearRatio+0x14>
    320c:	40 c0       	rjmp	.+128    	; 0x328e <commandGetGearRatio+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%f", motor[i].gearRatio);
    320e:	60 91 e7 03 	lds	r22, 0x03E7
    3212:	70 91 e8 03 	lds	r23, 0x03E8
    3216:	e2 2f       	mov	r30, r18
    3218:	f0 e0       	ldi	r31, 0x00	; 0
    321a:	ee 0f       	add	r30, r30
    321c:	ff 1f       	adc	r31, r31
    321e:	ee 0f       	add	r30, r30
    3220:	ff 1f       	adc	r31, r31
    3222:	ee 0f       	add	r30, r30
    3224:	ff 1f       	adc	r31, r31
    3226:	cf 01       	movw	r24, r30
    3228:	88 0f       	add	r24, r24
    322a:	99 1f       	adc	r25, r25
    322c:	88 0f       	add	r24, r24
    322e:	99 1f       	adc	r25, r25
    3230:	e8 0f       	add	r30, r24
    3232:	f9 1f       	adc	r31, r25
    3234:	e0 51       	subi	r30, 0x10	; 16
    3236:	fc 4f       	sbci	r31, 0xFC	; 252
    3238:	25 85       	ldd	r18, Z+13	; 0x0d
    323a:	36 85       	ldd	r19, Z+14	; 0x0e
    323c:	47 85       	ldd	r20, Z+15	; 0x0f
    323e:	50 89       	ldd	r21, Z+16	; 0x10
    3240:	ad b7       	in	r26, 0x3d	; 61
    3242:	be b7       	in	r27, 0x3e	; 62
    3244:	18 97       	sbiw	r26, 0x08	; 8
    3246:	0f b6       	in	r0, 0x3f	; 63
    3248:	f8 94       	cli
    324a:	be bf       	out	0x3e, r27	; 62
    324c:	0f be       	out	0x3f, r0	; 63
    324e:	ad bf       	out	0x3d, r26	; 61
    3250:	ed b7       	in	r30, 0x3d	; 61
    3252:	fe b7       	in	r31, 0x3e	; 62
    3254:	31 96       	adiw	r30, 0x01	; 1
    3256:	12 96       	adiw	r26, 0x02	; 2
    3258:	7c 93       	st	X, r23
    325a:	6e 93       	st	-X, r22
    325c:	11 97       	sbiw	r26, 0x01	; 1
    325e:	8a e1       	ldi	r24, 0x1A	; 26
    3260:	91 e0       	ldi	r25, 0x01	; 1
    3262:	93 83       	std	Z+3, r25	; 0x03
    3264:	82 83       	std	Z+2, r24	; 0x02
    3266:	24 83       	std	Z+4, r18	; 0x04
    3268:	35 83       	std	Z+5, r19	; 0x05
    326a:	46 83       	std	Z+6, r20	; 0x06
    326c:	57 83       	std	Z+7, r21	; 0x07
    326e:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3272:	8d b7       	in	r24, 0x3d	; 61
    3274:	9e b7       	in	r25, 0x3e	; 62
    3276:	08 96       	adiw	r24, 0x08	; 8
    3278:	0f b6       	in	r0, 0x3f	; 63
    327a:	f8 94       	cli
    327c:	9e bf       	out	0x3e, r25	; 62
    327e:	0f be       	out	0x3f, r0	; 63
    3280:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    3282:	20 91 e7 03 	lds	r18, 0x03E7
    3286:	30 91 e8 03 	lds	r19, 0x03E8
}
    328a:	c9 01       	movw	r24, r18
    328c:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    328e:	80 91 e7 03 	lds	r24, 0x03E7
    3292:	90 91 e8 03 	lds	r25, 0x03E8
    3296:	00 d0       	rcall	.+0      	; 0x3298 <commandGetGearRatio+0x9e>
    3298:	00 d0       	rcall	.+0      	; 0x329a <commandGetGearRatio+0xa0>
    329a:	00 d0       	rcall	.+0      	; 0x329c <commandGetGearRatio+0xa2>
    329c:	ed b7       	in	r30, 0x3d	; 61
    329e:	fe b7       	in	r31, 0x3e	; 62
    32a0:	31 96       	adiw	r30, 0x01	; 1
    32a2:	ad b7       	in	r26, 0x3d	; 61
    32a4:	be b7       	in	r27, 0x3e	; 62
    32a6:	12 96       	adiw	r26, 0x02	; 2
    32a8:	9c 93       	st	X, r25
    32aa:	8e 93       	st	-X, r24
    32ac:	11 97       	sbiw	r26, 0x01	; 1
    32ae:	80 e0       	ldi	r24, 0x00	; 0
    32b0:	91 e0       	ldi	r25, 0x01	; 1
    32b2:	93 83       	std	Z+3, r25	; 0x03
    32b4:	82 83       	std	Z+2, r24	; 0x02
    32b6:	24 83       	std	Z+4, r18	; 0x04
    32b8:	15 82       	std	Z+5, r1	; 0x05
    32ba:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    32be:	8d b7       	in	r24, 0x3d	; 61
    32c0:	9e b7       	in	r25, 0x3e	; 62
    32c2:	06 96       	adiw	r24, 0x06	; 6
    32c4:	0f b6       	in	r0, 0x3f	; 63
    32c6:	f8 94       	cli
    32c8:	9e bf       	out	0x3e, r25	; 62
    32ca:	0f be       	out	0x3f, r0	; 63
    32cc:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%f", motor[i].gearRatio);
  }

  return txString.buffer;
    32ce:	20 91 e7 03 	lds	r18, 0x03E7
    32d2:	30 91 e8 03 	lds	r19, 0x03E8
}
    32d6:	c9 01       	movw	r24, r18
    32d8:	08 95       	ret

000032da <commandGetOptZeroPos>:
 --------------------------------------------------------------------- */
char* commandGetOptZeroPos(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    32da:	60 e0       	ldi	r22, 0x00	; 0
    32dc:	70 e0       	ldi	r23, 0x00	; 0
    32de:	4a e0       	ldi	r20, 0x0A	; 10
    32e0:	50 e0       	ldi	r21, 0x00	; 0
    32e2:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    32e6:	64 30       	cpi	r22, 0x04	; 4
    32e8:	d8 f5       	brcc	.+118    	; 0x3360 <commandGetOptZeroPos+0x86>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].opticalZeroPosition);
    32ea:	40 91 e7 03 	lds	r20, 0x03E7
    32ee:	50 91 e8 03 	lds	r21, 0x03E8
    32f2:	86 2f       	mov	r24, r22
    32f4:	90 e0       	ldi	r25, 0x00	; 0
    32f6:	fc 01       	movw	r30, r24
    32f8:	ee 0f       	add	r30, r30
    32fa:	ff 1f       	adc	r31, r31
    32fc:	ee 0f       	add	r30, r30
    32fe:	ff 1f       	adc	r31, r31
    3300:	ee 0f       	add	r30, r30
    3302:	ff 1f       	adc	r31, r31
    3304:	88 0f       	add	r24, r24
    3306:	99 1f       	adc	r25, r25
    3308:	e8 0f       	add	r30, r24
    330a:	f9 1f       	adc	r31, r25
    330c:	ee 0f       	add	r30, r30
    330e:	ff 1f       	adc	r31, r31
    3310:	ee 0f       	add	r30, r30
    3312:	ff 1f       	adc	r31, r31
    3314:	ec 50       	subi	r30, 0x0C	; 12
    3316:	fc 4f       	sbci	r31, 0xFC	; 252
    3318:	20 81       	ld	r18, Z
    331a:	31 81       	ldd	r19, Z+1	; 0x01
    331c:	00 d0       	rcall	.+0      	; 0x331e <commandGetOptZeroPos+0x44>
    331e:	00 d0       	rcall	.+0      	; 0x3320 <commandGetOptZeroPos+0x46>
    3320:	00 d0       	rcall	.+0      	; 0x3322 <commandGetOptZeroPos+0x48>
    3322:	ed b7       	in	r30, 0x3d	; 61
    3324:	fe b7       	in	r31, 0x3e	; 62
    3326:	31 96       	adiw	r30, 0x01	; 1
    3328:	ad b7       	in	r26, 0x3d	; 61
    332a:	be b7       	in	r27, 0x3e	; 62
    332c:	12 96       	adiw	r26, 0x02	; 2
    332e:	5c 93       	st	X, r21
    3330:	4e 93       	st	-X, r20
    3332:	11 97       	sbiw	r26, 0x01	; 1
    3334:	87 e1       	ldi	r24, 0x17	; 23
    3336:	91 e0       	ldi	r25, 0x01	; 1
    3338:	93 83       	std	Z+3, r25	; 0x03
    333a:	82 83       	std	Z+2, r24	; 0x02
    333c:	35 83       	std	Z+5, r19	; 0x05
    333e:	24 83       	std	Z+4, r18	; 0x04
    3340:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3344:	8d b7       	in	r24, 0x3d	; 61
    3346:	9e b7       	in	r25, 0x3e	; 62
    3348:	06 96       	adiw	r24, 0x06	; 6
    334a:	0f b6       	in	r0, 0x3f	; 63
    334c:	f8 94       	cli
    334e:	9e bf       	out	0x3e, r25	; 62
    3350:	0f be       	out	0x3f, r0	; 63
    3352:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    3354:	20 91 e7 03 	lds	r18, 0x03E7
    3358:	30 91 e8 03 	lds	r19, 0x03E8
}
    335c:	c9 01       	movw	r24, r18
    335e:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    3360:	80 91 e7 03 	lds	r24, 0x03E7
    3364:	90 91 e8 03 	lds	r25, 0x03E8
    3368:	00 d0       	rcall	.+0      	; 0x336a <commandGetOptZeroPos+0x90>
    336a:	00 d0       	rcall	.+0      	; 0x336c <commandGetOptZeroPos+0x92>
    336c:	00 d0       	rcall	.+0      	; 0x336e <commandGetOptZeroPos+0x94>
    336e:	ed b7       	in	r30, 0x3d	; 61
    3370:	fe b7       	in	r31, 0x3e	; 62
    3372:	31 96       	adiw	r30, 0x01	; 1
    3374:	ad b7       	in	r26, 0x3d	; 61
    3376:	be b7       	in	r27, 0x3e	; 62
    3378:	12 96       	adiw	r26, 0x02	; 2
    337a:	9c 93       	st	X, r25
    337c:	8e 93       	st	-X, r24
    337e:	11 97       	sbiw	r26, 0x01	; 1
    3380:	80 e0       	ldi	r24, 0x00	; 0
    3382:	91 e0       	ldi	r25, 0x01	; 1
    3384:	93 83       	std	Z+3, r25	; 0x03
    3386:	82 83       	std	Z+2, r24	; 0x02
    3388:	64 83       	std	Z+4, r22	; 0x04
    338a:	15 82       	std	Z+5, r1	; 0x05
    338c:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3390:	8d b7       	in	r24, 0x3d	; 61
    3392:	9e b7       	in	r25, 0x3e	; 62
    3394:	06 96       	adiw	r24, 0x06	; 6
    3396:	0f b6       	in	r0, 0x3f	; 63
    3398:	f8 94       	cli
    339a:	9e bf       	out	0x3e, r25	; 62
    339c:	0f be       	out	0x3f, r0	; 63
    339e:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].opticalZeroPosition);
  }

  return txString.buffer;
    33a0:	20 91 e7 03 	lds	r18, 0x03E7
    33a4:	30 91 e8 03 	lds	r19, 0x03E8
}
    33a8:	c9 01       	movw	r24, r18
    33aa:	08 95       	ret

000033ac <commandGetAnalog>:
char* commandGetAnalog(char* param0){

  uint8_t i = 0;
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    33ac:	60 e0       	ldi	r22, 0x00	; 0
    33ae:	70 e0       	ldi	r23, 0x00	; 0
    33b0:	4a e0       	ldi	r20, 0x0A	; 10
    33b2:	50 e0       	ldi	r21, 0x00	; 0
    33b4:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if((i < MOTOR_SENS0) || (i > MOTOR_SENS_MAX)){
    33b8:	64 30       	cpi	r22, 0x04	; 4
    33ba:	48 f5       	brcc	.+82     	; 0x340e <commandGetAnalog+0x62>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    val = getADCvalue(i);
    33bc:	86 2f       	mov	r24, r22
    33be:	0e 94 a9 06 	call	0xd52	; 0xd52 <getADCvalue>
    sprintf(txString.buffer, "%d", val);
    33c2:	20 91 e7 03 	lds	r18, 0x03E7
    33c6:	30 91 e8 03 	lds	r19, 0x03E8
    33ca:	00 d0       	rcall	.+0      	; 0x33cc <commandGetAnalog+0x20>
    33cc:	00 d0       	rcall	.+0      	; 0x33ce <commandGetAnalog+0x22>
    33ce:	00 d0       	rcall	.+0      	; 0x33d0 <commandGetAnalog+0x24>
    33d0:	ed b7       	in	r30, 0x3d	; 61
    33d2:	fe b7       	in	r31, 0x3e	; 62
    33d4:	31 96       	adiw	r30, 0x01	; 1
    33d6:	ad b7       	in	r26, 0x3d	; 61
    33d8:	be b7       	in	r27, 0x3e	; 62
    33da:	12 96       	adiw	r26, 0x02	; 2
    33dc:	3c 93       	st	X, r19
    33de:	2e 93       	st	-X, r18
    33e0:	11 97       	sbiw	r26, 0x01	; 1
    33e2:	27 e1       	ldi	r18, 0x17	; 23
    33e4:	31 e0       	ldi	r19, 0x01	; 1
    33e6:	33 83       	std	Z+3, r19	; 0x03
    33e8:	22 83       	std	Z+2, r18	; 0x02
    33ea:	95 83       	std	Z+5, r25	; 0x05
    33ec:	84 83       	std	Z+4, r24	; 0x04
    33ee:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    33f2:	8d b7       	in	r24, 0x3d	; 61
    33f4:	9e b7       	in	r25, 0x3e	; 62
    33f6:	06 96       	adiw	r24, 0x06	; 6
    33f8:	0f b6       	in	r0, 0x3f	; 63
    33fa:	f8 94       	cli
    33fc:	9e bf       	out	0x3e, r25	; 62
    33fe:	0f be       	out	0x3f, r0	; 63
    3400:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    3402:	20 91 e7 03 	lds	r18, 0x03E7
    3406:	30 91 e8 03 	lds	r19, 0x03E8
}
    340a:	c9 01       	movw	r24, r18
    340c:	08 95       	ret
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if((i < MOTOR_SENS0) || (i > MOTOR_SENS_MAX)){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    340e:	80 91 e7 03 	lds	r24, 0x03E7
    3412:	90 91 e8 03 	lds	r25, 0x03E8
    3416:	00 d0       	rcall	.+0      	; 0x3418 <commandGetAnalog+0x6c>
    3418:	00 d0       	rcall	.+0      	; 0x341a <commandGetAnalog+0x6e>
    341a:	00 d0       	rcall	.+0      	; 0x341c <commandGetAnalog+0x70>
    341c:	ed b7       	in	r30, 0x3d	; 61
    341e:	fe b7       	in	r31, 0x3e	; 62
    3420:	31 96       	adiw	r30, 0x01	; 1
    3422:	ad b7       	in	r26, 0x3d	; 61
    3424:	be b7       	in	r27, 0x3e	; 62
    3426:	12 96       	adiw	r26, 0x02	; 2
    3428:	9c 93       	st	X, r25
    342a:	8e 93       	st	-X, r24
    342c:	11 97       	sbiw	r26, 0x01	; 1
    342e:	80 e0       	ldi	r24, 0x00	; 0
    3430:	91 e0       	ldi	r25, 0x01	; 1
    3432:	93 83       	std	Z+3, r25	; 0x03
    3434:	82 83       	std	Z+2, r24	; 0x02
    3436:	64 83       	std	Z+4, r22	; 0x04
    3438:	15 82       	std	Z+5, r1	; 0x05
    343a:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    343e:	8d b7       	in	r24, 0x3d	; 61
    3440:	9e b7       	in	r25, 0x3e	; 62
    3442:	06 96       	adiw	r24, 0x06	; 6
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	9e bf       	out	0x3e, r25	; 62
    344a:	0f be       	out	0x3f, r0	; 63
    344c:	8d bf       	out	0x3d, r24	; 61
  else{
    val = getADCvalue(i);
    sprintf(txString.buffer, "%d", val);
  }

  return txString.buffer;
    344e:	20 91 e7 03 	lds	r18, 0x03E7
    3452:	30 91 e8 03 	lds	r19, 0x03E8
}
    3456:	c9 01       	movw	r24, r18
    3458:	08 95       	ret

0000345a <commandIsConnected>:
}

/* ---------------------------------------------------------------------
    returns whether a motor is connected or not
 --------------------------------------------------------------------- */
char* commandIsConnected(char* param0){
    345a:	1f 93       	push	r17

  uint8_t i = 0;
  //uint8_t mota = 0;
  //uint8_t motb = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    345c:	60 e0       	ldi	r22, 0x00	; 0
    345e:	70 e0       	ldi	r23, 0x00	; 0
    3460:	4a e0       	ldi	r20, 0x0A	; 10
    3462:	50 e0       	ldi	r21, 0x00	; 0
    3464:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    3468:	16 2f       	mov	r17, r22
  //motb = getMotorSens(i, PORTEXP_MOTOR_MOTB);
  
  //sprintf(txString.buffer, "\nmota=%d\nmotb=%d\n", mota, motb);
  //sendText(txString.buffer);

  if(i > MAX_MOTOR){
    346a:	64 30       	cpi	r22, 0x04	; 4
    346c:	20 f5       	brcc	.+72     	; 0x34b6 <commandIsConnected+0x5c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(getMotorSens(i, PORTEXP_MOTOR_MOTA) && getMotorSens(i, PORTEXP_MOTOR_MOTB)){
    346e:	86 2f       	mov	r24, r22
    3470:	65 e0       	ldi	r22, 0x05	; 5
    3472:	0e 94 77 0c 	call	0x18ee	; 0x18ee <getMotorSens>
    3476:	88 23       	and	r24, r24
    3478:	79 f4       	brne	.+30     	; 0x3498 <commandIsConnected+0x3e>
      sprintf(txString.buffer, "0"); //motor is not connected
    }
    else{
      sprintf(txString.buffer, "1"); //motor is connected
    347a:	e0 91 e7 03 	lds	r30, 0x03E7
    347e:	f0 91 e8 03 	lds	r31, 0x03E8
    3482:	81 e3       	ldi	r24, 0x31	; 49
    3484:	90 e0       	ldi	r25, 0x00	; 0
    3486:	91 83       	std	Z+1, r25	; 0x01
    3488:	80 83       	st	Z, r24
    }
  }

  return txString.buffer;
    348a:	20 91 e7 03 	lds	r18, 0x03E7
    348e:	30 91 e8 03 	lds	r19, 0x03E8
}
    3492:	c9 01       	movw	r24, r18
    3494:	1f 91       	pop	r17
    3496:	08 95       	ret

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(getMotorSens(i, PORTEXP_MOTOR_MOTA) && getMotorSens(i, PORTEXP_MOTOR_MOTB)){
    3498:	81 2f       	mov	r24, r17
    349a:	66 e0       	ldi	r22, 0x06	; 6
    349c:	0e 94 77 0c 	call	0x18ee	; 0x18ee <getMotorSens>
    34a0:	88 23       	and	r24, r24
    34a2:	59 f3       	breq	.-42     	; 0x347a <commandIsConnected+0x20>
      sprintf(txString.buffer, "0"); //motor is not connected
    34a4:	e0 91 e7 03 	lds	r30, 0x03E7
    34a8:	f0 91 e8 03 	lds	r31, 0x03E8
    34ac:	80 e3       	ldi	r24, 0x30	; 48
    34ae:	90 e0       	ldi	r25, 0x00	; 0
    34b0:	91 83       	std	Z+1, r25	; 0x01
    34b2:	80 83       	st	Z, r24
    34b4:	ea cf       	rjmp	.-44     	; 0x348a <commandIsConnected+0x30>
  
  //sprintf(txString.buffer, "\nmota=%d\nmotb=%d\n", mota, motb);
  //sendText(txString.buffer);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    34b6:	80 91 e7 03 	lds	r24, 0x03E7
    34ba:	90 91 e8 03 	lds	r25, 0x03E8
    34be:	00 d0       	rcall	.+0      	; 0x34c0 <commandIsConnected+0x66>
    34c0:	00 d0       	rcall	.+0      	; 0x34c2 <commandIsConnected+0x68>
    34c2:	00 d0       	rcall	.+0      	; 0x34c4 <commandIsConnected+0x6a>
    34c4:	ed b7       	in	r30, 0x3d	; 61
    34c6:	fe b7       	in	r31, 0x3e	; 62
    34c8:	31 96       	adiw	r30, 0x01	; 1
    34ca:	ad b7       	in	r26, 0x3d	; 61
    34cc:	be b7       	in	r27, 0x3e	; 62
    34ce:	12 96       	adiw	r26, 0x02	; 2
    34d0:	9c 93       	st	X, r25
    34d2:	8e 93       	st	-X, r24
    34d4:	11 97       	sbiw	r26, 0x01	; 1
    34d6:	80 e0       	ldi	r24, 0x00	; 0
    34d8:	91 e0       	ldi	r25, 0x01	; 1
    34da:	93 83       	std	Z+3, r25	; 0x03
    34dc:	82 83       	std	Z+2, r24	; 0x02
    34de:	14 83       	std	Z+4, r17	; 0x04
    34e0:	15 82       	std	Z+5, r1	; 0x05
    34e2:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    34e6:	8d b7       	in	r24, 0x3d	; 61
    34e8:	9e b7       	in	r25, 0x3e	; 62
    34ea:	06 96       	adiw	r24, 0x06	; 6
    34ec:	0f b6       	in	r0, 0x3f	; 63
    34ee:	f8 94       	cli
    34f0:	9e bf       	out	0x3e, r25	; 62
    34f2:	0f be       	out	0x3f, r0	; 63
    34f4:	8d bf       	out	0x3d, r24	; 61
    else{
      sprintf(txString.buffer, "1"); //motor is connected
    }
  }

  return txString.buffer;
    34f6:	20 91 e7 03 	lds	r18, 0x03E7
    34fa:	30 91 e8 03 	lds	r19, 0x03E8
}
    34fe:	c9 01       	movw	r24, r18
    3500:	1f 91       	pop	r17
    3502:	08 95       	ret

00003504 <commandIsMoving>:
 --------------------------------------------------------------------- */
char* commandIsMoving(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    3504:	60 e0       	ldi	r22, 0x00	; 0
    3506:	70 e0       	ldi	r23, 0x00	; 0
    3508:	4a e0       	ldi	r20, 0x0A	; 10
    350a:	50 e0       	ldi	r21, 0x00	; 0
    350c:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if(i > MAX_MOTOR){
    3510:	64 30       	cpi	r22, 0x04	; 4
    3512:	08 f0       	brcs	.+2      	; 0x3516 <commandIsMoving+0x12>
    3514:	45 c0       	rjmp	.+138    	; 0x35a0 <commandIsMoving+0x9c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(motor[i].desiredPosition - motor[i].actualPosition){
    3516:	e6 2f       	mov	r30, r22
    3518:	f0 e0       	ldi	r31, 0x00	; 0
    351a:	ee 0f       	add	r30, r30
    351c:	ff 1f       	adc	r31, r31
    351e:	ee 0f       	add	r30, r30
    3520:	ff 1f       	adc	r31, r31
    3522:	cf 01       	movw	r24, r30
    3524:	88 0f       	add	r24, r24
    3526:	99 1f       	adc	r25, r25
    3528:	88 0f       	add	r24, r24
    352a:	99 1f       	adc	r25, r25
    352c:	e8 0f       	add	r30, r24
    352e:	f9 1f       	adc	r31, r25
    3530:	ee 0f       	add	r30, r30
    3532:	ff 1f       	adc	r31, r31
    3534:	ee 50       	subi	r30, 0x0E	; 14
    3536:	fc 4f       	sbci	r31, 0xFC	; 252
    3538:	20 81       	ld	r18, Z
    353a:	31 81       	ldd	r19, Z+1	; 0x01
    353c:	e6 2f       	mov	r30, r22
    353e:	f0 e0       	ldi	r31, 0x00	; 0
    3540:	ee 0f       	add	r30, r30
    3542:	ff 1f       	adc	r31, r31
    3544:	ee 0f       	add	r30, r30
    3546:	ff 1f       	adc	r31, r31
    3548:	ee 0f       	add	r30, r30
    354a:	ff 1f       	adc	r31, r31
    354c:	cf 01       	movw	r24, r30
    354e:	88 0f       	add	r24, r24
    3550:	99 1f       	adc	r25, r25
    3552:	88 0f       	add	r24, r24
    3554:	99 1f       	adc	r25, r25
    3556:	e8 0f       	add	r30, r24
    3558:	f9 1f       	adc	r31, r25
    355a:	e0 51       	subi	r30, 0x10	; 16
    355c:	fc 4f       	sbci	r31, 0xFC	; 252
    355e:	80 81       	ld	r24, Z
    3560:	91 81       	ldd	r25, Z+1	; 0x01
    3562:	28 17       	cp	r18, r24
    3564:	39 07       	cpc	r19, r25
    3566:	71 f0       	breq	.+28     	; 0x3584 <commandIsMoving+0x80>
      sprintf(txString.buffer, "1");
    3568:	e0 91 e7 03 	lds	r30, 0x03E7
    356c:	f0 91 e8 03 	lds	r31, 0x03E8
    3570:	81 e3       	ldi	r24, 0x31	; 49
    3572:	90 e0       	ldi	r25, 0x00	; 0
    3574:	91 83       	std	Z+1, r25	; 0x01
    3576:	80 83       	st	Z, r24
    else{
      sprintf(txString.buffer, "0");
    }
  }

  return txString.buffer;
    3578:	20 91 e7 03 	lds	r18, 0x03E7
    357c:	30 91 e8 03 	lds	r19, 0x03E8
}
    3580:	c9 01       	movw	r24, r18
    3582:	08 95       	ret
  else{
    if(motor[i].desiredPosition - motor[i].actualPosition){
      sprintf(txString.buffer, "1");
    }
    else{
      sprintf(txString.buffer, "0");
    3584:	e0 91 e7 03 	lds	r30, 0x03E7
    3588:	f0 91 e8 03 	lds	r31, 0x03E8
    358c:	80 e3       	ldi	r24, 0x30	; 48
    358e:	90 e0       	ldi	r25, 0x00	; 0
    3590:	91 83       	std	Z+1, r25	; 0x01
    3592:	80 83       	st	Z, r24
    }
  }

  return txString.buffer;
    3594:	20 91 e7 03 	lds	r18, 0x03E7
    3598:	30 91 e8 03 	lds	r19, 0x03E8
}
    359c:	c9 01       	movw	r24, r18
    359e:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    35a0:	80 91 e7 03 	lds	r24, 0x03E7
    35a4:	90 91 e8 03 	lds	r25, 0x03E8
    35a8:	00 d0       	rcall	.+0      	; 0x35aa <commandIsMoving+0xa6>
    35aa:	00 d0       	rcall	.+0      	; 0x35ac <commandIsMoving+0xa8>
    35ac:	00 d0       	rcall	.+0      	; 0x35ae <commandIsMoving+0xaa>
    35ae:	ed b7       	in	r30, 0x3d	; 61
    35b0:	fe b7       	in	r31, 0x3e	; 62
    35b2:	31 96       	adiw	r30, 0x01	; 1
    35b4:	ad b7       	in	r26, 0x3d	; 61
    35b6:	be b7       	in	r27, 0x3e	; 62
    35b8:	12 96       	adiw	r26, 0x02	; 2
    35ba:	9c 93       	st	X, r25
    35bc:	8e 93       	st	-X, r24
    35be:	11 97       	sbiw	r26, 0x01	; 1
    35c0:	80 e0       	ldi	r24, 0x00	; 0
    35c2:	91 e0       	ldi	r25, 0x01	; 1
    35c4:	93 83       	std	Z+3, r25	; 0x03
    35c6:	82 83       	std	Z+2, r24	; 0x02
    35c8:	64 83       	std	Z+4, r22	; 0x04
    35ca:	15 82       	std	Z+5, r1	; 0x05
    35cc:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    35d0:	8d b7       	in	r24, 0x3d	; 61
    35d2:	9e b7       	in	r25, 0x3e	; 62
    35d4:	06 96       	adiw	r24, 0x06	; 6
    35d6:	0f b6       	in	r0, 0x3f	; 63
    35d8:	f8 94       	cli
    35da:	9e bf       	out	0x3e, r25	; 62
    35dc:	0f be       	out	0x3f, r0	; 63
    35de:	8d bf       	out	0x3d, r24	; 61
    else{
      sprintf(txString.buffer, "0");
    }
  }

  return txString.buffer;
    35e0:	20 91 e7 03 	lds	r18, 0x03E7
    35e4:	30 91 e8 03 	lds	r19, 0x03E8
}
    35e8:	c9 01       	movw	r24, r18
    35ea:	08 95       	ret

000035ec <updateDisplayChangeValues>:

/* ---------------------------------------------------------------------
   update the display after switching to value-changing-mode
   or update changed values for a motor on the display
 --------------------------------------------------------------------- */
void updateDisplayChangeValues(uint8_t thisMenu){
    35ec:	2f 92       	push	r2
    35ee:	3f 92       	push	r3
    35f0:	4f 92       	push	r4
    35f2:	5f 92       	push	r5
    35f4:	6f 92       	push	r6
    35f6:	7f 92       	push	r7
    35f8:	8f 92       	push	r8
    35fa:	9f 92       	push	r9
    35fc:	af 92       	push	r10
    35fe:	bf 92       	push	r11
    3600:	df 92       	push	r13
    3602:	ef 92       	push	r14
    3604:	ff 92       	push	r15
    3606:	0f 93       	push	r16
    3608:	1f 93       	push	r17
    360a:	cf 93       	push	r28
    360c:	df 93       	push	r29

  uint8_t sLen;
  uint8_t c = 0;

  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
    360e:	90 e0       	ldi	r25, 0x00	; 0
    3610:	88 0f       	add	r24, r24
    3612:	99 1f       	adc	r25, r25
    3614:	8e 51       	subi	r24, 0x1E	; 30
    3616:	9b 4f       	sbci	r25, 0xFB	; 251
    3618:	fc 01       	movw	r30, r24
    361a:	25 91       	lpm	r18, Z+
    361c:	34 91       	lpm	r19, Z+
  state = (uint8_t)pgm_read_byte(&menuPtr->state);
    361e:	2e 5f       	subi	r18, 0xFE	; 254
    3620:	3f 4f       	sbci	r19, 0xFF	; 255
    3622:	f9 01       	movw	r30, r18
    3624:	84 91       	lpm	r24, Z+

  /* load the values of all 4 motors */
  switch(state){
    3626:	86 30       	cpi	r24, 0x06	; 6
    3628:	09 f4       	brne	.+2      	; 0x362c <updateDisplayChangeValues+0x40>
    362a:	61 c4       	rjmp	.+2242   	; 0x3eee <updateDisplayChangeValues+0x902>
    362c:	87 30       	cpi	r24, 0x07	; 7
    362e:	08 f4       	brcc	.+2      	; 0x3632 <updateDisplayChangeValues+0x46>
    3630:	55 c0       	rjmp	.+170    	; 0x36dc <updateDisplayChangeValues+0xf0>
    3632:	8b 30       	cpi	r24, 0x0B	; 11
    3634:	09 f4       	brne	.+2      	; 0x3638 <updateDisplayChangeValues+0x4c>
    3636:	c8 c5       	rjmp	.+2960   	; 0x41c8 <__stack+0xc9>
    3638:	8c 30       	cpi	r24, 0x0C	; 12
    363a:	08 f0       	brcs	.+2      	; 0x363e <updateDisplayChangeValues+0x52>
    363c:	bd c0       	rjmp	.+378    	; 0x37b8 <updateDisplayChangeValues+0x1cc>
    363e:	88 30       	cpi	r24, 0x08	; 8
    3640:	09 f4       	brne	.+2      	; 0x3644 <updateDisplayChangeValues+0x58>
    3642:	82 c5       	rjmp	.+2820   	; 0x4148 <__stack+0x49>
    3644:	88 30       	cpi	r24, 0x08	; 8
    3646:	08 f4       	brcc	.+2      	; 0x364a <updateDisplayChangeValues+0x5e>
    3648:	0f c5       	rjmp	.+2590   	; 0x4068 <updateDisplayChangeValues+0xa7c>
    364a:	8a 30       	cpi	r24, 0x0A	; 10
    364c:	09 f4       	brne	.+2      	; 0x3650 <updateDisplayChangeValues+0x64>
    364e:	af c4       	rjmp	.+2398   	; 0x3fae <updateDisplayChangeValues+0x9c2>
    case MENU_SETTINGS:
      sprintf(menu.newDisplayValue[0], "test    ");
      sprintf(menu.newDisplayValue[1], "test    ");
      sprintf(menu.newDisplayValue[2], "test    ");
      sprintf(menu.newDisplayValue[3], "test    ");
      menu.currentMenuMode = MENU_SETTINGS_MODE;
    3650:	20 e0       	ldi	r18, 0x00	; 0
    3652:	30 e0       	ldi	r19, 0x00	; 0

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
      menu.newDisplayValue[i][j] = ' ';
    3654:	90 e2       	ldi	r25, 0x20	; 32
      break;
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    3656:	a0 91 e8 02 	lds	r26, 0x02E8
    365a:	b0 91 e9 02 	lds	r27, 0x02E9
    365e:	a2 0f       	add	r26, r18
    3660:	b3 1f       	adc	r27, r19
    3662:	ec 91       	ld	r30, X
    3664:	11 96       	adiw	r26, 0x01	; 1
    3666:	fc 91       	ld	r31, X
    3668:	df 01       	movw	r26, r30
    366a:	0d 90       	ld	r0, X+
    366c:	00 20       	and	r0, r0
    366e:	e9 f7       	brne	.-6      	; 0x366a <updateDisplayChangeValues+0x7e>
    3670:	11 97       	sbiw	r26, 0x01	; 1
    3672:	ae 1b       	sub	r26, r30
    3674:	bf 0b       	sbc	r27, r31
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
    3676:	a8 30       	cpi	r26, 0x08	; 8
    3678:	80 f4       	brcc	.+32     	; 0x369a <updateDisplayChangeValues+0xae>
    367a:	8a 2f       	mov	r24, r26
      menu.newDisplayValue[i][j] = ' ';
    367c:	e0 91 e8 02 	lds	r30, 0x02E8
    3680:	f0 91 e9 02 	lds	r31, 0x02E9
    3684:	e2 0f       	add	r30, r18
    3686:	f3 1f       	adc	r31, r19
    3688:	01 90       	ld	r0, Z+
    368a:	f0 81       	ld	r31, Z
    368c:	e0 2d       	mov	r30, r0
    368e:	e8 0f       	add	r30, r24
    3690:	f1 1d       	adc	r31, r1
    3692:	90 83       	st	Z, r25
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
    3694:	8f 5f       	subi	r24, 0xFF	; 255
    3696:	88 30       	cpi	r24, 0x08	; 8
    3698:	88 f3       	brcs	.-30     	; 0x367c <updateDisplayChangeValues+0x90>
      menu.newDisplayValue[i][j] = ' ';
    }
    menu.newDisplayValue[i][DISPLAY_VALUE_STRING_LENGTH-1] = '\0';
    369a:	e0 91 e8 02 	lds	r30, 0x02E8
    369e:	f0 91 e9 02 	lds	r31, 0x02E9
    36a2:	e2 0f       	add	r30, r18
    36a4:	f3 1f       	adc	r31, r19
    36a6:	01 90       	ld	r0, Z+
    36a8:	f0 81       	ld	r31, Z
    36aa:	e0 2d       	mov	r30, r0
    36ac:	10 86       	std	Z+8, r1	; 0x08
    36ae:	2e 5f       	subi	r18, 0xFE	; 254
    36b0:	3f 4f       	sbci	r19, 0xFF	; 255
    default:  /* in case of fire ;-) */
      break;
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    36b2:	28 30       	cpi	r18, 0x08	; 8
    36b4:	31 05       	cpc	r19, r1
    36b6:	79 f6       	brne	.-98     	; 0x3656 <updateDisplayChangeValues+0x6a>
    }
    menu.newDisplayValue[i][DISPLAY_VALUE_STRING_LENGTH-1] = '\0';
  }

  return;
}
    36b8:	df 91       	pop	r29
    36ba:	cf 91       	pop	r28
    36bc:	1f 91       	pop	r17
    36be:	0f 91       	pop	r16
    36c0:	ff 90       	pop	r15
    36c2:	ef 90       	pop	r14
    36c4:	df 90       	pop	r13
    36c6:	bf 90       	pop	r11
    36c8:	af 90       	pop	r10
    36ca:	9f 90       	pop	r9
    36cc:	8f 90       	pop	r8
    36ce:	7f 90       	pop	r7
    36d0:	6f 90       	pop	r6
    36d2:	5f 90       	pop	r5
    36d4:	4f 90       	pop	r4
    36d6:	3f 90       	pop	r3
    36d8:	2f 90       	pop	r2
    36da:	08 95       	ret
  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    36dc:	82 30       	cpi	r24, 0x02	; 2
    36de:	09 f4       	brne	.+2      	; 0x36e2 <updateDisplayChangeValues+0xf6>
    36e0:	a9 c3       	rjmp	.+1874   	; 0x3e34 <updateDisplayChangeValues+0x848>
    36e2:	83 30       	cpi	r24, 0x03	; 3
    36e4:	08 f4       	brcc	.+2      	; 0x36e8 <updateDisplayChangeValues+0xfc>
    36e6:	ae c0       	rjmp	.+348    	; 0x3844 <updateDisplayChangeValues+0x258>
    36e8:	84 30       	cpi	r24, 0x04	; 4
    36ea:	09 f4       	brne	.+2      	; 0x36ee <updateDisplayChangeValues+0x102>
    36ec:	f0 c1       	rjmp	.+992    	; 0x3ace <updateDisplayChangeValues+0x4e2>
    36ee:	85 30       	cpi	r24, 0x05	; 5
    36f0:	08 f4       	brcc	.+2      	; 0x36f4 <updateDisplayChangeValues+0x108>
    36f2:	50 c1       	rjmp	.+672    	; 0x3994 <updateDisplayChangeValues+0x3a8>
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
    36f4:	c0 e0       	ldi	r28, 0x00	; 0
    36f6:	d0 e0       	ldi	r29, 0x00	; 0
    36f8:	ee 24       	eor	r14, r14
    36fa:	ff 24       	eor	r15, r15
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    36fc:	90 ee       	ldi	r25, 0xE0	; 224
    36fe:	a9 2e       	mov	r10, r25
    3700:	91 e0       	ldi	r25, 0x01	; 1
    3702:	b9 2e       	mov	r11, r25
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
    3704:	8b ed       	ldi	r24, 0xDB	; 219
    3706:	88 2e       	mov	r8, r24
    3708:	81 e0       	ldi	r24, 0x01	; 1
    370a:	98 2e       	mov	r9, r24
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
    370c:	04 ed       	ldi	r16, 0xD4	; 212
    370e:	60 2e       	mov	r6, r16
    3710:	01 e0       	ldi	r16, 0x01	; 1
    3712:	70 2e       	mov	r7, r16
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3714:	80 91 e5 02 	lds	r24, 0x02E5
    3718:	90 e0       	ldi	r25, 0x00	; 0
    371a:	0c 2e       	mov	r0, r28
    371c:	02 c0       	rjmp	.+4      	; 0x3722 <updateDisplayChangeValues+0x136>
    371e:	95 95       	asr	r25
    3720:	87 95       	ror	r24
    3722:	0a 94       	dec	r0
    3724:	e2 f7       	brpl	.-8      	; 0x371e <updateDisplayChangeValues+0x132>
    3726:	80 fd       	sbrc	r24, 0
    3728:	1d c1       	rjmp	.+570    	; 0x3964 <updateDisplayChangeValues+0x378>
    372a:	10 e2       	ldi	r17, 0x20	; 32
    372c:	d1 2e       	mov	r13, r17
        if(forbiddenZone[i].active){
    372e:	fe 01       	movw	r30, r28
    3730:	ee 0f       	add	r30, r30
    3732:	ff 1f       	adc	r31, r31
    3734:	ee 0f       	add	r30, r30
    3736:	ff 1f       	adc	r31, r31
    3738:	ec 0f       	add	r30, r28
    373a:	fd 1f       	adc	r31, r29
    373c:	ed 52       	subi	r30, 0x2D	; 45
    373e:	fc 4f       	sbci	r31, 0xFC	; 252
    3740:	84 81       	ldd	r24, Z+4	; 0x04
    3742:	88 23       	and	r24, r24
    3744:	09 f0       	breq	.+2      	; 0x3748 <updateDisplayChangeValues+0x15c>
    3746:	11 c1       	rjmp	.+546    	; 0x396a <updateDisplayChangeValues+0x37e>
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
    3748:	8e 01       	movw	r16, r28
    374a:	00 0f       	add	r16, r16
    374c:	11 1f       	adc	r17, r17
    374e:	00 0f       	add	r16, r16
    3750:	11 1f       	adc	r17, r17
    3752:	00 0f       	add	r16, r16
    3754:	11 1f       	adc	r17, r17
    3756:	f8 01       	movw	r30, r16
    3758:	ee 0f       	add	r30, r30
    375a:	ff 1f       	adc	r31, r31
    375c:	ee 0f       	add	r30, r30
    375e:	ff 1f       	adc	r31, r31
    3760:	e0 0f       	add	r30, r16
    3762:	f1 1f       	adc	r31, r17
    3764:	e0 51       	subi	r30, 0x10	; 16
    3766:	fc 4f       	sbci	r31, 0xFC	; 252
    3768:	82 a1       	ldd	r24, Z+34	; 0x22
    376a:	88 23       	and	r24, r24
    376c:	09 f4       	brne	.+2      	; 0x3770 <updateDisplayChangeValues+0x184>
    376e:	8c c5       	rjmp	.+2840   	; 0x4288 <__stack+0x189>
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
    3770:	f8 01       	movw	r30, r16
    3772:	ee 0f       	add	r30, r30
    3774:	ff 1f       	adc	r31, r31
    3776:	ee 0f       	add	r30, r30
    3778:	ff 1f       	adc	r31, r31
    377a:	e0 0f       	add	r30, r16
    377c:	f1 1f       	adc	r31, r17
    377e:	e0 51       	subi	r30, 0x10	; 16
    3780:	fc 4f       	sbci	r31, 0xFC	; 252
    3782:	82 a1       	ldd	r24, Z+34	; 0x22
    3784:	81 30       	cpi	r24, 0x01	; 1
    3786:	09 f4       	brne	.+2      	; 0x378a <updateDisplayChangeValues+0x19e>
    3788:	2f c6       	rjmp	.+3166   	; 0x43e8 <__stack+0x2e9>
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
    378a:	f8 01       	movw	r30, r16
    378c:	ee 0f       	add	r30, r30
    378e:	ff 1f       	adc	r31, r31
    3790:	ee 0f       	add	r30, r30
    3792:	ff 1f       	adc	r31, r31
    3794:	e0 0f       	add	r30, r16
    3796:	f1 1f       	adc	r31, r17
    3798:	e0 51       	subi	r30, 0x10	; 16
    379a:	fc 4f       	sbci	r31, 0xFC	; 252
    379c:	82 a1       	ldd	r24, Z+34	; 0x22
    379e:	82 30       	cpi	r24, 0x02	; 2
    37a0:	09 f4       	brne	.+2      	; 0x37a4 <updateDisplayChangeValues+0x1b8>
    37a2:	fb c5       	rjmp	.+3062   	; 0x439a <__stack+0x29b>
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    37a4:	21 96       	adiw	r28, 0x01	; 1
    37a6:	82 e0       	ldi	r24, 0x02	; 2
    37a8:	90 e0       	ldi	r25, 0x00	; 0
    37aa:	e8 0e       	add	r14, r24
    37ac:	f9 1e       	adc	r15, r25
        sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].opticalZeroPosition);
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
    37ae:	c4 30       	cpi	r28, 0x04	; 4
    37b0:	d1 05       	cpc	r29, r1
    37b2:	09 f0       	breq	.+2      	; 0x37b6 <updateDisplayChangeValues+0x1ca>
    37b4:	af cf       	rjmp	.-162    	; 0x3714 <updateDisplayChangeValues+0x128>
    37b6:	4c cf       	rjmp	.-360    	; 0x3650 <updateDisplayChangeValues+0x64>
  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    37b8:	8d 30       	cpi	r24, 0x0D	; 13
    37ba:	09 f4       	brne	.+2      	; 0x37be <updateDisplayChangeValues+0x1d2>
    37bc:	39 c2       	rjmp	.+1138   	; 0x3c30 <updateDisplayChangeValues+0x644>
    37be:	8d 30       	cpi	r24, 0x0D	; 13
    37c0:	08 f4       	brcc	.+2      	; 0x37c4 <updateDisplayChangeValues+0x1d8>
    37c2:	dd c1       	rjmp	.+954    	; 0x3b7e <updateDisplayChangeValues+0x592>
    37c4:	8e 30       	cpi	r24, 0x0E	; 14
    37c6:	09 f0       	breq	.+2      	; 0x37ca <updateDisplayChangeValues+0x1de>
    37c8:	43 cf       	rjmp	.-378    	; 0x3650 <updateDisplayChangeValues+0x64>
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_LOAD_CONFIG:
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Load all");
    37ca:	e0 91 e8 02 	lds	r30, 0x02E8
    37ce:	f0 91 e9 02 	lds	r31, 0x02E9
    37d2:	20 81       	ld	r18, Z
    37d4:	31 81       	ldd	r19, Z+1	; 0x01
    37d6:	c9 01       	movw	r24, r18
    37d8:	dc 01       	movw	r26, r24
    37da:	e2 ec       	ldi	r30, 0xC2	; 194
    37dc:	f1 e0       	ldi	r31, 0x01	; 1
    37de:	89 e0       	ldi	r24, 0x09	; 9
    37e0:	01 90       	ld	r0, Z+
    37e2:	0d 92       	st	X+, r0
    37e4:	81 50       	subi	r24, 0x01	; 1
    37e6:	e1 f7       	brne	.-8      	; 0x37e0 <updateDisplayChangeValues+0x1f4>
      sprintf(menu.newDisplayValue[1], " saved  ");
    37e8:	e0 91 e8 02 	lds	r30, 0x02E8
    37ec:	f0 91 e9 02 	lds	r31, 0x02E9
    37f0:	22 81       	ldd	r18, Z+2	; 0x02
    37f2:	33 81       	ldd	r19, Z+3	; 0x03
    37f4:	c9 01       	movw	r24, r18
    37f6:	dc 01       	movw	r26, r24
    37f8:	eb ec       	ldi	r30, 0xCB	; 203
    37fa:	f1 e0       	ldi	r31, 0x01	; 1
    37fc:	89 e0       	ldi	r24, 0x09	; 9
    37fe:	01 90       	ld	r0, Z+
    3800:	0d 92       	st	X+, r0
    3802:	81 50       	subi	r24, 0x01	; 1
    3804:	e1 f7       	brne	.-8      	; 0x37fe <updateDisplayChangeValues+0x212>
      sprintf(menu.newDisplayValue[2], "configur");
    3806:	e0 91 e8 02 	lds	r30, 0x02E8
    380a:	f0 91 e9 02 	lds	r31, 0x02E9
    380e:	24 81       	ldd	r18, Z+4	; 0x04
    3810:	35 81       	ldd	r19, Z+5	; 0x05
    3812:	c9 01       	movw	r24, r18
    3814:	dc 01       	movw	r26, r24
    3816:	e0 eb       	ldi	r30, 0xB0	; 176
    3818:	f1 e0       	ldi	r31, 0x01	; 1
    381a:	89 e0       	ldi	r24, 0x09	; 9
    381c:	01 90       	ld	r0, Z+
    381e:	0d 92       	st	X+, r0
    3820:	81 50       	subi	r24, 0x01	; 1
    3822:	e1 f7       	brne	.-8      	; 0x381c <updateDisplayChangeValues+0x230>
      sprintf(menu.newDisplayValue[3], "ations  ");
    3824:	e0 91 e8 02 	lds	r30, 0x02E8
    3828:	f0 91 e9 02 	lds	r31, 0x02E9
    382c:	26 81       	ldd	r18, Z+6	; 0x06
    382e:	37 81       	ldd	r19, Z+7	; 0x07
    3830:	c9 01       	movw	r24, r18
    3832:	dc 01       	movw	r26, r24
    3834:	e9 eb       	ldi	r30, 0xB9	; 185
    3836:	f1 e0       	ldi	r31, 0x01	; 1
    3838:	89 e0       	ldi	r24, 0x09	; 9
    383a:	01 90       	ld	r0, Z+
    383c:	0d 92       	st	X+, r0
    383e:	81 50       	subi	r24, 0x01	; 1
    3840:	e1 f7       	brne	.-8      	; 0x383a <updateDisplayChangeValues+0x24e>
    3842:	06 cf       	rjmp	.-500    	; 0x3650 <updateDisplayChangeValues+0x64>
  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    3844:	88 23       	and	r24, r24
    3846:	09 f4       	brne	.+2      	; 0x384a <updateDisplayChangeValues+0x25e>
    3848:	30 c2       	rjmp	.+1120   	; 0x3caa <updateDisplayChangeValues+0x6be>
    384a:	81 30       	cpi	r24, 0x01	; 1
    384c:	09 f0       	breq	.+2      	; 0x3850 <updateDisplayChangeValues+0x264>
    384e:	00 cf       	rjmp	.-512    	; 0x3650 <updateDisplayChangeValues+0x64>
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
      sprintf(menu.newDisplayValue[1], "        ");
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;
    3850:	c0 e0       	ldi	r28, 0x00	; 0
    3852:	d0 e0       	ldi	r29, 0x00	; 0
    3854:	ee 24       	eor	r14, r14
    3856:	ff 24       	eor	r15, r15
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
            break;

          case MOTOR_STEP_UNIT_DEGREE:
            /* 0xDF is the display code for the degree-circle */
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
    3858:	bb e4       	ldi	r27, 0x4B	; 75
    385a:	ab 2e       	mov	r10, r27
    385c:	b1 e0       	ldi	r27, 0x01	; 1
    385e:	bb 2e       	mov	r11, r27
    3860:	af ed       	ldi	r26, 0xDF	; 223
    3862:	8a 2e       	mov	r8, r26
    3864:	91 2c       	mov	r9, r1
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    3866:	f4 e5       	ldi	r31, 0x54	; 84
    3868:	6f 2e       	mov	r6, r31
    386a:	f1 e0       	ldi	r31, 0x01	; 1
    386c:	7f 2e       	mov	r7, r31
    386e:	e7 ef       	ldi	r30, 0xF7	; 247
    3870:	4e 2e       	mov	r4, r30
    3872:	51 2c       	mov	r5, r1
            c = 0x3E;
          }
        }
        switch(motor[i].stepUnit){
          case MOTOR_STEP_UNIT_STEP:
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
    3874:	74 e4       	ldi	r23, 0x44	; 68
    3876:	27 2e       	mov	r2, r23
    3878:	71 e0       	ldi	r23, 0x01	; 1
    387a:	37 2e       	mov	r3, r23
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
      sprintf(menu.newDisplayValue[1], "        ");
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;
    387c:	4c 2f       	mov	r20, r28

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    387e:	80 91 e5 02 	lds	r24, 0x02E5
    3882:	9e 01       	movw	r18, r28
    3884:	90 e0       	ldi	r25, 0x00	; 0
    3886:	0c 2e       	mov	r0, r28
    3888:	02 c0       	rjmp	.+4      	; 0x388e <updateDisplayChangeValues+0x2a2>
    388a:	95 95       	asr	r25
    388c:	87 95       	ror	r24
    388e:	0a 94       	dec	r0
    3890:	e2 f7       	brpl	.-8      	; 0x388a <updateDisplayChangeValues+0x29e>
    3892:	80 fd       	sbrc	r24, 0
    3894:	60 c0       	rjmp	.+192    	; 0x3956 <updateDisplayChangeValues+0x36a>
    3896:	60 e2       	ldi	r22, 0x20	; 32
    3898:	d6 2e       	mov	r13, r22
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        switch(motor[i].stepUnit){
    389a:	f9 01       	movw	r30, r18
    389c:	ee 0f       	add	r30, r30
    389e:	ff 1f       	adc	r31, r31
    38a0:	ee 0f       	add	r30, r30
    38a2:	ff 1f       	adc	r31, r31
    38a4:	ee 0f       	add	r30, r30
    38a6:	ff 1f       	adc	r31, r31
    38a8:	cf 01       	movw	r24, r30
    38aa:	88 0f       	add	r24, r24
    38ac:	99 1f       	adc	r25, r25
    38ae:	88 0f       	add	r24, r24
    38b0:	99 1f       	adc	r25, r25
    38b2:	e8 0f       	add	r30, r24
    38b4:	f9 1f       	adc	r31, r25
    38b6:	e0 51       	subi	r30, 0x10	; 16
    38b8:	fc 4f       	sbci	r31, 0xFC	; 252
    38ba:	81 8d       	ldd	r24, Z+25	; 0x19
    38bc:	81 30       	cpi	r24, 0x01	; 1
    38be:	09 f4       	brne	.+2      	; 0x38c2 <updateDisplayChangeValues+0x2d6>
    38c0:	75 c2       	rjmp	.+1258   	; 0x3dac <updateDisplayChangeValues+0x7c0>
    38c2:	82 30       	cpi	r24, 0x02	; 2
    38c4:	09 f4       	brne	.+2      	; 0x38c8 <updateDisplayChangeValues+0x2dc>
    38c6:	2e c2       	rjmp	.+1116   	; 0x3d24 <updateDisplayChangeValues+0x738>
    38c8:	88 23       	and	r24, r24
    38ca:	d9 f5       	brne	.+118    	; 0x3942 <updateDisplayChangeValues+0x356>
          case MOTOR_STEP_UNIT_STEP:
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
    38cc:	a0 91 e8 02 	lds	r26, 0x02E8
    38d0:	b0 91 e9 02 	lds	r27, 0x02E9
    38d4:	f9 01       	movw	r30, r18
    38d6:	ee 0f       	add	r30, r30
    38d8:	ff 1f       	adc	r31, r31
    38da:	ee 0f       	add	r30, r30
    38dc:	ff 1f       	adc	r31, r31
    38de:	ee 0f       	add	r30, r30
    38e0:	ff 1f       	adc	r31, r31
    38e2:	cf 01       	movw	r24, r30
    38e4:	88 0f       	add	r24, r24
    38e6:	99 1f       	adc	r25, r25
    38e8:	88 0f       	add	r24, r24
    38ea:	99 1f       	adc	r25, r25
    38ec:	e8 0f       	add	r30, r24
    38ee:	f9 1f       	adc	r31, r25
    38f0:	e0 51       	subi	r30, 0x10	; 16
    38f2:	fc 4f       	sbci	r31, 0xFC	; 252
    38f4:	20 81       	ld	r18, Z
    38f6:	31 81       	ldd	r19, Z+1	; 0x01
    38f8:	8d b7       	in	r24, 0x3d	; 61
    38fa:	9e b7       	in	r25, 0x3e	; 62
    38fc:	08 97       	sbiw	r24, 0x08	; 8
    38fe:	0f b6       	in	r0, 0x3f	; 63
    3900:	f8 94       	cli
    3902:	9e bf       	out	0x3e, r25	; 62
    3904:	0f be       	out	0x3f, r0	; 63
    3906:	8d bf       	out	0x3d, r24	; 61
    3908:	ed b7       	in	r30, 0x3d	; 61
    390a:	fe b7       	in	r31, 0x3e	; 62
    390c:	31 96       	adiw	r30, 0x01	; 1
    390e:	ae 0d       	add	r26, r14
    3910:	bf 1d       	adc	r27, r15
    3912:	8d 91       	ld	r24, X+
    3914:	9c 91       	ld	r25, X
    3916:	ad b7       	in	r26, 0x3d	; 61
    3918:	be b7       	in	r27, 0x3e	; 62
    391a:	12 96       	adiw	r26, 0x02	; 2
    391c:	9c 93       	st	X, r25
    391e:	8e 93       	st	-X, r24
    3920:	11 97       	sbiw	r26, 0x01	; 1
    3922:	33 82       	std	Z+3, r3	; 0x03
    3924:	22 82       	std	Z+2, r2	; 0x02
    3926:	d4 82       	std	Z+4, r13	; 0x04
    3928:	15 82       	std	Z+5, r1	; 0x05
    392a:	37 83       	std	Z+7, r19	; 0x07
    392c:	26 83       	std	Z+6, r18	; 0x06
    392e:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3932:	ed b7       	in	r30, 0x3d	; 61
    3934:	fe b7       	in	r31, 0x3e	; 62
    3936:	38 96       	adiw	r30, 0x08	; 8
    3938:	0f b6       	in	r0, 0x3f	; 63
    393a:	f8 94       	cli
    393c:	fe bf       	out	0x3e, r31	; 62
    393e:	0f be       	out	0x3f, r0	; 63
    3940:	ed bf       	out	0x3d, r30	; 61
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    3942:	21 96       	adiw	r28, 0x01	; 1
    3944:	22 e0       	ldi	r18, 0x02	; 2
    3946:	30 e0       	ldi	r19, 0x00	; 0
    3948:	e2 0e       	add	r14, r18
    394a:	f3 1e       	adc	r15, r19
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
    394c:	c4 30       	cpi	r28, 0x04	; 4
    394e:	d1 05       	cpc	r29, r1
    3950:	09 f0       	breq	.+2      	; 0x3954 <updateDisplayChangeValues+0x368>
    3952:	94 cf       	rjmp	.-216    	; 0x387c <updateDisplayChangeValues+0x290>
    3954:	7d ce       	rjmp	.-774    	; 0x3650 <updateDisplayChangeValues+0x64>
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3956:	80 91 e2 02 	lds	r24, 0x02E2
    395a:	88 23       	and	r24, r24
    395c:	c1 f0       	breq	.+48     	; 0x398e <updateDisplayChangeValues+0x3a2>
    395e:	5e e3       	ldi	r21, 0x3E	; 62
    3960:	d5 2e       	mov	r13, r21
    3962:	9b cf       	rjmp	.-202    	; 0x389a <updateDisplayChangeValues+0x2ae>
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3964:	be e7       	ldi	r27, 0x7E	; 126
    3966:	db 2e       	mov	r13, r27
    3968:	e2 ce       	rjmp	.-572    	; 0x372e <updateDisplayChangeValues+0x142>
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
    396a:	e0 91 e8 02 	lds	r30, 0x02E8
    396e:	f0 91 e9 02 	lds	r31, 0x02E9
    3972:	ee 0d       	add	r30, r14
    3974:	ff 1d       	adc	r31, r15
    3976:	20 81       	ld	r18, Z
    3978:	31 81       	ldd	r19, Z+1	; 0x01
    397a:	c9 01       	movw	r24, r18
    397c:	dc 01       	movw	r26, r24
    397e:	e5 e8       	ldi	r30, 0x85	; 133
    3980:	f1 e0       	ldi	r31, 0x01	; 1
    3982:	89 e0       	ldi	r24, 0x09	; 9
    3984:	01 90       	ld	r0, Z+
    3986:	0d 92       	st	X+, r0
    3988:	81 50       	subi	r24, 0x01	; 1
    398a:	e1 f7       	brne	.-8      	; 0x3984 <updateDisplayChangeValues+0x398>
    398c:	0b cf       	rjmp	.-490    	; 0x37a4 <updateDisplayChangeValues+0x1b8>
    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    398e:	9e e7       	ldi	r25, 0x7E	; 126
    3990:	d9 2e       	mov	r13, r25
    3992:	83 cf       	rjmp	.-250    	; 0x389a <updateDisplayChangeValues+0x2ae>
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
    3994:	c0 e0       	ldi	r28, 0x00	; 0
    3996:	d0 e0       	ldi	r29, 0x00	; 0
    3998:	00 e0       	ldi	r16, 0x00	; 0
    399a:	10 e0       	ldi	r17, 0x00	; 0

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
    399c:	9d e5       	ldi	r25, 0x5D	; 93
    399e:	a9 2e       	mov	r10, r25
    39a0:	91 e0       	ldi	r25, 0x01	; 1
    39a2:	b9 2e       	mov	r11, r25
    39a4:	82 e6       	ldi	r24, 0x62	; 98
    39a6:	88 2e       	mov	r8, r24
    39a8:	81 e0       	ldi	r24, 0x01	; 1
    39aa:	98 2e       	mov	r9, r24
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
    39ac:	b7 e6       	ldi	r27, 0x67	; 103
    39ae:	6b 2e       	mov	r6, r27
    39b0:	b1 e0       	ldi	r27, 0x01	; 1
    39b2:	7b 2e       	mov	r7, r27
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    39b4:	ae e6       	ldi	r26, 0x6E	; 110
    39b6:	4a 2e       	mov	r4, r26
    39b8:	a1 e0       	ldi	r26, 0x01	; 1
    39ba:	5a 2e       	mov	r5, r26
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    39bc:	80 91 e5 02 	lds	r24, 0x02E5
    39c0:	fc 2e       	mov	r15, r28
    39c2:	ed 2e       	mov	r14, r29
    39c4:	90 e0       	ldi	r25, 0x00	; 0
    39c6:	0c 2e       	mov	r0, r28
    39c8:	02 c0       	rjmp	.+4      	; 0x39ce <updateDisplayChangeValues+0x3e2>
    39ca:	95 95       	asr	r25
    39cc:	87 95       	ror	r24
    39ce:	0a 94       	dec	r0
    39d0:	e2 f7       	brpl	.-8      	; 0x39ca <updateDisplayChangeValues+0x3de>
    39d2:	80 fd       	sbrc	r24, 0
    39d4:	48 c0       	rjmp	.+144    	; 0x3a66 <updateDisplayChangeValues+0x47a>
    39d6:	f0 e2       	ldi	r31, 0x20	; 32
    39d8:	df 2e       	mov	r13, r31
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
    39da:	ef 2d       	mov	r30, r15
    39dc:	fe 2d       	mov	r31, r14
    39de:	ee 0f       	add	r30, r30
    39e0:	ff 1f       	adc	r31, r31
    39e2:	ee 0f       	add	r30, r30
    39e4:	ff 1f       	adc	r31, r31
    39e6:	ee 0f       	add	r30, r30
    39e8:	ff 1f       	adc	r31, r31
    39ea:	cf 01       	movw	r24, r30
    39ec:	88 0f       	add	r24, r24
    39ee:	99 1f       	adc	r25, r25
    39f0:	88 0f       	add	r24, r24
    39f2:	99 1f       	adc	r25, r25
    39f4:	e8 0f       	add	r30, r24
    39f6:	f9 1f       	adc	r31, r25
    39f8:	e0 51       	subi	r30, 0x10	; 16
    39fa:	fc 4f       	sbci	r31, 0xFC	; 252
    39fc:	81 8d       	ldd	r24, Z+25	; 0x19
    39fe:	88 23       	and	r24, r24
    3a00:	a9 f1       	breq	.+106    	; 0x3a6c <updateDisplayChangeValues+0x480>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
    3a02:	ef 2d       	mov	r30, r15
    3a04:	fe 2d       	mov	r31, r14
    3a06:	ee 0f       	add	r30, r30
    3a08:	ff 1f       	adc	r31, r31
    3a0a:	ee 0f       	add	r30, r30
    3a0c:	ff 1f       	adc	r31, r31
    3a0e:	ee 0f       	add	r30, r30
    3a10:	ff 1f       	adc	r31, r31
    3a12:	cf 01       	movw	r24, r30
    3a14:	88 0f       	add	r24, r24
    3a16:	99 1f       	adc	r25, r25
    3a18:	88 0f       	add	r24, r24
    3a1a:	99 1f       	adc	r25, r25
    3a1c:	e8 0f       	add	r30, r24
    3a1e:	f9 1f       	adc	r31, r25
    3a20:	e0 51       	subi	r30, 0x10	; 16
    3a22:	fc 4f       	sbci	r31, 0xFC	; 252
    3a24:	81 8d       	ldd	r24, Z+25	; 0x19
    3a26:	81 30       	cpi	r24, 0x01	; 1
    3a28:	09 f4       	brne	.+2      	; 0x3a2c <updateDisplayChangeValues+0x440>
    3a2a:	55 c4       	rjmp	.+2218   	; 0x42d6 <__stack+0x1d7>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
    3a2c:	ef 2d       	mov	r30, r15
    3a2e:	fe 2d       	mov	r31, r14
    3a30:	ee 0f       	add	r30, r30
    3a32:	ff 1f       	adc	r31, r31
    3a34:	ee 0f       	add	r30, r30
    3a36:	ff 1f       	adc	r31, r31
    3a38:	ee 0f       	add	r30, r30
    3a3a:	ff 1f       	adc	r31, r31
    3a3c:	cf 01       	movw	r24, r30
    3a3e:	88 0f       	add	r24, r24
    3a40:	99 1f       	adc	r25, r25
    3a42:	88 0f       	add	r24, r24
    3a44:	99 1f       	adc	r25, r25
    3a46:	e8 0f       	add	r30, r24
    3a48:	f9 1f       	adc	r31, r25
    3a4a:	e0 51       	subi	r30, 0x10	; 16
    3a4c:	fc 4f       	sbci	r31, 0xFC	; 252
    3a4e:	81 8d       	ldd	r24, Z+25	; 0x19
    3a50:	82 30       	cpi	r24, 0x02	; 2
    3a52:	09 f4       	brne	.+2      	; 0x3a56 <updateDisplayChangeValues+0x46a>
    3a54:	71 c4       	rjmp	.+2274   	; 0x4338 <__stack+0x239>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    3a56:	21 96       	adiw	r28, 0x01	; 1
    3a58:	0e 5f       	subi	r16, 0xFE	; 254
    3a5a:	1f 4f       	sbci	r17, 0xFF	; 255
        }
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
    3a5c:	c4 30       	cpi	r28, 0x04	; 4
    3a5e:	d1 05       	cpc	r29, r1
    3a60:	09 f0       	breq	.+2      	; 0x3a64 <updateDisplayChangeValues+0x478>
    3a62:	ac cf       	rjmp	.-168    	; 0x39bc <updateDisplayChangeValues+0x3d0>
    3a64:	f5 cd       	rjmp	.-1046   	; 0x3650 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3a66:	ee e7       	ldi	r30, 0x7E	; 126
    3a68:	de 2e       	mov	r13, r30
    3a6a:	b7 cf       	rjmp	.-146    	; 0x39da <updateDisplayChangeValues+0x3ee>
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
    3a6c:	e0 91 e8 02 	lds	r30, 0x02E8
    3a70:	f0 91 e9 02 	lds	r31, 0x02E9
    3a74:	8d b7       	in	r24, 0x3d	; 61
    3a76:	9e b7       	in	r25, 0x3e	; 62
    3a78:	08 97       	sbiw	r24, 0x08	; 8
    3a7a:	0f b6       	in	r0, 0x3f	; 63
    3a7c:	f8 94       	cli
    3a7e:	9e bf       	out	0x3e, r25	; 62
    3a80:	0f be       	out	0x3f, r0	; 63
    3a82:	8d bf       	out	0x3d, r24	; 61
    3a84:	ad b7       	in	r26, 0x3d	; 61
    3a86:	be b7       	in	r27, 0x3e	; 62
    3a88:	11 96       	adiw	r26, 0x01	; 1
    3a8a:	e0 0f       	add	r30, r16
    3a8c:	f1 1f       	adc	r31, r17
    3a8e:	80 81       	ld	r24, Z
    3a90:	91 81       	ldd	r25, Z+1	; 0x01
    3a92:	ed b7       	in	r30, 0x3d	; 61
    3a94:	fe b7       	in	r31, 0x3e	; 62
    3a96:	92 83       	std	Z+2, r25	; 0x02
    3a98:	81 83       	std	Z+1, r24	; 0x01
    3a9a:	13 96       	adiw	r26, 0x03	; 3
    3a9c:	bc 92       	st	X, r11
    3a9e:	ae 92       	st	-X, r10
    3aa0:	12 97       	sbiw	r26, 0x02	; 2
    3aa2:	14 96       	adiw	r26, 0x04	; 4
    3aa4:	dc 92       	st	X, r13
    3aa6:	14 97       	sbiw	r26, 0x04	; 4
    3aa8:	15 96       	adiw	r26, 0x05	; 5
    3aaa:	1c 92       	st	X, r1
    3aac:	15 97       	sbiw	r26, 0x05	; 5
    3aae:	17 96       	adiw	r26, 0x07	; 7
    3ab0:	9c 92       	st	X, r9
    3ab2:	8e 92       	st	-X, r8
    3ab4:	16 97       	sbiw	r26, 0x06	; 6
    3ab6:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3aba:	2d b7       	in	r18, 0x3d	; 61
    3abc:	3e b7       	in	r19, 0x3e	; 62
    3abe:	28 5f       	subi	r18, 0xF8	; 248
    3ac0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ac2:	0f b6       	in	r0, 0x3f	; 63
    3ac4:	f8 94       	cli
    3ac6:	3e bf       	out	0x3e, r19	; 62
    3ac8:	0f be       	out	0x3f, r0	; 63
    3aca:	2d bf       	out	0x3d, r18	; 61
    3acc:	9a cf       	rjmp	.-204    	; 0x3a02 <updateDisplayChangeValues+0x416>
        }
      }
      break;

    case MENU_RUN_PROGRAM:
      sprintf(menu.newDisplayValue[0], "Program ");
    3ace:	e0 91 e8 02 	lds	r30, 0x02E8
    3ad2:	f0 91 e9 02 	lds	r31, 0x02E9
    3ad6:	20 81       	ld	r18, Z
    3ad8:	31 81       	ldd	r19, Z+1	; 0x01
    3ada:	c9 01       	movw	r24, r18
    3adc:	dc 01       	movw	r26, r24
    3ade:	e6 ee       	ldi	r30, 0xE6	; 230
    3ae0:	f1 e0       	ldi	r31, 0x01	; 1
    3ae2:	89 e0       	ldi	r24, 0x09	; 9
    3ae4:	01 90       	ld	r0, Z+
    3ae6:	0d 92       	st	X+, r0
    3ae8:	81 50       	subi	r24, 0x01	; 1
    3aea:	e1 f7       	brne	.-8      	; 0x3ae4 <updateDisplayChangeValues+0x4f8>
      sprintf(menu.newDisplayValue[1], "running ");
    3aec:	e0 91 e8 02 	lds	r30, 0x02E8
    3af0:	f0 91 e9 02 	lds	r31, 0x02E9
    3af4:	22 81       	ldd	r18, Z+2	; 0x02
    3af6:	33 81       	ldd	r19, Z+3	; 0x03
    3af8:	c9 01       	movw	r24, r18
    3afa:	dc 01       	movw	r26, r24
    3afc:	ef ee       	ldi	r30, 0xEF	; 239
    3afe:	f1 e0       	ldi	r31, 0x01	; 1
    3b00:	89 e0       	ldi	r24, 0x09	; 9
    3b02:	01 90       	ld	r0, Z+
    3b04:	0d 92       	st	X+, r0
    3b06:	81 50       	subi	r24, 0x01	; 1
    3b08:	e1 f7       	brne	.-8      	; 0x3b02 <updateDisplayChangeValues+0x516>
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
    3b0a:	e0 91 e8 02 	lds	r30, 0x02E8
    3b0e:	f0 91 e9 02 	lds	r31, 0x02E9
    3b12:	20 91 e3 02 	lds	r18, 0x02E3
    3b16:	00 d0       	rcall	.+0      	; 0x3b18 <updateDisplayChangeValues+0x52c>
    3b18:	00 d0       	rcall	.+0      	; 0x3b1a <updateDisplayChangeValues+0x52e>
    3b1a:	00 d0       	rcall	.+0      	; 0x3b1c <updateDisplayChangeValues+0x530>
    3b1c:	ad b7       	in	r26, 0x3d	; 61
    3b1e:	be b7       	in	r27, 0x3e	; 62
    3b20:	11 96       	adiw	r26, 0x01	; 1
    3b22:	84 81       	ldd	r24, Z+4	; 0x04
    3b24:	95 81       	ldd	r25, Z+5	; 0x05
    3b26:	ed b7       	in	r30, 0x3d	; 61
    3b28:	fe b7       	in	r31, 0x3e	; 62
    3b2a:	92 83       	std	Z+2, r25	; 0x02
    3b2c:	81 83       	std	Z+1, r24	; 0x01
    3b2e:	88 ef       	ldi	r24, 0xF8	; 248
    3b30:	91 e0       	ldi	r25, 0x01	; 1
    3b32:	13 96       	adiw	r26, 0x03	; 3
    3b34:	9c 93       	st	X, r25
    3b36:	8e 93       	st	-X, r24
    3b38:	12 97       	sbiw	r26, 0x02	; 2
    3b3a:	33 27       	eor	r19, r19
    3b3c:	27 fd       	sbrc	r18, 7
    3b3e:	30 95       	com	r19
    3b40:	15 96       	adiw	r26, 0x05	; 5
    3b42:	3c 93       	st	X, r19
    3b44:	2e 93       	st	-X, r18
    3b46:	14 97       	sbiw	r26, 0x04	; 4
    3b48:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
      sprintf(menu.newDisplayValue[3], "        ");
    3b4c:	e0 91 e8 02 	lds	r30, 0x02E8
    3b50:	f0 91 e9 02 	lds	r31, 0x02E9
    3b54:	26 81       	ldd	r18, Z+6	; 0x06
    3b56:	37 81       	ldd	r19, Z+7	; 0x07
    3b58:	c9 01       	movw	r24, r18
    3b5a:	dc 01       	movw	r26, r24
    3b5c:	eb e2       	ldi	r30, 0x2B	; 43
    3b5e:	f1 e0       	ldi	r31, 0x01	; 1
    3b60:	89 e0       	ldi	r24, 0x09	; 9
    3b62:	01 90       	ld	r0, Z+
    3b64:	0d 92       	st	X+, r0
    3b66:	81 50       	subi	r24, 0x01	; 1
    3b68:	e1 f7       	brne	.-8      	; 0x3b62 <updateDisplayChangeValues+0x576>
    3b6a:	2d b7       	in	r18, 0x3d	; 61
    3b6c:	3e b7       	in	r19, 0x3e	; 62
    3b6e:	2a 5f       	subi	r18, 0xFA	; 250
    3b70:	3f 4f       	sbci	r19, 0xFF	; 255
    3b72:	0f b6       	in	r0, 0x3f	; 63
    3b74:	f8 94       	cli
    3b76:	3e bf       	out	0x3e, r19	; 62
    3b78:	0f be       	out	0x3f, r0	; 63
    3b7a:	2d bf       	out	0x3d, r18	; 61
    3b7c:	69 cd       	rjmp	.-1326   	; 0x3650 <updateDisplayChangeValues+0x64>
        }
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
    3b7e:	c0 e0       	ldi	r28, 0x00	; 0
    3b80:	d0 e0       	ldi	r29, 0x00	; 0
    3b82:	05 e7       	ldi	r16, 0x75	; 117
    3b84:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3b86:	80 91 e5 02 	lds	r24, 0x02E5
    3b8a:	9e 01       	movw	r18, r28
    3b8c:	90 e0       	ldi	r25, 0x00	; 0
    3b8e:	0c 2e       	mov	r0, r28
    3b90:	02 c0       	rjmp	.+4      	; 0x3b96 <updateDisplayChangeValues+0x5aa>
    3b92:	95 95       	asr	r25
    3b94:	87 95       	ror	r24
    3b96:	0a 94       	dec	r0
    3b98:	e2 f7       	brpl	.-8      	; 0x3b92 <updateDisplayChangeValues+0x5a6>
    3b9a:	80 fd       	sbrc	r24, 0
    3b9c:	46 c0       	rjmp	.+140    	; 0x3c2a <updateDisplayChangeValues+0x63e>
    3b9e:	40 e2       	ldi	r20, 0x20	; 32
    3ba0:	50 e0       	ldi	r21, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
    3ba2:	a0 91 e8 02 	lds	r26, 0x02E8
    3ba6:	b0 91 e9 02 	lds	r27, 0x02E9
    3baa:	f9 01       	movw	r30, r18
    3bac:	ee 0f       	add	r30, r30
    3bae:	ff 1f       	adc	r31, r31
    3bb0:	ee 0f       	add	r30, r30
    3bb2:	ff 1f       	adc	r31, r31
    3bb4:	ee 0f       	add	r30, r30
    3bb6:	ff 1f       	adc	r31, r31
    3bb8:	cf 01       	movw	r24, r30
    3bba:	88 0f       	add	r24, r24
    3bbc:	99 1f       	adc	r25, r25
    3bbe:	88 0f       	add	r24, r24
    3bc0:	99 1f       	adc	r25, r25
    3bc2:	e8 0f       	add	r30, r24
    3bc4:	f9 1f       	adc	r31, r25
    3bc6:	e0 51       	subi	r30, 0x10	; 16
    3bc8:	fc 4f       	sbci	r31, 0xFC	; 252
    3bca:	26 8d       	ldd	r18, Z+30	; 0x1e
    3bcc:	37 8d       	ldd	r19, Z+31	; 0x1f
    3bce:	8d b7       	in	r24, 0x3d	; 61
    3bd0:	9e b7       	in	r25, 0x3e	; 62
    3bd2:	08 97       	sbiw	r24, 0x08	; 8
    3bd4:	0f b6       	in	r0, 0x3f	; 63
    3bd6:	f8 94       	cli
    3bd8:	9e bf       	out	0x3e, r25	; 62
    3bda:	0f be       	out	0x3f, r0	; 63
    3bdc:	8d bf       	out	0x3d, r24	; 61
    3bde:	ed b7       	in	r30, 0x3d	; 61
    3be0:	fe b7       	in	r31, 0x3e	; 62
    3be2:	31 96       	adiw	r30, 0x01	; 1
    3be4:	ce 01       	movw	r24, r28
    3be6:	88 0f       	add	r24, r24
    3be8:	99 1f       	adc	r25, r25
    3bea:	a8 0f       	add	r26, r24
    3bec:	b9 1f       	adc	r27, r25
    3bee:	8d 91       	ld	r24, X+
    3bf0:	9c 91       	ld	r25, X
    3bf2:	ad b7       	in	r26, 0x3d	; 61
    3bf4:	be b7       	in	r27, 0x3e	; 62
    3bf6:	12 96       	adiw	r26, 0x02	; 2
    3bf8:	9c 93       	st	X, r25
    3bfa:	8e 93       	st	-X, r24
    3bfc:	11 97       	sbiw	r26, 0x01	; 1
    3bfe:	13 83       	std	Z+3, r17	; 0x03
    3c00:	02 83       	std	Z+2, r16	; 0x02
    3c02:	55 83       	std	Z+5, r21	; 0x05
    3c04:	44 83       	std	Z+4, r20	; 0x04
    3c06:	37 83       	std	Z+7, r19	; 0x07
    3c08:	26 83       	std	Z+6, r18	; 0x06
    3c0a:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3c0e:	21 96       	adiw	r28, 0x01	; 1
        }
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
    3c10:	ed b7       	in	r30, 0x3d	; 61
    3c12:	fe b7       	in	r31, 0x3e	; 62
    3c14:	38 96       	adiw	r30, 0x08	; 8
    3c16:	0f b6       	in	r0, 0x3f	; 63
    3c18:	f8 94       	cli
    3c1a:	fe bf       	out	0x3e, r31	; 62
    3c1c:	0f be       	out	0x3f, r0	; 63
    3c1e:	ed bf       	out	0x3d, r30	; 61
    3c20:	c4 30       	cpi	r28, 0x04	; 4
    3c22:	d1 05       	cpc	r29, r1
    3c24:	09 f0       	breq	.+2      	; 0x3c28 <updateDisplayChangeValues+0x63c>
    3c26:	af cf       	rjmp	.-162    	; 0x3b86 <updateDisplayChangeValues+0x59a>
    3c28:	13 cd       	rjmp	.-1498   	; 0x3650 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3c2a:	4e e7       	ldi	r20, 0x7E	; 126
    3c2c:	50 e0       	ldi	r21, 0x00	; 0
    3c2e:	b9 cf       	rjmp	.-142    	; 0x3ba2 <updateDisplayChangeValues+0x5b6>
      }
      break;

    case MENU_SAVE_CONFIG:
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Save all");
    3c30:	e0 91 e8 02 	lds	r30, 0x02E8
    3c34:	f0 91 e9 02 	lds	r31, 0x02E9
    3c38:	20 81       	ld	r18, Z
    3c3a:	31 81       	ldd	r19, Z+1	; 0x01
    3c3c:	c9 01       	movw	r24, r18
    3c3e:	dc 01       	movw	r26, r24
    3c40:	ee e9       	ldi	r30, 0x9E	; 158
    3c42:	f1 e0       	ldi	r31, 0x01	; 1
    3c44:	89 e0       	ldi	r24, 0x09	; 9
    3c46:	01 90       	ld	r0, Z+
    3c48:	0d 92       	st	X+, r0
    3c4a:	81 50       	subi	r24, 0x01	; 1
    3c4c:	e1 f7       	brne	.-8      	; 0x3c46 <updateDisplayChangeValues+0x65a>
      sprintf(menu.newDisplayValue[1], " current");
    3c4e:	e0 91 e8 02 	lds	r30, 0x02E8
    3c52:	f0 91 e9 02 	lds	r31, 0x02E9
    3c56:	22 81       	ldd	r18, Z+2	; 0x02
    3c58:	33 81       	ldd	r19, Z+3	; 0x03
    3c5a:	c9 01       	movw	r24, r18
    3c5c:	dc 01       	movw	r26, r24
    3c5e:	e7 ea       	ldi	r30, 0xA7	; 167
    3c60:	f1 e0       	ldi	r31, 0x01	; 1
    3c62:	89 e0       	ldi	r24, 0x09	; 9
    3c64:	01 90       	ld	r0, Z+
    3c66:	0d 92       	st	X+, r0
    3c68:	81 50       	subi	r24, 0x01	; 1
    3c6a:	e1 f7       	brne	.-8      	; 0x3c64 <updateDisplayChangeValues+0x678>
      sprintf(menu.newDisplayValue[2], "configur");
    3c6c:	e0 91 e8 02 	lds	r30, 0x02E8
    3c70:	f0 91 e9 02 	lds	r31, 0x02E9
    3c74:	24 81       	ldd	r18, Z+4	; 0x04
    3c76:	35 81       	ldd	r19, Z+5	; 0x05
    3c78:	c9 01       	movw	r24, r18
    3c7a:	dc 01       	movw	r26, r24
    3c7c:	e0 eb       	ldi	r30, 0xB0	; 176
    3c7e:	f1 e0       	ldi	r31, 0x01	; 1
    3c80:	89 e0       	ldi	r24, 0x09	; 9
    3c82:	01 90       	ld	r0, Z+
    3c84:	0d 92       	st	X+, r0
    3c86:	81 50       	subi	r24, 0x01	; 1
    3c88:	e1 f7       	brne	.-8      	; 0x3c82 <updateDisplayChangeValues+0x696>
      sprintf(menu.newDisplayValue[3], "ations  ");
    3c8a:	e0 91 e8 02 	lds	r30, 0x02E8
    3c8e:	f0 91 e9 02 	lds	r31, 0x02E9
    3c92:	26 81       	ldd	r18, Z+6	; 0x06
    3c94:	37 81       	ldd	r19, Z+7	; 0x07
    3c96:	c9 01       	movw	r24, r18
    3c98:	dc 01       	movw	r26, r24
    3c9a:	e9 eb       	ldi	r30, 0xB9	; 185
    3c9c:	f1 e0       	ldi	r31, 0x01	; 1
    3c9e:	89 e0       	ldi	r24, 0x09	; 9
    3ca0:	01 90       	ld	r0, Z+
    3ca2:	0d 92       	st	X+, r0
    3ca4:	81 50       	subi	r24, 0x01	; 1
    3ca6:	e1 f7       	brne	.-8      	; 0x3ca0 <updateDisplayChangeValues+0x6b4>
    3ca8:	d3 cc       	rjmp	.-1626   	; 0x3650 <updateDisplayChangeValues+0x64>
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
    3caa:	e0 91 e8 02 	lds	r30, 0x02E8
    3cae:	f0 91 e9 02 	lds	r31, 0x02E9
    3cb2:	20 81       	ld	r18, Z
    3cb4:	31 81       	ldd	r19, Z+1	; 0x01
    3cb6:	c9 01       	movw	r24, r18
    3cb8:	dc 01       	movw	r26, r24
    3cba:	e2 e2       	ldi	r30, 0x22	; 34
    3cbc:	f1 e0       	ldi	r31, 0x01	; 1
    3cbe:	89 e0       	ldi	r24, 0x09	; 9
    3cc0:	01 90       	ld	r0, Z+
    3cc2:	0d 92       	st	X+, r0
    3cc4:	81 50       	subi	r24, 0x01	; 1
    3cc6:	e1 f7       	brne	.-8      	; 0x3cc0 <updateDisplayChangeValues+0x6d4>
      sprintf(menu.newDisplayValue[1], "        ");
    3cc8:	e0 91 e8 02 	lds	r30, 0x02E8
    3ccc:	f0 91 e9 02 	lds	r31, 0x02E9
    3cd0:	22 81       	ldd	r18, Z+2	; 0x02
    3cd2:	33 81       	ldd	r19, Z+3	; 0x03
    3cd4:	c9 01       	movw	r24, r18
    3cd6:	dc 01       	movw	r26, r24
    3cd8:	eb e2       	ldi	r30, 0x2B	; 43
    3cda:	f1 e0       	ldi	r31, 0x01	; 1
    3cdc:	89 e0       	ldi	r24, 0x09	; 9
    3cde:	01 90       	ld	r0, Z+
    3ce0:	0d 92       	st	X+, r0
    3ce2:	81 50       	subi	r24, 0x01	; 1
    3ce4:	e1 f7       	brne	.-8      	; 0x3cde <updateDisplayChangeValues+0x6f2>
      sprintf(menu.newDisplayValue[2], "Firmware");
    3ce6:	e0 91 e8 02 	lds	r30, 0x02E8
    3cea:	f0 91 e9 02 	lds	r31, 0x02E9
    3cee:	24 81       	ldd	r18, Z+4	; 0x04
    3cf0:	35 81       	ldd	r19, Z+5	; 0x05
    3cf2:	c9 01       	movw	r24, r18
    3cf4:	dc 01       	movw	r26, r24
    3cf6:	e4 e3       	ldi	r30, 0x34	; 52
    3cf8:	f1 e0       	ldi	r31, 0x01	; 1
    3cfa:	89 e0       	ldi	r24, 0x09	; 9
    3cfc:	01 90       	ld	r0, Z+
    3cfe:	0d 92       	st	X+, r0
    3d00:	81 50       	subi	r24, 0x01	; 1
    3d02:	e1 f7       	brne	.-8      	; 0x3cfc <updateDisplayChangeValues+0x710>
      sprintf(menu.newDisplayValue[3], FW_VERSION);
    3d04:	e0 91 e8 02 	lds	r30, 0x02E8
    3d08:	f0 91 e9 02 	lds	r31, 0x02E9
    3d0c:	26 81       	ldd	r18, Z+6	; 0x06
    3d0e:	37 81       	ldd	r19, Z+7	; 0x07
    3d10:	c9 01       	movw	r24, r18
    3d12:	dc 01       	movw	r26, r24
    3d14:	ed e3       	ldi	r30, 0x3D	; 61
    3d16:	f1 e0       	ldi	r31, 0x01	; 1
    3d18:	87 e0       	ldi	r24, 0x07	; 7
    3d1a:	01 90       	ld	r0, Z+
    3d1c:	0d 92       	st	X+, r0
    3d1e:	81 50       	subi	r24, 0x01	; 1
    3d20:	e1 f7       	brne	.-8      	; 0x3d1a <updateDisplayChangeValues+0x72e>
    3d22:	96 cc       	rjmp	.-1748   	; 0x3650 <updateDisplayChangeValues+0x64>
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    3d24:	e0 91 e8 02 	lds	r30, 0x02E8
    3d28:	f0 91 e9 02 	lds	r31, 0x02E9
    3d2c:	ee 0d       	add	r30, r14
    3d2e:	ff 1d       	adc	r31, r15
    3d30:	00 81       	ld	r16, Z
    3d32:	11 81       	ldd	r17, Z+1	; 0x01
    3d34:	f9 01       	movw	r30, r18
    3d36:	ee 0f       	add	r30, r30
    3d38:	ff 1f       	adc	r31, r31
    3d3a:	ee 0f       	add	r30, r30
    3d3c:	ff 1f       	adc	r31, r31
    3d3e:	ee 0f       	add	r30, r30
    3d40:	ff 1f       	adc	r31, r31
    3d42:	cf 01       	movw	r24, r30
    3d44:	88 0f       	add	r24, r24
    3d46:	99 1f       	adc	r25, r25
    3d48:	88 0f       	add	r24, r24
    3d4a:	99 1f       	adc	r25, r25
    3d4c:	e8 0f       	add	r30, r24
    3d4e:	f9 1f       	adc	r31, r25
    3d50:	e0 51       	subi	r30, 0x10	; 16
    3d52:	fc 4f       	sbci	r31, 0xFC	; 252
    3d54:	60 81       	ld	r22, Z
    3d56:	71 81       	ldd	r23, Z+1	; 0x01
    3d58:	84 2f       	mov	r24, r20
    3d5a:	0e 94 23 08 	call	0x1046	; 0x1046 <stepsToRadian>
    3d5e:	2d b7       	in	r18, 0x3d	; 61
    3d60:	3e b7       	in	r19, 0x3e	; 62
    3d62:	2c 50       	subi	r18, 0x0C	; 12
    3d64:	30 40       	sbci	r19, 0x00	; 0
    3d66:	0f b6       	in	r0, 0x3f	; 63
    3d68:	f8 94       	cli
    3d6a:	3e bf       	out	0x3e, r19	; 62
    3d6c:	0f be       	out	0x3f, r0	; 63
    3d6e:	2d bf       	out	0x3d, r18	; 61
    3d70:	ed b7       	in	r30, 0x3d	; 61
    3d72:	fe b7       	in	r31, 0x3e	; 62
    3d74:	31 96       	adiw	r30, 0x01	; 1
    3d76:	ad b7       	in	r26, 0x3d	; 61
    3d78:	be b7       	in	r27, 0x3e	; 62
    3d7a:	12 96       	adiw	r26, 0x02	; 2
    3d7c:	1c 93       	st	X, r17
    3d7e:	0e 93       	st	-X, r16
    3d80:	11 97       	sbiw	r26, 0x01	; 1
    3d82:	73 82       	std	Z+3, r7	; 0x03
    3d84:	62 82       	std	Z+2, r6	; 0x02
    3d86:	d4 82       	std	Z+4, r13	; 0x04
    3d88:	15 82       	std	Z+5, r1	; 0x05
    3d8a:	66 83       	std	Z+6, r22	; 0x06
    3d8c:	77 83       	std	Z+7, r23	; 0x07
    3d8e:	80 87       	std	Z+8, r24	; 0x08
    3d90:	91 87       	std	Z+9, r25	; 0x09
    3d92:	53 86       	std	Z+11, r5	; 0x0b
    3d94:	42 86       	std	Z+10, r4	; 0x0a
    3d96:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3d9a:	ed b7       	in	r30, 0x3d	; 61
    3d9c:	fe b7       	in	r31, 0x3e	; 62
    3d9e:	3c 96       	adiw	r30, 0x0c	; 12
    3da0:	0f b6       	in	r0, 0x3f	; 63
    3da2:	f8 94       	cli
    3da4:	fe bf       	out	0x3e, r31	; 62
    3da6:	0f be       	out	0x3f, r0	; 63
    3da8:	ed bf       	out	0x3d, r30	; 61
    3daa:	cb cd       	rjmp	.-1130   	; 0x3942 <updateDisplayChangeValues+0x356>
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
            break;

          case MOTOR_STEP_UNIT_DEGREE:
            /* 0xDF is the display code for the degree-circle */
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
    3dac:	e0 91 e8 02 	lds	r30, 0x02E8
    3db0:	f0 91 e9 02 	lds	r31, 0x02E9
    3db4:	ee 0d       	add	r30, r14
    3db6:	ff 1d       	adc	r31, r15
    3db8:	00 81       	ld	r16, Z
    3dba:	11 81       	ldd	r17, Z+1	; 0x01
    3dbc:	f9 01       	movw	r30, r18
    3dbe:	ee 0f       	add	r30, r30
    3dc0:	ff 1f       	adc	r31, r31
    3dc2:	ee 0f       	add	r30, r30
    3dc4:	ff 1f       	adc	r31, r31
    3dc6:	ee 0f       	add	r30, r30
    3dc8:	ff 1f       	adc	r31, r31
    3dca:	cf 01       	movw	r24, r30
    3dcc:	88 0f       	add	r24, r24
    3dce:	99 1f       	adc	r25, r25
    3dd0:	88 0f       	add	r24, r24
    3dd2:	99 1f       	adc	r25, r25
    3dd4:	e8 0f       	add	r30, r24
    3dd6:	f9 1f       	adc	r31, r25
    3dd8:	e0 51       	subi	r30, 0x10	; 16
    3dda:	fc 4f       	sbci	r31, 0xFC	; 252
    3ddc:	60 81       	ld	r22, Z
    3dde:	71 81       	ldd	r23, Z+1	; 0x01
    3de0:	84 2f       	mov	r24, r20
    3de2:	0e 94 9e 07 	call	0xf3c	; 0xf3c <stepsToDegree>
    3de6:	2d b7       	in	r18, 0x3d	; 61
    3de8:	3e b7       	in	r19, 0x3e	; 62
    3dea:	2c 50       	subi	r18, 0x0C	; 12
    3dec:	30 40       	sbci	r19, 0x00	; 0
    3dee:	0f b6       	in	r0, 0x3f	; 63
    3df0:	f8 94       	cli
    3df2:	3e bf       	out	0x3e, r19	; 62
    3df4:	0f be       	out	0x3f, r0	; 63
    3df6:	2d bf       	out	0x3d, r18	; 61
    3df8:	ed b7       	in	r30, 0x3d	; 61
    3dfa:	fe b7       	in	r31, 0x3e	; 62
    3dfc:	31 96       	adiw	r30, 0x01	; 1
    3dfe:	ad b7       	in	r26, 0x3d	; 61
    3e00:	be b7       	in	r27, 0x3e	; 62
    3e02:	12 96       	adiw	r26, 0x02	; 2
    3e04:	1c 93       	st	X, r17
    3e06:	0e 93       	st	-X, r16
    3e08:	11 97       	sbiw	r26, 0x01	; 1
    3e0a:	b3 82       	std	Z+3, r11	; 0x03
    3e0c:	a2 82       	std	Z+2, r10	; 0x02
    3e0e:	d4 82       	std	Z+4, r13	; 0x04
    3e10:	15 82       	std	Z+5, r1	; 0x05
    3e12:	66 83       	std	Z+6, r22	; 0x06
    3e14:	77 83       	std	Z+7, r23	; 0x07
    3e16:	80 87       	std	Z+8, r24	; 0x08
    3e18:	91 87       	std	Z+9, r25	; 0x09
    3e1a:	93 86       	std	Z+11, r9	; 0x0b
    3e1c:	82 86       	std	Z+10, r8	; 0x0a
    3e1e:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3e22:	ed b7       	in	r30, 0x3d	; 61
    3e24:	fe b7       	in	r31, 0x3e	; 62
    3e26:	3c 96       	adiw	r30, 0x0c	; 12
    3e28:	0f b6       	in	r0, 0x3f	; 63
    3e2a:	f8 94       	cli
    3e2c:	fe bf       	out	0x3e, r31	; 62
    3e2e:	0f be       	out	0x3f, r0	; 63
    3e30:	ed bf       	out	0x3d, r30	; 61
    3e32:	87 cd       	rjmp	.-1266   	; 0x3942 <updateDisplayChangeValues+0x356>
        }
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
    3e34:	c0 e0       	ldi	r28, 0x00	; 0
    3e36:	d0 e0       	ldi	r29, 0x00	; 0
    3e38:	0d e7       	ldi	r16, 0x7D	; 125
    3e3a:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3e3c:	80 91 e5 02 	lds	r24, 0x02E5
    3e40:	9e 01       	movw	r18, r28
    3e42:	90 e0       	ldi	r25, 0x00	; 0
    3e44:	0c 2e       	mov	r0, r28
    3e46:	02 c0       	rjmp	.+4      	; 0x3e4c <updateDisplayChangeValues+0x860>
    3e48:	95 95       	asr	r25
    3e4a:	87 95       	ror	r24
    3e4c:	0a 94       	dec	r0
    3e4e:	e2 f7       	brpl	.-8      	; 0x3e48 <updateDisplayChangeValues+0x85c>
    3e50:	80 fd       	sbrc	r24, 0
    3e52:	4a c0       	rjmp	.+148    	; 0x3ee8 <updateDisplayChangeValues+0x8fc>
    3e54:	60 e2       	ldi	r22, 0x20	; 32
    3e56:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
    3e58:	a0 91 e8 02 	lds	r26, 0x02E8
    3e5c:	b0 91 e9 02 	lds	r27, 0x02E9
    3e60:	f9 01       	movw	r30, r18
    3e62:	ee 0f       	add	r30, r30
    3e64:	ff 1f       	adc	r31, r31
    3e66:	ee 0f       	add	r30, r30
    3e68:	ff 1f       	adc	r31, r31
    3e6a:	ee 0f       	add	r30, r30
    3e6c:	ff 1f       	adc	r31, r31
    3e6e:	cf 01       	movw	r24, r30
    3e70:	88 0f       	add	r24, r24
    3e72:	99 1f       	adc	r25, r25
    3e74:	88 0f       	add	r24, r24
    3e76:	99 1f       	adc	r25, r25
    3e78:	e8 0f       	add	r30, r24
    3e7a:	f9 1f       	adc	r31, r25
    3e7c:	e0 51       	subi	r30, 0x10	; 16
    3e7e:	fc 4f       	sbci	r31, 0xFC	; 252
    3e80:	22 8d       	ldd	r18, Z+26	; 0x1a
    3e82:	33 8d       	ldd	r19, Z+27	; 0x1b
    3e84:	44 8d       	ldd	r20, Z+28	; 0x1c
    3e86:	55 8d       	ldd	r21, Z+29	; 0x1d
    3e88:	8d b7       	in	r24, 0x3d	; 61
    3e8a:	9e b7       	in	r25, 0x3e	; 62
    3e8c:	0a 97       	sbiw	r24, 0x0a	; 10
    3e8e:	0f b6       	in	r0, 0x3f	; 63
    3e90:	f8 94       	cli
    3e92:	9e bf       	out	0x3e, r25	; 62
    3e94:	0f be       	out	0x3f, r0	; 63
    3e96:	8d bf       	out	0x3d, r24	; 61
    3e98:	ed b7       	in	r30, 0x3d	; 61
    3e9a:	fe b7       	in	r31, 0x3e	; 62
    3e9c:	31 96       	adiw	r30, 0x01	; 1
    3e9e:	ce 01       	movw	r24, r28
    3ea0:	88 0f       	add	r24, r24
    3ea2:	99 1f       	adc	r25, r25
    3ea4:	a8 0f       	add	r26, r24
    3ea6:	b9 1f       	adc	r27, r25
    3ea8:	8d 91       	ld	r24, X+
    3eaa:	9c 91       	ld	r25, X
    3eac:	ad b7       	in	r26, 0x3d	; 61
    3eae:	be b7       	in	r27, 0x3e	; 62
    3eb0:	12 96       	adiw	r26, 0x02	; 2
    3eb2:	9c 93       	st	X, r25
    3eb4:	8e 93       	st	-X, r24
    3eb6:	11 97       	sbiw	r26, 0x01	; 1
    3eb8:	13 83       	std	Z+3, r17	; 0x03
    3eba:	02 83       	std	Z+2, r16	; 0x02
    3ebc:	75 83       	std	Z+5, r23	; 0x05
    3ebe:	64 83       	std	Z+4, r22	; 0x04
    3ec0:	26 83       	std	Z+6, r18	; 0x06
    3ec2:	37 83       	std	Z+7, r19	; 0x07
    3ec4:	40 87       	std	Z+8, r20	; 0x08
    3ec6:	51 87       	std	Z+9, r21	; 0x09
    3ec8:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3ecc:	21 96       	adiw	r28, 0x01	; 1
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
    3ece:	ed b7       	in	r30, 0x3d	; 61
    3ed0:	fe b7       	in	r31, 0x3e	; 62
    3ed2:	3a 96       	adiw	r30, 0x0a	; 10
    3ed4:	0f b6       	in	r0, 0x3f	; 63
    3ed6:	f8 94       	cli
    3ed8:	fe bf       	out	0x3e, r31	; 62
    3eda:	0f be       	out	0x3f, r0	; 63
    3edc:	ed bf       	out	0x3d, r30	; 61
    3ede:	c4 30       	cpi	r28, 0x04	; 4
    3ee0:	d1 05       	cpc	r29, r1
    3ee2:	09 f0       	breq	.+2      	; 0x3ee6 <updateDisplayChangeValues+0x8fa>
    3ee4:	ab cf       	rjmp	.-170    	; 0x3e3c <updateDisplayChangeValues+0x850>
    3ee6:	b4 cb       	rjmp	.-2200   	; 0x3650 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3ee8:	6e e7       	ldi	r22, 0x7E	; 126
    3eea:	70 e0       	ldi	r23, 0x00	; 0
    3eec:	b5 cf       	rjmp	.-150    	; 0x3e58 <updateDisplayChangeValues+0x86c>
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Load all");
      sprintf(menu.newDisplayValue[1], " saved  ");
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;
    3eee:	c0 e0       	ldi	r28, 0x00	; 0
    3ef0:	d0 e0       	ldi	r29, 0x00	; 0
    3ef2:	04 e4       	ldi	r16, 0x44	; 68
    3ef4:	11 e0       	ldi	r17, 0x01	; 1

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    3ef6:	80 91 e5 02 	lds	r24, 0x02E5
    3efa:	9e 01       	movw	r18, r28
    3efc:	90 e0       	ldi	r25, 0x00	; 0
    3efe:	0c 2e       	mov	r0, r28
    3f00:	02 c0       	rjmp	.+4      	; 0x3f06 <updateDisplayChangeValues+0x91a>
    3f02:	95 95       	asr	r25
    3f04:	87 95       	ror	r24
    3f06:	0a 94       	dec	r0
    3f08:	e2 f7       	brpl	.-8      	; 0x3f02 <updateDisplayChangeValues+0x916>
    3f0a:	80 fd       	sbrc	r24, 0
    3f0c:	48 c0       	rjmp	.+144    	; 0x3f9e <updateDisplayChangeValues+0x9b2>
    3f0e:	40 e2       	ldi	r20, 0x20	; 32
    3f10:	50 e0       	ldi	r21, 0x00	; 0
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].opticalZeroPosition);
    3f12:	a0 91 e8 02 	lds	r26, 0x02E8
    3f16:	b0 91 e9 02 	lds	r27, 0x02E9
    3f1a:	c9 01       	movw	r24, r18
    3f1c:	f9 01       	movw	r30, r18
    3f1e:	ee 0f       	add	r30, r30
    3f20:	ff 1f       	adc	r31, r31
    3f22:	ee 0f       	add	r30, r30
    3f24:	ff 1f       	adc	r31, r31
    3f26:	ee 0f       	add	r30, r30
    3f28:	ff 1f       	adc	r31, r31
    3f2a:	88 0f       	add	r24, r24
    3f2c:	99 1f       	adc	r25, r25
    3f2e:	e8 0f       	add	r30, r24
    3f30:	f9 1f       	adc	r31, r25
    3f32:	ee 0f       	add	r30, r30
    3f34:	ff 1f       	adc	r31, r31
    3f36:	ee 0f       	add	r30, r30
    3f38:	ff 1f       	adc	r31, r31
    3f3a:	ec 50       	subi	r30, 0x0C	; 12
    3f3c:	fc 4f       	sbci	r31, 0xFC	; 252
    3f3e:	20 81       	ld	r18, Z
    3f40:	31 81       	ldd	r19, Z+1	; 0x01
    3f42:	8d b7       	in	r24, 0x3d	; 61
    3f44:	9e b7       	in	r25, 0x3e	; 62
    3f46:	08 97       	sbiw	r24, 0x08	; 8
    3f48:	0f b6       	in	r0, 0x3f	; 63
    3f4a:	f8 94       	cli
    3f4c:	9e bf       	out	0x3e, r25	; 62
    3f4e:	0f be       	out	0x3f, r0	; 63
    3f50:	8d bf       	out	0x3d, r24	; 61
    3f52:	ed b7       	in	r30, 0x3d	; 61
    3f54:	fe b7       	in	r31, 0x3e	; 62
    3f56:	31 96       	adiw	r30, 0x01	; 1
    3f58:	ce 01       	movw	r24, r28
    3f5a:	88 0f       	add	r24, r24
    3f5c:	99 1f       	adc	r25, r25
    3f5e:	a8 0f       	add	r26, r24
    3f60:	b9 1f       	adc	r27, r25
    3f62:	8d 91       	ld	r24, X+
    3f64:	9c 91       	ld	r25, X
    3f66:	ad b7       	in	r26, 0x3d	; 61
    3f68:	be b7       	in	r27, 0x3e	; 62
    3f6a:	12 96       	adiw	r26, 0x02	; 2
    3f6c:	9c 93       	st	X, r25
    3f6e:	8e 93       	st	-X, r24
    3f70:	11 97       	sbiw	r26, 0x01	; 1
    3f72:	13 83       	std	Z+3, r17	; 0x03
    3f74:	02 83       	std	Z+2, r16	; 0x02
    3f76:	55 83       	std	Z+5, r21	; 0x05
    3f78:	44 83       	std	Z+4, r20	; 0x04
    3f7a:	37 83       	std	Z+7, r19	; 0x07
    3f7c:	26 83       	std	Z+6, r18	; 0x06
    3f7e:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    3f82:	21 96       	adiw	r28, 0x01	; 1
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
    3f84:	ed b7       	in	r30, 0x3d	; 61
    3f86:	fe b7       	in	r31, 0x3e	; 62
    3f88:	38 96       	adiw	r30, 0x08	; 8
    3f8a:	0f b6       	in	r0, 0x3f	; 63
    3f8c:	f8 94       	cli
    3f8e:	fe bf       	out	0x3e, r31	; 62
    3f90:	0f be       	out	0x3f, r0	; 63
    3f92:	ed bf       	out	0x3d, r30	; 61
    3f94:	c4 30       	cpi	r28, 0x04	; 4
    3f96:	d1 05       	cpc	r29, r1
    3f98:	09 f0       	breq	.+2      	; 0x3f9c <updateDisplayChangeValues+0x9b0>
    3f9a:	ad cf       	rjmp	.-166    	; 0x3ef6 <updateDisplayChangeValues+0x90a>
    3f9c:	59 cb       	rjmp	.-2382   	; 0x3650 <updateDisplayChangeValues+0x64>
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3f9e:	80 91 e2 02 	lds	r24, 0x02E2
    3fa2:	88 23       	and	r24, r24
    3fa4:	09 f4       	brne	.+2      	; 0x3fa8 <updateDisplayChangeValues+0x9bc>
    3fa6:	6d c1       	rjmp	.+730    	; 0x4282 <__stack+0x183>
    3fa8:	4e e3       	ldi	r20, 0x3E	; 62
    3faa:	50 e0       	ldi	r21, 0x00	; 0
    3fac:	b2 cf       	rjmp	.-156    	; 0x3f12 <updateDisplayChangeValues+0x926>
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    3fae:	c0 e0       	ldi	r28, 0x00	; 0
    3fb0:	d0 e0       	ldi	r29, 0x00	; 0
    3fb2:	07 e9       	ldi	r16, 0x97	; 151
    3fb4:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_CHANGE_SUBSTEPS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3fb6:	80 91 e5 02 	lds	r24, 0x02E5
    3fba:	9e 01       	movw	r18, r28
    3fbc:	90 e0       	ldi	r25, 0x00	; 0
    3fbe:	0c 2e       	mov	r0, r28
    3fc0:	02 c0       	rjmp	.+4      	; 0x3fc6 <updateDisplayChangeValues+0x9da>
    3fc2:	95 95       	asr	r25
    3fc4:	87 95       	ror	r24
    3fc6:	0a 94       	dec	r0
    3fc8:	e2 f7       	brpl	.-8      	; 0x3fc2 <updateDisplayChangeValues+0x9d6>
    3fca:	80 fd       	sbrc	r24, 0
    3fcc:	4a c0       	rjmp	.+148    	; 0x4062 <updateDisplayChangeValues+0xa76>
    3fce:	60 e2       	ldi	r22, 0x20	; 32
    3fd0:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.0f", c, motor[i].subSteps);
    3fd2:	a0 91 e8 02 	lds	r26, 0x02E8
    3fd6:	b0 91 e9 02 	lds	r27, 0x02E9
    3fda:	f9 01       	movw	r30, r18
    3fdc:	ee 0f       	add	r30, r30
    3fde:	ff 1f       	adc	r31, r31
    3fe0:	ee 0f       	add	r30, r30
    3fe2:	ff 1f       	adc	r31, r31
    3fe4:	ee 0f       	add	r30, r30
    3fe6:	ff 1f       	adc	r31, r31
    3fe8:	cf 01       	movw	r24, r30
    3fea:	88 0f       	add	r24, r24
    3fec:	99 1f       	adc	r25, r25
    3fee:	88 0f       	add	r24, r24
    3ff0:	99 1f       	adc	r25, r25
    3ff2:	e8 0f       	add	r30, r24
    3ff4:	f9 1f       	adc	r31, r25
    3ff6:	e0 51       	subi	r30, 0x10	; 16
    3ff8:	fc 4f       	sbci	r31, 0xFC	; 252
    3ffa:	25 89       	ldd	r18, Z+21	; 0x15
    3ffc:	36 89       	ldd	r19, Z+22	; 0x16
    3ffe:	47 89       	ldd	r20, Z+23	; 0x17
    4000:	50 8d       	ldd	r21, Z+24	; 0x18
    4002:	8d b7       	in	r24, 0x3d	; 61
    4004:	9e b7       	in	r25, 0x3e	; 62
    4006:	0a 97       	sbiw	r24, 0x0a	; 10
    4008:	0f b6       	in	r0, 0x3f	; 63
    400a:	f8 94       	cli
    400c:	9e bf       	out	0x3e, r25	; 62
    400e:	0f be       	out	0x3f, r0	; 63
    4010:	8d bf       	out	0x3d, r24	; 61
    4012:	ed b7       	in	r30, 0x3d	; 61
    4014:	fe b7       	in	r31, 0x3e	; 62
    4016:	31 96       	adiw	r30, 0x01	; 1
    4018:	ce 01       	movw	r24, r28
    401a:	88 0f       	add	r24, r24
    401c:	99 1f       	adc	r25, r25
    401e:	a8 0f       	add	r26, r24
    4020:	b9 1f       	adc	r27, r25
    4022:	8d 91       	ld	r24, X+
    4024:	9c 91       	ld	r25, X
    4026:	ad b7       	in	r26, 0x3d	; 61
    4028:	be b7       	in	r27, 0x3e	; 62
    402a:	12 96       	adiw	r26, 0x02	; 2
    402c:	9c 93       	st	X, r25
    402e:	8e 93       	st	-X, r24
    4030:	11 97       	sbiw	r26, 0x01	; 1
    4032:	13 83       	std	Z+3, r17	; 0x03
    4034:	02 83       	std	Z+2, r16	; 0x02
    4036:	75 83       	std	Z+5, r23	; 0x05
    4038:	64 83       	std	Z+4, r22	; 0x04
    403a:	26 83       	std	Z+6, r18	; 0x06
    403c:	37 83       	std	Z+7, r19	; 0x07
    403e:	40 87       	std	Z+8, r20	; 0x08
    4040:	51 87       	std	Z+9, r21	; 0x09
    4042:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4046:	21 96       	adiw	r28, 0x01	; 1
        }
      }
      break;

    case MENU_CHANGE_SUBSTEPS:
      for(i = 0; i <= MAX_MOTOR; i++){
    4048:	ed b7       	in	r30, 0x3d	; 61
    404a:	fe b7       	in	r31, 0x3e	; 62
    404c:	3a 96       	adiw	r30, 0x0a	; 10
    404e:	0f b6       	in	r0, 0x3f	; 63
    4050:	f8 94       	cli
    4052:	fe bf       	out	0x3e, r31	; 62
    4054:	0f be       	out	0x3f, r0	; 63
    4056:	ed bf       	out	0x3d, r30	; 61
    4058:	c4 30       	cpi	r28, 0x04	; 4
    405a:	d1 05       	cpc	r29, r1
    405c:	09 f0       	breq	.+2      	; 0x4060 <updateDisplayChangeValues+0xa74>
    405e:	ab cf       	rjmp	.-170    	; 0x3fb6 <updateDisplayChangeValues+0x9ca>
    4060:	f7 ca       	rjmp	.-2578   	; 0x3650 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    4062:	6e e7       	ldi	r22, 0x7E	; 126
    4064:	70 e0       	ldi	r23, 0x00	; 0
    4066:	b5 cf       	rjmp	.-150    	; 0x3fd2 <updateDisplayChangeValues+0x9e6>
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
    4068:	40 e0       	ldi	r20, 0x00	; 0
    406a:	50 e0       	ldi	r21, 0x00	; 0
    406c:	00 e0       	ldi	r16, 0x00	; 0
    406e:	10 e0       	ldi	r17, 0x00	; 0
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          sprintf(menu.newDisplayValue[i], "%cMot %d", c, i+1);
    4070:	7e e8       	ldi	r23, 0x8E	; 142
    4072:	e7 2e       	mov	r14, r23
    4074:	71 e0       	ldi	r23, 0x01	; 1
    4076:	f7 2e       	mov	r15, r23
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    4078:	80 91 e5 02 	lds	r24, 0x02E5
    407c:	90 e0       	ldi	r25, 0x00	; 0
    407e:	04 2e       	mov	r0, r20
    4080:	02 c0       	rjmp	.+4      	; 0x4086 <updateDisplayChangeValues+0xa9a>
    4082:	95 95       	asr	r25
    4084:	87 95       	ror	r24
    4086:	0a 94       	dec	r0
    4088:	e2 f7       	brpl	.-8      	; 0x4082 <updateDisplayChangeValues+0xa96>
    408a:	80 fd       	sbrc	r24, 0
    408c:	21 c0       	rjmp	.+66     	; 0x40d0 <updateDisplayChangeValues+0xae4>
    408e:	20 e2       	ldi	r18, 0x20	; 32
        if(forbiddenZone[i].active){
    4090:	fa 01       	movw	r30, r20
    4092:	ee 0f       	add	r30, r30
    4094:	ff 1f       	adc	r31, r31
    4096:	ee 0f       	add	r30, r30
    4098:	ff 1f       	adc	r31, r31
    409a:	e4 0f       	add	r30, r20
    409c:	f5 1f       	adc	r31, r21
    409e:	ed 52       	subi	r30, 0x2D	; 45
    40a0:	fc 4f       	sbci	r31, 0xFC	; 252
    40a2:	84 81       	ldd	r24, Z+4	; 0x04
    40a4:	88 23       	and	r24, r24
    40a6:	b1 f0       	breq	.+44     	; 0x40d4 <updateDisplayChangeValues+0xae8>
          sprintf(menu.newDisplayValue[i], "ForbZone");
    40a8:	e0 91 e8 02 	lds	r30, 0x02E8
    40ac:	f0 91 e9 02 	lds	r31, 0x02E9
    40b0:	e0 0f       	add	r30, r16
    40b2:	f1 1f       	adc	r31, r17
    40b4:	20 81       	ld	r18, Z
    40b6:	31 81       	ldd	r19, Z+1	; 0x01
    40b8:	c9 01       	movw	r24, r18
    40ba:	dc 01       	movw	r26, r24
    40bc:	e5 e8       	ldi	r30, 0x85	; 133
    40be:	f1 e0       	ldi	r31, 0x01	; 1
    40c0:	89 e0       	ldi	r24, 0x09	; 9
    40c2:	01 90       	ld	r0, Z+
    40c4:	0d 92       	st	X+, r0
    40c6:	81 50       	subi	r24, 0x01	; 1
    40c8:	e1 f7       	brne	.-8      	; 0x40c2 <updateDisplayChangeValues+0xad6>
    40ca:	ea 01       	movw	r28, r20
    40cc:	21 96       	adiw	r28, 0x01	; 1
    40ce:	34 c0       	rjmp	.+104    	; 0x4138 <__stack+0x39>
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    40d0:	2e e7       	ldi	r18, 0x7E	; 126
    40d2:	de cf       	rjmp	.-68     	; 0x4090 <updateDisplayChangeValues+0xaa4>
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          sprintf(menu.newDisplayValue[i], "%cMot %d", c, i+1);
    40d4:	e0 91 e8 02 	lds	r30, 0x02E8
    40d8:	f0 91 e9 02 	lds	r31, 0x02E9
    40dc:	8d b7       	in	r24, 0x3d	; 61
    40de:	9e b7       	in	r25, 0x3e	; 62
    40e0:	08 97       	sbiw	r24, 0x08	; 8
    40e2:	0f b6       	in	r0, 0x3f	; 63
    40e4:	f8 94       	cli
    40e6:	9e bf       	out	0x3e, r25	; 62
    40e8:	0f be       	out	0x3f, r0	; 63
    40ea:	8d bf       	out	0x3d, r24	; 61
    40ec:	ad b7       	in	r26, 0x3d	; 61
    40ee:	be b7       	in	r27, 0x3e	; 62
    40f0:	11 96       	adiw	r26, 0x01	; 1
    40f2:	e0 0f       	add	r30, r16
    40f4:	f1 1f       	adc	r31, r17
    40f6:	80 81       	ld	r24, Z
    40f8:	91 81       	ldd	r25, Z+1	; 0x01
    40fa:	ed b7       	in	r30, 0x3d	; 61
    40fc:	fe b7       	in	r31, 0x3e	; 62
    40fe:	92 83       	std	Z+2, r25	; 0x02
    4100:	81 83       	std	Z+1, r24	; 0x01
    4102:	13 96       	adiw	r26, 0x03	; 3
    4104:	fc 92       	st	X, r15
    4106:	ee 92       	st	-X, r14
    4108:	12 97       	sbiw	r26, 0x02	; 2
    410a:	14 96       	adiw	r26, 0x04	; 4
    410c:	2c 93       	st	X, r18
    410e:	14 97       	sbiw	r26, 0x04	; 4
    4110:	15 96       	adiw	r26, 0x05	; 5
    4112:	1c 92       	st	X, r1
    4114:	15 97       	sbiw	r26, 0x05	; 5
    4116:	ea 01       	movw	r28, r20
    4118:	21 96       	adiw	r28, 0x01	; 1
    411a:	17 96       	adiw	r26, 0x07	; 7
    411c:	dc 93       	st	X, r29
    411e:	ce 93       	st	-X, r28
    4120:	16 97       	sbiw	r26, 0x06	; 6
    4122:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4126:	2d b7       	in	r18, 0x3d	; 61
    4128:	3e b7       	in	r19, 0x3e	; 62
    412a:	28 5f       	subi	r18, 0xF8	; 248
    412c:	3f 4f       	sbci	r19, 0xFF	; 255
    412e:	0f b6       	in	r0, 0x3f	; 63
    4130:	f8 94       	cli
    4132:	3e bf       	out	0x3e, r19	; 62
    4134:	0f be       	out	0x3f, r0	; 63
    4136:	2d bf       	out	0x3d, r18	; 61
    4138:	ae 01       	movw	r20, r28
    413a:	0e 5f       	subi	r16, 0xFE	; 254
    413c:	1f 4f       	sbci	r17, 0xFF	; 255
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    413e:	c4 30       	cpi	r28, 0x04	; 4
    4140:	d1 05       	cpc	r29, r1
    4142:	09 f0       	breq	.+2      	; 0x4146 <__stack+0x47>
    4144:	99 cf       	rjmp	.-206    	; 0x4078 <updateDisplayChangeValues+0xa8c>
    4146:	84 ca       	rjmp	.-2808   	; 0x3650 <updateDisplayChangeValues+0x64>
        sprintf(menu.newDisplayValue[i], "%c%.1f A", c, motor[i].current);
      }
      break;
      
    case MENU_SETTINGS:
      sprintf(menu.newDisplayValue[0], "test    ");
    4148:	e0 91 e8 02 	lds	r30, 0x02E8
    414c:	f0 91 e9 02 	lds	r31, 0x02E9
    4150:	20 81       	ld	r18, Z
    4152:	31 81       	ldd	r19, Z+1	; 0x01
    4154:	c9 01       	movw	r24, r18
    4156:	dc 01       	movw	r26, r24
    4158:	e9 e0       	ldi	r30, 0x09	; 9
    415a:	f2 e0       	ldi	r31, 0x02	; 2
    415c:	89 e0       	ldi	r24, 0x09	; 9
    415e:	01 90       	ld	r0, Z+
    4160:	0d 92       	st	X+, r0
    4162:	81 50       	subi	r24, 0x01	; 1
    4164:	e1 f7       	brne	.-8      	; 0x415e <__stack+0x5f>
      sprintf(menu.newDisplayValue[1], "test    ");
    4166:	e0 91 e8 02 	lds	r30, 0x02E8
    416a:	f0 91 e9 02 	lds	r31, 0x02E9
    416e:	22 81       	ldd	r18, Z+2	; 0x02
    4170:	33 81       	ldd	r19, Z+3	; 0x03
    4172:	c9 01       	movw	r24, r18
    4174:	dc 01       	movw	r26, r24
    4176:	e9 e0       	ldi	r30, 0x09	; 9
    4178:	f2 e0       	ldi	r31, 0x02	; 2
    417a:	89 e0       	ldi	r24, 0x09	; 9
    417c:	01 90       	ld	r0, Z+
    417e:	0d 92       	st	X+, r0
    4180:	81 50       	subi	r24, 0x01	; 1
    4182:	e1 f7       	brne	.-8      	; 0x417c <__stack+0x7d>
      sprintf(menu.newDisplayValue[2], "test    ");
    4184:	e0 91 e8 02 	lds	r30, 0x02E8
    4188:	f0 91 e9 02 	lds	r31, 0x02E9
    418c:	24 81       	ldd	r18, Z+4	; 0x04
    418e:	35 81       	ldd	r19, Z+5	; 0x05
    4190:	c9 01       	movw	r24, r18
    4192:	dc 01       	movw	r26, r24
    4194:	e9 e0       	ldi	r30, 0x09	; 9
    4196:	f2 e0       	ldi	r31, 0x02	; 2
    4198:	89 e0       	ldi	r24, 0x09	; 9
    419a:	01 90       	ld	r0, Z+
    419c:	0d 92       	st	X+, r0
    419e:	81 50       	subi	r24, 0x01	; 1
    41a0:	e1 f7       	brne	.-8      	; 0x419a <__stack+0x9b>
      sprintf(menu.newDisplayValue[3], "test    ");
    41a2:	e0 91 e8 02 	lds	r30, 0x02E8
    41a6:	f0 91 e9 02 	lds	r31, 0x02E9
    41aa:	26 81       	ldd	r18, Z+6	; 0x06
    41ac:	37 81       	ldd	r19, Z+7	; 0x07
    41ae:	c9 01       	movw	r24, r18
    41b0:	dc 01       	movw	r26, r24
    41b2:	e9 e0       	ldi	r30, 0x09	; 9
    41b4:	f2 e0       	ldi	r31, 0x02	; 2
    41b6:	89 e0       	ldi	r24, 0x09	; 9
    41b8:	01 90       	ld	r0, Z+
    41ba:	0d 92       	st	X+, r0
    41bc:	81 50       	subi	r24, 0x01	; 1
    41be:	e1 f7       	brne	.-8      	; 0x41b8 <__stack+0xb9>
      menu.currentMenuMode = MENU_SETTINGS_MODE;
    41c0:	85 e0       	ldi	r24, 0x05	; 5
    41c2:	80 93 e4 02 	sts	0x02E4, r24
    41c6:	44 ca       	rjmp	.-2936   	; 0x3650 <updateDisplayChangeValues+0x64>
    case MENU_RUN_PROGRAM:
      sprintf(menu.newDisplayValue[0], "Program ");
      sprintf(menu.newDisplayValue[1], "running ");
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
      sprintf(menu.newDisplayValue[3], "        ");
      break;
    41c8:	c0 e0       	ldi	r28, 0x00	; 0
    41ca:	d0 e0       	ldi	r29, 0x00	; 0
    41cc:	00 e0       	ldi	r16, 0x00	; 0
    41ce:	12 e0       	ldi	r17, 0x02	; 2
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    41d0:	80 91 e5 02 	lds	r24, 0x02E5
    41d4:	9e 01       	movw	r18, r28
    41d6:	90 e0       	ldi	r25, 0x00	; 0
    41d8:	0c 2e       	mov	r0, r28
    41da:	02 c0       	rjmp	.+4      	; 0x41e0 <__stack+0xe1>
    41dc:	95 95       	asr	r25
    41de:	87 95       	ror	r24
    41e0:	0a 94       	dec	r0
    41e2:	e2 f7       	brpl	.-8      	; 0x41dc <__stack+0xdd>
    41e4:	80 fd       	sbrc	r24, 0
    41e6:	4a c0       	rjmp	.+148    	; 0x427c <__stack+0x17d>
    41e8:	60 e2       	ldi	r22, 0x20	; 32
    41ea:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.1f A", c, motor[i].current);
    41ec:	a0 91 e8 02 	lds	r26, 0x02E8
    41f0:	b0 91 e9 02 	lds	r27, 0x02E9
    41f4:	f9 01       	movw	r30, r18
    41f6:	ee 0f       	add	r30, r30
    41f8:	ff 1f       	adc	r31, r31
    41fa:	ee 0f       	add	r30, r30
    41fc:	ff 1f       	adc	r31, r31
    41fe:	ee 0f       	add	r30, r30
    4200:	ff 1f       	adc	r31, r31
    4202:	cf 01       	movw	r24, r30
    4204:	88 0f       	add	r24, r24
    4206:	99 1f       	adc	r25, r25
    4208:	88 0f       	add	r24, r24
    420a:	99 1f       	adc	r25, r25
    420c:	e8 0f       	add	r30, r24
    420e:	f9 1f       	adc	r31, r25
    4210:	e0 51       	subi	r30, 0x10	; 16
    4212:	fc 4f       	sbci	r31, 0xFC	; 252
    4214:	23 a1       	ldd	r18, Z+35	; 0x23
    4216:	34 a1       	ldd	r19, Z+36	; 0x24
    4218:	45 a1       	ldd	r20, Z+37	; 0x25
    421a:	56 a1       	ldd	r21, Z+38	; 0x26
    421c:	8d b7       	in	r24, 0x3d	; 61
    421e:	9e b7       	in	r25, 0x3e	; 62
    4220:	0a 97       	sbiw	r24, 0x0a	; 10
    4222:	0f b6       	in	r0, 0x3f	; 63
    4224:	f8 94       	cli
    4226:	9e bf       	out	0x3e, r25	; 62
    4228:	0f be       	out	0x3f, r0	; 63
    422a:	8d bf       	out	0x3d, r24	; 61
    422c:	ed b7       	in	r30, 0x3d	; 61
    422e:	fe b7       	in	r31, 0x3e	; 62
    4230:	31 96       	adiw	r30, 0x01	; 1
    4232:	ce 01       	movw	r24, r28
    4234:	88 0f       	add	r24, r24
    4236:	99 1f       	adc	r25, r25
    4238:	a8 0f       	add	r26, r24
    423a:	b9 1f       	adc	r27, r25
    423c:	8d 91       	ld	r24, X+
    423e:	9c 91       	ld	r25, X
    4240:	ad b7       	in	r26, 0x3d	; 61
    4242:	be b7       	in	r27, 0x3e	; 62
    4244:	12 96       	adiw	r26, 0x02	; 2
    4246:	9c 93       	st	X, r25
    4248:	8e 93       	st	-X, r24
    424a:	11 97       	sbiw	r26, 0x01	; 1
    424c:	13 83       	std	Z+3, r17	; 0x03
    424e:	02 83       	std	Z+2, r16	; 0x02
    4250:	75 83       	std	Z+5, r23	; 0x05
    4252:	64 83       	std	Z+4, r22	; 0x04
    4254:	26 83       	std	Z+6, r18	; 0x06
    4256:	37 83       	std	Z+7, r19	; 0x07
    4258:	40 87       	std	Z+8, r20	; 0x08
    425a:	51 87       	std	Z+9, r21	; 0x09
    425c:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4260:	21 96       	adiw	r28, 0x01	; 1
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
      sprintf(menu.newDisplayValue[3], "        ");
      break;
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
    4262:	ed b7       	in	r30, 0x3d	; 61
    4264:	fe b7       	in	r31, 0x3e	; 62
    4266:	3a 96       	adiw	r30, 0x0a	; 10
    4268:	0f b6       	in	r0, 0x3f	; 63
    426a:	f8 94       	cli
    426c:	fe bf       	out	0x3e, r31	; 62
    426e:	0f be       	out	0x3f, r0	; 63
    4270:	ed bf       	out	0x3d, r30	; 61
    4272:	c4 30       	cpi	r28, 0x04	; 4
    4274:	d1 05       	cpc	r29, r1
    4276:	09 f0       	breq	.+2      	; 0x427a <__stack+0x17b>
    4278:	ab cf       	rjmp	.-170    	; 0x41d0 <__stack+0xd1>
    427a:	ea c9       	rjmp	.-3116   	; 0x3650 <updateDisplayChangeValues+0x64>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    427c:	6e e7       	ldi	r22, 0x7E	; 126
    427e:	70 e0       	ldi	r23, 0x00	; 0
    4280:	b5 cf       	rjmp	.-150    	; 0x41ec <__stack+0xed>
    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    4282:	4e e7       	ldi	r20, 0x7E	; 126
    4284:	50 e0       	ldi	r21, 0x00	; 0
    4286:	45 ce       	rjmp	.-886    	; 0x3f12 <updateDisplayChangeValues+0x926>
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
    4288:	e0 91 e8 02 	lds	r30, 0x02E8
    428c:	f0 91 e9 02 	lds	r31, 0x02E9
    4290:	00 d0       	rcall	.+0      	; 0x4292 <__stack+0x193>
    4292:	00 d0       	rcall	.+0      	; 0x4294 <__stack+0x195>
    4294:	00 d0       	rcall	.+0      	; 0x4296 <__stack+0x197>
    4296:	ad b7       	in	r26, 0x3d	; 61
    4298:	be b7       	in	r27, 0x3e	; 62
    429a:	11 96       	adiw	r26, 0x01	; 1
    429c:	ee 0d       	add	r30, r14
    429e:	ff 1d       	adc	r31, r15
    42a0:	80 81       	ld	r24, Z
    42a2:	91 81       	ldd	r25, Z+1	; 0x01
    42a4:	ed b7       	in	r30, 0x3d	; 61
    42a6:	fe b7       	in	r31, 0x3e	; 62
    42a8:	92 83       	std	Z+2, r25	; 0x02
    42aa:	81 83       	std	Z+1, r24	; 0x01
    42ac:	13 96       	adiw	r26, 0x03	; 3
    42ae:	7c 92       	st	X, r7
    42b0:	6e 92       	st	-X, r6
    42b2:	12 97       	sbiw	r26, 0x02	; 2
    42b4:	14 96       	adiw	r26, 0x04	; 4
    42b6:	dc 92       	st	X, r13
    42b8:	14 97       	sbiw	r26, 0x04	; 4
    42ba:	15 96       	adiw	r26, 0x05	; 5
    42bc:	1c 92       	st	X, r1
    42be:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    42c2:	2d b7       	in	r18, 0x3d	; 61
    42c4:	3e b7       	in	r19, 0x3e	; 62
    42c6:	2a 5f       	subi	r18, 0xFA	; 250
    42c8:	3f 4f       	sbci	r19, 0xFF	; 255
    42ca:	0f b6       	in	r0, 0x3f	; 63
    42cc:	f8 94       	cli
    42ce:	3e bf       	out	0x3e, r19	; 62
    42d0:	0f be       	out	0x3f, r0	; 63
    42d2:	2d bf       	out	0x3d, r18	; 61
    42d4:	4d ca       	rjmp	.-2918   	; 0x3770 <updateDisplayChangeValues+0x184>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
    42d6:	e0 91 e8 02 	lds	r30, 0x02E8
    42da:	f0 91 e9 02 	lds	r31, 0x02E9
    42de:	8d b7       	in	r24, 0x3d	; 61
    42e0:	9e b7       	in	r25, 0x3e	; 62
    42e2:	08 97       	sbiw	r24, 0x08	; 8
    42e4:	0f b6       	in	r0, 0x3f	; 63
    42e6:	f8 94       	cli
    42e8:	9e bf       	out	0x3e, r25	; 62
    42ea:	0f be       	out	0x3f, r0	; 63
    42ec:	8d bf       	out	0x3d, r24	; 61
    42ee:	ad b7       	in	r26, 0x3d	; 61
    42f0:	be b7       	in	r27, 0x3e	; 62
    42f2:	11 96       	adiw	r26, 0x01	; 1
    42f4:	e0 0f       	add	r30, r16
    42f6:	f1 1f       	adc	r31, r17
    42f8:	80 81       	ld	r24, Z
    42fa:	91 81       	ldd	r25, Z+1	; 0x01
    42fc:	ed b7       	in	r30, 0x3d	; 61
    42fe:	fe b7       	in	r31, 0x3e	; 62
    4300:	92 83       	std	Z+2, r25	; 0x02
    4302:	81 83       	std	Z+1, r24	; 0x01
    4304:	13 96       	adiw	r26, 0x03	; 3
    4306:	bc 92       	st	X, r11
    4308:	ae 92       	st	-X, r10
    430a:	12 97       	sbiw	r26, 0x02	; 2
    430c:	14 96       	adiw	r26, 0x04	; 4
    430e:	dc 92       	st	X, r13
    4310:	14 97       	sbiw	r26, 0x04	; 4
    4312:	15 96       	adiw	r26, 0x05	; 5
    4314:	1c 92       	st	X, r1
    4316:	15 97       	sbiw	r26, 0x05	; 5
    4318:	17 96       	adiw	r26, 0x07	; 7
    431a:	7c 92       	st	X, r7
    431c:	6e 92       	st	-X, r6
    431e:	16 97       	sbiw	r26, 0x06	; 6
    4320:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4324:	2d b7       	in	r18, 0x3d	; 61
    4326:	3e b7       	in	r19, 0x3e	; 62
    4328:	28 5f       	subi	r18, 0xF8	; 248
    432a:	3f 4f       	sbci	r19, 0xFF	; 255
    432c:	0f b6       	in	r0, 0x3f	; 63
    432e:	f8 94       	cli
    4330:	3e bf       	out	0x3e, r19	; 62
    4332:	0f be       	out	0x3f, r0	; 63
    4334:	2d bf       	out	0x3d, r18	; 61
    4336:	7a cb       	rjmp	.-2316   	; 0x3a2c <updateDisplayChangeValues+0x440>
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    4338:	e0 91 e8 02 	lds	r30, 0x02E8
    433c:	f0 91 e9 02 	lds	r31, 0x02E9
    4340:	8d b7       	in	r24, 0x3d	; 61
    4342:	9e b7       	in	r25, 0x3e	; 62
    4344:	08 97       	sbiw	r24, 0x08	; 8
    4346:	0f b6       	in	r0, 0x3f	; 63
    4348:	f8 94       	cli
    434a:	9e bf       	out	0x3e, r25	; 62
    434c:	0f be       	out	0x3f, r0	; 63
    434e:	8d bf       	out	0x3d, r24	; 61
    4350:	ad b7       	in	r26, 0x3d	; 61
    4352:	be b7       	in	r27, 0x3e	; 62
    4354:	11 96       	adiw	r26, 0x01	; 1
    4356:	e0 0f       	add	r30, r16
    4358:	f1 1f       	adc	r31, r17
    435a:	80 81       	ld	r24, Z
    435c:	91 81       	ldd	r25, Z+1	; 0x01
    435e:	ed b7       	in	r30, 0x3d	; 61
    4360:	fe b7       	in	r31, 0x3e	; 62
    4362:	92 83       	std	Z+2, r25	; 0x02
    4364:	81 83       	std	Z+1, r24	; 0x01
    4366:	13 96       	adiw	r26, 0x03	; 3
    4368:	bc 92       	st	X, r11
    436a:	ae 92       	st	-X, r10
    436c:	12 97       	sbiw	r26, 0x02	; 2
    436e:	14 96       	adiw	r26, 0x04	; 4
    4370:	dc 92       	st	X, r13
    4372:	14 97       	sbiw	r26, 0x04	; 4
    4374:	15 96       	adiw	r26, 0x05	; 5
    4376:	1c 92       	st	X, r1
    4378:	15 97       	sbiw	r26, 0x05	; 5
    437a:	17 96       	adiw	r26, 0x07	; 7
    437c:	5c 92       	st	X, r5
    437e:	4e 92       	st	-X, r4
    4380:	16 97       	sbiw	r26, 0x06	; 6
    4382:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4386:	2d b7       	in	r18, 0x3d	; 61
    4388:	3e b7       	in	r19, 0x3e	; 62
    438a:	28 5f       	subi	r18, 0xF8	; 248
    438c:	3f 4f       	sbci	r19, 0xFF	; 255
    438e:	0f b6       	in	r0, 0x3f	; 63
    4390:	f8 94       	cli
    4392:	3e bf       	out	0x3e, r19	; 62
    4394:	0f be       	out	0x3f, r0	; 63
    4396:	2d bf       	out	0x3d, r18	; 61
    4398:	5e cb       	rjmp	.-2372   	; 0x3a56 <updateDisplayChangeValues+0x46a>
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    439a:	e0 91 e8 02 	lds	r30, 0x02E8
    439e:	f0 91 e9 02 	lds	r31, 0x02E9
    43a2:	00 d0       	rcall	.+0      	; 0x43a4 <__stack+0x2a5>
    43a4:	00 d0       	rcall	.+0      	; 0x43a6 <__stack+0x2a7>
    43a6:	00 d0       	rcall	.+0      	; 0x43a8 <__stack+0x2a9>
    43a8:	ad b7       	in	r26, 0x3d	; 61
    43aa:	be b7       	in	r27, 0x3e	; 62
    43ac:	11 96       	adiw	r26, 0x01	; 1
    43ae:	ee 0d       	add	r30, r14
    43b0:	ff 1d       	adc	r31, r15
    43b2:	80 81       	ld	r24, Z
    43b4:	91 81       	ldd	r25, Z+1	; 0x01
    43b6:	ed b7       	in	r30, 0x3d	; 61
    43b8:	fe b7       	in	r31, 0x3e	; 62
    43ba:	92 83       	std	Z+2, r25	; 0x02
    43bc:	81 83       	std	Z+1, r24	; 0x01
    43be:	13 96       	adiw	r26, 0x03	; 3
    43c0:	bc 92       	st	X, r11
    43c2:	ae 92       	st	-X, r10
    43c4:	12 97       	sbiw	r26, 0x02	; 2
    43c6:	14 96       	adiw	r26, 0x04	; 4
    43c8:	dc 92       	st	X, r13
    43ca:	14 97       	sbiw	r26, 0x04	; 4
    43cc:	15 96       	adiw	r26, 0x05	; 5
    43ce:	1c 92       	st	X, r1
    43d0:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    43d4:	2d b7       	in	r18, 0x3d	; 61
    43d6:	3e b7       	in	r19, 0x3e	; 62
    43d8:	2a 5f       	subi	r18, 0xFA	; 250
    43da:	3f 4f       	sbci	r19, 0xFF	; 255
    43dc:	0f b6       	in	r0, 0x3f	; 63
    43de:	f8 94       	cli
    43e0:	3e bf       	out	0x3e, r19	; 62
    43e2:	0f be       	out	0x3f, r0	; 63
    43e4:	2d bf       	out	0x3d, r18	; 61
    43e6:	de c9       	rjmp	.-3140   	; 0x37a4 <updateDisplayChangeValues+0x1b8>
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
    43e8:	e0 91 e8 02 	lds	r30, 0x02E8
    43ec:	f0 91 e9 02 	lds	r31, 0x02E9
    43f0:	00 d0       	rcall	.+0      	; 0x43f2 <__stack+0x2f3>
    43f2:	00 d0       	rcall	.+0      	; 0x43f4 <__stack+0x2f5>
    43f4:	00 d0       	rcall	.+0      	; 0x43f6 <__stack+0x2f7>
    43f6:	ad b7       	in	r26, 0x3d	; 61
    43f8:	be b7       	in	r27, 0x3e	; 62
    43fa:	11 96       	adiw	r26, 0x01	; 1
    43fc:	ee 0d       	add	r30, r14
    43fe:	ff 1d       	adc	r31, r15
    4400:	80 81       	ld	r24, Z
    4402:	91 81       	ldd	r25, Z+1	; 0x01
    4404:	ed b7       	in	r30, 0x3d	; 61
    4406:	fe b7       	in	r31, 0x3e	; 62
    4408:	92 83       	std	Z+2, r25	; 0x02
    440a:	81 83       	std	Z+1, r24	; 0x01
    440c:	13 96       	adiw	r26, 0x03	; 3
    440e:	9c 92       	st	X, r9
    4410:	8e 92       	st	-X, r8
    4412:	12 97       	sbiw	r26, 0x02	; 2
    4414:	14 96       	adiw	r26, 0x04	; 4
    4416:	dc 92       	st	X, r13
    4418:	14 97       	sbiw	r26, 0x04	; 4
    441a:	15 96       	adiw	r26, 0x05	; 5
    441c:	1c 92       	st	X, r1
    441e:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4422:	2d b7       	in	r18, 0x3d	; 61
    4424:	3e b7       	in	r19, 0x3e	; 62
    4426:	2a 5f       	subi	r18, 0xFA	; 250
    4428:	3f 4f       	sbci	r19, 0xFF	; 255
    442a:	0f b6       	in	r0, 0x3f	; 63
    442c:	f8 94       	cli
    442e:	3e bf       	out	0x3e, r19	; 62
    4430:	0f be       	out	0x3f, r0	; 63
    4432:	2d bf       	out	0x3d, r18	; 61
    4434:	aa c9       	rjmp	.-3244   	; 0x378a <updateDisplayChangeValues+0x19e>

00004436 <commandSetProgStep>:
    param5: absolute or relative movement

    always gets param1..param4 in steps (calculated by python interface)
 --------------------------------------------------------------------- */
void commandSetProgStep(char* param0, char* param1, char* param2,
                        char* param3, char* param4, char* param5){
    4436:	8f 92       	push	r8
    4438:	9f 92       	push	r9
    443a:	af 92       	push	r10
    443c:	bf 92       	push	r11
    443e:	cf 92       	push	r12
    4440:	df 92       	push	r13
    4442:	ef 92       	push	r14
    4444:	ff 92       	push	r15
    4446:	0f 93       	push	r16
    4448:	1f 93       	push	r17
    444a:	cf 93       	push	r28
    444c:	df 93       	push	r29
    444e:	eb 01       	movw	r28, r22
    4450:	6a 01       	movw	r12, r20
    4452:	59 01       	movw	r10, r18
    4454:	48 01       	movw	r8, r16

  uint8_t step, i;

  step = (uint8_t)strtol(param0, (char **)NULL, 10);
    4456:	60 e0       	ldi	r22, 0x00	; 0
    4458:	70 e0       	ldi	r23, 0x00	; 0
    445a:	4a e0       	ldi	r20, 0x0A	; 10
    445c:	50 e0       	ldi	r21, 0x00	; 0
    445e:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    4462:	16 2f       	mov	r17, r22

  if(step >= MAX_PROGRAM_STEPS){
    4464:	60 31       	cpi	r22, 0x10	; 16
    4466:	68 f0       	brcs	.+26     	; 0x4482 <commandSetProgStep+0x4c>
  if(strcmp(param5, "REL") == 0){
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
  }

  return;
}
    4468:	df 91       	pop	r29
    446a:	cf 91       	pop	r28
    446c:	1f 91       	pop	r17
    446e:	0f 91       	pop	r16
    4470:	ff 90       	pop	r15
    4472:	ef 90       	pop	r14
    4474:	df 90       	pop	r13
    4476:	cf 90       	pop	r12
    4478:	bf 90       	pop	r11
    447a:	af 90       	pop	r10
    447c:	9f 90       	pop	r9
    447e:	8f 90       	pop	r8
    4480:	08 95       	ret
  if(step >= MAX_PROGRAM_STEPS){
    /* not more than MAX_PROGAM_STEPS allowed */
    return;
  }

  if(strcmp(param5, "NONE") == 0){
    4482:	c7 01       	movw	r24, r14
    4484:	62 e1       	ldi	r22, 0x12	; 18
    4486:	72 e0       	ldi	r23, 0x02	; 2
    4488:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    448c:	00 97       	sbiw	r24, 0x00	; 0
    448e:	09 f0       	breq	.+2      	; 0x4492 <commandSetProgStep+0x5c>
    4490:	66 c0       	rjmp	.+204    	; 0x455e <commandSetProgStep+0x128>
    programList[step].isActive = 0;
    4492:	81 2f       	mov	r24, r17
    4494:	90 e0       	ldi	r25, 0x00	; 0
    4496:	fc 01       	movw	r30, r24
    4498:	ee 0f       	add	r30, r30
    449a:	ff 1f       	adc	r31, r31
    449c:	ee 0f       	add	r30, r30
    449e:	ff 1f       	adc	r31, r31
    44a0:	ee 0f       	add	r30, r30
    44a2:	ff 1f       	adc	r31, r31
    44a4:	88 0f       	add	r24, r24
    44a6:	99 1f       	adc	r25, r25
    44a8:	e8 0f       	add	r30, r24
    44aa:	f9 1f       	adc	r31, r25
    44ac:	ed 50       	subi	r30, 0x0D	; 13
    44ae:	fd 4f       	sbci	r31, 0xFD	; 253
    44b0:	10 82       	st	Z, r1
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
    44b2:	81 2f       	mov	r24, r17
    44b4:	90 e0       	ldi	r25, 0x00	; 0
    44b6:	fc 01       	movw	r30, r24
    44b8:	ee 0f       	add	r30, r30
    44ba:	ff 1f       	adc	r31, r31
    44bc:	ee 0f       	add	r30, r30
    44be:	ff 1f       	adc	r31, r31
    44c0:	ee 0f       	add	r30, r30
    44c2:	ff 1f       	adc	r31, r31
    44c4:	88 0f       	add	r24, r24
    44c6:	99 1f       	adc	r25, r25
    44c8:	e8 0f       	add	r30, r24
    44ca:	f9 1f       	adc	r31, r25
    44cc:	ed 50       	subi	r30, 0x0D	; 13
    44ce:	fd 4f       	sbci	r31, 0xFD	; 253
    44d0:	81 e0       	ldi	r24, 0x01	; 1
    44d2:	81 87       	std	Z+9, r24	; 0x09
    for(i = 0; i <= MAX_MOTOR; i++){
      programList[step].position[i] = 0;
    44d4:	81 2f       	mov	r24, r17
    44d6:	90 e0       	ldi	r25, 0x00	; 0
    44d8:	fc 01       	movw	r30, r24
    44da:	ee 0f       	add	r30, r30
    44dc:	ff 1f       	adc	r31, r31
    44de:	ee 0f       	add	r30, r30
    44e0:	ff 1f       	adc	r31, r31
    44e2:	ee 0f       	add	r30, r30
    44e4:	ff 1f       	adc	r31, r31
    44e6:	88 0f       	add	r24, r24
    44e8:	99 1f       	adc	r25, r25
    44ea:	e8 0f       	add	r30, r24
    44ec:	f9 1f       	adc	r31, r25
    44ee:	ed 50       	subi	r30, 0x0D	; 13
    44f0:	fd 4f       	sbci	r31, 0xFD	; 253
    44f2:	12 82       	std	Z+2, r1	; 0x02
    44f4:	11 82       	std	Z+1, r1	; 0x01
    44f6:	81 2f       	mov	r24, r17
    44f8:	90 e0       	ldi	r25, 0x00	; 0
    44fa:	fc 01       	movw	r30, r24
    44fc:	ee 0f       	add	r30, r30
    44fe:	ff 1f       	adc	r31, r31
    4500:	ee 0f       	add	r30, r30
    4502:	ff 1f       	adc	r31, r31
    4504:	ee 0f       	add	r30, r30
    4506:	ff 1f       	adc	r31, r31
    4508:	88 0f       	add	r24, r24
    450a:	99 1f       	adc	r25, r25
    450c:	e8 0f       	add	r30, r24
    450e:	f9 1f       	adc	r31, r25
    4510:	ed 50       	subi	r30, 0x0D	; 13
    4512:	fd 4f       	sbci	r31, 0xFD	; 253
    4514:	14 82       	std	Z+4, r1	; 0x04
    4516:	13 82       	std	Z+3, r1	; 0x03
    4518:	81 2f       	mov	r24, r17
    451a:	90 e0       	ldi	r25, 0x00	; 0
    451c:	fc 01       	movw	r30, r24
    451e:	ee 0f       	add	r30, r30
    4520:	ff 1f       	adc	r31, r31
    4522:	ee 0f       	add	r30, r30
    4524:	ff 1f       	adc	r31, r31
    4526:	ee 0f       	add	r30, r30
    4528:	ff 1f       	adc	r31, r31
    452a:	88 0f       	add	r24, r24
    452c:	99 1f       	adc	r25, r25
    452e:	e8 0f       	add	r30, r24
    4530:	f9 1f       	adc	r31, r25
    4532:	ed 50       	subi	r30, 0x0D	; 13
    4534:	fd 4f       	sbci	r31, 0xFD	; 253
    4536:	16 82       	std	Z+6, r1	; 0x06
    4538:	15 82       	std	Z+5, r1	; 0x05
    453a:	81 2f       	mov	r24, r17
    453c:	90 e0       	ldi	r25, 0x00	; 0
    453e:	fc 01       	movw	r30, r24
    4540:	ee 0f       	add	r30, r30
    4542:	ff 1f       	adc	r31, r31
    4544:	ee 0f       	add	r30, r30
    4546:	ff 1f       	adc	r31, r31
    4548:	ee 0f       	add	r30, r30
    454a:	ff 1f       	adc	r31, r31
    454c:	88 0f       	add	r24, r24
    454e:	99 1f       	adc	r25, r25
    4550:	e8 0f       	add	r30, r24
    4552:	f9 1f       	adc	r31, r25
    4554:	ed 50       	subi	r30, 0x0D	; 13
    4556:	fd 4f       	sbci	r31, 0xFD	; 253
    4558:	10 86       	std	Z+8, r1	; 0x08
    455a:	17 82       	std	Z+7, r1	; 0x07
    455c:	85 cf       	rjmp	.-246    	; 0x4468 <commandSetProgStep+0x32>
    }
    return;
  }

  programList[step].position[0] = (int16_t)strtol(param1, (char **)NULL, 10);
    455e:	ce 01       	movw	r24, r28
    4560:	60 e0       	ldi	r22, 0x00	; 0
    4562:	70 e0       	ldi	r23, 0x00	; 0
    4564:	4a e0       	ldi	r20, 0x0A	; 10
    4566:	50 e0       	ldi	r21, 0x00	; 0
    4568:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    456c:	21 2f       	mov	r18, r17
    456e:	30 e0       	ldi	r19, 0x00	; 0
    4570:	f9 01       	movw	r30, r18
    4572:	ee 0f       	add	r30, r30
    4574:	ff 1f       	adc	r31, r31
    4576:	ee 0f       	add	r30, r30
    4578:	ff 1f       	adc	r31, r31
    457a:	ee 0f       	add	r30, r30
    457c:	ff 1f       	adc	r31, r31
    457e:	22 0f       	add	r18, r18
    4580:	33 1f       	adc	r19, r19
    4582:	e2 0f       	add	r30, r18
    4584:	f3 1f       	adc	r31, r19
    4586:	ed 50       	subi	r30, 0x0D	; 13
    4588:	fd 4f       	sbci	r31, 0xFD	; 253
    458a:	72 83       	std	Z+2, r23	; 0x02
    458c:	61 83       	std	Z+1, r22	; 0x01
  programList[step].position[1] = (int16_t)strtol(param2, (char **)NULL, 10);
    458e:	c6 01       	movw	r24, r12
    4590:	60 e0       	ldi	r22, 0x00	; 0
    4592:	70 e0       	ldi	r23, 0x00	; 0
    4594:	4a e0       	ldi	r20, 0x0A	; 10
    4596:	50 e0       	ldi	r21, 0x00	; 0
    4598:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    459c:	21 2f       	mov	r18, r17
    459e:	30 e0       	ldi	r19, 0x00	; 0
    45a0:	f9 01       	movw	r30, r18
    45a2:	ee 0f       	add	r30, r30
    45a4:	ff 1f       	adc	r31, r31
    45a6:	ee 0f       	add	r30, r30
    45a8:	ff 1f       	adc	r31, r31
    45aa:	ee 0f       	add	r30, r30
    45ac:	ff 1f       	adc	r31, r31
    45ae:	22 0f       	add	r18, r18
    45b0:	33 1f       	adc	r19, r19
    45b2:	e2 0f       	add	r30, r18
    45b4:	f3 1f       	adc	r31, r19
    45b6:	ed 50       	subi	r30, 0x0D	; 13
    45b8:	fd 4f       	sbci	r31, 0xFD	; 253
    45ba:	74 83       	std	Z+4, r23	; 0x04
    45bc:	63 83       	std	Z+3, r22	; 0x03
  programList[step].position[2] = (int16_t)strtol(param3, (char **)NULL, 10);
    45be:	c5 01       	movw	r24, r10
    45c0:	60 e0       	ldi	r22, 0x00	; 0
    45c2:	70 e0       	ldi	r23, 0x00	; 0
    45c4:	4a e0       	ldi	r20, 0x0A	; 10
    45c6:	50 e0       	ldi	r21, 0x00	; 0
    45c8:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    45cc:	21 2f       	mov	r18, r17
    45ce:	30 e0       	ldi	r19, 0x00	; 0
    45d0:	f9 01       	movw	r30, r18
    45d2:	ee 0f       	add	r30, r30
    45d4:	ff 1f       	adc	r31, r31
    45d6:	ee 0f       	add	r30, r30
    45d8:	ff 1f       	adc	r31, r31
    45da:	ee 0f       	add	r30, r30
    45dc:	ff 1f       	adc	r31, r31
    45de:	22 0f       	add	r18, r18
    45e0:	33 1f       	adc	r19, r19
    45e2:	e2 0f       	add	r30, r18
    45e4:	f3 1f       	adc	r31, r19
    45e6:	ed 50       	subi	r30, 0x0D	; 13
    45e8:	fd 4f       	sbci	r31, 0xFD	; 253
    45ea:	76 83       	std	Z+6, r23	; 0x06
    45ec:	65 83       	std	Z+5, r22	; 0x05
  programList[step].position[3] = (int16_t)strtol(param4, (char **)NULL, 10);
    45ee:	c4 01       	movw	r24, r8
    45f0:	60 e0       	ldi	r22, 0x00	; 0
    45f2:	70 e0       	ldi	r23, 0x00	; 0
    45f4:	4a e0       	ldi	r20, 0x0A	; 10
    45f6:	50 e0       	ldi	r21, 0x00	; 0
    45f8:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    45fc:	21 2f       	mov	r18, r17
    45fe:	30 e0       	ldi	r19, 0x00	; 0
    4600:	f9 01       	movw	r30, r18
    4602:	ee 0f       	add	r30, r30
    4604:	ff 1f       	adc	r31, r31
    4606:	ee 0f       	add	r30, r30
    4608:	ff 1f       	adc	r31, r31
    460a:	ee 0f       	add	r30, r30
    460c:	ff 1f       	adc	r31, r31
    460e:	22 0f       	add	r18, r18
    4610:	33 1f       	adc	r19, r19
    4612:	e2 0f       	add	r30, r18
    4614:	f3 1f       	adc	r31, r19
    4616:	ed 50       	subi	r30, 0x0D	; 13
    4618:	fd 4f       	sbci	r31, 0xFD	; 253
    461a:	70 87       	std	Z+8, r23	; 0x08
    461c:	67 83       	std	Z+7, r22	; 0x07

  programList[step].isActive = 1;
    461e:	81 2f       	mov	r24, r17
    4620:	90 e0       	ldi	r25, 0x00	; 0
    4622:	fc 01       	movw	r30, r24
    4624:	ee 0f       	add	r30, r30
    4626:	ff 1f       	adc	r31, r31
    4628:	ee 0f       	add	r30, r30
    462a:	ff 1f       	adc	r31, r31
    462c:	ee 0f       	add	r30, r30
    462e:	ff 1f       	adc	r31, r31
    4630:	88 0f       	add	r24, r24
    4632:	99 1f       	adc	r25, r25
    4634:	e8 0f       	add	r30, r24
    4636:	f9 1f       	adc	r31, r25
    4638:	ed 50       	subi	r30, 0x0D	; 13
    463a:	fd 4f       	sbci	r31, 0xFD	; 253
    463c:	81 e0       	ldi	r24, 0x01	; 1
    463e:	80 83       	st	Z, r24

  if(strcmp(param5, "ABS") == 0){
    4640:	c7 01       	movw	r24, r14
    4642:	67 e1       	ldi	r22, 0x17	; 23
    4644:	72 e0       	ldi	r23, 0x02	; 2
    4646:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    464a:	00 97       	sbiw	r24, 0x00	; 0
    464c:	81 f4       	brne	.+32     	; 0x466e <commandSetProgStep+0x238>
    programList[step].absRel = PROG_ABSOLUTE_MOVEMENT;
    464e:	81 2f       	mov	r24, r17
    4650:	90 e0       	ldi	r25, 0x00	; 0
    4652:	fc 01       	movw	r30, r24
    4654:	ee 0f       	add	r30, r30
    4656:	ff 1f       	adc	r31, r31
    4658:	ee 0f       	add	r30, r30
    465a:	ff 1f       	adc	r31, r31
    465c:	ee 0f       	add	r30, r30
    465e:	ff 1f       	adc	r31, r31
    4660:	88 0f       	add	r24, r24
    4662:	99 1f       	adc	r25, r25
    4664:	e8 0f       	add	r30, r24
    4666:	f9 1f       	adc	r31, r25
    4668:	ed 50       	subi	r30, 0x0D	; 13
    466a:	fd 4f       	sbci	r31, 0xFD	; 253
    466c:	11 86       	std	Z+9, r1	; 0x09
  }
  if(strcmp(param5, "REL") == 0){
    466e:	c7 01       	movw	r24, r14
    4670:	6b e1       	ldi	r22, 0x1B	; 27
    4672:	72 e0       	ldi	r23, 0x02	; 2
    4674:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    4678:	00 97       	sbiw	r24, 0x00	; 0
    467a:	09 f0       	breq	.+2      	; 0x467e <commandSetProgStep+0x248>
    467c:	f5 ce       	rjmp	.-534    	; 0x4468 <commandSetProgStep+0x32>
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
    467e:	81 2f       	mov	r24, r17
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	fc 01       	movw	r30, r24
    4684:	ee 0f       	add	r30, r30
    4686:	ff 1f       	adc	r31, r31
    4688:	ee 0f       	add	r30, r30
    468a:	ff 1f       	adc	r31, r31
    468c:	ee 0f       	add	r30, r30
    468e:	ff 1f       	adc	r31, r31
    4690:	88 0f       	add	r24, r24
    4692:	99 1f       	adc	r25, r25
    4694:	e8 0f       	add	r30, r24
    4696:	f9 1f       	adc	r31, r25
    4698:	ed 50       	subi	r30, 0x0D	; 13
    469a:	fd 4f       	sbci	r31, 0xFD	; 253
    469c:	81 e0       	ldi	r24, 0x01	; 1
    469e:	81 87       	std	Z+9, r24	; 0x09
    46a0:	e3 ce       	rjmp	.-570    	; 0x4468 <commandSetProgStep+0x32>

000046a2 <commandGetMotorPosition>:

/* ---------------------------------------------------------------------
    returns the actual motor position as string
    the format depends on the given unit
 --------------------------------------------------------------------- */
char* commandGetMotorPosition(char* param0, char* param1){
    46a2:	0f 93       	push	r16
    46a4:	cf 93       	push	r28
    46a6:	df 93       	push	r29
    46a8:	eb 01       	movw	r28, r22

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    46aa:	60 e0       	ldi	r22, 0x00	; 0
    46ac:	70 e0       	ldi	r23, 0x00	; 0
    46ae:	4a e0       	ldi	r20, 0x0A	; 10
    46b0:	50 e0       	ldi	r21, 0x00	; 0
    46b2:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    46b6:	06 2f       	mov	r16, r22

  if(i > MAX_MOTOR){
    46b8:	64 30       	cpi	r22, 0x04	; 4
    46ba:	08 f0       	brcs	.+2      	; 0x46be <commandGetMotorPosition+0x1c>
    46bc:	ac c0       	rjmp	.+344    	; 0x4816 <commandGetMotorPosition+0x174>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(strcmp(param1, "steps") == 0){
    46be:	ce 01       	movw	r24, r28
    46c0:	6f e1       	ldi	r22, 0x1F	; 31
    46c2:	72 e0       	ldi	r23, 0x02	; 2
    46c4:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    46c8:	00 97       	sbiw	r24, 0x00	; 0
    46ca:	59 f1       	breq	.+86     	; 0x4722 <commandGetMotorPosition+0x80>
      sprintf(txString.buffer, "%d", motor[i].actualPosition);
    }
    else if(strcmp(param1, "deg") == 0){
    46cc:	ce 01       	movw	r24, r28
    46ce:	65 e2       	ldi	r22, 0x25	; 37
    46d0:	72 e0       	ldi	r23, 0x02	; 2
    46d2:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    46d6:	00 97       	sbiw	r24, 0x00	; 0
    46d8:	09 f4       	brne	.+2      	; 0x46dc <commandGetMotorPosition+0x3a>
    46da:	60 c0       	rjmp	.+192    	; 0x479c <commandGetMotorPosition+0xfa>
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    }
    else if(strcmp(param1, "pi") == 0){
    46dc:	ce 01       	movw	r24, r28
    46de:	69 e2       	ldi	r22, 0x29	; 41
    46e0:	72 e0       	ldi	r23, 0x02	; 2
    46e2:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    46e6:	00 97       	sbiw	r24, 0x00	; 0
    46e8:	09 f0       	breq	.+2      	; 0x46ec <commandGetMotorPosition+0x4a>
    46ea:	58 c0       	rjmp	.+176    	; 0x479c <commandGetMotorPosition+0xfa>
      sprintf(txString.buffer, "%f", stepsToRadian(i, motor[i].actualPosition));
    46ec:	c0 91 e7 03 	lds	r28, 0x03E7
    46f0:	d0 91 e8 03 	lds	r29, 0x03E8
    46f4:	e0 2f       	mov	r30, r16
    46f6:	f0 e0       	ldi	r31, 0x00	; 0
    46f8:	ee 0f       	add	r30, r30
    46fa:	ff 1f       	adc	r31, r31
    46fc:	ee 0f       	add	r30, r30
    46fe:	ff 1f       	adc	r31, r31
    4700:	ee 0f       	add	r30, r30
    4702:	ff 1f       	adc	r31, r31
    4704:	cf 01       	movw	r24, r30
    4706:	88 0f       	add	r24, r24
    4708:	99 1f       	adc	r25, r25
    470a:	88 0f       	add	r24, r24
    470c:	99 1f       	adc	r25, r25
    470e:	e8 0f       	add	r30, r24
    4710:	f9 1f       	adc	r31, r25
    4712:	e0 51       	subi	r30, 0x10	; 16
    4714:	fc 4f       	sbci	r31, 0xFC	; 252
    4716:	60 81       	ld	r22, Z
    4718:	71 81       	ldd	r23, Z+1	; 0x01
    471a:	80 2f       	mov	r24, r16
    471c:	0e 94 23 08 	call	0x1046	; 0x1046 <stepsToRadian>
    4720:	57 c0       	rjmp	.+174    	; 0x47d0 <commandGetMotorPosition+0x12e>
  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(strcmp(param1, "steps") == 0){
      sprintf(txString.buffer, "%d", motor[i].actualPosition);
    4722:	40 91 e7 03 	lds	r20, 0x03E7
    4726:	50 91 e8 03 	lds	r21, 0x03E8
    472a:	e0 2f       	mov	r30, r16
    472c:	f0 e0       	ldi	r31, 0x00	; 0
    472e:	ee 0f       	add	r30, r30
    4730:	ff 1f       	adc	r31, r31
    4732:	ee 0f       	add	r30, r30
    4734:	ff 1f       	adc	r31, r31
    4736:	ee 0f       	add	r30, r30
    4738:	ff 1f       	adc	r31, r31
    473a:	cf 01       	movw	r24, r30
    473c:	88 0f       	add	r24, r24
    473e:	99 1f       	adc	r25, r25
    4740:	88 0f       	add	r24, r24
    4742:	99 1f       	adc	r25, r25
    4744:	e8 0f       	add	r30, r24
    4746:	f9 1f       	adc	r31, r25
    4748:	e0 51       	subi	r30, 0x10	; 16
    474a:	fc 4f       	sbci	r31, 0xFC	; 252
    474c:	20 81       	ld	r18, Z
    474e:	31 81       	ldd	r19, Z+1	; 0x01
    4750:	00 d0       	rcall	.+0      	; 0x4752 <commandGetMotorPosition+0xb0>
    4752:	00 d0       	rcall	.+0      	; 0x4754 <commandGetMotorPosition+0xb2>
    4754:	00 d0       	rcall	.+0      	; 0x4756 <commandGetMotorPosition+0xb4>
    4756:	ed b7       	in	r30, 0x3d	; 61
    4758:	fe b7       	in	r31, 0x3e	; 62
    475a:	31 96       	adiw	r30, 0x01	; 1
    475c:	ad b7       	in	r26, 0x3d	; 61
    475e:	be b7       	in	r27, 0x3e	; 62
    4760:	12 96       	adiw	r26, 0x02	; 2
    4762:	5c 93       	st	X, r21
    4764:	4e 93       	st	-X, r20
    4766:	11 97       	sbiw	r26, 0x01	; 1
    4768:	87 e1       	ldi	r24, 0x17	; 23
    476a:	91 e0       	ldi	r25, 0x01	; 1
    476c:	93 83       	std	Z+3, r25	; 0x03
    476e:	82 83       	std	Z+2, r24	; 0x02
    4770:	35 83       	std	Z+5, r19	; 0x05
    4772:	24 83       	std	Z+4, r18	; 0x04
    4774:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4778:	2d b7       	in	r18, 0x3d	; 61
    477a:	3e b7       	in	r19, 0x3e	; 62
    477c:	2a 5f       	subi	r18, 0xFA	; 250
    477e:	3f 4f       	sbci	r19, 0xFF	; 255
    4780:	0f b6       	in	r0, 0x3f	; 63
    4782:	f8 94       	cli
    4784:	3e bf       	out	0x3e, r19	; 62
    4786:	0f be       	out	0x3f, r0	; 63
    4788:	2d bf       	out	0x3d, r18	; 61
      /* wrong unit argument returns in degree */
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    }
  }

  return txString.buffer;
    478a:	20 91 e7 03 	lds	r18, 0x03E7
    478e:	30 91 e8 03 	lds	r19, 0x03E8
}
    4792:	c9 01       	movw	r24, r18
    4794:	df 91       	pop	r29
    4796:	cf 91       	pop	r28
    4798:	0f 91       	pop	r16
    479a:	08 95       	ret
    else if(strcmp(param1, "pi") == 0){
      sprintf(txString.buffer, "%f", stepsToRadian(i, motor[i].actualPosition));
    }
    else{
      /* wrong unit argument returns in degree */
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    479c:	c0 91 e7 03 	lds	r28, 0x03E7
    47a0:	d0 91 e8 03 	lds	r29, 0x03E8
    47a4:	e0 2f       	mov	r30, r16
    47a6:	f0 e0       	ldi	r31, 0x00	; 0
    47a8:	ee 0f       	add	r30, r30
    47aa:	ff 1f       	adc	r31, r31
    47ac:	ee 0f       	add	r30, r30
    47ae:	ff 1f       	adc	r31, r31
    47b0:	ee 0f       	add	r30, r30
    47b2:	ff 1f       	adc	r31, r31
    47b4:	cf 01       	movw	r24, r30
    47b6:	88 0f       	add	r24, r24
    47b8:	99 1f       	adc	r25, r25
    47ba:	88 0f       	add	r24, r24
    47bc:	99 1f       	adc	r25, r25
    47be:	e8 0f       	add	r30, r24
    47c0:	f9 1f       	adc	r31, r25
    47c2:	e0 51       	subi	r30, 0x10	; 16
    47c4:	fc 4f       	sbci	r31, 0xFC	; 252
    47c6:	60 81       	ld	r22, Z
    47c8:	71 81       	ldd	r23, Z+1	; 0x01
    47ca:	80 2f       	mov	r24, r16
    47cc:	0e 94 9e 07 	call	0xf3c	; 0xf3c <stepsToDegree>
    47d0:	ad b7       	in	r26, 0x3d	; 61
    47d2:	be b7       	in	r27, 0x3e	; 62
    47d4:	18 97       	sbiw	r26, 0x08	; 8
    47d6:	0f b6       	in	r0, 0x3f	; 63
    47d8:	f8 94       	cli
    47da:	be bf       	out	0x3e, r27	; 62
    47dc:	0f be       	out	0x3f, r0	; 63
    47de:	ad bf       	out	0x3d, r26	; 61
    47e0:	ed b7       	in	r30, 0x3d	; 61
    47e2:	fe b7       	in	r31, 0x3e	; 62
    47e4:	31 96       	adiw	r30, 0x01	; 1
    47e6:	12 96       	adiw	r26, 0x02	; 2
    47e8:	dc 93       	st	X, r29
    47ea:	ce 93       	st	-X, r28
    47ec:	11 97       	sbiw	r26, 0x01	; 1
    47ee:	2a e1       	ldi	r18, 0x1A	; 26
    47f0:	31 e0       	ldi	r19, 0x01	; 1
    47f2:	33 83       	std	Z+3, r19	; 0x03
    47f4:	22 83       	std	Z+2, r18	; 0x02
    47f6:	64 83       	std	Z+4, r22	; 0x04
    47f8:	75 83       	std	Z+5, r23	; 0x05
    47fa:	86 83       	std	Z+6, r24	; 0x06
    47fc:	97 83       	std	Z+7, r25	; 0x07
    47fe:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4802:	2d b7       	in	r18, 0x3d	; 61
    4804:	3e b7       	in	r19, 0x3e	; 62
    4806:	28 5f       	subi	r18, 0xF8	; 248
    4808:	3f 4f       	sbci	r19, 0xFF	; 255
    480a:	0f b6       	in	r0, 0x3f	; 63
    480c:	f8 94       	cli
    480e:	3e bf       	out	0x3e, r19	; 62
    4810:	0f be       	out	0x3f, r0	; 63
    4812:	2d bf       	out	0x3d, r18	; 61
    4814:	ba cf       	rjmp	.-140    	; 0x478a <commandGetMotorPosition+0xe8>
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4816:	80 91 e7 03 	lds	r24, 0x03E7
    481a:	90 91 e8 03 	lds	r25, 0x03E8
    481e:	00 d0       	rcall	.+0      	; 0x4820 <commandGetMotorPosition+0x17e>
    4820:	00 d0       	rcall	.+0      	; 0x4822 <commandGetMotorPosition+0x180>
    4822:	00 d0       	rcall	.+0      	; 0x4824 <commandGetMotorPosition+0x182>
    4824:	ed b7       	in	r30, 0x3d	; 61
    4826:	fe b7       	in	r31, 0x3e	; 62
    4828:	31 96       	adiw	r30, 0x01	; 1
    482a:	ad b7       	in	r26, 0x3d	; 61
    482c:	be b7       	in	r27, 0x3e	; 62
    482e:	12 96       	adiw	r26, 0x02	; 2
    4830:	9c 93       	st	X, r25
    4832:	8e 93       	st	-X, r24
    4834:	11 97       	sbiw	r26, 0x01	; 1
    4836:	80 e0       	ldi	r24, 0x00	; 0
    4838:	91 e0       	ldi	r25, 0x01	; 1
    483a:	93 83       	std	Z+3, r25	; 0x03
    483c:	82 83       	std	Z+2, r24	; 0x02
    483e:	04 83       	std	Z+4, r16	; 0x04
    4840:	15 82       	std	Z+5, r1	; 0x05
    4842:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    4846:	2d b7       	in	r18, 0x3d	; 61
    4848:	3e b7       	in	r19, 0x3e	; 62
    484a:	2a 5f       	subi	r18, 0xFA	; 250
    484c:	3f 4f       	sbci	r19, 0xFF	; 255
    484e:	0f b6       	in	r0, 0x3f	; 63
    4850:	f8 94       	cli
    4852:	3e bf       	out	0x3e, r19	; 62
    4854:	0f be       	out	0x3f, r0	; 63
    4856:	2d bf       	out	0x3d, r18	; 61
    4858:	98 cf       	rjmp	.-208    	; 0x478a <commandGetMotorPosition+0xe8>

0000485a <changeDisplayMenu>:

  uint8_t j = 0;
  uint8_t k = 0;
  uint8_t sLen = 0;

  menuPtr  = (menuItem*)pgm_read_word(&menuList[i]);
    485a:	90 e0       	ldi	r25, 0x00	; 0
    485c:	88 0f       	add	r24, r24
    485e:	99 1f       	adc	r25, r25
    4860:	8e 51       	subi	r24, 0x1E	; 30
    4862:	9b 4f       	sbci	r25, 0xFB	; 251
    4864:	fc 01       	movw	r30, r24
    4866:	25 91       	lpm	r18, Z+
    4868:	34 91       	lpm	r19, Z+
  menuText = (char*)pgm_read_word(&menuPtr->displayText);
    486a:	f9 01       	movw	r30, r18
    486c:	65 91       	lpm	r22, Z+
    486e:	74 91       	lpm	r23, Z+

  strcpy_P(displayBuffer, menuText);
    4870:	80 91 eb 03 	lds	r24, 0x03EB
    4874:	90 91 ec 03 	lds	r25, 0x03EC
    4878:	0e 94 4a 45 	call	0x8a94	; 0x8a94 <strcpy_P>

  displayBuffer = strtok(displayBuffer, "\n");
    487c:	80 91 eb 03 	lds	r24, 0x03EB
    4880:	90 91 ec 03 	lds	r25, 0x03EC
    4884:	6c e2       	ldi	r22, 0x2C	; 44
    4886:	72 e0       	ldi	r23, 0x02	; 2
    4888:	0e 94 5c 45 	call	0x8ab8	; 0x8ab8 <strtok>
    488c:	bc 01       	movw	r22, r24
    488e:	90 93 ec 03 	sts	0x03EC, r25
    4892:	80 93 eb 03 	sts	0x03EB, r24
  strcpy(menu.newMenuText[0], displayBuffer);
    4896:	e0 91 ec 02 	lds	r30, 0x02EC
    489a:	f0 91 ed 02 	lds	r31, 0x02ED
    489e:	80 81       	ld	r24, Z
    48a0:	91 81       	ldd	r25, Z+1	; 0x01
    48a2:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
  displayBuffer = strtok(NULL, "\0");
    48a6:	80 e0       	ldi	r24, 0x00	; 0
    48a8:	90 e0       	ldi	r25, 0x00	; 0
    48aa:	6e e2       	ldi	r22, 0x2E	; 46
    48ac:	72 e0       	ldi	r23, 0x02	; 2
    48ae:	0e 94 5c 45 	call	0x8ab8	; 0x8ab8 <strtok>
    48b2:	bc 01       	movw	r22, r24
    48b4:	90 93 ec 03 	sts	0x03EC, r25
    48b8:	80 93 eb 03 	sts	0x03EB, r24
  strcpy(menu.newMenuText[1], displayBuffer);
    48bc:	e0 91 ec 02 	lds	r30, 0x02EC
    48c0:	f0 91 ed 02 	lds	r31, 0x02ED
    48c4:	82 81       	ldd	r24, Z+2	; 0x02
    48c6:	93 81       	ldd	r25, Z+3	; 0x03
    48c8:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
    48cc:	20 e0       	ldi	r18, 0x00	; 0
    48ce:	30 e0       	ldi	r19, 0x00	; 0

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
      menu.newMenuText[j][k] = ' ';
    48d0:	90 e2       	ldi	r25, 0x20	; 32
  displayBuffer = strtok(NULL, "\0");
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    48d2:	a0 91 ec 02 	lds	r26, 0x02EC
    48d6:	b0 91 ed 02 	lds	r27, 0x02ED
    48da:	a2 0f       	add	r26, r18
    48dc:	b3 1f       	adc	r27, r19
    48de:	ec 91       	ld	r30, X
    48e0:	11 96       	adiw	r26, 0x01	; 1
    48e2:	fc 91       	ld	r31, X
    48e4:	df 01       	movw	r26, r30
    48e6:	0d 90       	ld	r0, X+
    48e8:	00 20       	and	r0, r0
    48ea:	e9 f7       	brne	.-6      	; 0x48e6 <changeDisplayMenu+0x8c>
    48ec:	11 97       	sbiw	r26, 0x01	; 1
    48ee:	ae 1b       	sub	r26, r30
    48f0:	bf 0b       	sbc	r27, r31
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
    48f2:	a0 31       	cpi	r26, 0x10	; 16
    48f4:	80 f4       	brcc	.+32     	; 0x4916 <changeDisplayMenu+0xbc>
    48f6:	8a 2f       	mov	r24, r26
      menu.newMenuText[j][k] = ' ';
    48f8:	e0 91 ec 02 	lds	r30, 0x02EC
    48fc:	f0 91 ed 02 	lds	r31, 0x02ED
    4900:	e2 0f       	add	r30, r18
    4902:	f3 1f       	adc	r31, r19
    4904:	01 90       	ld	r0, Z+
    4906:	f0 81       	ld	r31, Z
    4908:	e0 2d       	mov	r30, r0
    490a:	e8 0f       	add	r30, r24
    490c:	f1 1d       	adc	r31, r1
    490e:	90 83       	st	Z, r25
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
    4910:	8f 5f       	subi	r24, 0xFF	; 255
    4912:	80 31       	cpi	r24, 0x10	; 16
    4914:	88 f3       	brcs	.-30     	; 0x48f8 <changeDisplayMenu+0x9e>
      menu.newMenuText[j][k] = ' ';
    }
    menu.newMenuText[j][DISPLAY_MENU_STRING_LENGTH-1] = '\0';
    4916:	e0 91 ec 02 	lds	r30, 0x02EC
    491a:	f0 91 ed 02 	lds	r31, 0x02ED
    491e:	e2 0f       	add	r30, r18
    4920:	f3 1f       	adc	r31, r19
    4922:	01 90       	ld	r0, Z+
    4924:	f0 81       	ld	r31, Z
    4926:	e0 2d       	mov	r30, r0
    4928:	10 8a       	std	Z+16, r1	; 0x10
    492a:	2e 5f       	subi	r18, 0xFE	; 254
    492c:	3f 4f       	sbci	r19, 0xFF	; 255
  strcpy(menu.newMenuText[0], displayBuffer);
  displayBuffer = strtok(NULL, "\0");
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    492e:	24 30       	cpi	r18, 0x04	; 4
    4930:	31 05       	cpc	r19, r1
    4932:	79 f6       	brne	.-98     	; 0x48d2 <changeDisplayMenu+0x78>
    }
    menu.newMenuText[j][DISPLAY_MENU_STRING_LENGTH-1] = '\0';
  }

  return;
}
    4934:	08 95       	ret

00004936 <parseCommand>:
}

/* ---------------------------------------------------------------------
    returns the command code and fills the parameter list
 --------------------------------------------------------------------- */
uint8_t parseCommand(void){
    4936:	af 92       	push	r10
    4938:	bf 92       	push	r11
    493a:	cf 92       	push	r12
    493c:	df 92       	push	r13
    493e:	ef 92       	push	r14
    4940:	ff 92       	push	r15
    4942:	0f 93       	push	r16
    4944:	1f 93       	push	r17
    4946:	cf 93       	push	r28
    4948:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    494a:	f8 94       	cli
  //uint8_t j = 0;
  command *cmdPtr;
  char *token;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
    494c:	80 91 92 04 	lds	r24, 0x0492
    4950:	88 23       	and	r24, r24
    4952:	79 f4       	brne	.+30     	; 0x4972 <parseCommand+0x3c>
    4954:	b0 e8       	ldi	r27, 0x80	; 128
    4956:	ab 2e       	mov	r10, r27
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    4958:	78 94       	sei
      commandString.readyToProcess = 0;
    }
  }

  return commandCode;
}
    495a:	8a 2d       	mov	r24, r10
    495c:	df 91       	pop	r29
    495e:	cf 91       	pop	r28
    4960:	1f 91       	pop	r17
    4962:	0f 91       	pop	r16
    4964:	ff 90       	pop	r15
    4966:	ef 90       	pop	r14
    4968:	df 90       	pop	r13
    496a:	cf 90       	pop	r12
    496c:	bf 90       	pop	r11
    496e:	af 90       	pop	r10
    4970:	08 95       	ret
  char *token;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
      /* extract command and get cmdCode */
      token = strtok(commandString.buffer, ALLOWED_CMD_DELIMITERS);
    4972:	80 91 90 04 	lds	r24, 0x0490
    4976:	90 91 91 04 	lds	r25, 0x0491
    497a:	60 e3       	ldi	r22, 0x30	; 48
    497c:	72 e0       	ldi	r23, 0x02	; 2
    497e:	0e 94 5c 45 	call	0x8ab8	; 0x8ab8 <strtok>
    4982:	6c 01       	movw	r12, r24
    4984:	0a e0       	ldi	r16, 0x0A	; 10
    4986:	13 e0       	ldi	r17, 0x03	; 3
    4988:	a0 e8       	ldi	r26, 0x80	; 128
    498a:	aa 2e       	mov	r10, r26
    498c:	bb 24       	eor	r11, r11
    498e:	e0 90 d6 02 	lds	r14, 0x02D6
    4992:	f0 90 d7 02 	lds	r15, 0x02D7

      for(i = 0; i < TOTAL_NUMBER_OF_COMMANDS; i++){            /* loop over all commands */
        cmdPtr = (command*)pgm_read_word(&commandList[i]);      /* pointer to struct in flash */
    4996:	f8 01       	movw	r30, r16
    4998:	c5 91       	lpm	r28, Z+
    499a:	d4 91       	lpm	r29, Z+
        strcpy_P(commandParam[0], pgm_read_word(&cmdPtr->cmd)); /* contents of command code in flash */
    499c:	fe 01       	movw	r30, r28
    499e:	65 91       	lpm	r22, Z+
    49a0:	74 91       	lpm	r23, Z+
    49a2:	d7 01       	movw	r26, r14
    49a4:	8d 91       	ld	r24, X+
    49a6:	9c 91       	ld	r25, X
    49a8:	0e 94 4a 45 	call	0x8a94	; 0x8a94 <strcpy_P>

        if(strcmp(token, commandParam[0]) == 0){
    49ac:	e0 90 d6 02 	lds	r14, 0x02D6
    49b0:	f0 90 d7 02 	lds	r15, 0x02D7
    49b4:	f7 01       	movw	r30, r14
    49b6:	60 81       	ld	r22, Z
    49b8:	71 81       	ldd	r23, Z+1	; 0x01
    49ba:	c6 01       	movw	r24, r12
    49bc:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    49c0:	00 97       	sbiw	r24, 0x00	; 0
    49c2:	41 f4       	brne	.+16     	; 0x49d4 <parseCommand+0x9e>
          /* found a known command */
          commandCode = (uint8_t)pgm_read_byte(&cmdPtr->cmdCode);
    49c4:	23 96       	adiw	r28, 0x03	; 3
    49c6:	fe 01       	movw	r30, r28
    49c8:	94 91       	lpm	r25, Z+
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
    49ca:	21 97       	sbiw	r28, 0x01	; 1
    49cc:	fe 01       	movw	r30, r28
    49ce:	84 91       	lpm	r24, Z+
    49d0:	a9 2e       	mov	r10, r25
    49d2:	b8 2e       	mov	r11, r24
    49d4:	0e 5f       	subi	r16, 0xFE	; 254
    49d6:	1f 4f       	sbci	r17, 0xFF	; 255
  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
      /* extract command and get cmdCode */
      token = strtok(commandString.buffer, ALLOWED_CMD_DELIMITERS);

      for(i = 0; i < TOTAL_NUMBER_OF_COMMANDS; i++){            /* loop over all commands */
    49d8:	f3 e0       	ldi	r31, 0x03	; 3
    49da:	04 35       	cpi	r16, 0x54	; 84
    49dc:	1f 07       	cpc	r17, r31
    49de:	d9 f6       	brne	.-74     	; 0x4996 <parseCommand+0x60>
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
        }
      }

      /* now parse the command parameters into tokens */
      for(i = 1; i <= noOfOpts; i++){
    49e0:	bb 20       	and	r11, r11
    49e2:	c9 f0       	breq	.+50     	; 0x4a16 <parseCommand+0xe0>
    49e4:	11 e0       	ldi	r17, 0x01	; 1
        token = strtok(NULL, ALLOWED_CMD_DELIMITERS);
    49e6:	80 e0       	ldi	r24, 0x00	; 0
    49e8:	90 e0       	ldi	r25, 0x00	; 0
    49ea:	60 e3       	ldi	r22, 0x30	; 48
    49ec:	72 e0       	ldi	r23, 0x02	; 2
    49ee:	0e 94 5c 45 	call	0x8ab8	; 0x8ab8 <strtok>
    49f2:	bc 01       	movw	r22, r24
        strcpy(commandParam[i], token);
    49f4:	81 2f       	mov	r24, r17
    49f6:	90 e0       	ldi	r25, 0x00	; 0
    49f8:	88 0f       	add	r24, r24
    49fa:	99 1f       	adc	r25, r25
    49fc:	e0 91 d6 02 	lds	r30, 0x02D6
    4a00:	f0 91 d7 02 	lds	r31, 0x02D7
    4a04:	e8 0f       	add	r30, r24
    4a06:	f9 1f       	adc	r31, r25
    4a08:	80 81       	ld	r24, Z
    4a0a:	91 81       	ldd	r25, Z+1	; 0x01
    4a0c:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
        }
      }

      /* now parse the command parameters into tokens */
      for(i = 1; i <= noOfOpts; i++){
    4a10:	1f 5f       	subi	r17, 0xFF	; 255
    4a12:	b1 16       	cp	r11, r17
    4a14:	40 f7       	brcc	.-48     	; 0x49e6 <parseCommand+0xb0>
        token = strtok(NULL, ALLOWED_CMD_DELIMITERS);
        strcpy(commandParam[i], token);
      }

      memset(commandString.buffer, 0, SERIAL_BUFFERSIZE);
    4a16:	e0 91 90 04 	lds	r30, 0x0490
    4a1a:	f0 91 91 04 	lds	r31, 0x0491
    4a1e:	80 e4       	ldi	r24, 0x40	; 64
    4a20:	df 01       	movw	r26, r30
    4a22:	1d 92       	st	X+, r1
    4a24:	8a 95       	dec	r24
    4a26:	e9 f7       	brne	.-6      	; 0x4a22 <parseCommand+0xec>
      commandString.readyToProcess = 0;
    4a28:	10 92 92 04 	sts	0x0492, r1
    4a2c:	95 cf       	rjmp	.-214    	; 0x4958 <parseCommand+0x22>

00004a2e <sendText>:
}

/* ---------------------------------------------------------------------
    sends a terminated string via RS232
 --------------------------------------------------------------------- */
void sendText(char *c){
    4a2e:	fc 01       	movw	r30, r24

  while(*c){
    4a30:	90 81       	ld	r25, Z
    4a32:	99 23       	and	r25, r25
    4a34:	51 f0       	breq	.+20     	; 0x4a4a <sendText+0x1c>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    4a36:	80 91 c0 00 	lds	r24, 0x00C0
    4a3a:	85 ff       	sbrs	r24, 5
    4a3c:	fc cf       	rjmp	.-8      	; 0x4a36 <sendText+0x8>
    ;
  }

  UDR0 = c;
    4a3e:	90 93 c6 00 	sts	0x00C6, r25
 --------------------------------------------------------------------- */
void sendText(char *c){

  while(*c){
    sendChar(*c);
    c++;
    4a42:	31 96       	adiw	r30, 0x01	; 1
/* ---------------------------------------------------------------------
    sends a terminated string via RS232
 --------------------------------------------------------------------- */
void sendText(char *c){

  while(*c){
    4a44:	90 81       	ld	r25, Z
    4a46:	99 23       	and	r25, r25
    4a48:	b1 f7       	brne	.-20     	; 0x4a36 <sendText+0x8>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    4a4a:	80 91 c0 00 	lds	r24, 0x00C0
    4a4e:	85 ff       	sbrs	r24, 5
    4a50:	fc cf       	rjmp	.-8      	; 0x4a4a <sendText+0x1c>
    ;
  }

  UDR0 = c;
    4a52:	8a e0       	ldi	r24, 0x0A	; 10
    4a54:	80 93 c6 00 	sts	0x00C6, r24
    c++;
  }
  /* send LF after finishing text sending */
  sendChar('\n');

  memset(txString.buffer, 0, SERIAL_BUFFERSIZE);
    4a58:	e0 91 e7 03 	lds	r30, 0x03E7
    4a5c:	f0 91 e8 03 	lds	r31, 0x03E8
    4a60:	80 e4       	ldi	r24, 0x40	; 64
    4a62:	df 01       	movw	r26, r30
    4a64:	1d 92       	st	X+, r1
    4a66:	8a 95       	dec	r24
    4a68:	e9 f7       	brne	.-6      	; 0x4a64 <sendText+0x36>

  return;
}
    4a6a:	08 95       	ret

00004a6c <commandLED>:


/* ---------------------------------------------------------------------
    debugging output for anything we'd like to know
 --------------------------------------------------------------------- */
void commandLED(char* param0, char* param1, char* param2){
    4a6c:	df 92       	push	r13
    4a6e:	ef 92       	push	r14
    4a70:	ff 92       	push	r15
    4a72:	0f 93       	push	r16
    4a74:	1f 93       	push	r17
    4a76:	8b 01       	movw	r16, r22
    4a78:	7a 01       	movw	r14, r20

  uint8_t a, b, c;

  a = (uint8_t)strtol(param0, (char **)NULL, 10);
    4a7a:	60 e0       	ldi	r22, 0x00	; 0
    4a7c:	70 e0       	ldi	r23, 0x00	; 0
    4a7e:	4a e0       	ldi	r20, 0x0A	; 10
    4a80:	50 e0       	ldi	r21, 0x00	; 0
    4a82:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    4a86:	d6 2e       	mov	r13, r22
  b = (uint8_t)strtol(param1, (char **)NULL, 10);
    4a88:	c8 01       	movw	r24, r16
    4a8a:	60 e0       	ldi	r22, 0x00	; 0
    4a8c:	70 e0       	ldi	r23, 0x00	; 0
    4a8e:	4a e0       	ldi	r20, 0x0A	; 10
    4a90:	50 e0       	ldi	r21, 0x00	; 0
    4a92:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    4a96:	06 2f       	mov	r16, r22
  c = (uint8_t)strtol(param2, (char **)NULL, 16);
    4a98:	c7 01       	movw	r24, r14
    4a9a:	60 e0       	ldi	r22, 0x00	; 0
    4a9c:	70 e0       	ldi	r23, 0x00	; 0
    4a9e:	40 e1       	ldi	r20, 0x10	; 16
    4aa0:	50 e0       	ldi	r21, 0x00	; 0
    4aa2:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    4aa6:	16 2f       	mov	r17, r22
  
  sprintf(txString.buffer, "\na=%d\nb=%d\nc=%d", a, b, c);
    4aa8:	80 91 e7 03 	lds	r24, 0x03E7
    4aac:	90 91 e8 03 	lds	r25, 0x03E8
    4ab0:	2d b7       	in	r18, 0x3d	; 61
    4ab2:	3e b7       	in	r19, 0x3e	; 62
    4ab4:	2a 50       	subi	r18, 0x0A	; 10
    4ab6:	30 40       	sbci	r19, 0x00	; 0
    4ab8:	0f b6       	in	r0, 0x3f	; 63
    4aba:	f8 94       	cli
    4abc:	3e bf       	out	0x3e, r19	; 62
    4abe:	0f be       	out	0x3f, r0	; 63
    4ac0:	2d bf       	out	0x3d, r18	; 61
    4ac2:	ed b7       	in	r30, 0x3d	; 61
    4ac4:	fe b7       	in	r31, 0x3e	; 62
    4ac6:	31 96       	adiw	r30, 0x01	; 1
    4ac8:	ad b7       	in	r26, 0x3d	; 61
    4aca:	be b7       	in	r27, 0x3e	; 62
    4acc:	12 96       	adiw	r26, 0x02	; 2
    4ace:	9c 93       	st	X, r25
    4ad0:	8e 93       	st	-X, r24
    4ad2:	11 97       	sbiw	r26, 0x01	; 1
    4ad4:	85 e3       	ldi	r24, 0x35	; 53
    4ad6:	92 e0       	ldi	r25, 0x02	; 2
    4ad8:	93 83       	std	Z+3, r25	; 0x03
    4ada:	82 83       	std	Z+2, r24	; 0x02
    4adc:	d4 82       	std	Z+4, r13	; 0x04
    4ade:	15 82       	std	Z+5, r1	; 0x05
    4ae0:	06 83       	std	Z+6, r16	; 0x06
    4ae2:	17 82       	std	Z+7, r1	; 0x07
    4ae4:	10 87       	std	Z+8, r17	; 0x08
    4ae6:	11 86       	std	Z+9, r1	; 0x09
    4ae8:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
  sendText(txString.buffer);
    4aec:	80 91 e7 03 	lds	r24, 0x03E7
    4af0:	90 91 e8 03 	lds	r25, 0x03E8
    4af4:	2d b7       	in	r18, 0x3d	; 61
    4af6:	3e b7       	in	r19, 0x3e	; 62
    4af8:	26 5f       	subi	r18, 0xF6	; 246
    4afa:	3f 4f       	sbci	r19, 0xFF	; 255
    4afc:	0f b6       	in	r0, 0x3f	; 63
    4afe:	f8 94       	cli
    4b00:	3e bf       	out	0x3e, r19	; 62
    4b02:	0f be       	out	0x3f, r0	; 63
    4b04:	2d bf       	out	0x3d, r18	; 61
    4b06:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>

  changeButtonLED(a, b, c);
    4b0a:	8d 2d       	mov	r24, r13
    4b0c:	60 2f       	mov	r22, r16
    4b0e:	41 2f       	mov	r20, r17
    4b10:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
  updateLEDs();
    4b14:	0e 94 2c 07 	call	0xe58	; 0xe58 <updateLEDs>
  
  return;
}
    4b18:	1f 91       	pop	r17
    4b1a:	0f 91       	pop	r16
    4b1c:	ff 90       	pop	r15
    4b1e:	ef 90       	pop	r14
    4b20:	df 90       	pop	r13
    4b22:	08 95       	ret

00004b24 <commandDebugReadout>:
}

/* ---------------------------------------------------------------------
    debugging output for anything we'd like to know
 --------------------------------------------------------------------- */
void commandDebugReadout(){
    4b24:	af 92       	push	r10
    4b26:	bf 92       	push	r11
    4b28:	cf 92       	push	r12
    4b2a:	df 92       	push	r13
    4b2c:	ef 92       	push	r14
    4b2e:	ff 92       	push	r15
    4b30:	0f 93       	push	r16
    4b32:	1f 93       	push	r17
    4b34:	cf 93       	push	r28
    4b36:	df 93       	push	r29
    4b38:	c0 e0       	ldi	r28, 0x00	; 0
    4b3a:	d0 e0       	ldi	r29, 0x00	; 0
    4b3c:	75 e4       	ldi	r23, 0x45	; 69
    4b3e:	c7 2e       	mov	r12, r23
    4b40:	72 e0       	ldi	r23, 0x02	; 2
    4b42:	d7 2e       	mov	r13, r23

  uint8_t i = 0;

  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    sprintf(txString.buffer, "%d %d %d %d %d %d %d", i, programList[i].position[0],
    4b44:	e0 90 e7 03 	lds	r14, 0x03E7
    4b48:	f0 90 e8 03 	lds	r15, 0x03E8
    4b4c:	ce 01       	movw	r24, r28
    4b4e:	fe 01       	movw	r30, r28
    4b50:	ee 0f       	add	r30, r30
    4b52:	ff 1f       	adc	r31, r31
    4b54:	ee 0f       	add	r30, r30
    4b56:	ff 1f       	adc	r31, r31
    4b58:	ee 0f       	add	r30, r30
    4b5a:	ff 1f       	adc	r31, r31
    4b5c:	88 0f       	add	r24, r24
    4b5e:	99 1f       	adc	r25, r25
    4b60:	e8 0f       	add	r30, r24
    4b62:	f9 1f       	adc	r31, r25
    4b64:	ed 50       	subi	r30, 0x0D	; 13
    4b66:	fd 4f       	sbci	r31, 0xFD	; 253
    4b68:	01 81       	ldd	r16, Z+1	; 0x01
    4b6a:	12 81       	ldd	r17, Z+2	; 0x02
    4b6c:	ce 01       	movw	r24, r28
    4b6e:	fe 01       	movw	r30, r28
    4b70:	ee 0f       	add	r30, r30
    4b72:	ff 1f       	adc	r31, r31
    4b74:	ee 0f       	add	r30, r30
    4b76:	ff 1f       	adc	r31, r31
    4b78:	ee 0f       	add	r30, r30
    4b7a:	ff 1f       	adc	r31, r31
    4b7c:	88 0f       	add	r24, r24
    4b7e:	99 1f       	adc	r25, r25
    4b80:	e8 0f       	add	r30, r24
    4b82:	f9 1f       	adc	r31, r25
    4b84:	ed 50       	subi	r30, 0x0D	; 13
    4b86:	fd 4f       	sbci	r31, 0xFD	; 253
    4b88:	a3 80       	ldd	r10, Z+3	; 0x03
    4b8a:	b4 80       	ldd	r11, Z+4	; 0x04
    4b8c:	ce 01       	movw	r24, r28
    4b8e:	fe 01       	movw	r30, r28
    4b90:	ee 0f       	add	r30, r30
    4b92:	ff 1f       	adc	r31, r31
    4b94:	ee 0f       	add	r30, r30
    4b96:	ff 1f       	adc	r31, r31
    4b98:	ee 0f       	add	r30, r30
    4b9a:	ff 1f       	adc	r31, r31
    4b9c:	88 0f       	add	r24, r24
    4b9e:	99 1f       	adc	r25, r25
    4ba0:	e8 0f       	add	r30, r24
    4ba2:	f9 1f       	adc	r31, r25
    4ba4:	ed 50       	subi	r30, 0x0D	; 13
    4ba6:	fd 4f       	sbci	r31, 0xFD	; 253
    4ba8:	45 81       	ldd	r20, Z+5	; 0x05
    4baa:	56 81       	ldd	r21, Z+6	; 0x06
    4bac:	ce 01       	movw	r24, r28
    4bae:	fe 01       	movw	r30, r28
    4bb0:	ee 0f       	add	r30, r30
    4bb2:	ff 1f       	adc	r31, r31
    4bb4:	ee 0f       	add	r30, r30
    4bb6:	ff 1f       	adc	r31, r31
    4bb8:	ee 0f       	add	r30, r30
    4bba:	ff 1f       	adc	r31, r31
    4bbc:	88 0f       	add	r24, r24
    4bbe:	99 1f       	adc	r25, r25
    4bc0:	e8 0f       	add	r30, r24
    4bc2:	f9 1f       	adc	r31, r25
    4bc4:	ed 50       	subi	r30, 0x0D	; 13
    4bc6:	fd 4f       	sbci	r31, 0xFD	; 253
    4bc8:	27 81       	ldd	r18, Z+7	; 0x07
    4bca:	30 85       	ldd	r19, Z+8	; 0x08
    4bcc:	ce 01       	movw	r24, r28
    4bce:	fe 01       	movw	r30, r28
    4bd0:	ee 0f       	add	r30, r30
    4bd2:	ff 1f       	adc	r31, r31
    4bd4:	ee 0f       	add	r30, r30
    4bd6:	ff 1f       	adc	r31, r31
    4bd8:	ee 0f       	add	r30, r30
    4bda:	ff 1f       	adc	r31, r31
    4bdc:	88 0f       	add	r24, r24
    4bde:	99 1f       	adc	r25, r25
    4be0:	e8 0f       	add	r30, r24
    4be2:	f9 1f       	adc	r31, r25
    4be4:	ed 50       	subi	r30, 0x0D	; 13
    4be6:	fd 4f       	sbci	r31, 0xFD	; 253
    4be8:	61 85       	ldd	r22, Z+9	; 0x09
    4bea:	ce 01       	movw	r24, r28
    4bec:	fe 01       	movw	r30, r28
    4bee:	ee 0f       	add	r30, r30
    4bf0:	ff 1f       	adc	r31, r31
    4bf2:	ee 0f       	add	r30, r30
    4bf4:	ff 1f       	adc	r31, r31
    4bf6:	ee 0f       	add	r30, r30
    4bf8:	ff 1f       	adc	r31, r31
    4bfa:	88 0f       	add	r24, r24
    4bfc:	99 1f       	adc	r25, r25
    4bfe:	e8 0f       	add	r30, r24
    4c00:	f9 1f       	adc	r31, r25
    4c02:	ed 50       	subi	r30, 0x0D	; 13
    4c04:	fd 4f       	sbci	r31, 0xFD	; 253
    4c06:	80 81       	ld	r24, Z
    4c08:	ad b7       	in	r26, 0x3d	; 61
    4c0a:	be b7       	in	r27, 0x3e	; 62
    4c0c:	52 97       	sbiw	r26, 0x12	; 18
    4c0e:	0f b6       	in	r0, 0x3f	; 63
    4c10:	f8 94       	cli
    4c12:	be bf       	out	0x3e, r27	; 62
    4c14:	0f be       	out	0x3f, r0	; 63
    4c16:	ad bf       	out	0x3d, r26	; 61
    4c18:	ed b7       	in	r30, 0x3d	; 61
    4c1a:	fe b7       	in	r31, 0x3e	; 62
    4c1c:	31 96       	adiw	r30, 0x01	; 1
    4c1e:	12 96       	adiw	r26, 0x02	; 2
    4c20:	fc 92       	st	X, r15
    4c22:	ee 92       	st	-X, r14
    4c24:	11 97       	sbiw	r26, 0x01	; 1
    4c26:	d3 82       	std	Z+3, r13	; 0x03
    4c28:	c2 82       	std	Z+2, r12	; 0x02
    4c2a:	c4 83       	std	Z+4, r28	; 0x04
    4c2c:	d5 83       	std	Z+5, r29	; 0x05
    4c2e:	17 83       	std	Z+7, r17	; 0x07
    4c30:	06 83       	std	Z+6, r16	; 0x06
    4c32:	b1 86       	std	Z+9, r11	; 0x09
    4c34:	a0 86       	std	Z+8, r10	; 0x08
    4c36:	53 87       	std	Z+11, r21	; 0x0b
    4c38:	42 87       	std	Z+10, r20	; 0x0a
    4c3a:	35 87       	std	Z+13, r19	; 0x0d
    4c3c:	24 87       	std	Z+12, r18	; 0x0c
    4c3e:	66 87       	std	Z+14, r22	; 0x0e
    4c40:	17 86       	std	Z+15, r1	; 0x0f
    4c42:	80 8b       	std	Z+16, r24	; 0x10
    4c44:	11 8a       	std	Z+17, r1	; 0x11
    4c46:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
                                                        programList[i].position[1],
                                                        programList[i].position[2],
                                                        programList[i].position[3],
                                                        programList[i].absRel,
                                                        programList[i].isActive);
    sendText(txString.buffer);
    4c4a:	80 91 e7 03 	lds	r24, 0x03E7
    4c4e:	90 91 e8 03 	lds	r25, 0x03E8
    4c52:	ed b7       	in	r30, 0x3d	; 61
    4c54:	fe b7       	in	r31, 0x3e	; 62
    4c56:	72 96       	adiw	r30, 0x12	; 18
    4c58:	0f b6       	in	r0, 0x3f	; 63
    4c5a:	f8 94       	cli
    4c5c:	fe bf       	out	0x3e, r31	; 62
    4c5e:	0f be       	out	0x3f, r0	; 63
    4c60:	ed bf       	out	0x3d, r30	; 61
    4c62:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    4c66:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void commandDebugReadout(){

  uint8_t i = 0;

  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    4c68:	c0 31       	cpi	r28, 0x10	; 16
    4c6a:	d1 05       	cpc	r29, r1
    4c6c:	09 f0       	breq	.+2      	; 0x4c70 <commandDebugReadout+0x14c>
    4c6e:	6a cf       	rjmp	.-300    	; 0x4b44 <commandDebugReadout+0x20>
                                                        programList[i].isActive);
    sendText(txString.buffer);
  }

  return;
}
    4c70:	df 91       	pop	r29
    4c72:	cf 91       	pop	r28
    4c74:	1f 91       	pop	r17
    4c76:	0f 91       	pop	r16
    4c78:	ff 90       	pop	r15
    4c7a:	ef 90       	pop	r14
    4c7c:	df 90       	pop	r13
    4c7e:	cf 90       	pop	r12
    4c80:	bf 90       	pop	r11
    4c82:	af 90       	pop	r10
    4c84:	08 95       	ret

00004c86 <commandSetMotorDecay>:
}

/* ---------------------------------------------------------------------
    sets the desired motor decay
 --------------------------------------------------------------------- */
void commandSetMotorDecay(char* param0, char* param1){
    4c86:	1f 93       	push	r17
    4c88:	cf 93       	push	r28
    4c8a:	df 93       	push	r29
    4c8c:	eb 01       	movw	r28, r22
  
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4c8e:	60 e0       	ldi	r22, 0x00	; 0
    4c90:	70 e0       	ldi	r23, 0x00	; 0
    4c92:	4a e0       	ldi	r20, 0x0A	; 10
    4c94:	50 e0       	ldi	r21, 0x00	; 0
    4c96:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    4c9a:	16 2f       	mov	r17, r22
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    4c9c:	64 30       	cpi	r22, 0x04	; 4
    4c9e:	80 f5       	brcc	.+96     	; 0x4d00 <commandSetMotorDecay+0x7a>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
  }
  else{
    motor[i].decay = atof(param1);
    4ca0:	ce 01       	movw	r24, r28
    4ca2:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    4ca6:	0e 94 30 40 	call	0x8060	; 0x8060 <__fixsfsi>
    4caa:	e1 2f       	mov	r30, r17
    4cac:	f0 e0       	ldi	r31, 0x00	; 0
    4cae:	ee 0f       	add	r30, r30
    4cb0:	ff 1f       	adc	r31, r31
    4cb2:	ee 0f       	add	r30, r30
    4cb4:	ff 1f       	adc	r31, r31
    4cb6:	ee 0f       	add	r30, r30
    4cb8:	ff 1f       	adc	r31, r31
    4cba:	9f 01       	movw	r18, r30
    4cbc:	22 0f       	add	r18, r18
    4cbe:	33 1f       	adc	r19, r19
    4cc0:	22 0f       	add	r18, r18
    4cc2:	33 1f       	adc	r19, r19
    4cc4:	e2 0f       	add	r30, r18
    4cc6:	f3 1f       	adc	r31, r19
    4cc8:	e0 51       	subi	r30, 0x10	; 16
    4cca:	fc 4f       	sbci	r31, 0xFC	; 252
    4ccc:	67 a3       	std	Z+39, r22	; 0x27
    setMotorDecay(i, motor[i].decay);
    4cce:	e1 2f       	mov	r30, r17
    4cd0:	f0 e0       	ldi	r31, 0x00	; 0
    4cd2:	ee 0f       	add	r30, r30
    4cd4:	ff 1f       	adc	r31, r31
    4cd6:	ee 0f       	add	r30, r30
    4cd8:	ff 1f       	adc	r31, r31
    4cda:	ee 0f       	add	r30, r30
    4cdc:	ff 1f       	adc	r31, r31
    4cde:	cf 01       	movw	r24, r30
    4ce0:	88 0f       	add	r24, r24
    4ce2:	99 1f       	adc	r25, r25
    4ce4:	88 0f       	add	r24, r24
    4ce6:	99 1f       	adc	r25, r25
    4ce8:	e8 0f       	add	r30, r24
    4cea:	f9 1f       	adc	r31, r25
    4cec:	e0 51       	subi	r30, 0x10	; 16
    4cee:	fc 4f       	sbci	r31, 0xFC	; 252
    4cf0:	67 a1       	ldd	r22, Z+39	; 0x27
    4cf2:	81 2f       	mov	r24, r17
    4cf4:	0e 94 0d 0c 	call	0x181a	; 0x181a <setMotorDecay>
  }

  return;
}
    4cf8:	df 91       	pop	r29
    4cfa:	cf 91       	pop	r28
    4cfc:	1f 91       	pop	r17
    4cfe:	08 95       	ret
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4d00:	80 91 e7 03 	lds	r24, 0x03E7
    4d04:	90 91 e8 03 	lds	r25, 0x03E8
    4d08:	00 d0       	rcall	.+0      	; 0x4d0a <commandSetMotorDecay+0x84>
    4d0a:	00 d0       	rcall	.+0      	; 0x4d0c <commandSetMotorDecay+0x86>
    4d0c:	00 d0       	rcall	.+0      	; 0x4d0e <commandSetMotorDecay+0x88>
    4d0e:	ed b7       	in	r30, 0x3d	; 61
    4d10:	fe b7       	in	r31, 0x3e	; 62
    4d12:	31 96       	adiw	r30, 0x01	; 1
    4d14:	ad b7       	in	r26, 0x3d	; 61
    4d16:	be b7       	in	r27, 0x3e	; 62
    4d18:	12 96       	adiw	r26, 0x02	; 2
    4d1a:	9c 93       	st	X, r25
    4d1c:	8e 93       	st	-X, r24
    4d1e:	11 97       	sbiw	r26, 0x01	; 1
    4d20:	80 e0       	ldi	r24, 0x00	; 0
    4d22:	91 e0       	ldi	r25, 0x01	; 1
    4d24:	93 83       	std	Z+3, r25	; 0x03
    4d26:	82 83       	std	Z+2, r24	; 0x02
    4d28:	14 83       	std	Z+4, r17	; 0x04
    4d2a:	15 82       	std	Z+5, r1	; 0x05
    4d2c:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    sendText(txString.buffer);
    4d30:	80 91 e7 03 	lds	r24, 0x03E7
    4d34:	90 91 e8 03 	lds	r25, 0x03E8
    4d38:	2d b7       	in	r18, 0x3d	; 61
    4d3a:	3e b7       	in	r19, 0x3e	; 62
    4d3c:	2a 5f       	subi	r18, 0xFA	; 250
    4d3e:	3f 4f       	sbci	r19, 0xFF	; 255
    4d40:	0f b6       	in	r0, 0x3f	; 63
    4d42:	f8 94       	cli
    4d44:	3e bf       	out	0x3e, r19	; 62
    4d46:	0f be       	out	0x3f, r0	; 63
    4d48:	2d bf       	out	0x3d, r18	; 61
    4d4a:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    motor[i].decay = atof(param1);
    setMotorDecay(i, motor[i].decay);
  }

  return;
}
    4d4e:	df 91       	pop	r29
    4d50:	cf 91       	pop	r28
    4d52:	1f 91       	pop	r17
    4d54:	08 95       	ret

00004d56 <commandGetMotorState>:
void commandGetMotorState(char* param0){

  uint8_t i = 0;
  //uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4d56:	60 e0       	ldi	r22, 0x00	; 0
    4d58:	70 e0       	ldi	r23, 0x00	; 0
    4d5a:	4a e0       	ldi	r20, 0x0A	; 10
    4d5c:	50 e0       	ldi	r21, 0x00	; 0
    4d5e:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    4d62:	64 30       	cpi	r22, 0x04	; 4
    4d64:	90 f5       	brcc	.+100    	; 0x4dca <commandGetMotorState+0x74>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    if(motor[i].isTurnedOn){
    4d66:	e6 2f       	mov	r30, r22
    4d68:	f0 e0       	ldi	r31, 0x00	; 0
    4d6a:	ee 0f       	add	r30, r30
    4d6c:	ff 1f       	adc	r31, r31
    4d6e:	ee 0f       	add	r30, r30
    4d70:	ff 1f       	adc	r31, r31
    4d72:	ee 0f       	add	r30, r30
    4d74:	ff 1f       	adc	r31, r31
    4d76:	cf 01       	movw	r24, r30
    4d78:	88 0f       	add	r24, r24
    4d7a:	99 1f       	adc	r25, r25
    4d7c:	88 0f       	add	r24, r24
    4d7e:	99 1f       	adc	r25, r25
    4d80:	e8 0f       	add	r30, r24
    4d82:	f9 1f       	adc	r31, r25
    4d84:	e0 51       	subi	r30, 0x10	; 16
    4d86:	fc 4f       	sbci	r31, 0xFC	; 252
    4d88:	83 85       	ldd	r24, Z+11	; 0x0b
    4d8a:	88 23       	and	r24, r24
    4d8c:	79 f4       	brne	.+30     	; 0x4dac <commandGetMotorState+0x56>
      sprintf(txString.buffer, "1");
    }
    else{
      sprintf(txString.buffer, "0");
    4d8e:	e0 91 e7 03 	lds	r30, 0x03E7
    4d92:	f0 91 e8 03 	lds	r31, 0x03E8
    4d96:	80 e3       	ldi	r24, 0x30	; 48
    4d98:	90 e0       	ldi	r25, 0x00	; 0
    4d9a:	91 83       	std	Z+1, r25	; 0x01
    4d9c:	80 83       	st	Z, r24
    }

    sendText(txString.buffer);
    4d9e:	80 91 e7 03 	lds	r24, 0x03E7
    4da2:	90 91 e8 03 	lds	r25, 0x03E8
    4da6:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    4daa:	08 95       	ret
    sendText(txString.buffer);
    return;
  }
  else{
    if(motor[i].isTurnedOn){
      sprintf(txString.buffer, "1");
    4dac:	e0 91 e7 03 	lds	r30, 0x03E7
    4db0:	f0 91 e8 03 	lds	r31, 0x03E8
    4db4:	81 e3       	ldi	r24, 0x31	; 49
    4db6:	90 e0       	ldi	r25, 0x00	; 0
    4db8:	91 83       	std	Z+1, r25	; 0x01
    4dba:	80 83       	st	Z, r24
    }
    else{
      sprintf(txString.buffer, "0");
    }

    sendText(txString.buffer);
    4dbc:	80 91 e7 03 	lds	r24, 0x03E7
    4dc0:	90 91 e8 03 	lds	r25, 0x03E8
    4dc4:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    4dc8:	08 95       	ret
  //uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    4dca:	a0 91 e7 03 	lds	r26, 0x03E7
    4dce:	b0 91 e8 03 	lds	r27, 0x03E8
    4dd2:	ea e5       	ldi	r30, 0x5A	; 90
    4dd4:	f2 e0       	ldi	r31, 0x02	; 2
    4dd6:	83 e1       	ldi	r24, 0x13	; 19
    4dd8:	01 90       	ld	r0, Z+
    4dda:	0d 92       	st	X+, r0
    4ddc:	81 50       	subi	r24, 0x01	; 1
    4dde:	e1 f7       	brne	.-8      	; 0x4dd8 <commandGetMotorState+0x82>
    4de0:	de cf       	rjmp	.-68     	; 0x4d9e <commandGetMotorState+0x48>

00004de2 <commandEnableForbiddenZone>:
}

/* ---------------------------------------------------------------------
    enable/disable forbidden zone
 --------------------------------------------------------------------- */
void commandEnableForbiddenZone(char* param0, char* param1){
    4de2:	1f 93       	push	r17
    4de4:	cf 93       	push	r28
    4de6:	df 93       	push	r29
    4de8:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4dea:	60 e0       	ldi	r22, 0x00	; 0
    4dec:	70 e0       	ldi	r23, 0x00	; 0
    4dee:	4a e0       	ldi	r20, 0x0A	; 10
    4df0:	50 e0       	ldi	r21, 0x00	; 0
    4df2:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    4df6:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4df8:	64 30       	cpi	r22, 0x04	; 4
    4dfa:	b8 f4       	brcc	.+46     	; 0x4e2a <commandEnableForbiddenZone+0x48>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    val = (uint8_t)strtol(param1, (char **)NULL, 10);
    4dfc:	ce 01       	movw	r24, r28
    4dfe:	60 e0       	ldi	r22, 0x00	; 0
    4e00:	70 e0       	ldi	r23, 0x00	; 0
    4e02:	4a e0       	ldi	r20, 0x0A	; 10
    4e04:	50 e0       	ldi	r21, 0x00	; 0
    4e06:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    forbiddenZone[i].active = val;
    4e0a:	81 2f       	mov	r24, r17
    4e0c:	90 e0       	ldi	r25, 0x00	; 0
    4e0e:	fc 01       	movw	r30, r24
    4e10:	ee 0f       	add	r30, r30
    4e12:	ff 1f       	adc	r31, r31
    4e14:	ee 0f       	add	r30, r30
    4e16:	ff 1f       	adc	r31, r31
    4e18:	e8 0f       	add	r30, r24
    4e1a:	f9 1f       	adc	r31, r25
    4e1c:	ed 52       	subi	r30, 0x2D	; 45
    4e1e:	fc 4f       	sbci	r31, 0xFC	; 252
    4e20:	64 83       	std	Z+4, r22	; 0x04
  }

  return;
}
    4e22:	df 91       	pop	r29
    4e24:	cf 91       	pop	r28
    4e26:	1f 91       	pop	r17
    4e28:	08 95       	ret
  uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    4e2a:	a0 91 e7 03 	lds	r26, 0x03E7
    4e2e:	b0 91 e8 03 	lds	r27, 0x03E8
    4e32:	ea e5       	ldi	r30, 0x5A	; 90
    4e34:	f2 e0       	ldi	r31, 0x02	; 2
    4e36:	83 e1       	ldi	r24, 0x13	; 19
    4e38:	01 90       	ld	r0, Z+
    4e3a:	0d 92       	st	X+, r0
    4e3c:	81 50       	subi	r24, 0x01	; 1
    4e3e:	e1 f7       	brne	.-8      	; 0x4e38 <commandEnableForbiddenZone+0x56>
    sendText(txString.buffer);
    4e40:	80 91 e7 03 	lds	r24, 0x03E7
    4e44:	90 91 e8 03 	lds	r25, 0x03E8
    4e48:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    4e4c:	ea cf       	rjmp	.-44     	; 0x4e22 <commandEnableForbiddenZone+0x40>

00004e4e <commandSetForbiddenZone>:
}

/* ---------------------------------------------------------------------
    defines forbidden zone
 --------------------------------------------------------------------- */
void commandSetForbiddenZone(char* param0, char* param1, char* param2){
    4e4e:	ff 92       	push	r15
    4e50:	0f 93       	push	r16
    4e52:	1f 93       	push	r17
    4e54:	cf 93       	push	r28
    4e56:	df 93       	push	r29
    4e58:	eb 01       	movw	r28, r22
    4e5a:	8a 01       	movw	r16, r20
  uint8_t i = 0;
  int16_t start = 0;
  int16_t stop  = 0;
  int16_t swap = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4e5c:	60 e0       	ldi	r22, 0x00	; 0
    4e5e:	70 e0       	ldi	r23, 0x00	; 0
    4e60:	4a e0       	ldi	r20, 0x0A	; 10
    4e62:	50 e0       	ldi	r21, 0x00	; 0
    4e64:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    4e68:	f6 2e       	mov	r15, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4e6a:	83 e0       	ldi	r24, 0x03	; 3
    4e6c:	8f 15       	cp	r24, r15
    4e6e:	28 f1       	brcs	.+74     	; 0x4eba <commandSetForbiddenZone+0x6c>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    start = (int16_t)atoi(param1);
    4e70:	ce 01       	movw	r24, r28
    4e72:	0e 94 4c 44 	call	0x8898	; 0x8898 <atoi>
    4e76:	ec 01       	movw	r28, r24
    stop  = (int16_t)atoi(param2);
    4e78:	c8 01       	movw	r24, r16
    4e7a:	0e 94 4c 44 	call	0x8898	; 0x8898 <atoi>
    4e7e:	ac 01       	movw	r20, r24

    if(start == stop){
    4e80:	c8 17       	cp	r28, r24
    4e82:	d9 07       	cpc	r29, r25
    4e84:	79 f1       	breq	.+94     	; 0x4ee4 <commandSetForbiddenZone+0x96>
      forbiddenZone[i].stop   = 0;
      forbiddenZone[i].active = 0;
      return;
    }

    if(start > stop){
    4e86:	8c 17       	cp	r24, r28
    4e88:	9d 07       	cpc	r25, r29
    4e8a:	4c f1       	brlt	.+82     	; 0x4ede <commandSetForbiddenZone+0x90>
      swap = stop;
      stop = start;
      start = swap;
    }

    forbiddenZone[i].start  = start;
    4e8c:	8f 2d       	mov	r24, r15
    4e8e:	90 e0       	ldi	r25, 0x00	; 0
    4e90:	fc 01       	movw	r30, r24
    4e92:	ee 0f       	add	r30, r30
    4e94:	ff 1f       	adc	r31, r31
    4e96:	ee 0f       	add	r30, r30
    4e98:	ff 1f       	adc	r31, r31
    4e9a:	e8 0f       	add	r30, r24
    4e9c:	f9 1f       	adc	r31, r25
    4e9e:	ed 52       	subi	r30, 0x2D	; 45
    4ea0:	fc 4f       	sbci	r31, 0xFC	; 252
    4ea2:	d1 83       	std	Z+1, r29	; 0x01
    4ea4:	c0 83       	st	Z, r28
    forbiddenZone[i].stop   = stop;
    4ea6:	53 83       	std	Z+3, r21	; 0x03
    4ea8:	42 83       	std	Z+2, r20	; 0x02
    forbiddenZone[i].active = 1;
    4eaa:	81 e0       	ldi	r24, 0x01	; 1
    4eac:	84 83       	std	Z+4, r24	; 0x04
  }

  return;
}
    4eae:	df 91       	pop	r29
    4eb0:	cf 91       	pop	r28
    4eb2:	1f 91       	pop	r17
    4eb4:	0f 91       	pop	r16
    4eb6:	ff 90       	pop	r15
    4eb8:	08 95       	ret
  int16_t swap = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    4eba:	a0 91 e7 03 	lds	r26, 0x03E7
    4ebe:	b0 91 e8 03 	lds	r27, 0x03E8
    4ec2:	ea e5       	ldi	r30, 0x5A	; 90
    4ec4:	f2 e0       	ldi	r31, 0x02	; 2
    4ec6:	83 e1       	ldi	r24, 0x13	; 19
    4ec8:	01 90       	ld	r0, Z+
    4eca:	0d 92       	st	X+, r0
    4ecc:	81 50       	subi	r24, 0x01	; 1
    4ece:	e1 f7       	brne	.-8      	; 0x4ec8 <commandSetForbiddenZone+0x7a>
    sendText(txString.buffer);
    4ed0:	80 91 e7 03 	lds	r24, 0x03E7
    4ed4:	90 91 e8 03 	lds	r25, 0x03E8
    4ed8:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    4edc:	e8 cf       	rjmp	.-48     	; 0x4eae <commandSetForbiddenZone+0x60>
      forbiddenZone[i].stop   = 0;
      forbiddenZone[i].active = 0;
      return;
    }

    if(start > stop){
    4ede:	ae 01       	movw	r20, r28
    4ee0:	ec 01       	movw	r28, r24
    4ee2:	d4 cf       	rjmp	.-88     	; 0x4e8c <commandSetForbiddenZone+0x3e>
  else{
    start = (int16_t)atoi(param1);
    stop  = (int16_t)atoi(param2);

    if(start == stop){
      forbiddenZone[i].start  = 0;
    4ee4:	8f 2d       	mov	r24, r15
    4ee6:	90 e0       	ldi	r25, 0x00	; 0
    4ee8:	fc 01       	movw	r30, r24
    4eea:	ee 0f       	add	r30, r30
    4eec:	ff 1f       	adc	r31, r31
    4eee:	ee 0f       	add	r30, r30
    4ef0:	ff 1f       	adc	r31, r31
    4ef2:	e8 0f       	add	r30, r24
    4ef4:	f9 1f       	adc	r31, r25
    4ef6:	ed 52       	subi	r30, 0x2D	; 45
    4ef8:	fc 4f       	sbci	r31, 0xFC	; 252
    4efa:	11 82       	std	Z+1, r1	; 0x01
    4efc:	10 82       	st	Z, r1
      forbiddenZone[i].stop   = 0;
    4efe:	13 82       	std	Z+3, r1	; 0x03
    4f00:	12 82       	std	Z+2, r1	; 0x02
      forbiddenZone[i].active = 0;
    4f02:	14 82       	std	Z+4, r1	; 0x04
    forbiddenZone[i].stop   = stop;
    forbiddenZone[i].active = 1;
  }

  return;
}
    4f04:	df 91       	pop	r29
    4f06:	cf 91       	pop	r28
    4f08:	1f 91       	pop	r17
    4f0a:	0f 91       	pop	r16
    4f0c:	ff 90       	pop	r15
    4f0e:	08 95       	ret

00004f10 <commandSetConstSpeed>:
}

/* ---------------------------------------------------------------------
    sets the infinite moving mode
 --------------------------------------------------------------------- */
void commandSetConstSpeed(char* param0, char* param1, char* param2){
    4f10:	2f 92       	push	r2
    4f12:	3f 92       	push	r3
    4f14:	4f 92       	push	r4
    4f16:	5f 92       	push	r5
    4f18:	6f 92       	push	r6
    4f1a:	7f 92       	push	r7
    4f1c:	8f 92       	push	r8
    4f1e:	9f 92       	push	r9
    4f20:	af 92       	push	r10
    4f22:	bf 92       	push	r11
    4f24:	cf 92       	push	r12
    4f26:	df 92       	push	r13
    4f28:	ef 92       	push	r14
    4f2a:	ff 92       	push	r15
    4f2c:	0f 93       	push	r16
    4f2e:	1f 93       	push	r17
    4f30:	df 93       	push	r29
    4f32:	cf 93       	push	r28
    4f34:	00 d0       	rcall	.+0      	; 0x4f36 <commandSetConstSpeed+0x26>
    4f36:	00 d0       	rcall	.+0      	; 0x4f38 <commandSetConstSpeed+0x28>
    4f38:	00 d0       	rcall	.+0      	; 0x4f3a <commandSetConstSpeed+0x2a>
    4f3a:	cd b7       	in	r28, 0x3d	; 61
    4f3c:	de b7       	in	r29, 0x3e	; 62
    4f3e:	7a 83       	std	Y+2, r23	; 0x02
    4f40:	69 83       	std	Y+1, r22	; 0x01
    4f42:	8a 01       	movw	r16, r20

  uint8_t i = 0;
  double val = 0.0;
  uint16_t waitTime = 1;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4f44:	60 e0       	ldi	r22, 0x00	; 0
    4f46:	70 e0       	ldi	r23, 0x00	; 0
    4f48:	4a e0       	ldi	r20, 0x0A	; 10
    4f4a:	50 e0       	ldi	r21, 0x00	; 0
    4f4c:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    4f50:	64 30       	cpi	r22, 0x04	; 4
    4f52:	08 f0       	brcs	.+2      	; 0x4f56 <commandSetConstSpeed+0x46>
    4f54:	62 c0       	rjmp	.+196    	; 0x501a <commandSetConstSpeed+0x10a>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    if(forbiddenZone[i].active){
    4f56:	e6 2e       	mov	r14, r22
    4f58:	ff 24       	eor	r15, r15
    4f5a:	97 01       	movw	r18, r14
    4f5c:	22 0f       	add	r18, r18
    4f5e:	33 1f       	adc	r19, r19
    4f60:	22 0f       	add	r18, r18
    4f62:	33 1f       	adc	r19, r19
    4f64:	3c 83       	std	Y+4, r19	; 0x04
    4f66:	2b 83       	std	Y+3, r18	; 0x03
    4f68:	f9 01       	movw	r30, r18
    4f6a:	ee 0d       	add	r30, r14
    4f6c:	ff 1d       	adc	r31, r15
    4f6e:	ed 52       	subi	r30, 0x2D	; 45
    4f70:	fc 4f       	sbci	r31, 0xFC	; 252
    4f72:	84 81       	ldd	r24, Z+4	; 0x04
    4f74:	88 23       	and	r24, r24
    4f76:	c9 f0       	breq	.+50     	; 0x4faa <commandSetConstSpeed+0x9a>
      motor[i].desiredPosition += -1;
    }
  }

  return;
}
    4f78:	26 96       	adiw	r28, 0x06	; 6
    4f7a:	0f b6       	in	r0, 0x3f	; 63
    4f7c:	f8 94       	cli
    4f7e:	de bf       	out	0x3e, r29	; 62
    4f80:	0f be       	out	0x3f, r0	; 63
    4f82:	cd bf       	out	0x3d, r28	; 61
    4f84:	cf 91       	pop	r28
    4f86:	df 91       	pop	r29
    4f88:	1f 91       	pop	r17
    4f8a:	0f 91       	pop	r16
    4f8c:	ff 90       	pop	r15
    4f8e:	ef 90       	pop	r14
    4f90:	df 90       	pop	r13
    4f92:	cf 90       	pop	r12
    4f94:	bf 90       	pop	r11
    4f96:	af 90       	pop	r10
    4f98:	9f 90       	pop	r9
    4f9a:	8f 90       	pop	r8
    4f9c:	7f 90       	pop	r7
    4f9e:	6f 90       	pop	r6
    4fa0:	5f 90       	pop	r5
    4fa2:	4f 90       	pop	r4
    4fa4:	3f 90       	pop	r3
    4fa6:	2f 90       	pop	r2
    4fa8:	08 95       	ret
      /* command not allowed if forbidden zone is set */
      return;
    }

    /* this is the wait-time for a full rotation in seconds */
    val = atof(param2);
    4faa:	c8 01       	movw	r24, r16
    4fac:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    4fb0:	3b 01       	movw	r6, r22
    4fb2:	4c 01       	movw	r8, r24

    if(strcmp(param1, "STOP") == 0){
    4fb4:	89 81       	ldd	r24, Y+1	; 0x01
    4fb6:	9a 81       	ldd	r25, Y+2	; 0x02
    4fb8:	6d e6       	ldi	r22, 0x6D	; 109
    4fba:	72 e0       	ldi	r23, 0x02	; 2
    4fbc:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    4fc0:	00 97       	sbiw	r24, 0x00	; 0
    4fc2:	09 f0       	breq	.+2      	; 0x4fc6 <commandSetConstSpeed+0xb6>
    4fc4:	3c c0       	rjmp	.+120    	; 0x503e <commandSetConstSpeed+0x12e>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4fc6:	f8 94       	cli
      ATOMIC_BLOCK(ATOMIC_FORCEON){
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    4fc8:	c7 01       	movw	r24, r14
    4fca:	88 0f       	add	r24, r24
    4fcc:	99 1f       	adc	r25, r25
    4fce:	88 0f       	add	r24, r24
    4fd0:	99 1f       	adc	r25, r25
    4fd2:	88 0f       	add	r24, r24
    4fd4:	99 1f       	adc	r25, r25
    4fd6:	fc 01       	movw	r30, r24
    4fd8:	ee 0f       	add	r30, r30
    4fda:	ff 1f       	adc	r31, r31
    4fdc:	ee 0f       	add	r30, r30
    4fde:	ff 1f       	adc	r31, r31
    4fe0:	e8 0f       	add	r30, r24
    4fe2:	f9 1f       	adc	r31, r25
    4fe4:	e0 51       	subi	r30, 0x10	; 16
    4fe6:	fc 4f       	sbci	r31, 0xFC	; 252
    4fe8:	14 86       	std	Z+12, r1	; 0x0c
        motor[i].waitBetweenSteps = 3;
    4fea:	83 e0       	ldi	r24, 0x03	; 3
    4fec:	90 e0       	ldi	r25, 0x00	; 0
    4fee:	97 8f       	std	Z+31, r25	; 0x1f
    4ff0:	86 8f       	std	Z+30, r24	; 0x1e
        motor[i].desiredPosition  = motor[i].actualPosition;
    4ff2:	80 81       	ld	r24, Z
    4ff4:	91 81       	ldd	r25, Z+1	; 0x01
    4ff6:	eb 81       	ldd	r30, Y+3	; 0x03
    4ff8:	fc 81       	ldd	r31, Y+4	; 0x04
    4ffa:	ee 0f       	add	r30, r30
    4ffc:	ff 1f       	adc	r31, r31
    4ffe:	ee 0f       	add	r30, r30
    5000:	ff 1f       	adc	r31, r31
    5002:	ab 81       	ldd	r26, Y+3	; 0x03
    5004:	bc 81       	ldd	r27, Y+4	; 0x04
    5006:	ea 0f       	add	r30, r26
    5008:	fb 1f       	adc	r31, r27
    500a:	ee 0f       	add	r30, r30
    500c:	ff 1f       	adc	r31, r31
    500e:	ee 50       	subi	r30, 0x0E	; 14
    5010:	fc 4f       	sbci	r31, 0xFC	; 252
    5012:	91 83       	std	Z+1, r25	; 0x01
    5014:	80 83       	st	Z, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    5016:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    5018:	af cf       	rjmp	.-162    	; 0x4f78 <commandSetConstSpeed+0x68>
  uint16_t waitTime = 1;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    501a:	a0 91 e7 03 	lds	r26, 0x03E7
    501e:	b0 91 e8 03 	lds	r27, 0x03E8
    5022:	ea e5       	ldi	r30, 0x5A	; 90
    5024:	f2 e0       	ldi	r31, 0x02	; 2
    5026:	83 e1       	ldi	r24, 0x13	; 19
    5028:	01 90       	ld	r0, Z+
    502a:	0d 92       	st	X+, r0
    502c:	81 50       	subi	r24, 0x01	; 1
    502e:	e1 f7       	brne	.-8      	; 0x5028 <commandSetConstSpeed+0x118>
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
    5030:	80 91 e7 03 	lds	r24, 0x03E7
    5034:	90 91 e8 03 	lds	r25, 0x03E8
    5038:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    503c:	9d cf       	rjmp	.-198    	; 0x4f78 <commandSetConstSpeed+0x68>
      }
      return;
    }

    /* now calculate wait time between two steps in ms */
    waitTime = (uint16_t)round((fabs(val)*1000.0f) / ( motor[i].gearRatio
    503e:	f7 01       	movw	r30, r14
    5040:	ee 0f       	add	r30, r30
    5042:	ff 1f       	adc	r31, r31
    5044:	ee 0f       	add	r30, r30
    5046:	ff 1f       	adc	r31, r31
    5048:	ee 0f       	add	r30, r30
    504a:	ff 1f       	adc	r31, r31
    504c:	fe 83       	std	Y+6, r31	; 0x06
    504e:	ed 83       	std	Y+5, r30	; 0x05
    5050:	ee 0f       	add	r30, r30
    5052:	ff 1f       	adc	r31, r31
    5054:	ee 0f       	add	r30, r30
    5056:	ff 1f       	adc	r31, r31
    5058:	2d 81       	ldd	r18, Y+5	; 0x05
    505a:	3e 81       	ldd	r19, Y+6	; 0x06
    505c:	e2 0f       	add	r30, r18
    505e:	f3 1f       	adc	r31, r19
    5060:	e0 51       	subi	r30, 0x10	; 16
    5062:	fc 4f       	sbci	r31, 0xFC	; 252
    5064:	e5 84       	ldd	r14, Z+13	; 0x0d
    5066:	f6 84       	ldd	r15, Z+14	; 0x0e
    5068:	07 85       	ldd	r16, Z+15	; 0x0f
    506a:	10 89       	ldd	r17, Z+16	; 0x10
    506c:	a1 88       	ldd	r10, Z+17	; 0x11
    506e:	b2 88       	ldd	r11, Z+18	; 0x12
    5070:	c3 88       	ldd	r12, Z+19	; 0x13
    5072:	d4 88       	ldd	r13, Z+20	; 0x14
    5074:	25 88       	ldd	r2, Z+21	; 0x15
    5076:	36 88       	ldd	r3, Z+22	; 0x16
    5078:	47 88       	ldd	r4, Z+23	; 0x17
    507a:	50 8c       	ldd	r5, Z+24	; 0x18
    507c:	c4 01       	movw	r24, r8
    507e:	b3 01       	movw	r22, r6
    5080:	9f 77       	andi	r25, 0x7F	; 127
    5082:	20 e0       	ldi	r18, 0x00	; 0
    5084:	30 e0       	ldi	r19, 0x00	; 0
    5086:	4a e7       	ldi	r20, 0x7A	; 122
    5088:	54 e4       	ldi	r21, 0x44	; 68
    508a:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    508e:	3b 01       	movw	r6, r22
    5090:	4c 01       	movw	r8, r24
    5092:	c8 01       	movw	r24, r16
    5094:	b7 01       	movw	r22, r14
    5096:	a6 01       	movw	r20, r12
    5098:	95 01       	movw	r18, r10
    509a:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    509e:	a2 01       	movw	r20, r4
    50a0:	91 01       	movw	r18, r2
    50a2:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    50a6:	9b 01       	movw	r18, r22
    50a8:	ac 01       	movw	r20, r24
    50aa:	c4 01       	movw	r24, r8
    50ac:	b3 01       	movw	r22, r6
    50ae:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>
    50b2:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    50b6:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
    50ba:	8b 01       	movw	r16, r22
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
    50bc:	67 2b       	or	r22, r23
    50be:	09 f4       	brne	.+2      	; 0x50c2 <commandSetConstSpeed+0x1b2>
    50c0:	77 c0       	rjmp	.+238    	; 0x51b0 <commandSetConstSpeed+0x2a0>
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
      return;
    }
    if(waitTime > 9999){
    50c2:	37 e2       	ldi	r19, 0x27	; 39
    50c4:	60 31       	cpi	r22, 0x10	; 16
    50c6:	73 07       	cpc	r23, r19
    50c8:	08 f0       	brcs	.+2      	; 0x50cc <commandSetConstSpeed+0x1bc>
    50ca:	60 c0       	rjmp	.+192    	; 0x518c <commandSetConstSpeed+0x27c>
    sprintf(txString.buffer, "err: time too long");
    sendText(txString.buffer);
    }

    if(strcmp(param1, "CW")  == 0){
    50cc:	89 81       	ldd	r24, Y+1	; 0x01
    50ce:	9a 81       	ldd	r25, Y+2	; 0x02
    50d0:	69 e9       	ldi	r22, 0x99	; 153
    50d2:	72 e0       	ldi	r23, 0x02	; 2
    50d4:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    50d8:	00 97       	sbiw	r24, 0x00	; 0
    50da:	39 f5       	brne	.+78     	; 0x512a <commandSetConstSpeed+0x21a>
      motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CW;
    50dc:	ed 81       	ldd	r30, Y+5	; 0x05
    50de:	fe 81       	ldd	r31, Y+6	; 0x06
    50e0:	ee 0f       	add	r30, r30
    50e2:	ff 1f       	adc	r31, r31
    50e4:	ee 0f       	add	r30, r30
    50e6:	ff 1f       	adc	r31, r31
    50e8:	8d 81       	ldd	r24, Y+5	; 0x05
    50ea:	9e 81       	ldd	r25, Y+6	; 0x06
    50ec:	e8 0f       	add	r30, r24
    50ee:	f9 1f       	adc	r31, r25
    50f0:	e0 51       	subi	r30, 0x10	; 16
    50f2:	fc 4f       	sbci	r31, 0xFC	; 252
    50f4:	81 e0       	ldi	r24, 0x01	; 1
    50f6:	84 87       	std	Z+12, r24	; 0x0c
      motor[i].waitBetweenSteps = waitTime;
    50f8:	17 8f       	std	Z+31, r17	; 0x1f
    50fa:	06 8f       	std	Z+30, r16	; 0x1e
      motor[i].desiredPosition  = motor[i].actualPosition;
    50fc:	80 81       	ld	r24, Z
    50fe:	91 81       	ldd	r25, Z+1	; 0x01
    5100:	eb 81       	ldd	r30, Y+3	; 0x03
    5102:	fc 81       	ldd	r31, Y+4	; 0x04
    5104:	ee 0f       	add	r30, r30
    5106:	ff 1f       	adc	r31, r31
    5108:	ee 0f       	add	r30, r30
    510a:	ff 1f       	adc	r31, r31
    510c:	ab 81       	ldd	r26, Y+3	; 0x03
    510e:	bc 81       	ldd	r27, Y+4	; 0x04
    5110:	ea 0f       	add	r30, r26
    5112:	fb 1f       	adc	r31, r27
    5114:	ee 0f       	add	r30, r30
    5116:	ff 1f       	adc	r31, r31
    5118:	ee 50       	subi	r30, 0x0E	; 14
    511a:	fc 4f       	sbci	r31, 0xFC	; 252
    511c:	91 83       	std	Z+1, r25	; 0x01
    511e:	80 83       	st	Z, r24
      motor[i].desiredPosition += 1;
    5120:	80 81       	ld	r24, Z
    5122:	91 81       	ldd	r25, Z+1	; 0x01
    5124:	01 96       	adiw	r24, 0x01	; 1
    5126:	91 83       	std	Z+1, r25	; 0x01
    5128:	80 83       	st	Z, r24
    }
    if(strcmp(param1, "CCW") == 0){
    512a:	89 81       	ldd	r24, Y+1	; 0x01
    512c:	9a 81       	ldd	r25, Y+2	; 0x02
    512e:	6c e9       	ldi	r22, 0x9C	; 156
    5130:	72 e0       	ldi	r23, 0x02	; 2
    5132:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5136:	00 97       	sbiw	r24, 0x00	; 0
    5138:	09 f0       	breq	.+2      	; 0x513c <commandSetConstSpeed+0x22c>
    513a:	1e cf       	rjmp	.-452    	; 0x4f78 <commandSetConstSpeed+0x68>
      motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
    513c:	ed 81       	ldd	r30, Y+5	; 0x05
    513e:	fe 81       	ldd	r31, Y+6	; 0x06
    5140:	ee 0f       	add	r30, r30
    5142:	ff 1f       	adc	r31, r31
    5144:	ee 0f       	add	r30, r30
    5146:	ff 1f       	adc	r31, r31
    5148:	2d 81       	ldd	r18, Y+5	; 0x05
    514a:	3e 81       	ldd	r19, Y+6	; 0x06
    514c:	e2 0f       	add	r30, r18
    514e:	f3 1f       	adc	r31, r19
    5150:	e0 51       	subi	r30, 0x10	; 16
    5152:	fc 4f       	sbci	r31, 0xFC	; 252
    5154:	82 e0       	ldi	r24, 0x02	; 2
    5156:	84 87       	std	Z+12, r24	; 0x0c
      motor[i].waitBetweenSteps = waitTime;
    5158:	17 8f       	std	Z+31, r17	; 0x1f
    515a:	06 8f       	std	Z+30, r16	; 0x1e
      motor[i].desiredPosition  = motor[i].actualPosition;
    515c:	80 81       	ld	r24, Z
    515e:	91 81       	ldd	r25, Z+1	; 0x01
    5160:	eb 81       	ldd	r30, Y+3	; 0x03
    5162:	fc 81       	ldd	r31, Y+4	; 0x04
    5164:	ee 0f       	add	r30, r30
    5166:	ff 1f       	adc	r31, r31
    5168:	ee 0f       	add	r30, r30
    516a:	ff 1f       	adc	r31, r31
    516c:	ab 81       	ldd	r26, Y+3	; 0x03
    516e:	bc 81       	ldd	r27, Y+4	; 0x04
    5170:	ea 0f       	add	r30, r26
    5172:	fb 1f       	adc	r31, r27
    5174:	ee 0f       	add	r30, r30
    5176:	ff 1f       	adc	r31, r31
    5178:	ee 50       	subi	r30, 0x0E	; 14
    517a:	fc 4f       	sbci	r31, 0xFC	; 252
    517c:	91 83       	std	Z+1, r25	; 0x01
    517e:	80 83       	st	Z, r24
      motor[i].desiredPosition += -1;
    5180:	80 81       	ld	r24, Z
    5182:	91 81       	ldd	r25, Z+1	; 0x01
    5184:	01 97       	sbiw	r24, 0x01	; 1
    5186:	91 83       	std	Z+1, r25	; 0x01
    5188:	80 83       	st	Z, r24
    518a:	f6 ce       	rjmp	.-532    	; 0x4f78 <commandSetConstSpeed+0x68>
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
      return;
    }
    if(waitTime > 9999){
    sprintf(txString.buffer, "err: time too long");
    518c:	a0 91 e7 03 	lds	r26, 0x03E7
    5190:	b0 91 e8 03 	lds	r27, 0x03E8
    5194:	e6 e8       	ldi	r30, 0x86	; 134
    5196:	f2 e0       	ldi	r31, 0x02	; 2
    5198:	83 e1       	ldi	r24, 0x13	; 19
    519a:	01 90       	ld	r0, Z+
    519c:	0d 92       	st	X+, r0
    519e:	81 50       	subi	r24, 0x01	; 1
    51a0:	e1 f7       	brne	.-8      	; 0x519a <commandSetConstSpeed+0x28a>
    sendText(txString.buffer);
    51a2:	80 91 e7 03 	lds	r24, 0x03E7
    51a6:	90 91 e8 03 	lds	r25, 0x03E8
    51aa:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    51ae:	8e cf       	rjmp	.-228    	; 0x50cc <commandSetConstSpeed+0x1bc>
    waitTime = (uint16_t)round((fabs(val)*1000.0f) / ( motor[i].gearRatio
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
      sprintf(txString.buffer, "err: time too short");
    51b0:	a0 91 e7 03 	lds	r26, 0x03E7
    51b4:	b0 91 e8 03 	lds	r27, 0x03E8
    51b8:	e2 e7       	ldi	r30, 0x72	; 114
    51ba:	f2 e0       	ldi	r31, 0x02	; 2
    51bc:	84 e1       	ldi	r24, 0x14	; 20
    51be:	01 90       	ld	r0, Z+
    51c0:	0d 92       	st	X+, r0
    51c2:	81 50       	subi	r24, 0x01	; 1
    51c4:	e1 f7       	brne	.-8      	; 0x51be <commandSetConstSpeed+0x2ae>
    51c6:	34 cf       	rjmp	.-408    	; 0x5030 <commandSetConstSpeed+0x120>

000051c8 <commandSetWaitTime>:
}

/* ---------------------------------------------------------------------
    sets the wait time between two single steps
 --------------------------------------------------------------------- */
void commandSetWaitTime(char* param0, char* param1){
    51c8:	1f 93       	push	r17
    51ca:	cf 93       	push	r28
    51cc:	df 93       	push	r29
    51ce:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    51d0:	60 e0       	ldi	r22, 0x00	; 0
    51d2:	70 e0       	ldi	r23, 0x00	; 0
    51d4:	4a e0       	ldi	r20, 0x0A	; 10
    51d6:	50 e0       	ldi	r21, 0x00	; 0
    51d8:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    51dc:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    51de:	64 30       	cpi	r22, 0x04	; 4
    51e0:	d8 f4       	brcc	.+54     	; 0x5218 <commandSetWaitTime+0x50>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    val = (uint16_t)atoi(param1);
    51e2:	ce 01       	movw	r24, r28
    51e4:	0e 94 4c 44 	call	0x8898	; 0x8898 <atoi>
    51e8:	9c 01       	movw	r18, r24
    motor[i].waitBetweenSteps = val;
    51ea:	e1 2f       	mov	r30, r17
    51ec:	f0 e0       	ldi	r31, 0x00	; 0
    51ee:	ee 0f       	add	r30, r30
    51f0:	ff 1f       	adc	r31, r31
    51f2:	ee 0f       	add	r30, r30
    51f4:	ff 1f       	adc	r31, r31
    51f6:	ee 0f       	add	r30, r30
    51f8:	ff 1f       	adc	r31, r31
    51fa:	cf 01       	movw	r24, r30
    51fc:	88 0f       	add	r24, r24
    51fe:	99 1f       	adc	r25, r25
    5200:	88 0f       	add	r24, r24
    5202:	99 1f       	adc	r25, r25
    5204:	e8 0f       	add	r30, r24
    5206:	f9 1f       	adc	r31, r25
    5208:	e0 51       	subi	r30, 0x10	; 16
    520a:	fc 4f       	sbci	r31, 0xFC	; 252
    520c:	37 8f       	std	Z+31, r19	; 0x1f
    520e:	26 8f       	std	Z+30, r18	; 0x1e
  }

  return;
}
    5210:	df 91       	pop	r29
    5212:	cf 91       	pop	r28
    5214:	1f 91       	pop	r17
    5216:	08 95       	ret
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    5218:	a0 91 e7 03 	lds	r26, 0x03E7
    521c:	b0 91 e8 03 	lds	r27, 0x03E8
    5220:	ea e5       	ldi	r30, 0x5A	; 90
    5222:	f2 e0       	ldi	r31, 0x02	; 2
    5224:	83 e1       	ldi	r24, 0x13	; 19
    5226:	01 90       	ld	r0, Z+
    5228:	0d 92       	st	X+, r0
    522a:	81 50       	subi	r24, 0x01	; 1
    522c:	e1 f7       	brne	.-8      	; 0x5226 <commandSetWaitTime+0x5e>
    sendText(txString.buffer);
    522e:	80 91 e7 03 	lds	r24, 0x03E7
    5232:	90 91 e8 03 	lds	r25, 0x03E8
    5236:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    523a:	ea cf       	rjmp	.-44     	; 0x5210 <commandSetWaitTime+0x48>

0000523c <commandSetSubSteps>:
}

/* ---------------------------------------------------------------------
    sets the desired substeps
 --------------------------------------------------------------------- */
void commandSetSubSteps(char* param0, char* param1){
    523c:	1f 93       	push	r17
    523e:	cf 93       	push	r28
    5240:	df 93       	push	r29
    5242:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    5244:	60 e0       	ldi	r22, 0x00	; 0
    5246:	70 e0       	ldi	r23, 0x00	; 0
    5248:	4a e0       	ldi	r20, 0x0A	; 10
    524a:	50 e0       	ldi	r21, 0x00	; 0
    524c:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    5250:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    5252:	64 30       	cpi	r22, 0x04	; 4
    5254:	88 f4       	brcc	.+34     	; 0x5278 <commandSetSubSteps+0x3c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    5256:	ce 01       	movw	r24, r28
    5258:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    //motor[i].subSteps = val;
    setSubSteps(i, (uint8_t)round(val));
    525c:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    5260:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
    5264:	9b 01       	movw	r18, r22
    5266:	ac 01       	movw	r20, r24
    5268:	81 2f       	mov	r24, r17
    526a:	62 2f       	mov	r22, r18
    526c:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <setSubSteps>
  }

  return;
}
    5270:	df 91       	pop	r29
    5272:	cf 91       	pop	r28
    5274:	1f 91       	pop	r17
    5276:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    5278:	80 91 e7 03 	lds	r24, 0x03E7
    527c:	90 91 e8 03 	lds	r25, 0x03E8
    5280:	00 d0       	rcall	.+0      	; 0x5282 <commandSetSubSteps+0x46>
    5282:	00 d0       	rcall	.+0      	; 0x5284 <commandSetSubSteps+0x48>
    5284:	00 d0       	rcall	.+0      	; 0x5286 <commandSetSubSteps+0x4a>
    5286:	ed b7       	in	r30, 0x3d	; 61
    5288:	fe b7       	in	r31, 0x3e	; 62
    528a:	31 96       	adiw	r30, 0x01	; 1
    528c:	ad b7       	in	r26, 0x3d	; 61
    528e:	be b7       	in	r27, 0x3e	; 62
    5290:	12 96       	adiw	r26, 0x02	; 2
    5292:	9c 93       	st	X, r25
    5294:	8e 93       	st	-X, r24
    5296:	11 97       	sbiw	r26, 0x01	; 1
    5298:	80 e0       	ldi	r24, 0x00	; 0
    529a:	91 e0       	ldi	r25, 0x01	; 1
    529c:	93 83       	std	Z+3, r25	; 0x03
    529e:	82 83       	std	Z+2, r24	; 0x02
    52a0:	14 83       	std	Z+4, r17	; 0x04
    52a2:	15 82       	std	Z+5, r1	; 0x05
    52a4:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    sendText(txString.buffer);
    52a8:	80 91 e7 03 	lds	r24, 0x03E7
    52ac:	90 91 e8 03 	lds	r25, 0x03E8
    52b0:	2d b7       	in	r18, 0x3d	; 61
    52b2:	3e b7       	in	r19, 0x3e	; 62
    52b4:	2a 5f       	subi	r18, 0xFA	; 250
    52b6:	3f 4f       	sbci	r19, 0xFF	; 255
    52b8:	0f b6       	in	r0, 0x3f	; 63
    52ba:	f8 94       	cli
    52bc:	3e bf       	out	0x3e, r19	; 62
    52be:	0f be       	out	0x3f, r0	; 63
    52c0:	2d bf       	out	0x3d, r18	; 61
    52c2:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    //motor[i].subSteps = val;
    setSubSteps(i, (uint8_t)round(val));
  }

  return;
}
    52c6:	df 91       	pop	r29
    52c8:	cf 91       	pop	r28
    52ca:	1f 91       	pop	r17
    52cc:	08 95       	ret

000052ce <commandSetFullRotation>:
}

/* ---------------------------------------------------------------------
    sets the steps per full rotation w/o substeps
 --------------------------------------------------------------------- */
void commandSetFullRotation(char* param0, char* param1){
    52ce:	1f 93       	push	r17
    52d0:	cf 93       	push	r28
    52d2:	df 93       	push	r29
    52d4:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    52d6:	60 e0       	ldi	r22, 0x00	; 0
    52d8:	70 e0       	ldi	r23, 0x00	; 0
    52da:	4a e0       	ldi	r20, 0x0A	; 10
    52dc:	50 e0       	ldi	r21, 0x00	; 0
    52de:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    52e2:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    52e4:	64 30       	cpi	r22, 0x04	; 4
    52e6:	e0 f4       	brcc	.+56     	; 0x5320 <commandSetFullRotation+0x52>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    52e8:	ce 01       	movw	r24, r28
    52ea:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    motor[i].stepsPerFullRotation = val;
    52ee:	e1 2f       	mov	r30, r17
    52f0:	f0 e0       	ldi	r31, 0x00	; 0
    52f2:	ee 0f       	add	r30, r30
    52f4:	ff 1f       	adc	r31, r31
    52f6:	ee 0f       	add	r30, r30
    52f8:	ff 1f       	adc	r31, r31
    52fa:	ee 0f       	add	r30, r30
    52fc:	ff 1f       	adc	r31, r31
    52fe:	9f 01       	movw	r18, r30
    5300:	22 0f       	add	r18, r18
    5302:	33 1f       	adc	r19, r19
    5304:	22 0f       	add	r18, r18
    5306:	33 1f       	adc	r19, r19
    5308:	e2 0f       	add	r30, r18
    530a:	f3 1f       	adc	r31, r19
    530c:	e0 51       	subi	r30, 0x10	; 16
    530e:	fc 4f       	sbci	r31, 0xFC	; 252
    5310:	61 8b       	std	Z+17, r22	; 0x11
    5312:	72 8b       	std	Z+18, r23	; 0x12
    5314:	83 8b       	std	Z+19, r24	; 0x13
    5316:	94 8b       	std	Z+20, r25	; 0x14
  }

  return;
}
    5318:	df 91       	pop	r29
    531a:	cf 91       	pop	r28
    531c:	1f 91       	pop	r17
    531e:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    5320:	80 91 e7 03 	lds	r24, 0x03E7
    5324:	90 91 e8 03 	lds	r25, 0x03E8
    5328:	00 d0       	rcall	.+0      	; 0x532a <commandSetFullRotation+0x5c>
    532a:	00 d0       	rcall	.+0      	; 0x532c <commandSetFullRotation+0x5e>
    532c:	00 d0       	rcall	.+0      	; 0x532e <commandSetFullRotation+0x60>
    532e:	ed b7       	in	r30, 0x3d	; 61
    5330:	fe b7       	in	r31, 0x3e	; 62
    5332:	31 96       	adiw	r30, 0x01	; 1
    5334:	ad b7       	in	r26, 0x3d	; 61
    5336:	be b7       	in	r27, 0x3e	; 62
    5338:	12 96       	adiw	r26, 0x02	; 2
    533a:	9c 93       	st	X, r25
    533c:	8e 93       	st	-X, r24
    533e:	11 97       	sbiw	r26, 0x01	; 1
    5340:	80 e0       	ldi	r24, 0x00	; 0
    5342:	91 e0       	ldi	r25, 0x01	; 1
    5344:	93 83       	std	Z+3, r25	; 0x03
    5346:	82 83       	std	Z+2, r24	; 0x02
    5348:	14 83       	std	Z+4, r17	; 0x04
    534a:	15 82       	std	Z+5, r1	; 0x05
    534c:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    sendText(txString.buffer);
    5350:	80 91 e7 03 	lds	r24, 0x03E7
    5354:	90 91 e8 03 	lds	r25, 0x03E8
    5358:	2d b7       	in	r18, 0x3d	; 61
    535a:	3e b7       	in	r19, 0x3e	; 62
    535c:	2a 5f       	subi	r18, 0xFA	; 250
    535e:	3f 4f       	sbci	r19, 0xFF	; 255
    5360:	0f b6       	in	r0, 0x3f	; 63
    5362:	f8 94       	cli
    5364:	3e bf       	out	0x3e, r19	; 62
    5366:	0f be       	out	0x3f, r0	; 63
    5368:	2d bf       	out	0x3d, r18	; 61
    536a:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    val = (double)atof(param1);
    motor[i].stepsPerFullRotation = val;
  }

  return;
}
    536e:	df 91       	pop	r29
    5370:	cf 91       	pop	r28
    5372:	1f 91       	pop	r17
    5374:	08 95       	ret

00005376 <commandSetGearRatio>:
}

/* ---------------------------------------------------------------------
    sets the mechanical gear ratio
 --------------------------------------------------------------------- */
void commandSetGearRatio(char* param0, char* param1){
    5376:	1f 93       	push	r17
    5378:	cf 93       	push	r28
    537a:	df 93       	push	r29
    537c:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    537e:	60 e0       	ldi	r22, 0x00	; 0
    5380:	70 e0       	ldi	r23, 0x00	; 0
    5382:	4a e0       	ldi	r20, 0x0A	; 10
    5384:	50 e0       	ldi	r21, 0x00	; 0
    5386:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    538a:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    538c:	64 30       	cpi	r22, 0x04	; 4
    538e:	e0 f4       	brcc	.+56     	; 0x53c8 <commandSetGearRatio+0x52>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    5390:	ce 01       	movw	r24, r28
    5392:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    motor[i].gearRatio = val;
    5396:	e1 2f       	mov	r30, r17
    5398:	f0 e0       	ldi	r31, 0x00	; 0
    539a:	ee 0f       	add	r30, r30
    539c:	ff 1f       	adc	r31, r31
    539e:	ee 0f       	add	r30, r30
    53a0:	ff 1f       	adc	r31, r31
    53a2:	ee 0f       	add	r30, r30
    53a4:	ff 1f       	adc	r31, r31
    53a6:	9f 01       	movw	r18, r30
    53a8:	22 0f       	add	r18, r18
    53aa:	33 1f       	adc	r19, r19
    53ac:	22 0f       	add	r18, r18
    53ae:	33 1f       	adc	r19, r19
    53b0:	e2 0f       	add	r30, r18
    53b2:	f3 1f       	adc	r31, r19
    53b4:	e0 51       	subi	r30, 0x10	; 16
    53b6:	fc 4f       	sbci	r31, 0xFC	; 252
    53b8:	65 87       	std	Z+13, r22	; 0x0d
    53ba:	76 87       	std	Z+14, r23	; 0x0e
    53bc:	87 87       	std	Z+15, r24	; 0x0f
    53be:	90 8b       	std	Z+16, r25	; 0x10
  }

  return;
}
    53c0:	df 91       	pop	r29
    53c2:	cf 91       	pop	r28
    53c4:	1f 91       	pop	r17
    53c6:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    53c8:	80 91 e7 03 	lds	r24, 0x03E7
    53cc:	90 91 e8 03 	lds	r25, 0x03E8
    53d0:	00 d0       	rcall	.+0      	; 0x53d2 <commandSetGearRatio+0x5c>
    53d2:	00 d0       	rcall	.+0      	; 0x53d4 <commandSetGearRatio+0x5e>
    53d4:	00 d0       	rcall	.+0      	; 0x53d6 <commandSetGearRatio+0x60>
    53d6:	ed b7       	in	r30, 0x3d	; 61
    53d8:	fe b7       	in	r31, 0x3e	; 62
    53da:	31 96       	adiw	r30, 0x01	; 1
    53dc:	ad b7       	in	r26, 0x3d	; 61
    53de:	be b7       	in	r27, 0x3e	; 62
    53e0:	12 96       	adiw	r26, 0x02	; 2
    53e2:	9c 93       	st	X, r25
    53e4:	8e 93       	st	-X, r24
    53e6:	11 97       	sbiw	r26, 0x01	; 1
    53e8:	80 e0       	ldi	r24, 0x00	; 0
    53ea:	91 e0       	ldi	r25, 0x01	; 1
    53ec:	93 83       	std	Z+3, r25	; 0x03
    53ee:	82 83       	std	Z+2, r24	; 0x02
    53f0:	14 83       	std	Z+4, r17	; 0x04
    53f2:	15 82       	std	Z+5, r1	; 0x05
    53f4:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    sendText(txString.buffer);
    53f8:	80 91 e7 03 	lds	r24, 0x03E7
    53fc:	90 91 e8 03 	lds	r25, 0x03E8
    5400:	2d b7       	in	r18, 0x3d	; 61
    5402:	3e b7       	in	r19, 0x3e	; 62
    5404:	2a 5f       	subi	r18, 0xFA	; 250
    5406:	3f 4f       	sbci	r19, 0xFF	; 255
    5408:	0f b6       	in	r0, 0x3f	; 63
    540a:	f8 94       	cli
    540c:	3e bf       	out	0x3e, r19	; 62
    540e:	0f be       	out	0x3f, r0	; 63
    5410:	2d bf       	out	0x3d, r18	; 61
    5412:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    val = (double)atof(param1);
    motor[i].gearRatio = val;
  }

  return;
}
    5416:	df 91       	pop	r29
    5418:	cf 91       	pop	r28
    541a:	1f 91       	pop	r17
    541c:	08 95       	ret

0000541e <commandSetOptZeroPos>:

/* ---------------------------------------------------------------------
    sets the optical zero position
    as offset from magnetic zero position
 --------------------------------------------------------------------- */
void commandSetOptZeroPos(char* param0, char* param1){
    541e:	1f 93       	push	r17
    5420:	cf 93       	push	r28
    5422:	df 93       	push	r29
    5424:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  int16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    5426:	60 e0       	ldi	r22, 0x00	; 0
    5428:	70 e0       	ldi	r23, 0x00	; 0
    542a:	4a e0       	ldi	r20, 0x0A	; 10
    542c:	50 e0       	ldi	r21, 0x00	; 0
    542e:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    5432:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    5434:	64 30       	cpi	r22, 0x04	; 4
    5436:	00 f5       	brcc	.+64     	; 0x5478 <commandSetOptZeroPos+0x5a>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (int16_t)strtol(param1, (char **)NULL, 10);
    5438:	ce 01       	movw	r24, r28
    543a:	60 e0       	ldi	r22, 0x00	; 0
    543c:	70 e0       	ldi	r23, 0x00	; 0
    543e:	4a e0       	ldi	r20, 0x0A	; 10
    5440:	50 e0       	ldi	r21, 0x00	; 0
    5442:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    motor[i].opticalZeroPosition = val;
    5446:	21 2f       	mov	r18, r17
    5448:	30 e0       	ldi	r19, 0x00	; 0
    544a:	f9 01       	movw	r30, r18
    544c:	ee 0f       	add	r30, r30
    544e:	ff 1f       	adc	r31, r31
    5450:	ee 0f       	add	r30, r30
    5452:	ff 1f       	adc	r31, r31
    5454:	ee 0f       	add	r30, r30
    5456:	ff 1f       	adc	r31, r31
    5458:	22 0f       	add	r18, r18
    545a:	33 1f       	adc	r19, r19
    545c:	e2 0f       	add	r30, r18
    545e:	f3 1f       	adc	r31, r19
    5460:	ee 0f       	add	r30, r30
    5462:	ff 1f       	adc	r31, r31
    5464:	ee 0f       	add	r30, r30
    5466:	ff 1f       	adc	r31, r31
    5468:	ec 50       	subi	r30, 0x0C	; 12
    546a:	fc 4f       	sbci	r31, 0xFC	; 252
    546c:	71 83       	std	Z+1, r23	; 0x01
    546e:	60 83       	st	Z, r22
  }

  return;
}
    5470:	df 91       	pop	r29
    5472:	cf 91       	pop	r28
    5474:	1f 91       	pop	r17
    5476:	08 95       	ret
  int16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    5478:	80 91 e7 03 	lds	r24, 0x03E7
    547c:	90 91 e8 03 	lds	r25, 0x03E8
    5480:	00 d0       	rcall	.+0      	; 0x5482 <commandSetOptZeroPos+0x64>
    5482:	00 d0       	rcall	.+0      	; 0x5484 <commandSetOptZeroPos+0x66>
    5484:	00 d0       	rcall	.+0      	; 0x5486 <commandSetOptZeroPos+0x68>
    5486:	ed b7       	in	r30, 0x3d	; 61
    5488:	fe b7       	in	r31, 0x3e	; 62
    548a:	31 96       	adiw	r30, 0x01	; 1
    548c:	ad b7       	in	r26, 0x3d	; 61
    548e:	be b7       	in	r27, 0x3e	; 62
    5490:	12 96       	adiw	r26, 0x02	; 2
    5492:	9c 93       	st	X, r25
    5494:	8e 93       	st	-X, r24
    5496:	11 97       	sbiw	r26, 0x01	; 1
    5498:	80 e0       	ldi	r24, 0x00	; 0
    549a:	91 e0       	ldi	r25, 0x01	; 1
    549c:	93 83       	std	Z+3, r25	; 0x03
    549e:	82 83       	std	Z+2, r24	; 0x02
    54a0:	14 83       	std	Z+4, r17	; 0x04
    54a2:	15 82       	std	Z+5, r1	; 0x05
    54a4:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    sendText(txString.buffer);
    54a8:	80 91 e7 03 	lds	r24, 0x03E7
    54ac:	90 91 e8 03 	lds	r25, 0x03E8
    54b0:	2d b7       	in	r18, 0x3d	; 61
    54b2:	3e b7       	in	r19, 0x3e	; 62
    54b4:	2a 5f       	subi	r18, 0xFA	; 250
    54b6:	3f 4f       	sbci	r19, 0xFF	; 255
    54b8:	0f b6       	in	r0, 0x3f	; 63
    54ba:	f8 94       	cli
    54bc:	3e bf       	out	0x3e, r19	; 62
    54be:	0f be       	out	0x3f, r0	; 63
    54c0:	2d bf       	out	0x3d, r18	; 61
    54c2:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    val = (int16_t)strtol(param1, (char **)NULL, 10);
    motor[i].opticalZeroPosition = val;
  }

  return;
}
    54c6:	df 91       	pop	r29
    54c8:	cf 91       	pop	r28
    54ca:	1f 91       	pop	r17
    54cc:	08 95       	ret

000054ce <commandMoveRel>:
}

/* ---------------------------------------------------------------------
    moves the motor relative to the actual position
 --------------------------------------------------------------------- */
void commandMoveRel(char* param0, char* param1, char* param2){
    54ce:	ff 92       	push	r15
    54d0:	0f 93       	push	r16
    54d2:	1f 93       	push	r17
    54d4:	cf 93       	push	r28
    54d6:	df 93       	push	r29
    54d8:	eb 01       	movw	r28, r22
    54da:	8a 01       	movw	r16, r20

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    54dc:	60 e0       	ldi	r22, 0x00	; 0
    54de:	70 e0       	ldi	r23, 0x00	; 0
    54e0:	4a e0       	ldi	r20, 0x0A	; 10
    54e2:	50 e0       	ldi	r21, 0x00	; 0
    54e4:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    54e8:	f6 2e       	mov	r15, r22

  if(i > MAX_MOTOR){
    54ea:	83 e0       	ldi	r24, 0x03	; 3
    54ec:	8f 15       	cp	r24, r15
    54ee:	30 f4       	brcc	.+12     	; 0x54fc <commandMoveRel+0x2e>
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    54f0:	df 91       	pop	r29
    54f2:	cf 91       	pop	r28
    54f4:	1f 91       	pop	r17
    54f6:	0f 91       	pop	r16
    54f8:	ff 90       	pop	r15
    54fa:	08 95       	ret

  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    54fc:	c8 01       	movw	r24, r16
    54fe:	6f e1       	ldi	r22, 0x1F	; 31
    5500:	72 e0       	ldi	r23, 0x02	; 2
    5502:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5506:	00 97       	sbiw	r24, 0x00	; 0
    5508:	a9 f0       	breq	.+42     	; 0x5534 <commandMoveRel+0x66>
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    550a:	c8 01       	movw	r24, r16
    550c:	65 e2       	ldi	r22, 0x25	; 37
    550e:	72 e0       	ldi	r23, 0x02	; 2
    5510:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5514:	00 97       	sbiw	r24, 0x00	; 0
    5516:	09 f4       	brne	.+2      	; 0x551a <commandMoveRel+0x4c>
    5518:	42 c0       	rjmp	.+132    	; 0x559e <commandMoveRel+0xd0>
    degreeToSteps(i, atof(param1), 1.0f);
  }
  else if(strcmp(param2, "pi") == 0){
    551a:	c8 01       	movw	r24, r16
    551c:	69 e2       	ldi	r22, 0x29	; 41
    551e:	72 e0       	ldi	r23, 0x02	; 2
    5520:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5524:	00 97       	sbiw	r24, 0x00	; 0
    5526:	09 f4       	brne	.+2      	; 0x552a <commandMoveRel+0x5c>
    5528:	47 c0       	rjmp	.+142    	; 0x55b8 <commandMoveRel+0xea>
    radiansToSteps(i, atof(param1), 1.0f);
  }
  else{
    sendText("ERROR: unknown unit");
    552a:	80 ea       	ldi	r24, 0xA0	; 160
    552c:	92 e0       	ldi	r25, 0x02	; 2
    552e:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    5532:	de cf       	rjmp	.-68     	; 0x54f0 <commandMoveRel+0x22>
  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
    5534:	ef 2d       	mov	r30, r15
    5536:	f0 e0       	ldi	r31, 0x00	; 0
    5538:	ee 0f       	add	r30, r30
    553a:	ff 1f       	adc	r31, r31
    553c:	ee 0f       	add	r30, r30
    553e:	ff 1f       	adc	r31, r31
    5540:	cf 01       	movw	r24, r30
    5542:	88 0f       	add	r24, r24
    5544:	99 1f       	adc	r25, r25
    5546:	88 0f       	add	r24, r24
    5548:	99 1f       	adc	r25, r25
    554a:	e8 0f       	add	r30, r24
    554c:	f9 1f       	adc	r31, r25
    554e:	ee 0f       	add	r30, r30
    5550:	ff 1f       	adc	r31, r31
    5552:	ee 50       	subi	r30, 0x0E	; 14
    5554:	fc 4f       	sbci	r31, 0xFC	; 252
    5556:	00 81       	ld	r16, Z
    5558:	11 81       	ldd	r17, Z+1	; 0x01
    555a:	ce 01       	movw	r24, r28
    555c:	60 e0       	ldi	r22, 0x00	; 0
    555e:	70 e0       	ldi	r23, 0x00	; 0
    5560:	4a e0       	ldi	r20, 0x0A	; 10
    5562:	50 e0       	ldi	r21, 0x00	; 0
    5564:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    5568:	06 0f       	add	r16, r22
    556a:	17 1f       	adc	r17, r23
    556c:	ef 2d       	mov	r30, r15
    556e:	f0 e0       	ldi	r31, 0x00	; 0
    5570:	ee 0f       	add	r30, r30
    5572:	ff 1f       	adc	r31, r31
    5574:	ee 0f       	add	r30, r30
    5576:	ff 1f       	adc	r31, r31
    5578:	cf 01       	movw	r24, r30
    557a:	88 0f       	add	r24, r24
    557c:	99 1f       	adc	r25, r25
    557e:	88 0f       	add	r24, r24
    5580:	99 1f       	adc	r25, r25
    5582:	e8 0f       	add	r30, r24
    5584:	f9 1f       	adc	r31, r25
    5586:	ee 0f       	add	r30, r30
    5588:	ff 1f       	adc	r31, r31
    558a:	ee 50       	subi	r30, 0x0E	; 14
    558c:	fc 4f       	sbci	r31, 0xFC	; 252
    558e:	11 83       	std	Z+1, r17	; 0x01
    5590:	00 83       	st	Z, r16
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    5592:	df 91       	pop	r29
    5594:	cf 91       	pop	r28
    5596:	1f 91       	pop	r17
    5598:	0f 91       	pop	r16
    559a:	ff 90       	pop	r15
    559c:	08 95       	ret

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    degreeToSteps(i, atof(param1), 1.0f);
    559e:	ce 01       	movw	r24, r28
    55a0:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    55a4:	ab 01       	movw	r20, r22
    55a6:	bc 01       	movw	r22, r24
    55a8:	8f 2d       	mov	r24, r15
    55aa:	00 e0       	ldi	r16, 0x00	; 0
    55ac:	10 e0       	ldi	r17, 0x00	; 0
    55ae:	20 e8       	ldi	r18, 0x80	; 128
    55b0:	3f e3       	ldi	r19, 0x3F	; 63
    55b2:	0e 94 7d 14 	call	0x28fa	; 0x28fa <degreeToSteps>
    55b6:	9c cf       	rjmp	.-200    	; 0x54f0 <commandMoveRel+0x22>
  }
  else if(strcmp(param2, "pi") == 0){
    radiansToSteps(i, atof(param1), 1.0f);
    55b8:	ce 01       	movw	r24, r28
    55ba:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    55be:	ab 01       	movw	r20, r22
    55c0:	bc 01       	movw	r22, r24
    55c2:	8f 2d       	mov	r24, r15
    55c4:	00 e0       	ldi	r16, 0x00	; 0
    55c6:	10 e0       	ldi	r17, 0x00	; 0
    55c8:	20 e8       	ldi	r18, 0x80	; 128
    55ca:	3f e3       	ldi	r19, 0x3F	; 63
    55cc:	0e 94 36 13 	call	0x266c	; 0x266c <radiansToSteps>
    55d0:	8f cf       	rjmp	.-226    	; 0x54f0 <commandMoveRel+0x22>

000055d2 <commandMoveAbs>:
}

/* ---------------------------------------------------------------------
    moves the motor to an absolute position
 --------------------------------------------------------------------- */
void commandMoveAbs(char* param0, char* param1, char* param2){
    55d2:	df 92       	push	r13
    55d4:	ef 92       	push	r14
    55d6:	ff 92       	push	r15
    55d8:	0f 93       	push	r16
    55da:	1f 93       	push	r17
    55dc:	cf 93       	push	r28
    55de:	df 93       	push	r29
    55e0:	eb 01       	movw	r28, r22
    55e2:	8a 01       	movw	r16, r20

  uint8_t i = 0;
  double actMotorPos = 0.0f;
  double posDiff = 0.0f;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    55e4:	60 e0       	ldi	r22, 0x00	; 0
    55e6:	70 e0       	ldi	r23, 0x00	; 0
    55e8:	4a e0       	ldi	r20, 0x0A	; 10
    55ea:	50 e0       	ldi	r21, 0x00	; 0
    55ec:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    55f0:	d6 2e       	mov	r13, r22

  if(i > MAX_MOTOR){
    55f2:	83 e0       	ldi	r24, 0x03	; 3
    55f4:	8d 15       	cp	r24, r13
    55f6:	40 f4       	brcc	.+16     	; 0x5608 <commandMoveAbs+0x36>
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    55f8:	df 91       	pop	r29
    55fa:	cf 91       	pop	r28
    55fc:	1f 91       	pop	r17
    55fe:	0f 91       	pop	r16
    5600:	ff 90       	pop	r15
    5602:	ef 90       	pop	r14
    5604:	df 90       	pop	r13
    5606:	08 95       	ret

  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    5608:	c8 01       	movw	r24, r16
    560a:	6f e1       	ldi	r22, 0x1F	; 31
    560c:	72 e0       	ldi	r23, 0x02	; 2
    560e:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5612:	00 97       	sbiw	r24, 0x00	; 0
    5614:	a1 f0       	breq	.+40     	; 0x563e <commandMoveAbs+0x6c>
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    5616:	c8 01       	movw	r24, r16
    5618:	65 e2       	ldi	r22, 0x25	; 37
    561a:	72 e0       	ldi	r23, 0x02	; 2
    561c:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5620:	00 97       	sbiw	r24, 0x00	; 0
    5622:	79 f1       	breq	.+94     	; 0x5682 <commandMoveAbs+0xb0>
    actMotorPos = stepsToDegree(i, motor[i].actualPosition);
    posDiff = atof(param1) - actMotorPos;
    degreeToSteps(i, posDiff, 1.0);
  }
  else if(strcmp(param2, "pi") == 0){
    5624:	c8 01       	movw	r24, r16
    5626:	69 e2       	ldi	r22, 0x29	; 41
    5628:	72 e0       	ldi	r23, 0x02	; 2
    562a:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    562e:	00 97       	sbiw	r24, 0x00	; 0
    5630:	09 f4       	brne	.+2      	; 0x5634 <commandMoveAbs+0x62>
    5632:	50 c0       	rjmp	.+160    	; 0x56d4 <commandMoveAbs+0x102>
    actMotorPos = stepsToRadian(i, motor[i].actualPosition);
    posDiff = atof(param1) - actMotorPos;
    radiansToSteps(i, posDiff, 1.0);
  }
  else{
    sendText("ERROR: unknown unit");
    5634:	80 ea       	ldi	r24, 0xA0	; 160
    5636:	92 e0       	ldi	r25, 0x02	; 2
    5638:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    563c:	dd cf       	rjmp	.-70     	; 0x55f8 <commandMoveAbs+0x26>
  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
    563e:	ce 01       	movw	r24, r28
    5640:	60 e0       	ldi	r22, 0x00	; 0
    5642:	70 e0       	ldi	r23, 0x00	; 0
    5644:	4a e0       	ldi	r20, 0x0A	; 10
    5646:	50 e0       	ldi	r21, 0x00	; 0
    5648:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    564c:	ed 2d       	mov	r30, r13
    564e:	f0 e0       	ldi	r31, 0x00	; 0
    5650:	ee 0f       	add	r30, r30
    5652:	ff 1f       	adc	r31, r31
    5654:	ee 0f       	add	r30, r30
    5656:	ff 1f       	adc	r31, r31
    5658:	9f 01       	movw	r18, r30
    565a:	22 0f       	add	r18, r18
    565c:	33 1f       	adc	r19, r19
    565e:	22 0f       	add	r18, r18
    5660:	33 1f       	adc	r19, r19
    5662:	e2 0f       	add	r30, r18
    5664:	f3 1f       	adc	r31, r19
    5666:	ee 0f       	add	r30, r30
    5668:	ff 1f       	adc	r31, r31
    566a:	ee 50       	subi	r30, 0x0E	; 14
    566c:	fc 4f       	sbci	r31, 0xFC	; 252
    566e:	71 83       	std	Z+1, r23	; 0x01
    5670:	60 83       	st	Z, r22
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    5672:	df 91       	pop	r29
    5674:	cf 91       	pop	r28
    5676:	1f 91       	pop	r17
    5678:	0f 91       	pop	r16
    567a:	ff 90       	pop	r15
    567c:	ef 90       	pop	r14
    567e:	df 90       	pop	r13
    5680:	08 95       	ret

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    actMotorPos = stepsToDegree(i, motor[i].actualPosition);
    5682:	ed 2d       	mov	r30, r13
    5684:	f0 e0       	ldi	r31, 0x00	; 0
    5686:	ee 0f       	add	r30, r30
    5688:	ff 1f       	adc	r31, r31
    568a:	ee 0f       	add	r30, r30
    568c:	ff 1f       	adc	r31, r31
    568e:	ee 0f       	add	r30, r30
    5690:	ff 1f       	adc	r31, r31
    5692:	cf 01       	movw	r24, r30
    5694:	88 0f       	add	r24, r24
    5696:	99 1f       	adc	r25, r25
    5698:	88 0f       	add	r24, r24
    569a:	99 1f       	adc	r25, r25
    569c:	e8 0f       	add	r30, r24
    569e:	f9 1f       	adc	r31, r25
    56a0:	e0 51       	subi	r30, 0x10	; 16
    56a2:	fc 4f       	sbci	r31, 0xFC	; 252
    56a4:	60 81       	ld	r22, Z
    56a6:	71 81       	ldd	r23, Z+1	; 0x01
    56a8:	8d 2d       	mov	r24, r13
    56aa:	0e 94 9e 07 	call	0xf3c	; 0xf3c <stepsToDegree>
    56ae:	7b 01       	movw	r14, r22
    56b0:	8c 01       	movw	r16, r24
    posDiff = atof(param1) - actMotorPos;
    56b2:	ce 01       	movw	r24, r28
    56b4:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    degreeToSteps(i, posDiff, 1.0);
    56b8:	a8 01       	movw	r20, r16
    56ba:	97 01       	movw	r18, r14
    56bc:	0e 94 5f 3f 	call	0x7ebe	; 0x7ebe <__subsf3>
    56c0:	ab 01       	movw	r20, r22
    56c2:	bc 01       	movw	r22, r24
    56c4:	8d 2d       	mov	r24, r13
    56c6:	00 e0       	ldi	r16, 0x00	; 0
    56c8:	10 e0       	ldi	r17, 0x00	; 0
    56ca:	20 e8       	ldi	r18, 0x80	; 128
    56cc:	3f e3       	ldi	r19, 0x3F	; 63
    56ce:	0e 94 7d 14 	call	0x28fa	; 0x28fa <degreeToSteps>
    56d2:	92 cf       	rjmp	.-220    	; 0x55f8 <commandMoveAbs+0x26>
  }
  else if(strcmp(param2, "pi") == 0){
    actMotorPos = stepsToRadian(i, motor[i].actualPosition);
    56d4:	ed 2d       	mov	r30, r13
    56d6:	f0 e0       	ldi	r31, 0x00	; 0
    56d8:	ee 0f       	add	r30, r30
    56da:	ff 1f       	adc	r31, r31
    56dc:	ee 0f       	add	r30, r30
    56de:	ff 1f       	adc	r31, r31
    56e0:	ee 0f       	add	r30, r30
    56e2:	ff 1f       	adc	r31, r31
    56e4:	cf 01       	movw	r24, r30
    56e6:	88 0f       	add	r24, r24
    56e8:	99 1f       	adc	r25, r25
    56ea:	88 0f       	add	r24, r24
    56ec:	99 1f       	adc	r25, r25
    56ee:	e8 0f       	add	r30, r24
    56f0:	f9 1f       	adc	r31, r25
    56f2:	e0 51       	subi	r30, 0x10	; 16
    56f4:	fc 4f       	sbci	r31, 0xFC	; 252
    56f6:	60 81       	ld	r22, Z
    56f8:	71 81       	ldd	r23, Z+1	; 0x01
    56fa:	8d 2d       	mov	r24, r13
    56fc:	0e 94 23 08 	call	0x1046	; 0x1046 <stepsToRadian>
    5700:	7b 01       	movw	r14, r22
    5702:	8c 01       	movw	r16, r24
    posDiff = atof(param1) - actMotorPos;
    5704:	ce 01       	movw	r24, r28
    5706:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    radiansToSteps(i, posDiff, 1.0);
    570a:	a8 01       	movw	r20, r16
    570c:	97 01       	movw	r18, r14
    570e:	0e 94 5f 3f 	call	0x7ebe	; 0x7ebe <__subsf3>
    5712:	ab 01       	movw	r20, r22
    5714:	bc 01       	movw	r22, r24
    5716:	8d 2d       	mov	r24, r13
    5718:	00 e0       	ldi	r16, 0x00	; 0
    571a:	10 e0       	ldi	r17, 0x00	; 0
    571c:	20 e8       	ldi	r18, 0x80	; 128
    571e:	3f e3       	ldi	r19, 0x3F	; 63
    5720:	0e 94 36 13 	call	0x266c	; 0x266c <radiansToSteps>
    5724:	69 cf       	rjmp	.-302    	; 0x55f8 <commandMoveAbs+0x26>

00005726 <initBuffers>:

  uint8_t i,j;

  /* command parameters */
  for(j = 0; j < PARAMETER_LENGTH; j++){
    commandParam[i][j] = 0;
    5726:	20 e0       	ldi	r18, 0x00	; 0
    5728:	30 e0       	ldi	r19, 0x00	; 0
    572a:	80 e0       	ldi	r24, 0x00	; 0
    572c:	90 e0       	ldi	r25, 0x00	; 0
    572e:	e0 91 d6 02 	lds	r30, 0x02D6
    5732:	f0 91 d7 02 	lds	r31, 0x02D7
    5736:	01 90       	ld	r0, Z+
    5738:	f0 81       	ld	r31, Z
    573a:	e0 2d       	mov	r30, r0
    573c:	e8 0f       	add	r30, r24
    573e:	f9 1f       	adc	r31, r25
    5740:	10 82       	st	Z, r1
    5742:	01 96       	adiw	r24, 0x01	; 1
void initBuffers(void){

  uint8_t i,j;

  /* command parameters */
  for(j = 0; j < PARAMETER_LENGTH; j++){
    5744:	84 31       	cpi	r24, 0x14	; 20
    5746:	91 05       	cpc	r25, r1
    5748:	91 f7       	brne	.-28     	; 0x572e <initBuffers+0x8>
    574a:	80 e0       	ldi	r24, 0x00	; 0
    574c:	90 e0       	ldi	r25, 0x00	; 0
    commandParam[i][j] = 0;
  }

  /* buffers for the display */
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    menu.currentDisplayValue[i][j] = 0;
    574e:	e0 91 e6 02 	lds	r30, 0x02E6
    5752:	f0 91 e7 02 	lds	r31, 0x02E7
    5756:	e2 0f       	add	r30, r18
    5758:	f3 1f       	adc	r31, r19
    575a:	01 90       	ld	r0, Z+
    575c:	f0 81       	ld	r31, Z
    575e:	e0 2d       	mov	r30, r0
    5760:	e8 0f       	add	r30, r24
    5762:	f9 1f       	adc	r31, r25
    5764:	10 82       	st	Z, r1
    menu.newDisplayValue[i][j]     = 0;
    5766:	e0 91 e8 02 	lds	r30, 0x02E8
    576a:	f0 91 e9 02 	lds	r31, 0x02E9
    576e:	e2 0f       	add	r30, r18
    5770:	f3 1f       	adc	r31, r19
    5772:	01 90       	ld	r0, Z+
    5774:	f0 81       	ld	r31, Z
    5776:	e0 2d       	mov	r30, r0
    5778:	e8 0f       	add	r30, r24
    577a:	f9 1f       	adc	r31, r25
    577c:	10 82       	st	Z, r1
    577e:	01 96       	adiw	r24, 0x01	; 1
  for(j = 0; j < PARAMETER_LENGTH; j++){
    commandParam[i][j] = 0;
  }

  /* buffers for the display */
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    5780:	89 30       	cpi	r24, 0x09	; 9
    5782:	91 05       	cpc	r25, r1
    5784:	21 f7       	brne	.-56     	; 0x574e <initBuffers+0x28>
    5786:	80 e0       	ldi	r24, 0x00	; 0
    5788:	90 e0       	ldi	r25, 0x00	; 0
    menu.currentDisplayValue[i][j] = 0;
    menu.newDisplayValue[i][j]     = 0;
  }

  for(j = 0; j < DISPLAY_MENU_STRING_LENGTH; j++){
    menu.currentMenuText[i][j] = 0;
    578a:	e0 91 ea 02 	lds	r30, 0x02EA
    578e:	f0 91 eb 02 	lds	r31, 0x02EB
    5792:	e2 0f       	add	r30, r18
    5794:	f3 1f       	adc	r31, r19
    5796:	01 90       	ld	r0, Z+
    5798:	f0 81       	ld	r31, Z
    579a:	e0 2d       	mov	r30, r0
    579c:	e8 0f       	add	r30, r24
    579e:	f9 1f       	adc	r31, r25
    57a0:	10 82       	st	Z, r1
    menu.newMenuText[i][j]     = 0;
    57a2:	e0 91 ec 02 	lds	r30, 0x02EC
    57a6:	f0 91 ed 02 	lds	r31, 0x02ED
    57aa:	e2 0f       	add	r30, r18
    57ac:	f3 1f       	adc	r31, r19
    57ae:	01 90       	ld	r0, Z+
    57b0:	f0 81       	ld	r31, Z
    57b2:	e0 2d       	mov	r30, r0
    57b4:	e8 0f       	add	r30, r24
    57b6:	f9 1f       	adc	r31, r25
    57b8:	10 82       	st	Z, r1
    57ba:	01 96       	adiw	r24, 0x01	; 1
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    menu.currentDisplayValue[i][j] = 0;
    menu.newDisplayValue[i][j]     = 0;
  }

  for(j = 0; j < DISPLAY_MENU_STRING_LENGTH; j++){
    57bc:	81 31       	cpi	r24, 0x11	; 17
    57be:	91 05       	cpc	r25, r1
    57c0:	21 f7       	brne	.-56     	; 0x578a <initBuffers+0x64>
    menu.currentMenuText[i][j] = 0;
    menu.newMenuText[i][j]     = 0;
  }

  memset(rxString.buffer, 0, SERIAL_BUFFERSIZE);
    57c2:	e0 91 ee 02 	lds	r30, 0x02EE
    57c6:	f0 91 ef 02 	lds	r31, 0x02EF
    57ca:	80 e4       	ldi	r24, 0x40	; 64
    57cc:	df 01       	movw	r26, r30
    57ce:	98 2f       	mov	r25, r24
    57d0:	1d 92       	st	X+, r1
    57d2:	9a 95       	dec	r25
    57d4:	e9 f7       	brne	.-6      	; 0x57d0 <initBuffers+0xaa>
  memset(txString.buffer, 0, SERIAL_BUFFERSIZE);
    57d6:	e0 91 e7 03 	lds	r30, 0x03E7
    57da:	f0 91 e8 03 	lds	r31, 0x03E8
    57de:	df 01       	movw	r26, r30
    57e0:	98 2f       	mov	r25, r24
    57e2:	1d 92       	st	X+, r1
    57e4:	9a 95       	dec	r25
    57e6:	e9 f7       	brne	.-6      	; 0x57e2 <initBuffers+0xbc>
  memset(commandString.buffer, 0, SERIAL_BUFFERSIZE);
    57e8:	e0 91 90 04 	lds	r30, 0x0490
    57ec:	f0 91 91 04 	lds	r31, 0x0491
    57f0:	df 01       	movw	r26, r30
    57f2:	1d 92       	st	X+, r1
    57f4:	8a 95       	dec	r24
    57f6:	e9 f7       	brne	.-6      	; 0x57f2 <initBuffers+0xcc>
  memset(displayBuffer, 0, DISPLAY_BUFFER_SIZE);
    57f8:	e0 91 eb 03 	lds	r30, 0x03EB
    57fc:	f0 91 ec 03 	lds	r31, 0x03EC
    5800:	88 e2       	ldi	r24, 0x28	; 40
    5802:	df 01       	movw	r26, r30
    5804:	1d 92       	st	X+, r1
    5806:	8a 95       	dec	r24
    5808:	e9 f7       	brne	.-6      	; 0x5804 <initBuffers+0xde>

  return;
}
    580a:	08 95       	ret

0000580c <copyRXstring>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    580c:	f8 94       	cli
    copy command to internal buffer
 --------------------------------------------------------------------- */
void copyRXstring(void){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    memcpy(commandString.buffer, rxString.buffer, SERIAL_BUFFERSIZE);
    580e:	80 91 90 04 	lds	r24, 0x0490
    5812:	90 91 91 04 	lds	r25, 0x0491
    5816:	20 91 ee 02 	lds	r18, 0x02EE
    581a:	30 91 ef 02 	lds	r19, 0x02EF
    581e:	dc 01       	movw	r26, r24
    5820:	f9 01       	movw	r30, r18
    5822:	80 e4       	ldi	r24, 0x40	; 64
    5824:	01 90       	ld	r0, Z+
    5826:	0d 92       	st	X+, r0
    5828:	81 50       	subi	r24, 0x01	; 1
    582a:	e1 f7       	brne	.-8      	; 0x5824 <copyRXstring+0x18>
    commandString.readyToProcess = 1;
    582c:	81 e0       	ldi	r24, 0x01	; 1
    582e:	80 93 92 04 	sts	0x0492, r24

    memset(rxString.buffer, 0, SERIAL_BUFFERSIZE);
    5832:	e0 91 ee 02 	lds	r30, 0x02EE
    5836:	f0 91 ef 02 	lds	r31, 0x02EF
    583a:	80 e4       	ldi	r24, 0x40	; 64
    583c:	df 01       	movw	r26, r30
    583e:	1d 92       	st	X+, r1
    5840:	8a 95       	dec	r24
    5842:	e9 f7       	brne	.-6      	; 0x583e <copyRXstring+0x32>
    rxString.charCount = 0;
    5844:	10 92 f1 02 	sts	0x02F1, r1
    rxString.readyToProcess = 0;
    5848:	10 92 f0 02 	sts	0x02F0, r1
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    584c:	78 94       	sei
  }

  return;
}
    584e:	08 95       	ret

00005850 <setMotorCurrent>:
}

/* ---------------------------------------------------------------------
   sets the motor current for DRV8825
 --------------------------------------------------------------------- */
void setMotorCurrent(uint8_t mot, float curr){
    5850:	df 92       	push	r13
    5852:	ef 92       	push	r14
    5854:	ff 92       	push	r15
    5856:	0f 93       	push	r16
    5858:	1f 93       	push	r17
    585a:	d8 2e       	mov	r13, r24
    585c:	7a 01       	movw	r14, r20
    585e:	8b 01       	movw	r16, r22

  uint8_t addr = 0;
  uint8_t val = 0;
  //uint16_t reg = 0;

  if(curr < 0.0){
    5860:	cb 01       	movw	r24, r22
    5862:	ba 01       	movw	r22, r20
    5864:	20 e0       	ldi	r18, 0x00	; 0
    5866:	30 e0       	ldi	r19, 0x00	; 0
    5868:	40 e0       	ldi	r20, 0x00	; 0
    586a:	50 e0       	ldi	r21, 0x00	; 0
    586c:	0e 94 c4 3f 	call	0x7f88	; 0x7f88 <__cmpsf2>
    5870:	88 23       	and	r24, r24
    5872:	34 f1       	brlt	.+76     	; 0x58c0 <setMotorCurrent+0x70>
    curr = 0.0;
  }

  if(curr > 2.5){ /* maximum for DRV8825: 2.5 Ampere */
    5874:	c8 01       	movw	r24, r16
    5876:	b7 01       	movw	r22, r14
    5878:	20 e0       	ldi	r18, 0x00	; 0
    587a:	30 e0       	ldi	r19, 0x00	; 0
    587c:	40 e2       	ldi	r20, 0x20	; 32
    587e:	50 e4       	ldi	r21, 0x40	; 64
    5880:	0e 94 66 41 	call	0x82cc	; 0x82cc <__gesf2>
    5884:	18 16       	cp	r1, r24
    5886:	fc f4       	brge	.+62     	; 0x58c6 <setMotorCurrent+0x76>
    5888:	0c e0       	ldi	r16, 0x0C	; 12
    588a:	10 e1       	ldi	r17, 0x10	; 16
    curr = 2.5;
  }

  addr = getDACAddress(mot);
    588c:	8d 2d       	mov	r24, r13
    588e:	0e 94 43 0a 	call	0x1486	; 0x1486 <getDACAddress>
  /* 255 / 3.3V * 2.5A = 193 */
  /* 193 <=> 2.5 A, 193/2.5 = 77.2 */

  val = (uint8_t)floor(77.2 * curr);

  IIC.data[0] = (val & 0xF0) >> 4;
    5892:	e0 91 ed 03 	lds	r30, 0x03ED
    5896:	f0 91 ee 03 	lds	r31, 0x03EE
    589a:	00 83       	st	Z, r16
  IIC.data[1] = (val & 0x0F) << 4;
    589c:	e0 91 ed 03 	lds	r30, 0x03ED
    58a0:	f0 91 ee 03 	lds	r31, 0x03EE
    58a4:	11 83       	std	Z+1, r17	; 0x01

  IICwrite(addr, IIC.data, 2);
    58a6:	60 91 ed 03 	lds	r22, 0x03ED
    58aa:	70 91 ee 03 	lds	r23, 0x03EE
    58ae:	42 e0       	ldi	r20, 0x02	; 2
    58b0:	0e 94 c3 09 	call	0x1386	; 0x1386 <IICwrite>

  return;
}
    58b4:	1f 91       	pop	r17
    58b6:	0f 91       	pop	r16
    58b8:	ff 90       	pop	r15
    58ba:	ef 90       	pop	r14
    58bc:	df 90       	pop	r13
    58be:	08 95       	ret

  uint8_t addr = 0;
  uint8_t val = 0;
  //uint16_t reg = 0;

  if(curr < 0.0){
    58c0:	00 e0       	ldi	r16, 0x00	; 0
    58c2:	10 e0       	ldi	r17, 0x00	; 0
    58c4:	e3 cf       	rjmp	.-58     	; 0x588c <setMotorCurrent+0x3c>
}

/* ---------------------------------------------------------------------
   sets the motor current for DRV8825
 --------------------------------------------------------------------- */
void setMotorCurrent(uint8_t mot, float curr){
    58c6:	c8 01       	movw	r24, r16
    58c8:	b7 01       	movw	r22, r14
    58ca:	26 e6       	ldi	r18, 0x66	; 102
    58cc:	36 e6       	ldi	r19, 0x66	; 102
    58ce:	4a e9       	ldi	r20, 0x9A	; 154
    58d0:	52 e4       	ldi	r21, 0x42	; 66
    58d2:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    58d6:	0e 94 9e 40 	call	0x813c	; 0x813c <floor>
    58da:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
    58de:	06 2f       	mov	r16, r22
    58e0:	02 95       	swap	r16
    58e2:	0f 70       	andi	r16, 0x0F	; 15
    58e4:	16 2f       	mov	r17, r22
    58e6:	12 95       	swap	r17
    58e8:	10 7f       	andi	r17, 0xF0	; 240
    58ea:	d0 cf       	rjmp	.-96     	; 0x588c <setMotorCurrent+0x3c>

000058ec <commandSetMotorCurrent>:
}

/* ---------------------------------------------------------------------
    sets the desired motor current
 --------------------------------------------------------------------- */
void commandSetMotorCurrent(char* param0, char* param1){
    58ec:	1f 93       	push	r17
    58ee:	cf 93       	push	r28
    58f0:	df 93       	push	r29
    58f2:	eb 01       	movw	r28, r22
  
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    58f4:	60 e0       	ldi	r22, 0x00	; 0
    58f6:	70 e0       	ldi	r23, 0x00	; 0
    58f8:	4a e0       	ldi	r20, 0x0A	; 10
    58fa:	50 e0       	ldi	r21, 0x00	; 0
    58fc:	0e 94 19 43 	call	0x8632	; 0x8632 <strtol>
    5900:	16 2f       	mov	r17, r22
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    5902:	64 30       	cpi	r22, 0x04	; 4
    5904:	a0 f5       	brcc	.+104    	; 0x596e <commandSetMotorCurrent+0x82>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
  }
  else{
    motor[i].current = atof(param1);
    5906:	ce 01       	movw	r24, r28
    5908:	0e 94 48 44 	call	0x8890	; 0x8890 <atof>
    590c:	e1 2f       	mov	r30, r17
    590e:	f0 e0       	ldi	r31, 0x00	; 0
    5910:	ee 0f       	add	r30, r30
    5912:	ff 1f       	adc	r31, r31
    5914:	ee 0f       	add	r30, r30
    5916:	ff 1f       	adc	r31, r31
    5918:	ee 0f       	add	r30, r30
    591a:	ff 1f       	adc	r31, r31
    591c:	9f 01       	movw	r18, r30
    591e:	22 0f       	add	r18, r18
    5920:	33 1f       	adc	r19, r19
    5922:	22 0f       	add	r18, r18
    5924:	33 1f       	adc	r19, r19
    5926:	e2 0f       	add	r30, r18
    5928:	f3 1f       	adc	r31, r19
    592a:	e0 51       	subi	r30, 0x10	; 16
    592c:	fc 4f       	sbci	r31, 0xFC	; 252
    592e:	63 a3       	std	Z+35, r22	; 0x23
    5930:	74 a3       	std	Z+36, r23	; 0x24
    5932:	85 a3       	std	Z+37, r24	; 0x25
    5934:	96 a3       	std	Z+38, r25	; 0x26
    setMotorCurrent(i, motor[i].current);
    5936:	e1 2f       	mov	r30, r17
    5938:	f0 e0       	ldi	r31, 0x00	; 0
    593a:	ee 0f       	add	r30, r30
    593c:	ff 1f       	adc	r31, r31
    593e:	ee 0f       	add	r30, r30
    5940:	ff 1f       	adc	r31, r31
    5942:	ee 0f       	add	r30, r30
    5944:	ff 1f       	adc	r31, r31
    5946:	cf 01       	movw	r24, r30
    5948:	88 0f       	add	r24, r24
    594a:	99 1f       	adc	r25, r25
    594c:	88 0f       	add	r24, r24
    594e:	99 1f       	adc	r25, r25
    5950:	e8 0f       	add	r30, r24
    5952:	f9 1f       	adc	r31, r25
    5954:	e0 51       	subi	r30, 0x10	; 16
    5956:	fc 4f       	sbci	r31, 0xFC	; 252
    5958:	43 a1       	ldd	r20, Z+35	; 0x23
    595a:	54 a1       	ldd	r21, Z+36	; 0x24
    595c:	65 a1       	ldd	r22, Z+37	; 0x25
    595e:	76 a1       	ldd	r23, Z+38	; 0x26
    5960:	81 2f       	mov	r24, r17
    5962:	0e 94 28 2c 	call	0x5850	; 0x5850 <setMotorCurrent>
  }

  return;
}
    5966:	df 91       	pop	r29
    5968:	cf 91       	pop	r28
    596a:	1f 91       	pop	r17
    596c:	08 95       	ret
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    596e:	80 91 e7 03 	lds	r24, 0x03E7
    5972:	90 91 e8 03 	lds	r25, 0x03E8
    5976:	00 d0       	rcall	.+0      	; 0x5978 <commandSetMotorCurrent+0x8c>
    5978:	00 d0       	rcall	.+0      	; 0x597a <commandSetMotorCurrent+0x8e>
    597a:	00 d0       	rcall	.+0      	; 0x597c <commandSetMotorCurrent+0x90>
    597c:	ed b7       	in	r30, 0x3d	; 61
    597e:	fe b7       	in	r31, 0x3e	; 62
    5980:	31 96       	adiw	r30, 0x01	; 1
    5982:	ad b7       	in	r26, 0x3d	; 61
    5984:	be b7       	in	r27, 0x3e	; 62
    5986:	12 96       	adiw	r26, 0x02	; 2
    5988:	9c 93       	st	X, r25
    598a:	8e 93       	st	-X, r24
    598c:	11 97       	sbiw	r26, 0x01	; 1
    598e:	80 e0       	ldi	r24, 0x00	; 0
    5990:	91 e0       	ldi	r25, 0x01	; 1
    5992:	93 83       	std	Z+3, r25	; 0x03
    5994:	82 83       	std	Z+2, r24	; 0x02
    5996:	14 83       	std	Z+4, r17	; 0x04
    5998:	15 82       	std	Z+5, r1	; 0x05
    599a:	0e 94 d7 45 	call	0x8bae	; 0x8bae <sprintf>
    sendText(txString.buffer);
    599e:	80 91 e7 03 	lds	r24, 0x03E7
    59a2:	90 91 e8 03 	lds	r25, 0x03E8
    59a6:	2d b7       	in	r18, 0x3d	; 61
    59a8:	3e b7       	in	r19, 0x3e	; 62
    59aa:	2a 5f       	subi	r18, 0xFA	; 250
    59ac:	3f 4f       	sbci	r19, 0xFF	; 255
    59ae:	0f b6       	in	r0, 0x3f	; 63
    59b0:	f8 94       	cli
    59b2:	3e bf       	out	0x3e, r19	; 62
    59b4:	0f be       	out	0x3f, r0	; 63
    59b6:	2d bf       	out	0x3d, r18	; 61
    59b8:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    motor[i].current = atof(param1);
    setMotorCurrent(i, motor[i].current);
  }

  return;
}
    59bc:	df 91       	pop	r29
    59be:	cf 91       	pop	r28
    59c0:	1f 91       	pop	r17
    59c2:	08 95       	ret

000059c4 <updateIICvalues>:
}

/* ---------------------------------------------------------------------
   update IIC values for all motors
 --------------------------------------------------------------------- */
void updateIICvalues(void){
    59c4:	cf 93       	push	r28
    59c6:	df 93       	push	r29
    59c8:	c0 e0       	ldi	r28, 0x00	; 0
    59ca:	d0 e0       	ldi	r29, 0x00	; 0

  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorCurrent(i, motor[i].current);
    59cc:	fe 01       	movw	r30, r28
    59ce:	ee 0f       	add	r30, r30
    59d0:	ff 1f       	adc	r31, r31
    59d2:	ee 0f       	add	r30, r30
    59d4:	ff 1f       	adc	r31, r31
    59d6:	ee 0f       	add	r30, r30
    59d8:	ff 1f       	adc	r31, r31
    59da:	cf 01       	movw	r24, r30
    59dc:	88 0f       	add	r24, r24
    59de:	99 1f       	adc	r25, r25
    59e0:	88 0f       	add	r24, r24
    59e2:	99 1f       	adc	r25, r25
    59e4:	e8 0f       	add	r30, r24
    59e6:	f9 1f       	adc	r31, r25
    59e8:	e0 51       	subi	r30, 0x10	; 16
    59ea:	fc 4f       	sbci	r31, 0xFC	; 252
    59ec:	43 a1       	ldd	r20, Z+35	; 0x23
    59ee:	54 a1       	ldd	r21, Z+36	; 0x24
    59f0:	65 a1       	ldd	r22, Z+37	; 0x25
    59f2:	76 a1       	ldd	r23, Z+38	; 0x26
    59f4:	8c 2f       	mov	r24, r28
    59f6:	0e 94 28 2c 	call	0x5850	; 0x5850 <setMotorCurrent>
    setMotorDecay(i, motor[i].decay);
    59fa:	fe 01       	movw	r30, r28
    59fc:	ee 0f       	add	r30, r30
    59fe:	ff 1f       	adc	r31, r31
    5a00:	ee 0f       	add	r30, r30
    5a02:	ff 1f       	adc	r31, r31
    5a04:	ee 0f       	add	r30, r30
    5a06:	ff 1f       	adc	r31, r31
    5a08:	cf 01       	movw	r24, r30
    5a0a:	88 0f       	add	r24, r24
    5a0c:	99 1f       	adc	r25, r25
    5a0e:	88 0f       	add	r24, r24
    5a10:	99 1f       	adc	r25, r25
    5a12:	e8 0f       	add	r30, r24
    5a14:	f9 1f       	adc	r31, r25
    5a16:	e0 51       	subi	r30, 0x10	; 16
    5a18:	fc 4f       	sbci	r31, 0xFC	; 252
    5a1a:	67 a1       	ldd	r22, Z+39	; 0x27
    5a1c:	8c 2f       	mov	r24, r28
    5a1e:	0e 94 0d 0c 	call	0x181a	; 0x181a <setMotorDecay>
    setSubSteps(i, (uint8_t)round(motor[i].subSteps));
    5a22:	fe 01       	movw	r30, r28
    5a24:	ee 0f       	add	r30, r30
    5a26:	ff 1f       	adc	r31, r31
    5a28:	ee 0f       	add	r30, r30
    5a2a:	ff 1f       	adc	r31, r31
    5a2c:	ee 0f       	add	r30, r30
    5a2e:	ff 1f       	adc	r31, r31
    5a30:	cf 01       	movw	r24, r30
    5a32:	88 0f       	add	r24, r24
    5a34:	99 1f       	adc	r25, r25
    5a36:	88 0f       	add	r24, r24
    5a38:	99 1f       	adc	r25, r25
    5a3a:	e8 0f       	add	r30, r24
    5a3c:	f9 1f       	adc	r31, r25
    5a3e:	e0 51       	subi	r30, 0x10	; 16
    5a40:	fc 4f       	sbci	r31, 0xFC	; 252
    5a42:	65 89       	ldd	r22, Z+21	; 0x15
    5a44:	76 89       	ldd	r23, Z+22	; 0x16
    5a46:	87 89       	ldd	r24, Z+23	; 0x17
    5a48:	90 8d       	ldd	r25, Z+24	; 0x18
    5a4a:	0e 94 cd 41 	call	0x839a	; 0x839a <round>
    5a4e:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
    5a52:	9b 01       	movw	r18, r22
    5a54:	ac 01       	movw	r20, r24
    5a56:	8c 2f       	mov	r24, r28
    5a58:	62 2f       	mov	r22, r18
    5a5a:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <setSubSteps>
    5a5e:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void updateIICvalues(void){

  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    5a60:	c4 30       	cpi	r28, 0x04	; 4
    5a62:	d1 05       	cpc	r29, r1
    5a64:	09 f0       	breq	.+2      	; 0x5a68 <updateIICvalues+0xa4>
    5a66:	b2 cf       	rjmp	.-156    	; 0x59cc <updateIICvalues+0x8>
    setMotorDecay(i, motor[i].decay);
    setSubSteps(i, (uint8_t)round(motor[i].subSteps));
  }

  return;
}
    5a68:	df 91       	pop	r29
    5a6a:	cf 91       	pop	r28
    5a6c:	08 95       	ret

00005a6e <updateDisplay>:
 --------------------------------------------------------------------- */
void updateDisplay(void){

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    5a6e:	80 91 e4 02 	lds	r24, 0x02E4
    5a72:	82 30       	cpi	r24, 0x02	; 2
    5a74:	09 f4       	brne	.+2      	; 0x5a78 <updateDisplay+0xa>
    5a76:	6f c0       	rjmp	.+222    	; 0x5b56 <updateDisplay+0xe8>
    5a78:	83 30       	cpi	r24, 0x03	; 3
    5a7a:	08 f4       	brcc	.+2      	; 0x5a7e <updateDisplay+0x10>
    5a7c:	64 c0       	rjmp	.+200    	; 0x5b46 <updateDisplay+0xd8>
    5a7e:	83 30       	cpi	r24, 0x03	; 3
    5a80:	09 f4       	brne	.+2      	; 0x5a84 <updateDisplay+0x16>
    5a82:	c6 c0       	rjmp	.+396    	; 0x5c10 <updateDisplay+0x1a2>
    5a84:	85 30       	cpi	r24, 0x05	; 5
    5a86:	09 f0       	breq	.+2      	; 0x5a8a <updateDisplay+0x1c>
    5a88:	61 c0       	rjmp	.+194    	; 0x5b4c <updateDisplay+0xde>
        }
      }
      break;
      
    case MENU_SETTINGS_MODE:
      if(menu.currentDisplayedMenu != menu.newDisplayedMenu){
    5a8a:	90 91 e0 02 	lds	r25, 0x02E0
    5a8e:	80 91 df 02 	lds	r24, 0x02DF
    5a92:	98 17       	cp	r25, r24
    5a94:	09 f4       	brne	.+2      	; 0x5a98 <updateDisplay+0x2a>
    5a96:	5a c0       	rjmp	.+180    	; 0x5b4c <updateDisplay+0xde>
        changeDisplayMenu(menu.newDisplayedMenu);
    5a98:	80 91 df 02 	lds	r24, 0x02DF
    5a9c:	0e 94 2d 24 	call	0x485a	; 0x485a <changeDisplayMenu>
        //lcd_setcursor(0, 1);  /* line 1 */
        //lcd_string(menu.newMenuText[0]);
        OLEDsetCursor(0, 0);
    5aa0:	80 e0       	ldi	r24, 0x00	; 0
    5aa2:	60 e0       	ldi	r22, 0x00	; 0
    5aa4:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[0]);
    5aa8:	e0 91 ec 02 	lds	r30, 0x02EC
    5aac:	f0 91 ed 02 	lds	r31, 0x02ED
    5ab0:	80 81       	ld	r24, Z
    5ab2:	91 81       	ldd	r25, Z+1	; 0x01
    5ab4:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentMenuText[0], menu.newMenuText[0]);
    5ab8:	a0 91 ea 02 	lds	r26, 0x02EA
    5abc:	b0 91 eb 02 	lds	r27, 0x02EB
    5ac0:	e0 91 ec 02 	lds	r30, 0x02EC
    5ac4:	f0 91 ed 02 	lds	r31, 0x02ED
    5ac8:	60 81       	ld	r22, Z
    5aca:	71 81       	ldd	r23, Z+1	; 0x01
    5acc:	8d 91       	ld	r24, X+
    5ace:	9c 91       	ld	r25, X
    5ad0:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
        //lcd_setcursor(0, 2);  /* line 2 */
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
    5ad4:	80 e0       	ldi	r24, 0x00	; 0
    5ad6:	61 e0       	ldi	r22, 0x01	; 1
    5ad8:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[1]);
    5adc:	e0 91 ec 02 	lds	r30, 0x02EC
    5ae0:	f0 91 ed 02 	lds	r31, 0x02ED
    5ae4:	82 81       	ldd	r24, Z+2	; 0x02
    5ae6:	93 81       	ldd	r25, Z+3	; 0x03
    5ae8:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
    5aec:	a0 91 ea 02 	lds	r26, 0x02EA
    5af0:	b0 91 eb 02 	lds	r27, 0x02EB
    5af4:	e0 91 ec 02 	lds	r30, 0x02EC
    5af8:	f0 91 ed 02 	lds	r31, 0x02ED
    5afc:	62 81       	ldd	r22, Z+2	; 0x02
    5afe:	73 81       	ldd	r23, Z+3	; 0x03
    5b00:	12 96       	adiw	r26, 0x02	; 2
    5b02:	8d 91       	ld	r24, X+
    5b04:	9c 91       	ld	r25, X
    5b06:	13 97       	sbiw	r26, 0x03	; 3
    5b08:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
    5b0c:	80 91 df 02 	lds	r24, 0x02DF
    5b10:	80 93 e0 02 	sts	0x02E0, r24
    5b14:	40 e0       	ldi	r20, 0x00	; 0
    5b16:	50 e0       	ldi	r21, 0x00	; 0
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
          sprintf(menu.currentDisplayValue[j], "no text");
    5b18:	e0 91 e6 02 	lds	r30, 0x02E6
    5b1c:	f0 91 e7 02 	lds	r31, 0x02E7
    5b20:	e4 0f       	add	r30, r20
    5b22:	f5 1f       	adc	r31, r21
    5b24:	20 81       	ld	r18, Z
    5b26:	31 81       	ldd	r19, Z+1	; 0x01
    5b28:	c9 01       	movw	r24, r18
    5b2a:	dc 01       	movw	r26, r24
    5b2c:	e4 eb       	ldi	r30, 0xB4	; 180
    5b2e:	f2 e0       	ldi	r31, 0x02	; 2
    5b30:	88 e0       	ldi	r24, 0x08	; 8
    5b32:	01 90       	ld	r0, Z+
    5b34:	0d 92       	st	X+, r0
    5b36:	81 50       	subi	r24, 0x01	; 1
    5b38:	e1 f7       	brne	.-8      	; 0x5b32 <updateDisplay+0xc4>
    5b3a:	4e 5f       	subi	r20, 0xFE	; 254
    5b3c:	5f 4f       	sbci	r21, 0xFF	; 255
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newMenuText[1]);
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
    5b3e:	4a 30       	cpi	r20, 0x0A	; 10
    5b40:	51 05       	cpc	r21, r1
    5b42:	51 f7       	brne	.-44     	; 0x5b18 <updateDisplay+0xaa>
    5b44:	03 c0       	rjmp	.+6      	; 0x5b4c <updateDisplay+0xde>
 --------------------------------------------------------------------- */
void updateDisplay(void){

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    5b46:	81 30       	cpi	r24, 0x01	; 1
    5b48:	09 f4       	brne	.+2      	; 0x5b4c <updateDisplay+0xde>
    5b4a:	62 c0       	rjmp	.+196    	; 0x5c10 <updateDisplay+0x1a2>

    default:
      break;
  }

  menu.currentMenuMode = menu.newMenuMode;
    5b4c:	80 91 e1 02 	lds	r24, 0x02E1
    5b50:	80 93 e4 02 	sts	0x02E4, r24

  return;
}
    5b54:	08 95       	ret

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    case MENU_SCROLL_MODE:
      if(menu.currentDisplayedMenu != menu.newDisplayedMenu){
    5b56:	90 91 e0 02 	lds	r25, 0x02E0
    5b5a:	80 91 df 02 	lds	r24, 0x02DF
    5b5e:	98 17       	cp	r25, r24
    5b60:	a9 f3       	breq	.-22     	; 0x5b4c <updateDisplay+0xde>
        changeDisplayMenu(menu.newDisplayedMenu);
    5b62:	80 91 df 02 	lds	r24, 0x02DF
    5b66:	0e 94 2d 24 	call	0x485a	; 0x485a <changeDisplayMenu>
        //lcd_setcursor(0, 1);  /* line 1 */
        //lcd_string(menu.newMenuText[0]);
        OLEDsetCursor(0, 0);
    5b6a:	80 e0       	ldi	r24, 0x00	; 0
    5b6c:	60 e0       	ldi	r22, 0x00	; 0
    5b6e:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[0]);
    5b72:	e0 91 ec 02 	lds	r30, 0x02EC
    5b76:	f0 91 ed 02 	lds	r31, 0x02ED
    5b7a:	80 81       	ld	r24, Z
    5b7c:	91 81       	ldd	r25, Z+1	; 0x01
    5b7e:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentMenuText[0], menu.newMenuText[0]);
    5b82:	a0 91 ea 02 	lds	r26, 0x02EA
    5b86:	b0 91 eb 02 	lds	r27, 0x02EB
    5b8a:	e0 91 ec 02 	lds	r30, 0x02EC
    5b8e:	f0 91 ed 02 	lds	r31, 0x02ED
    5b92:	60 81       	ld	r22, Z
    5b94:	71 81       	ldd	r23, Z+1	; 0x01
    5b96:	8d 91       	ld	r24, X+
    5b98:	9c 91       	ld	r25, X
    5b9a:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
        //lcd_setcursor(0, 2);  /* line 2 */
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
    5b9e:	80 e0       	ldi	r24, 0x00	; 0
    5ba0:	61 e0       	ldi	r22, 0x01	; 1
    5ba2:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[1]);
    5ba6:	e0 91 ec 02 	lds	r30, 0x02EC
    5baa:	f0 91 ed 02 	lds	r31, 0x02ED
    5bae:	82 81       	ldd	r24, Z+2	; 0x02
    5bb0:	93 81       	ldd	r25, Z+3	; 0x03
    5bb2:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
    5bb6:	a0 91 ea 02 	lds	r26, 0x02EA
    5bba:	b0 91 eb 02 	lds	r27, 0x02EB
    5bbe:	e0 91 ec 02 	lds	r30, 0x02EC
    5bc2:	f0 91 ed 02 	lds	r31, 0x02ED
    5bc6:	62 81       	ldd	r22, Z+2	; 0x02
    5bc8:	73 81       	ldd	r23, Z+3	; 0x03
    5bca:	12 96       	adiw	r26, 0x02	; 2
    5bcc:	8d 91       	ld	r24, X+
    5bce:	9c 91       	ld	r25, X
    5bd0:	13 97       	sbiw	r26, 0x03	; 3
    5bd2:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
    5bd6:	80 91 df 02 	lds	r24, 0x02DF
    5bda:	80 93 e0 02 	sts	0x02E0, r24
    5bde:	40 e0       	ldi	r20, 0x00	; 0
    5be0:	50 e0       	ldi	r21, 0x00	; 0
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
          sprintf(menu.currentDisplayValue[j], "no text");
    5be2:	e0 91 e6 02 	lds	r30, 0x02E6
    5be6:	f0 91 e7 02 	lds	r31, 0x02E7
    5bea:	e4 0f       	add	r30, r20
    5bec:	f5 1f       	adc	r31, r21
    5bee:	20 81       	ld	r18, Z
    5bf0:	31 81       	ldd	r19, Z+1	; 0x01
    5bf2:	c9 01       	movw	r24, r18
    5bf4:	dc 01       	movw	r26, r24
    5bf6:	e4 eb       	ldi	r30, 0xB4	; 180
    5bf8:	f2 e0       	ldi	r31, 0x02	; 2
    5bfa:	88 e0       	ldi	r24, 0x08	; 8
    5bfc:	01 90       	ld	r0, Z+
    5bfe:	0d 92       	st	X+, r0
    5c00:	81 50       	subi	r24, 0x01	; 1
    5c02:	e1 f7       	brne	.-8      	; 0x5bfc <updateDisplay+0x18e>
    5c04:	4e 5f       	subi	r20, 0xFE	; 254
    5c06:	5f 4f       	sbci	r21, 0xFF	; 255
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newMenuText[1]);
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
    5c08:	4a 30       	cpi	r20, 0x0A	; 10
    5c0a:	51 05       	cpc	r21, r1
    5c0c:	51 f7       	brne	.-44     	; 0x5be2 <updateDisplay+0x174>
    5c0e:	9e cf       	rjmp	.-196    	; 0x5b4c <updateDisplay+0xde>
      }
      break;

    case MENU_CHANGE_MODE:
    case MENU_VALUE_CHANGE:
      updateDisplayChangeValues(menu.currentDisplayedMenu);
    5c10:	80 91 e0 02 	lds	r24, 0x02E0
    5c14:	0e 94 f6 1a 	call	0x35ec	; 0x35ec <updateDisplayChangeValues>
      if(strcmp(menu.currentDisplayValue[0], menu.newDisplayValue[0])){
    5c18:	a0 91 e6 02 	lds	r26, 0x02E6
    5c1c:	b0 91 e7 02 	lds	r27, 0x02E7
    5c20:	e0 91 e8 02 	lds	r30, 0x02E8
    5c24:	f0 91 e9 02 	lds	r31, 0x02E9
    5c28:	60 81       	ld	r22, Z
    5c2a:	71 81       	ldd	r23, Z+1	; 0x01
    5c2c:	8d 91       	ld	r24, X+
    5c2e:	9c 91       	ld	r25, X
    5c30:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5c34:	00 97       	sbiw	r24, 0x00	; 0
    5c36:	09 f0       	breq	.+2      	; 0x5c3a <updateDisplay+0x1cc>
    5c38:	8f c0       	rjmp	.+286    	; 0x5d58 <updateDisplay+0x2ea>
        //lcd_string(menu.newDisplayValue[0]);
        OLEDsetCursor(0, 0);
        OLEDprintCC(menu.newDisplayValue[0]);
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
      }
      if(strcmp(menu.currentDisplayValue[1], menu.newDisplayValue[1])){
    5c3a:	a0 91 e6 02 	lds	r26, 0x02E6
    5c3e:	b0 91 e7 02 	lds	r27, 0x02E7
    5c42:	e0 91 e8 02 	lds	r30, 0x02E8
    5c46:	f0 91 e9 02 	lds	r31, 0x02E9
    5c4a:	62 81       	ldd	r22, Z+2	; 0x02
    5c4c:	73 81       	ldd	r23, Z+3	; 0x03
    5c4e:	12 96       	adiw	r26, 0x02	; 2
    5c50:	8d 91       	ld	r24, X+
    5c52:	9c 91       	ld	r25, X
    5c54:	13 97       	sbiw	r26, 0x03	; 3
    5c56:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5c5a:	00 97       	sbiw	r24, 0x00	; 0
    5c5c:	09 f0       	breq	.+2      	; 0x5c60 <updateDisplay+0x1f2>
    5c5e:	5f c0       	rjmp	.+190    	; 0x5d1e <updateDisplay+0x2b0>
        //lcd_string(menu.newDisplayValue[1]);
        OLEDsetCursor(8, 0);
        OLEDprintCC(menu.newDisplayValue[1]);
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
      }
      if(strcmp(menu.currentDisplayValue[2], menu.newDisplayValue[2])){
    5c60:	a0 91 e6 02 	lds	r26, 0x02E6
    5c64:	b0 91 e7 02 	lds	r27, 0x02E7
    5c68:	e0 91 e8 02 	lds	r30, 0x02E8
    5c6c:	f0 91 e9 02 	lds	r31, 0x02E9
    5c70:	64 81       	ldd	r22, Z+4	; 0x04
    5c72:	75 81       	ldd	r23, Z+5	; 0x05
    5c74:	14 96       	adiw	r26, 0x04	; 4
    5c76:	8d 91       	ld	r24, X+
    5c78:	9c 91       	ld	r25, X
    5c7a:	15 97       	sbiw	r26, 0x05	; 5
    5c7c:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5c80:	00 97       	sbiw	r24, 0x00	; 0
    5c82:	81 f5       	brne	.+96     	; 0x5ce4 <updateDisplay+0x276>
        //lcd_string(menu.newDisplayValue[2]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newDisplayValue[2]);
        strcpy(menu.currentDisplayValue[2], menu.newDisplayValue[2]);
      }
      if(strcmp(menu.currentDisplayValue[3], menu.newDisplayValue[3])){
    5c84:	a0 91 e6 02 	lds	r26, 0x02E6
    5c88:	b0 91 e7 02 	lds	r27, 0x02E7
    5c8c:	e0 91 e8 02 	lds	r30, 0x02E8
    5c90:	f0 91 e9 02 	lds	r31, 0x02E9
    5c94:	66 81       	ldd	r22, Z+6	; 0x06
    5c96:	77 81       	ldd	r23, Z+7	; 0x07
    5c98:	16 96       	adiw	r26, 0x06	; 6
    5c9a:	8d 91       	ld	r24, X+
    5c9c:	9c 91       	ld	r25, X
    5c9e:	17 97       	sbiw	r26, 0x07	; 7
    5ca0:	0e 94 61 45 	call	0x8ac2	; 0x8ac2 <strcmp>
    5ca4:	00 97       	sbiw	r24, 0x00	; 0
    5ca6:	09 f4       	brne	.+2      	; 0x5caa <updateDisplay+0x23c>
    5ca8:	51 cf       	rjmp	.-350    	; 0x5b4c <updateDisplay+0xde>
        //lcd_setcursor(8, 2);
        //lcd_string(menu.newDisplayValue[3]);
        OLEDsetCursor(8, 1);
    5caa:	88 e0       	ldi	r24, 0x08	; 8
    5cac:	61 e0       	ldi	r22, 0x01	; 1
    5cae:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[3]);
    5cb2:	e0 91 e8 02 	lds	r30, 0x02E8
    5cb6:	f0 91 e9 02 	lds	r31, 0x02E9
    5cba:	86 81       	ldd	r24, Z+6	; 0x06
    5cbc:	97 81       	ldd	r25, Z+7	; 0x07
    5cbe:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentDisplayValue[3], menu.newDisplayValue[3]);
    5cc2:	a0 91 e6 02 	lds	r26, 0x02E6
    5cc6:	b0 91 e7 02 	lds	r27, 0x02E7
    5cca:	e0 91 e8 02 	lds	r30, 0x02E8
    5cce:	f0 91 e9 02 	lds	r31, 0x02E9
    5cd2:	66 81       	ldd	r22, Z+6	; 0x06
    5cd4:	77 81       	ldd	r23, Z+7	; 0x07
    5cd6:	16 96       	adiw	r26, 0x06	; 6
    5cd8:	8d 91       	ld	r24, X+
    5cda:	9c 91       	ld	r25, X
    5cdc:	17 97       	sbiw	r26, 0x07	; 7
    5cde:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
    5ce2:	34 cf       	rjmp	.-408    	; 0x5b4c <updateDisplay+0xde>
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
      }
      if(strcmp(menu.currentDisplayValue[2], menu.newDisplayValue[2])){
        //lcd_setcursor(0, 2);
        //lcd_string(menu.newDisplayValue[2]);
        OLEDsetCursor(0, 1);
    5ce4:	80 e0       	ldi	r24, 0x00	; 0
    5ce6:	61 e0       	ldi	r22, 0x01	; 1
    5ce8:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[2]);
    5cec:	e0 91 e8 02 	lds	r30, 0x02E8
    5cf0:	f0 91 e9 02 	lds	r31, 0x02E9
    5cf4:	84 81       	ldd	r24, Z+4	; 0x04
    5cf6:	95 81       	ldd	r25, Z+5	; 0x05
    5cf8:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentDisplayValue[2], menu.newDisplayValue[2]);
    5cfc:	a0 91 e6 02 	lds	r26, 0x02E6
    5d00:	b0 91 e7 02 	lds	r27, 0x02E7
    5d04:	e0 91 e8 02 	lds	r30, 0x02E8
    5d08:	f0 91 e9 02 	lds	r31, 0x02E9
    5d0c:	64 81       	ldd	r22, Z+4	; 0x04
    5d0e:	75 81       	ldd	r23, Z+5	; 0x05
    5d10:	14 96       	adiw	r26, 0x04	; 4
    5d12:	8d 91       	ld	r24, X+
    5d14:	9c 91       	ld	r25, X
    5d16:	15 97       	sbiw	r26, 0x05	; 5
    5d18:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
    5d1c:	b3 cf       	rjmp	.-154    	; 0x5c84 <updateDisplay+0x216>
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
      }
      if(strcmp(menu.currentDisplayValue[1], menu.newDisplayValue[1])){
        //lcd_setcursor(8, 1);
        //lcd_string(menu.newDisplayValue[1]);
        OLEDsetCursor(8, 0);
    5d1e:	88 e0       	ldi	r24, 0x08	; 8
    5d20:	60 e0       	ldi	r22, 0x00	; 0
    5d22:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[1]);
    5d26:	e0 91 e8 02 	lds	r30, 0x02E8
    5d2a:	f0 91 e9 02 	lds	r31, 0x02E9
    5d2e:	82 81       	ldd	r24, Z+2	; 0x02
    5d30:	93 81       	ldd	r25, Z+3	; 0x03
    5d32:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
    5d36:	a0 91 e6 02 	lds	r26, 0x02E6
    5d3a:	b0 91 e7 02 	lds	r27, 0x02E7
    5d3e:	e0 91 e8 02 	lds	r30, 0x02E8
    5d42:	f0 91 e9 02 	lds	r31, 0x02E9
    5d46:	62 81       	ldd	r22, Z+2	; 0x02
    5d48:	73 81       	ldd	r23, Z+3	; 0x03
    5d4a:	12 96       	adiw	r26, 0x02	; 2
    5d4c:	8d 91       	ld	r24, X+
    5d4e:	9c 91       	ld	r25, X
    5d50:	13 97       	sbiw	r26, 0x03	; 3
    5d52:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
    5d56:	84 cf       	rjmp	.-248    	; 0x5c60 <updateDisplay+0x1f2>
    case MENU_VALUE_CHANGE:
      updateDisplayChangeValues(menu.currentDisplayedMenu);
      if(strcmp(menu.currentDisplayValue[0], menu.newDisplayValue[0])){
        //lcd_setcursor(0, 1);
        //lcd_string(menu.newDisplayValue[0]);
        OLEDsetCursor(0, 0);
    5d58:	80 e0       	ldi	r24, 0x00	; 0
    5d5a:	60 e0       	ldi	r22, 0x00	; 0
    5d5c:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[0]);
    5d60:	e0 91 e8 02 	lds	r30, 0x02E8
    5d64:	f0 91 e9 02 	lds	r31, 0x02E9
    5d68:	80 81       	ld	r24, Z
    5d6a:	91 81       	ldd	r25, Z+1	; 0x01
    5d6c:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
    5d70:	a0 91 e6 02 	lds	r26, 0x02E6
    5d74:	b0 91 e7 02 	lds	r27, 0x02E7
    5d78:	e0 91 e8 02 	lds	r30, 0x02E8
    5d7c:	f0 91 e9 02 	lds	r31, 0x02E9
    5d80:	60 81       	ld	r22, Z
    5d82:	71 81       	ldd	r23, Z+1	; 0x01
    5d84:	8d 91       	ld	r24, X+
    5d86:	9c 91       	ld	r25, X
    5d88:	0e 94 6a 45 	call	0x8ad4	; 0x8ad4 <strcpy>
    5d8c:	56 cf       	rjmp	.-340    	; 0x5c3a <updateDisplay+0x1cc>

00005d8e <updateMenu>:


/* ---------------------------------------------------------------------
   implementing the display state machine
 --------------------------------------------------------------------- */
void updateMenu(void){
    5d8e:	6f 92       	push	r6
    5d90:	7f 92       	push	r7
    5d92:	8f 92       	push	r8
    5d94:	9f 92       	push	r9
    5d96:	af 92       	push	r10
    5d98:	bf 92       	push	r11
    5d9a:	cf 92       	push	r12
    5d9c:	df 92       	push	r13
    5d9e:	ef 92       	push	r14
    5da0:	ff 92       	push	r15
    5da2:	0f 93       	push	r16
    5da4:	1f 93       	push	r17
    5da6:	cf 93       	push	r28
    5da8:	df 93       	push	r29

  uint8_t i = 0;
  uint8_t tmp = 0;

  /* first check if we have something to change at all */
  if(buttonState.readyToProcess == 0 && rotEnc.readyToProcess == 0){
    5daa:	80 91 de 02 	lds	r24, 0x02DE
    5dae:	88 23       	and	r24, r24
    5db0:	21 f4       	brne	.+8      	; 0x5dba <updateMenu+0x2c>
    5db2:	80 91 d0 03 	lds	r24, 0x03D0
    5db6:	88 23       	and	r24, r24
    5db8:	a1 f0       	breq	.+40     	; 0x5de2 <updateMenu+0x54>
    /* nothing to be done */
    return;
  }

  /* now get information about the actual display prompt */
  menuPrompt = menu.currentDisplayedMenu;
    5dba:	00 91 e0 02 	lds	r16, 0x02E0
  menuState  = menu.currentMenuMode;
    5dbe:	10 91 e4 02 	lds	r17, 0x02E4

  if(menuState == MENU_SCROLL_MODE){
    5dc2:	12 30       	cpi	r17, 0x02	; 2
    5dc4:	09 f4       	brne	.+2      	; 0x5dc8 <updateMenu+0x3a>
    5dc6:	b4 c0       	rjmp	.+360    	; 0x5f30 <updateMenu+0x1a2>
      menu.newMenuMode = MENU_SETTINGS_MODE;
      menu.newDisplayedMenu = MENU_CHANGE_SUBSTEPS;
    }
  }
  
  if(menuState == MENU_SETTINGS_MODE){
    5dc8:	15 30       	cpi	r17, 0x05	; 5
    5dca:	09 f4       	brne	.+2      	; 0x5dce <updateMenu+0x40>
    5dcc:	de c0       	rjmp	.+444    	; 0x5f8a <updateMenu+0x1fc>
      menu.newDisplayedMenu = MENU_SETTINGS;
    }
  }
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    5dce:	11 30       	cpi	r17, 0x01	; 1
    5dd0:	b9 f0       	breq	.+46     	; 0x5e00 <updateMenu+0x72>
    5dd2:	13 30       	cpi	r17, 0x03	; 3
    5dd4:	a9 f0       	breq	.+42     	; 0x5e00 <updateMenu+0x72>
          break;
      }
    }
  }

  buttonState.readyToProcess = 0;
    5dd6:	10 92 de 02 	sts	0x02DE, r1
  rotEnc.readyToProcess = 0;
    5dda:	10 92 d0 03 	sts	0x03D0, r1
  rotEnc.buttonPressed = 0;
    5dde:	10 92 d1 03 	sts	0x03D1, r1

  return;
}
    5de2:	df 91       	pop	r29
    5de4:	cf 91       	pop	r28
    5de6:	1f 91       	pop	r17
    5de8:	0f 91       	pop	r16
    5dea:	ff 90       	pop	r15
    5dec:	ef 90       	pop	r14
    5dee:	df 90       	pop	r13
    5df0:	cf 90       	pop	r12
    5df2:	bf 90       	pop	r11
    5df4:	af 90       	pop	r10
    5df6:	9f 90       	pop	r9
    5df8:	8f 90       	pop	r8
    5dfa:	7f 90       	pop	r7
    5dfc:	6f 90       	pop	r6
    5dfe:	08 95       	ret
  }
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    5e00:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <getButtonEvent>
    switch(buttonVal){
    5e04:	85 30       	cpi	r24, 0x05	; 5
    5e06:	09 f4       	brne	.+2      	; 0x5e0a <updateMenu+0x7c>
    5e08:	1d c1       	rjmp	.+570    	; 0x6044 <updateMenu+0x2b6>
    5e0a:	86 30       	cpi	r24, 0x06	; 6
    5e0c:	08 f0       	brcs	.+2      	; 0x5e10 <updateMenu+0x82>
    5e0e:	7e c0       	rjmp	.+252    	; 0x5f0c <updateMenu+0x17e>
    5e10:	83 30       	cpi	r24, 0x03	; 3
    5e12:	09 f4       	brne	.+2      	; 0x5e16 <updateMenu+0x88>
    5e14:	0a c1       	rjmp	.+532    	; 0x602a <updateMenu+0x29c>
    5e16:	84 30       	cpi	r24, 0x04	; 4
    5e18:	09 f4       	brne	.+2      	; 0x5e1c <updateMenu+0x8e>
    5e1a:	ff c0       	rjmp	.+510    	; 0x601a <updateMenu+0x28c>
      default:
        break;
    }
  }

  if(menuState == MENU_VALUE_CHANGE){
    5e1c:	13 30       	cpi	r17, 0x03	; 3
    5e1e:	d9 f6       	brne	.-74     	; 0x5dd6 <updateMenu+0x48>
    /* here we have a motor selected and want to change any of its values */
    rotEncVal = getRotaryEncoderEvent();
    5e20:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <getRotaryEncoderEvent>
    5e24:	18 2f       	mov	r17, r24
    if(rotEncVal != 0){
    5e26:	88 23       	and	r24, r24
    5e28:	b1 f2       	breq	.-84     	; 0x5dd6 <updateMenu+0x48>
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
    5e2a:	80 91 e0 02 	lds	r24, 0x02E0
    5e2e:	90 e0       	ldi	r25, 0x00	; 0
    5e30:	88 0f       	add	r24, r24
    5e32:	99 1f       	adc	r25, r25
    5e34:	8e 51       	subi	r24, 0x1E	; 30
    5e36:	9b 4f       	sbci	r25, 0xFB	; 251
    5e38:	fc 01       	movw	r30, r24
    5e3a:	25 91       	lpm	r18, Z+
    5e3c:	34 91       	lpm	r19, Z+
      state = (uint8_t)pgm_read_byte(&menuPtr->state);
    5e3e:	2e 5f       	subi	r18, 0xFE	; 254
    5e40:	3f 4f       	sbci	r19, 0xFF	; 255
    5e42:	f9 01       	movw	r30, r18
    5e44:	84 91       	lpm	r24, Z+

      switch(state){
    5e46:	87 30       	cpi	r24, 0x07	; 7
    5e48:	09 f4       	brne	.+2      	; 0x5e4c <updateMenu+0xbe>
    5e4a:	cc c0       	rjmp	.+408    	; 0x5fe4 <updateMenu+0x256>
    5e4c:	88 30       	cpi	r24, 0x08	; 8
    5e4e:	08 f0       	brcs	.+2      	; 0x5e52 <updateMenu+0xc4>
    5e50:	2d c1       	rjmp	.+602    	; 0x60ac <updateMenu+0x31e>
    5e52:	83 30       	cpi	r24, 0x03	; 3
    5e54:	09 f4       	brne	.+2      	; 0x5e58 <updateMenu+0xca>
    5e56:	57 c2       	rjmp	.+1198   	; 0x6306 <updateMenu+0x578>
    5e58:	84 30       	cpi	r24, 0x04	; 4
    5e5a:	08 f0       	brcs	.+2      	; 0x5e5e <updateMenu+0xd0>
    5e5c:	c8 c1       	rjmp	.+912    	; 0x61ee <updateMenu+0x460>
    5e5e:	81 30       	cpi	r24, 0x01	; 1
    5e60:	09 f4       	brne	.+2      	; 0x5e64 <updateMenu+0xd6>
    5e62:	16 c5       	rjmp	.+2604   	; 0x6890 <updateMenu+0xb02>
    5e64:	82 30       	cpi	r24, 0x02	; 2
    5e66:	09 f0       	breq	.+2      	; 0x5e6a <updateMenu+0xdc>
    5e68:	b6 cf       	rjmp	.-148    	; 0x5dd6 <updateMenu+0x48>
            }
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    5e6a:	c0 e0       	ldi	r28, 0x00	; 0
    5e6c:	d0 e0       	ldi	r29, 0x00	; 0
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepMultiplier += (rotEncVal)/10.0;
    5e6e:	a1 2e       	mov	r10, r17
    5e70:	bb 24       	eor	r11, r11
    5e72:	a7 fc       	sbrc	r10, 7
    5e74:	b0 94       	com	r11
    5e76:	cb 2c       	mov	r12, r11
    5e78:	db 2c       	mov	r13, r11
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    5e7a:	80 91 e5 02 	lds	r24, 0x02E5
    5e7e:	90 e0       	ldi	r25, 0x00	; 0
    5e80:	0c 2e       	mov	r0, r28
    5e82:	02 c0       	rjmp	.+4      	; 0x5e88 <updateMenu+0xfa>
    5e84:	95 95       	asr	r25
    5e86:	87 95       	ror	r24
    5e88:	0a 94       	dec	r0
    5e8a:	e2 f7       	brpl	.-8      	; 0x5e84 <updateMenu+0xf6>
    5e8c:	80 ff       	sbrs	r24, 0
    5e8e:	38 c0       	rjmp	.+112    	; 0x5f00 <updateMenu+0x172>
              motor[i].stepMultiplier += (rotEncVal)/10.0;
    5e90:	fe 01       	movw	r30, r28
    5e92:	ee 0f       	add	r30, r30
    5e94:	ff 1f       	adc	r31, r31
    5e96:	ee 0f       	add	r30, r30
    5e98:	ff 1f       	adc	r31, r31
    5e9a:	ee 0f       	add	r30, r30
    5e9c:	ff 1f       	adc	r31, r31
    5e9e:	cf 01       	movw	r24, r30
    5ea0:	88 0f       	add	r24, r24
    5ea2:	99 1f       	adc	r25, r25
    5ea4:	88 0f       	add	r24, r24
    5ea6:	99 1f       	adc	r25, r25
    5ea8:	e8 0f       	add	r30, r24
    5eaa:	f9 1f       	adc	r31, r25
    5eac:	e0 51       	subi	r30, 0x10	; 16
    5eae:	fc 4f       	sbci	r31, 0xFC	; 252
    5eb0:	e2 8c       	ldd	r14, Z+26	; 0x1a
    5eb2:	f3 8c       	ldd	r15, Z+27	; 0x1b
    5eb4:	04 8d       	ldd	r16, Z+28	; 0x1c
    5eb6:	15 8d       	ldd	r17, Z+29	; 0x1d
    5eb8:	c6 01       	movw	r24, r12
    5eba:	b5 01       	movw	r22, r10
    5ebc:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    5ec0:	20 e0       	ldi	r18, 0x00	; 0
    5ec2:	30 e0       	ldi	r19, 0x00	; 0
    5ec4:	40 e2       	ldi	r20, 0x20	; 32
    5ec6:	51 e4       	ldi	r21, 0x41	; 65
    5ec8:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>
    5ecc:	9b 01       	movw	r18, r22
    5ece:	ac 01       	movw	r20, r24
    5ed0:	c8 01       	movw	r24, r16
    5ed2:	b7 01       	movw	r22, r14
    5ed4:	0e 94 60 3f 	call	0x7ec0	; 0x7ec0 <__addsf3>
    5ed8:	fe 01       	movw	r30, r28
    5eda:	ee 0f       	add	r30, r30
    5edc:	ff 1f       	adc	r31, r31
    5ede:	ee 0f       	add	r30, r30
    5ee0:	ff 1f       	adc	r31, r31
    5ee2:	ee 0f       	add	r30, r30
    5ee4:	ff 1f       	adc	r31, r31
    5ee6:	9f 01       	movw	r18, r30
    5ee8:	22 0f       	add	r18, r18
    5eea:	33 1f       	adc	r19, r19
    5eec:	22 0f       	add	r18, r18
    5eee:	33 1f       	adc	r19, r19
    5ef0:	e2 0f       	add	r30, r18
    5ef2:	f3 1f       	adc	r31, r19
    5ef4:	e0 51       	subi	r30, 0x10	; 16
    5ef6:	fc 4f       	sbci	r31, 0xFC	; 252
    5ef8:	62 8f       	std	Z+26, r22	; 0x1a
    5efa:	73 8f       	std	Z+27, r23	; 0x1b
    5efc:	84 8f       	std	Z+28, r24	; 0x1c
    5efe:	95 8f       	std	Z+29, r25	; 0x1d
    5f00:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    5f02:	c4 30       	cpi	r28, 0x04	; 4
    5f04:	d1 05       	cpc	r29, r1
    5f06:	09 f0       	breq	.+2      	; 0x5f0a <updateMenu+0x17c>
    5f08:	b8 cf       	rjmp	.-144    	; 0x5e7a <updateMenu+0xec>
    5f0a:	65 cf       	rjmp	.-310    	; 0x5dd6 <updateMenu+0x48>
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    switch(buttonVal){
    5f0c:	87 30       	cpi	r24, 0x07	; 7
    5f0e:	09 f4       	brne	.+2      	; 0x5f12 <updateMenu+0x184>
    5f10:	88 c0       	rjmp	.+272    	; 0x6022 <updateMenu+0x294>
    5f12:	87 30       	cpi	r24, 0x07	; 7
    5f14:	08 f0       	brcs	.+2      	; 0x5f18 <updateMenu+0x18a>
    5f16:	5c c0       	rjmp	.+184    	; 0x5fd0 <updateMenu+0x242>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR1:
        menu.selectedMotor ^= (1 << MOTOR1);
    5f18:	80 91 e5 02 	lds	r24, 0x02E5
    5f1c:	92 e0       	ldi	r25, 0x02	; 2
    5f1e:	89 27       	eor	r24, r25
    5f20:	80 93 e5 02 	sts	0x02E5, r24
        menu.newMenuMode = MENU_VALUE_CHANGE;
    5f24:	83 e0       	ldi	r24, 0x03	; 3
    5f26:	80 93 e1 02 	sts	0x02E1, r24
        updateMotorButtonLEDs();
    5f2a:	0e 94 7d 07 	call	0xefa	; 0xefa <updateMotorButtonLEDs>
    5f2e:	76 cf       	rjmp	.-276    	; 0x5e1c <updateMenu+0x8e>
  menuState  = menu.currentMenuMode;

  if(menuState == MENU_SCROLL_MODE){
    /* so here we want to scroll through the menu */

    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    5f30:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <getRotaryEncoderEvent>
    menuPrompt = (menuPrompt+(int8_t)rotEncVal) % NUMBER_OF_DISPLAY_MENUS;
    5f34:	99 27       	eor	r25, r25
    5f36:	87 fd       	sbrc	r24, 7
    5f38:	90 95       	com	r25
    5f3a:	20 2f       	mov	r18, r16
    5f3c:	33 27       	eor	r19, r19
    5f3e:	27 fd       	sbrc	r18, 7
    5f40:	30 95       	com	r19
    5f42:	82 0f       	add	r24, r18
    5f44:	93 1f       	adc	r25, r19
    5f46:	69 e0       	ldi	r22, 0x09	; 9
    5f48:	70 e0       	ldi	r23, 0x00	; 0
    5f4a:	0e 94 01 42 	call	0x8402	; 0x8402 <__divmodhi4>
    5f4e:	18 2f       	mov	r17, r24
    if(menuPrompt < 0){
    5f50:	87 fd       	sbrc	r24, 7
    5f52:	a0 c0       	rjmp	.+320    	; 0x6094 <updateMenu+0x306>
      menuPrompt = NUMBER_OF_DISPLAY_MENUS - 1;
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    5f54:	80 93 df 02 	sts	0x02DF, r24
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    5f58:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <getButtonEvent>
    5f5c:	88 30       	cpi	r24, 0x08	; 8
    5f5e:	09 f4       	brne	.+2      	; 0x5f62 <updateMenu+0x1d4>
    5f60:	90 c0       	rjmp	.+288    	; 0x6082 <updateMenu+0x2f4>
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    5f62:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <getButtonEvent>
    5f66:	88 30       	cpi	r24, 0x08	; 8
    5f68:	09 f4       	brne	.+2      	; 0x5f6c <updateMenu+0x1de>
    5f6a:	82 c0       	rjmp	.+260    	; 0x6070 <updateMenu+0x2e2>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    }
    
    //or enter MENU_SETTINGS_MODE
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menuPrompt == MENU_SETTINGS){
    5f6c:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <getButtonEvent>
    5f70:	88 30       	cpi	r24, 0x08	; 8
    5f72:	09 f0       	breq	.+2      	; 0x5f76 <updateMenu+0x1e8>
    5f74:	30 cf       	rjmp	.-416    	; 0x5dd6 <updateMenu+0x48>
    5f76:	18 30       	cpi	r17, 0x08	; 8
    5f78:	09 f0       	breq	.+2      	; 0x5f7c <updateMenu+0x1ee>
    5f7a:	2d cf       	rjmp	.-422    	; 0x5dd6 <updateMenu+0x48>
      menu.newMenuMode = MENU_SETTINGS_MODE;
    5f7c:	85 e0       	ldi	r24, 0x05	; 5
    5f7e:	80 93 e1 02 	sts	0x02E1, r24
      menu.newDisplayedMenu = MENU_CHANGE_SUBSTEPS;
    5f82:	8a e0       	ldi	r24, 0x0A	; 10
    5f84:	80 93 df 02 	sts	0x02DF, r24
    5f88:	26 cf       	rjmp	.-436    	; 0x5dd6 <updateMenu+0x48>
  }
  
  if(menuState == MENU_SETTINGS_MODE){
    /* so here we want to scroll through the settings menu */
          
    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    5f8a:	0e 94 29 0d 	call	0x1a52	; 0x1a52 <getRotaryEncoderEvent>
    menuPrompt = (menuPrompt + (int8_t)rotEncVal);
    5f8e:	28 2f       	mov	r18, r24
    5f90:	20 0f       	add	r18, r16
    if(menuPrompt > 9 + NUMBER_OF_SETTINGS_MENUS){
    5f92:	2f 30       	cpi	r18, 0x0F	; 15
    5f94:	cc f0       	brlt	.+50     	; 0x5fc8 <updateMenu+0x23a>
    5f96:	2a e0       	ldi	r18, 0x0A	; 10
    }
    if(menuPrompt < 10){
      menuPrompt = 9 + NUMBER_OF_SETTINGS_MENUS;
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    5f98:	20 93 df 02 	sts	0x02DF, r18

    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    5f9c:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <getButtonEvent>
    5fa0:	88 30       	cpi	r24, 0x08	; 8
    5fa2:	09 f4       	brne	.+2      	; 0x5fa6 <updateMenu+0x218>
    5fa4:	53 c0       	rjmp	.+166    	; 0x604c <updateMenu+0x2be>
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    5fa6:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <getButtonEvent>
    5faa:	88 30       	cpi	r24, 0x08	; 8
    5fac:	09 f4       	brne	.+2      	; 0x5fb0 <updateMenu+0x222>
    5fae:	57 c0       	rjmp	.+174    	; 0x605e <updateMenu+0x2d0>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    }
    
    buttonVal = getButtonEvent();
    5fb0:	0e 94 07 0d 	call	0x1a0e	; 0x1a0e <getButtonEvent>
    if(buttonVal == BUTTON_MENUESCAPE){
    5fb4:	83 30       	cpi	r24, 0x03	; 3
    5fb6:	09 f0       	breq	.+2      	; 0x5fba <updateMenu+0x22c>
    5fb8:	0e cf       	rjmp	.-484    	; 0x5dd6 <updateMenu+0x48>
      /* get back to the MENU_SCROLL_MODE */
      menu.newMenuMode = MENU_SCROLL_MODE;
    5fba:	82 e0       	ldi	r24, 0x02	; 2
    5fbc:	80 93 e1 02 	sts	0x02E1, r24
      menu.newDisplayedMenu = MENU_SETTINGS;
    5fc0:	88 e0       	ldi	r24, 0x08	; 8
    5fc2:	80 93 df 02 	sts	0x02DF, r24
    5fc6:	07 cf       	rjmp	.-498    	; 0x5dd6 <updateMenu+0x48>
    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    menuPrompt = (menuPrompt + (int8_t)rotEncVal);
    if(menuPrompt > 9 + NUMBER_OF_SETTINGS_MENUS){
      menuPrompt = 10;
    }
    if(menuPrompt < 10){
    5fc8:	2a 30       	cpi	r18, 0x0A	; 10
    5fca:	34 f7       	brge	.-52     	; 0x5f98 <updateMenu+0x20a>
    5fcc:	2e e0       	ldi	r18, 0x0E	; 14
    5fce:	e4 cf       	rjmp	.-56     	; 0x5f98 <updateMenu+0x20a>
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    switch(buttonVal){
    5fd0:	88 30       	cpi	r24, 0x08	; 8
    5fd2:	09 f0       	breq	.+2      	; 0x5fd6 <updateMenu+0x248>
    5fd4:	23 cf       	rjmp	.-442    	; 0x5e1c <updateMenu+0x8e>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_ROT_ENC_PRESS:
        menu.fastMovingMode ^= 1;
    5fd6:	80 91 e2 02 	lds	r24, 0x02E2
    5fda:	91 e0       	ldi	r25, 0x01	; 1
    5fdc:	89 27       	eor	r24, r25
    5fde:	80 93 e2 02 	sts	0x02E2, r24
    5fe2:	1c cf       	rjmp	.-456    	; 0x5e1c <updateMenu+0x8e>
            }
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    5fe4:	c0 e0       	ldi	r28, 0x00	; 0
    5fe6:	d0 e0       	ldi	r29, 0x00	; 0

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motorZeroRun(i);
              menu.selectedMotor ^= (1 << i);
    5fe8:	e1 e0       	ldi	r30, 0x01	; 1
    5fea:	ce 2e       	mov	r12, r30
    5fec:	d1 2c       	mov	r13, r1
          }
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    5fee:	80 91 e5 02 	lds	r24, 0x02E5
    5ff2:	90 e0       	ldi	r25, 0x00	; 0
    5ff4:	0c 2e       	mov	r0, r28
    5ff6:	02 c0       	rjmp	.+4      	; 0x5ffc <updateMenu+0x26e>
    5ff8:	95 95       	asr	r25
    5ffa:	87 95       	ror	r24
    5ffc:	0a 94       	dec	r0
    5ffe:	e2 f7       	brpl	.-8      	; 0x5ff8 <updateMenu+0x26a>
    6000:	80 fd       	sbrc	r24, 0
    6002:	6d c1       	rjmp	.+730    	; 0x62de <updateMenu+0x550>
              motorZeroRun(i);
              menu.selectedMotor ^= (1 << i);
              updateDisplay();
              updateMotorButtonLEDs();
    6004:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6006:	c4 30       	cpi	r28, 0x04	; 4
    6008:	d1 05       	cpc	r29, r1
    600a:	89 f7       	brne	.-30     	; 0x5fee <updateMenu+0x260>
              updateDisplay();
              updateMotorButtonLEDs();
            }
          }
          /* get back to the MENU_SCROLL_MODE when finished calibration*/
          menu.newMenuMode = MENU_SCROLL_MODE;
    600c:	82 e0       	ldi	r24, 0x02	; 2
    600e:	80 93 e1 02 	sts	0x02E1, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    6012:	89 e0       	ldi	r24, 0x09	; 9
    6014:	80 93 e0 02 	sts	0x02E0, r24
    6018:	de ce       	rjmp	.-580    	; 0x5dd6 <updateMenu+0x48>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR3:
        menu.selectedMotor ^= (1 << MOTOR3);
    601a:	80 91 e5 02 	lds	r24, 0x02E5
    601e:	98 e0       	ldi	r25, 0x08	; 8
    6020:	7e cf       	rjmp	.-260    	; 0x5f1e <updateMenu+0x190>
    switch(buttonVal){
      case NO_BUTTON:
        break;

      case BUTTON_MOTOR0:
        menu.selectedMotor ^= (1 << MOTOR0);
    6022:	80 91 e5 02 	lds	r24, 0x02E5
    6026:	91 e0       	ldi	r25, 0x01	; 1
    6028:	7a cf       	rjmp	.-268    	; 0x5f1e <updateMenu+0x190>
      case BUTTON_ROT_ENC_PRESS:
        menu.fastMovingMode ^= 1;
        break;

      case BUTTON_MENUESCAPE:
        if(menu.currentDisplayedMenu < 10){
    602a:	80 91 e0 02 	lds	r24, 0x02E0
    602e:	8a 30       	cpi	r24, 0x0A	; 10
    6030:	a0 f5       	brcc	.+104    	; 0x609a <updateMenu+0x30c>
          /* get back to the MENU_SCROLL_MODE */
          menu.newMenuMode = MENU_SCROLL_MODE;
    6032:	82 e0       	ldi	r24, 0x02	; 2
    6034:	80 93 e1 02 	sts	0x02E1, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    6038:	89 e0       	ldi	r24, 0x09	; 9
    603a:	80 93 e0 02 	sts	0x02E0, r24
          menu.fastMovingMode = OFF;
    603e:	10 92 e2 02 	sts	0x02E2, r1
    6042:	ec ce       	rjmp	.-552    	; 0x5e1c <updateMenu+0x8e>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR2:
        menu.selectedMotor ^= (1 << MOTOR2);
    6044:	80 91 e5 02 	lds	r24, 0x02E5
    6048:	94 e0       	ldi	r25, 0x04	; 4
    604a:	69 cf       	rjmp	.-302    	; 0x5f1e <updateMenu+0x190>
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;

    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    604c:	80 91 e5 02 	lds	r24, 0x02E5
    6050:	88 23       	and	r24, r24
    6052:	09 f0       	breq	.+2      	; 0x6056 <updateMenu+0x2c8>
    6054:	a8 cf       	rjmp	.-176    	; 0x5fa6 <updateMenu+0x218>
      menu.newMenuMode = MENU_CHANGE_MODE;
    6056:	81 e0       	ldi	r24, 0x01	; 1
    6058:	80 93 e1 02 	sts	0x02E1, r24
    605c:	a4 cf       	rjmp	.-184    	; 0x5fa6 <updateMenu+0x218>
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    605e:	80 91 e5 02 	lds	r24, 0x02E5
    6062:	88 23       	and	r24, r24
    6064:	09 f4       	brne	.+2      	; 0x6068 <updateMenu+0x2da>
    6066:	a4 cf       	rjmp	.-184    	; 0x5fb0 <updateMenu+0x222>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    6068:	83 e0       	ldi	r24, 0x03	; 3
    606a:	80 93 e1 02 	sts	0x02E1, r24
    606e:	a0 cf       	rjmp	.-192    	; 0x5fb0 <updateMenu+0x222>
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    6070:	80 91 e5 02 	lds	r24, 0x02E5
    6074:	88 23       	and	r24, r24
    6076:	09 f4       	brne	.+2      	; 0x607a <updateMenu+0x2ec>
    6078:	79 cf       	rjmp	.-270    	; 0x5f6c <updateMenu+0x1de>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    607a:	83 e0       	ldi	r24, 0x03	; 3
    607c:	80 93 e1 02 	sts	0x02E1, r24
    6080:	75 cf       	rjmp	.-278    	; 0x5f6c <updateMenu+0x1de>
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    6082:	80 91 e5 02 	lds	r24, 0x02E5
    6086:	88 23       	and	r24, r24
    6088:	09 f0       	breq	.+2      	; 0x608c <updateMenu+0x2fe>
    608a:	6b cf       	rjmp	.-298    	; 0x5f62 <updateMenu+0x1d4>
      menu.newMenuMode = MENU_CHANGE_MODE;
    608c:	81 e0       	ldi	r24, 0x01	; 1
    608e:	80 93 e1 02 	sts	0x02E1, r24
    6092:	67 cf       	rjmp	.-306    	; 0x5f62 <updateMenu+0x1d4>
  if(menuState == MENU_SCROLL_MODE){
    /* so here we want to scroll through the menu */

    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    menuPrompt = (menuPrompt+(int8_t)rotEncVal) % NUMBER_OF_DISPLAY_MENUS;
    if(menuPrompt < 0){
    6094:	18 e0       	ldi	r17, 0x08	; 8
    6096:	88 e0       	ldi	r24, 0x08	; 8
    6098:	5d cf       	rjmp	.-326    	; 0x5f54 <updateMenu+0x1c6>
          menu.currentDisplayedMenu = MENU_DUMMY;
          menu.fastMovingMode = OFF;
        }
        else{
          /* get back to the MENU_SETTINGS_MODE */
          menu.newMenuMode = MENU_SETTINGS_MODE;
    609a:	85 e0       	ldi	r24, 0x05	; 5
    609c:	80 93 e1 02 	sts	0x02E1, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    60a0:	89 e0       	ldi	r24, 0x09	; 9
    60a2:	80 93 e0 02 	sts	0x02E0, r24
          menu.fastMovingMode = OFF;
    60a6:	10 92 e2 02 	sts	0x02E2, r1
    60aa:	b8 ce       	rjmp	.-656    	; 0x5e1c <updateMenu+0x8e>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    60ac:	8b 30       	cpi	r24, 0x0B	; 11
    60ae:	09 f4       	brne	.+2      	; 0x60b2 <updateMenu+0x324>
    60b0:	30 c3       	rjmp	.+1632   	; 0x6712 <updateMenu+0x984>
    60b2:	8c 30       	cpi	r24, 0x0C	; 12
    60b4:	08 f0       	brcs	.+2      	; 0x60b8 <updateMenu+0x32a>
    60b6:	83 c0       	rjmp	.+262    	; 0x61be <updateMenu+0x430>
    60b8:	88 30       	cpi	r24, 0x08	; 8
    60ba:	09 f4       	brne	.+2      	; 0x60be <updateMenu+0x330>
    60bc:	1f c3       	rjmp	.+1598   	; 0x66fc <updateMenu+0x96e>
    60be:	8a 30       	cpi	r24, 0x0A	; 10
    60c0:	09 f0       	breq	.+2      	; 0x60c4 <updateMenu+0x336>
    60c2:	89 ce       	rjmp	.-750    	; 0x5dd6 <updateMenu+0x48>
          }
          /* get back to the MENU_SCROLL_MODE when finished calibration*/
          menu.newMenuMode = MENU_SCROLL_MODE;
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
          break;
    60c4:	c0 e0       	ldi	r28, 0x00	; 0
    60c6:	d0 e0       	ldi	r29, 0x00	; 0
    60c8:	ec 2e       	mov	r14, r28

        case MENU_CHANGE_SUBSTEPS:   /* change motor substeps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    60ca:	80 91 e5 02 	lds	r24, 0x02E5
    60ce:	dc 2e       	mov	r13, r28
    60d0:	cd 2e       	mov	r12, r29
    60d2:	90 e0       	ldi	r25, 0x00	; 0
    60d4:	0c 2e       	mov	r0, r28
    60d6:	02 c0       	rjmp	.+4      	; 0x60dc <updateMenu+0x34e>
    60d8:	95 95       	asr	r25
    60da:	87 95       	ror	r24
    60dc:	0a 94       	dec	r0
    60de:	e2 f7       	brpl	.-8      	; 0x60d8 <updateMenu+0x34a>
    60e0:	80 ff       	sbrs	r24, 0
    60e2:	67 c0       	rjmp	.+206    	; 0x61b2 <updateMenu+0x424>
              tmp = motor[i].subSteps;
    60e4:	fe 01       	movw	r30, r28
    60e6:	ee 0f       	add	r30, r30
    60e8:	ff 1f       	adc	r31, r31
    60ea:	ee 0f       	add	r30, r30
    60ec:	ff 1f       	adc	r31, r31
    60ee:	ee 0f       	add	r30, r30
    60f0:	ff 1f       	adc	r31, r31
    60f2:	cf 01       	movw	r24, r30
    60f4:	88 0f       	add	r24, r24
    60f6:	99 1f       	adc	r25, r25
    60f8:	88 0f       	add	r24, r24
    60fa:	99 1f       	adc	r25, r25
    60fc:	e8 0f       	add	r30, r24
    60fe:	f9 1f       	adc	r31, r25
    6100:	e0 51       	subi	r30, 0x10	; 16
    6102:	fc 4f       	sbci	r31, 0xFC	; 252
    6104:	65 89       	ldd	r22, Z+21	; 0x15
    6106:	76 89       	ldd	r23, Z+22	; 0x16
    6108:	87 89       	ldd	r24, Z+23	; 0x17
    610a:	90 8d       	ldd	r25, Z+24	; 0x18
    610c:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
              if(rotEncVal > 0){
    6110:	11 16       	cp	r1, r17
    6112:	0c f0       	brlt	.+2      	; 0x6116 <updateMenu+0x388>
    6114:	69 c4       	rjmp	.+2258   	; 0x69e8 <updateMenu+0xc5a>
                //motor[i].subSteps *= 2.0;
                tmp *= 2.0;
    6116:	70 e0       	ldi	r23, 0x00	; 0
    6118:	88 27       	eor	r24, r24
    611a:	77 fd       	sbrc	r23, 7
    611c:	80 95       	com	r24
    611e:	98 2f       	mov	r25, r24
    6120:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    6124:	9b 01       	movw	r18, r22
    6126:	ac 01       	movw	r20, r24
    6128:	0e 94 60 3f 	call	0x7ec0	; 0x7ec0 <__addsf3>
    612c:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
    6130:	06 2f       	mov	r16, r22
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
              }
              if(motor[i].subSteps < 1){
    6132:	ed 2d       	mov	r30, r13
    6134:	fc 2d       	mov	r31, r12
    6136:	ee 0f       	add	r30, r30
    6138:	ff 1f       	adc	r31, r31
    613a:	ee 0f       	add	r30, r30
    613c:	ff 1f       	adc	r31, r31
    613e:	ee 0f       	add	r30, r30
    6140:	ff 1f       	adc	r31, r31
    6142:	cf 01       	movw	r24, r30
    6144:	88 0f       	add	r24, r24
    6146:	99 1f       	adc	r25, r25
    6148:	88 0f       	add	r24, r24
    614a:	99 1f       	adc	r25, r25
    614c:	e8 0f       	add	r30, r24
    614e:	f9 1f       	adc	r31, r25
    6150:	e0 51       	subi	r30, 0x10	; 16
    6152:	fc 4f       	sbci	r31, 0xFC	; 252
    6154:	65 89       	ldd	r22, Z+21	; 0x15
    6156:	76 89       	ldd	r23, Z+22	; 0x16
    6158:	87 89       	ldd	r24, Z+23	; 0x17
    615a:	90 8d       	ldd	r25, Z+24	; 0x18
    615c:	20 e0       	ldi	r18, 0x00	; 0
    615e:	30 e0       	ldi	r19, 0x00	; 0
    6160:	40 e8       	ldi	r20, 0x80	; 128
    6162:	5f e3       	ldi	r21, 0x3F	; 63
    6164:	0e 94 c4 3f 	call	0x7f88	; 0x7f88 <__cmpsf2>
    6168:	88 23       	and	r24, r24
    616a:	0c f4       	brge	.+2      	; 0x616e <updateMenu+0x3e0>
    616c:	3b c4       	rjmp	.+2166   	; 0x69e4 <updateMenu+0xc56>
                //motor[i].subSteps = 1;
                tmp = 1;
              }
              if(motor[i].subSteps > 32){
    616e:	ed 2d       	mov	r30, r13
    6170:	fc 2d       	mov	r31, r12
    6172:	ee 0f       	add	r30, r30
    6174:	ff 1f       	adc	r31, r31
    6176:	ee 0f       	add	r30, r30
    6178:	ff 1f       	adc	r31, r31
    617a:	ee 0f       	add	r30, r30
    617c:	ff 1f       	adc	r31, r31
    617e:	cf 01       	movw	r24, r30
    6180:	88 0f       	add	r24, r24
    6182:	99 1f       	adc	r25, r25
    6184:	88 0f       	add	r24, r24
    6186:	99 1f       	adc	r25, r25
    6188:	e8 0f       	add	r30, r24
    618a:	f9 1f       	adc	r31, r25
    618c:	e0 51       	subi	r30, 0x10	; 16
    618e:	fc 4f       	sbci	r31, 0xFC	; 252
    6190:	65 89       	ldd	r22, Z+21	; 0x15
    6192:	76 89       	ldd	r23, Z+22	; 0x16
    6194:	87 89       	ldd	r24, Z+23	; 0x17
    6196:	90 8d       	ldd	r25, Z+24	; 0x18
    6198:	20 e0       	ldi	r18, 0x00	; 0
    619a:	30 e0       	ldi	r19, 0x00	; 0
    619c:	40 e0       	ldi	r20, 0x00	; 0
    619e:	52 e4       	ldi	r21, 0x42	; 66
    61a0:	0e 94 66 41 	call	0x82cc	; 0x82cc <__gesf2>
    61a4:	18 16       	cp	r1, r24
    61a6:	0c f4       	brge	.+2      	; 0x61aa <updateMenu+0x41c>
    61a8:	00 e2       	ldi	r16, 0x20	; 32
                //motor[i].subSteps = 32;
                tmp = 32;
              }
              setSubSteps(i,tmp);
    61aa:	8e 2d       	mov	r24, r14
    61ac:	60 2f       	mov	r22, r16
    61ae:	0e 94 62 0b 	call	0x16c4	; 0x16c4 <setSubSteps>
    61b2:	21 96       	adiw	r28, 0x01	; 1
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
          break;

        case MENU_CHANGE_SUBSTEPS:   /* change motor substeps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    61b4:	c4 30       	cpi	r28, 0x04	; 4
    61b6:	d1 05       	cpc	r29, r1
    61b8:	09 f0       	breq	.+2      	; 0x61bc <updateMenu+0x42e>
    61ba:	86 cf       	rjmp	.-244    	; 0x60c8 <updateMenu+0x33a>
    61bc:	0c ce       	rjmp	.-1000   	; 0x5dd6 <updateMenu+0x48>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    61be:	8d 30       	cpi	r24, 0x0D	; 13
    61c0:	09 f4       	brne	.+2      	; 0x61c4 <updateMenu+0x436>
    61c2:	a3 c1       	rjmp	.+838    	; 0x650a <updateMenu+0x77c>
    61c4:	8d 30       	cpi	r24, 0x0D	; 13
    61c6:	08 f4       	brcc	.+2      	; 0x61ca <updateMenu+0x43c>
    61c8:	11 c1       	rjmp	.+546    	; 0x63ec <updateMenu+0x65e>
    61ca:	8e 30       	cpi	r24, 0x0E	; 14
    61cc:	09 f0       	breq	.+2      	; 0x61d0 <updateMenu+0x442>
    61ce:	03 ce       	rjmp	.-1018   	; 0x5dd6 <updateMenu+0x48>
          OLEDsetCursor(0, 0);
          OLEDprintCC("saved");
          break;

        case MENU_LOAD_CONFIG:   /* load last configuration */
          loadConfigFromEEPROM();
    61d0:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <loadConfigFromEEPROM>
          updateIICvalues();
    61d4:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <updateIICvalues>
          //lcd_clear();
          //lcd_string("loaded");
          OLEDclear();
    61d8:	0e 94 d5 3a 	call	0x75aa	; 0x75aa <OLEDclear>
          OLEDsetCursor(0, 0);
    61dc:	80 e0       	ldi	r24, 0x00	; 0
    61de:	60 e0       	ldi	r22, 0x00	; 0
    61e0:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
          OLEDprintCC("loaded");
    61e4:	82 ec       	ldi	r24, 0xC2	; 194
    61e6:	92 e0       	ldi	r25, 0x02	; 2
    61e8:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
    61ec:	f4 cd       	rjmp	.-1048   	; 0x5dd6 <updateMenu+0x48>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    61ee:	85 30       	cpi	r24, 0x05	; 5
    61f0:	09 f4       	brne	.+2      	; 0x61f4 <updateMenu+0x466>
    61f2:	32 c2       	rjmp	.+1124   	; 0x6658 <updateMenu+0x8ca>
    61f4:	86 30       	cpi	r24, 0x06	; 6
    61f6:	08 f4       	brcc	.+2      	; 0x61fa <updateMenu+0x46c>
    61f8:	95 c1       	rjmp	.+810    	; 0x6524 <updateMenu+0x796>

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                defineOpticalZeroPosition(i, rotEncVal*100);
    61fa:	61 2f       	mov	r22, r17
    61fc:	77 27       	eor	r23, r23
    61fe:	67 fd       	sbrc	r22, 7
    6200:	70 95       	com	r23
    6202:	84 e6       	ldi	r24, 0x64	; 100
    6204:	90 e0       	ldi	r25, 0x00	; 0
    6206:	68 9f       	mul	r22, r24
    6208:	d0 01       	movw	r26, r0
    620a:	69 9f       	mul	r22, r25
    620c:	b0 0d       	add	r27, r0
    620e:	78 9f       	mul	r23, r24
    6210:	b0 0d       	add	r27, r0
    6212:	11 24       	eor	r1, r1
    6214:	40 e0       	ldi	r20, 0x00	; 0
    6216:	50 e0       	ldi	r21, 0x00	; 0
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6218:	80 91 e5 02 	lds	r24, 0x02E5
    621c:	90 e0       	ldi	r25, 0x00	; 0
    621e:	04 2e       	mov	r0, r20
    6220:	02 c0       	rjmp	.+4      	; 0x6226 <updateMenu+0x498>
    6222:	95 95       	asr	r25
    6224:	87 95       	ror	r24
    6226:	0a 94       	dec	r0
    6228:	e2 f7       	brpl	.-8      	; 0x6222 <updateMenu+0x494>
    622a:	80 ff       	sbrs	r24, 0
    622c:	51 c0       	rjmp	.+162    	; 0x62d0 <updateMenu+0x542>
              if(menu.fastMovingMode){
    622e:	80 91 e2 02 	lds	r24, 0x02E2
    6232:	88 23       	and	r24, r24
    6234:	09 f4       	brne	.+2      	; 0x6238 <updateMenu+0x4aa>
    6236:	96 c3       	rjmp	.+1836   	; 0x6964 <updateMenu+0xbd6>
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
    6238:	fa 01       	movw	r30, r20
    623a:	ee 0f       	add	r30, r30
    623c:	ff 1f       	adc	r31, r31
    623e:	ee 0f       	add	r30, r30
    6240:	ff 1f       	adc	r31, r31
    6242:	ee 0f       	add	r30, r30
    6244:	ff 1f       	adc	r31, r31
    6246:	cf 01       	movw	r24, r30
    6248:	88 0f       	add	r24, r24
    624a:	99 1f       	adc	r25, r25
    624c:	88 0f       	add	r24, r24
    624e:	99 1f       	adc	r25, r25
    6250:	e8 0f       	add	r30, r24
    6252:	f9 1f       	adc	r31, r25
    6254:	e0 51       	subi	r30, 0x10	; 16
    6256:	fc 4f       	sbci	r31, 0xFC	; 252
    6258:	20 81       	ld	r18, Z
    625a:	31 81       	ldd	r19, Z+1	; 0x01
    625c:	2a 0f       	add	r18, r26
    625e:	3b 1f       	adc	r19, r27
    6260:	fa 01       	movw	r30, r20
    6262:	ee 0f       	add	r30, r30
    6264:	ff 1f       	adc	r31, r31
    6266:	ee 0f       	add	r30, r30
    6268:	ff 1f       	adc	r31, r31
    626a:	cf 01       	movw	r24, r30
    626c:	88 0f       	add	r24, r24
    626e:	99 1f       	adc	r25, r25
    6270:	88 0f       	add	r24, r24
    6272:	99 1f       	adc	r25, r25
    6274:	e8 0f       	add	r30, r24
    6276:	f9 1f       	adc	r31, r25
    6278:	ee 0f       	add	r30, r30
    627a:	ff 1f       	adc	r31, r31
    627c:	ee 50       	subi	r30, 0x0E	; 14
    627e:	fc 4f       	sbci	r31, 0xFC	; 252
    6280:	31 83       	std	Z+1, r19	; 0x01
    6282:	20 83       	st	Z, r18
  motor[i].opticalZeroPosition = motor[i].desiredPosition;
    6284:	fa 01       	movw	r30, r20
    6286:	ee 0f       	add	r30, r30
    6288:	ff 1f       	adc	r31, r31
    628a:	ee 0f       	add	r30, r30
    628c:	ff 1f       	adc	r31, r31
    628e:	cf 01       	movw	r24, r30
    6290:	88 0f       	add	r24, r24
    6292:	99 1f       	adc	r25, r25
    6294:	88 0f       	add	r24, r24
    6296:	99 1f       	adc	r25, r25
    6298:	e8 0f       	add	r30, r24
    629a:	f9 1f       	adc	r31, r25
    629c:	ee 0f       	add	r30, r30
    629e:	ff 1f       	adc	r31, r31
    62a0:	ee 50       	subi	r30, 0x0E	; 14
    62a2:	fc 4f       	sbci	r31, 0xFC	; 252
    62a4:	20 81       	ld	r18, Z
    62a6:	31 81       	ldd	r19, Z+1	; 0x01
    62a8:	ca 01       	movw	r24, r20
    62aa:	fa 01       	movw	r30, r20
    62ac:	ee 0f       	add	r30, r30
    62ae:	ff 1f       	adc	r31, r31
    62b0:	ee 0f       	add	r30, r30
    62b2:	ff 1f       	adc	r31, r31
    62b4:	ee 0f       	add	r30, r30
    62b6:	ff 1f       	adc	r31, r31
    62b8:	88 0f       	add	r24, r24
    62ba:	99 1f       	adc	r25, r25
    62bc:	e8 0f       	add	r30, r24
    62be:	f9 1f       	adc	r31, r25
    62c0:	ee 0f       	add	r30, r30
    62c2:	ff 1f       	adc	r31, r31
    62c4:	ee 0f       	add	r30, r30
    62c6:	ff 1f       	adc	r31, r31
    62c8:	ec 50       	subi	r30, 0x0C	; 12
    62ca:	fc 4f       	sbci	r31, 0xFC	; 252
    62cc:	31 83       	std	Z+1, r19	; 0x01
    62ce:	20 83       	st	Z, r18
    62d0:	4f 5f       	subi	r20, 0xFF	; 255
    62d2:	5f 4f       	sbci	r21, 0xFF	; 255
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    62d4:	44 30       	cpi	r20, 0x04	; 4
    62d6:	51 05       	cpc	r21, r1
    62d8:	09 f0       	breq	.+2      	; 0x62dc <updateMenu+0x54e>
    62da:	9e cf       	rjmp	.-196    	; 0x6218 <updateMenu+0x48a>
    62dc:	7c cd       	rjmp	.-1288   	; 0x5dd6 <updateMenu+0x48>
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motorZeroRun(i);
    62de:	8c 2f       	mov	r24, r28
    62e0:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <motorZeroRun>
              menu.selectedMotor ^= (1 << i);
    62e4:	20 91 e5 02 	lds	r18, 0x02E5
    62e8:	c6 01       	movw	r24, r12
    62ea:	0c 2e       	mov	r0, r28
    62ec:	02 c0       	rjmp	.+4      	; 0x62f2 <updateMenu+0x564>
    62ee:	88 0f       	add	r24, r24
    62f0:	99 1f       	adc	r25, r25
    62f2:	0a 94       	dec	r0
    62f4:	e2 f7       	brpl	.-8      	; 0x62ee <updateMenu+0x560>
    62f6:	28 27       	eor	r18, r24
    62f8:	20 93 e5 02 	sts	0x02E5, r18
              updateDisplay();
    62fc:	0e 94 37 2d 	call	0x5a6e	; 0x5a6e <updateDisplay>
              updateMotorButtonLEDs();
    6300:	0e 94 7d 07 	call	0xefa	; 0xefa <updateMotorButtonLEDs>
    6304:	7f ce       	rjmp	.-770    	; 0x6004 <updateMenu+0x276>
      switch(state){
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6306:	40 e0       	ldi	r20, 0x00	; 0
    6308:	50 e0       	ldi	r21, 0x00	; 0
        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepUnit += rotEncVal;
              if(motor[i].stepUnit < 0){
                motor[i].stepUnit = 2;
    630a:	72 e0       	ldi	r23, 0x02	; 2
          }
          break;

        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    630c:	80 91 e5 02 	lds	r24, 0x02E5
    6310:	34 2f       	mov	r19, r20
    6312:	65 2f       	mov	r22, r21
    6314:	90 e0       	ldi	r25, 0x00	; 0
    6316:	04 2e       	mov	r0, r20
    6318:	02 c0       	rjmp	.+4      	; 0x631e <updateMenu+0x590>
    631a:	95 95       	asr	r25
    631c:	87 95       	ror	r24
    631e:	0a 94       	dec	r0
    6320:	e2 f7       	brpl	.-8      	; 0x631a <updateMenu+0x58c>
    6322:	80 ff       	sbrs	r24, 0
    6324:	5c c0       	rjmp	.+184    	; 0x63de <updateMenu+0x650>
              motor[i].stepUnit += rotEncVal;
    6326:	fa 01       	movw	r30, r20
    6328:	ee 0f       	add	r30, r30
    632a:	ff 1f       	adc	r31, r31
    632c:	ee 0f       	add	r30, r30
    632e:	ff 1f       	adc	r31, r31
    6330:	ee 0f       	add	r30, r30
    6332:	ff 1f       	adc	r31, r31
    6334:	cf 01       	movw	r24, r30
    6336:	88 0f       	add	r24, r24
    6338:	99 1f       	adc	r25, r25
    633a:	88 0f       	add	r24, r24
    633c:	99 1f       	adc	r25, r25
    633e:	e8 0f       	add	r30, r24
    6340:	f9 1f       	adc	r31, r25
    6342:	e0 51       	subi	r30, 0x10	; 16
    6344:	fc 4f       	sbci	r31, 0xFC	; 252
    6346:	21 8d       	ldd	r18, Z+25	; 0x19
    6348:	21 0f       	add	r18, r17
    634a:	fa 01       	movw	r30, r20
    634c:	ee 0f       	add	r30, r30
    634e:	ff 1f       	adc	r31, r31
    6350:	ee 0f       	add	r30, r30
    6352:	ff 1f       	adc	r31, r31
    6354:	ee 0f       	add	r30, r30
    6356:	ff 1f       	adc	r31, r31
    6358:	cf 01       	movw	r24, r30
    635a:	88 0f       	add	r24, r24
    635c:	99 1f       	adc	r25, r25
    635e:	88 0f       	add	r24, r24
    6360:	99 1f       	adc	r25, r25
    6362:	e8 0f       	add	r30, r24
    6364:	f9 1f       	adc	r31, r25
    6366:	e0 51       	subi	r30, 0x10	; 16
    6368:	fc 4f       	sbci	r31, 0xFC	; 252
    636a:	21 8f       	std	Z+25, r18	; 0x19
              if(motor[i].stepUnit < 0){
    636c:	fa 01       	movw	r30, r20
    636e:	ee 0f       	add	r30, r30
    6370:	ff 1f       	adc	r31, r31
    6372:	ee 0f       	add	r30, r30
    6374:	ff 1f       	adc	r31, r31
    6376:	ee 0f       	add	r30, r30
    6378:	ff 1f       	adc	r31, r31
    637a:	cf 01       	movw	r24, r30
    637c:	88 0f       	add	r24, r24
    637e:	99 1f       	adc	r25, r25
    6380:	88 0f       	add	r24, r24
    6382:	99 1f       	adc	r25, r25
    6384:	e8 0f       	add	r30, r24
    6386:	f9 1f       	adc	r31, r25
    6388:	e0 51       	subi	r30, 0x10	; 16
    638a:	fc 4f       	sbci	r31, 0xFC	; 252
    638c:	81 8d       	ldd	r24, Z+25	; 0x19
    638e:	87 fd       	sbrc	r24, 7
    6390:	17 c3       	rjmp	.+1582   	; 0x69c0 <updateMenu+0xc32>
                motor[i].stepUnit = 2;
              }
              if(motor[i].stepUnit > 2){
    6392:	e3 2f       	mov	r30, r19
    6394:	f6 2f       	mov	r31, r22
    6396:	ee 0f       	add	r30, r30
    6398:	ff 1f       	adc	r31, r31
    639a:	ee 0f       	add	r30, r30
    639c:	ff 1f       	adc	r31, r31
    639e:	ee 0f       	add	r30, r30
    63a0:	ff 1f       	adc	r31, r31
    63a2:	cf 01       	movw	r24, r30
    63a4:	88 0f       	add	r24, r24
    63a6:	99 1f       	adc	r25, r25
    63a8:	88 0f       	add	r24, r24
    63aa:	99 1f       	adc	r25, r25
    63ac:	e8 0f       	add	r30, r24
    63ae:	f9 1f       	adc	r31, r25
    63b0:	e0 51       	subi	r30, 0x10	; 16
    63b2:	fc 4f       	sbci	r31, 0xFC	; 252
    63b4:	81 8d       	ldd	r24, Z+25	; 0x19
    63b6:	83 30       	cpi	r24, 0x03	; 3
    63b8:	94 f0       	brlt	.+36     	; 0x63de <updateMenu+0x650>
                motor[i].stepUnit = 0;
    63ba:	e3 2f       	mov	r30, r19
    63bc:	f6 2f       	mov	r31, r22
    63be:	ee 0f       	add	r30, r30
    63c0:	ff 1f       	adc	r31, r31
    63c2:	ee 0f       	add	r30, r30
    63c4:	ff 1f       	adc	r31, r31
    63c6:	ee 0f       	add	r30, r30
    63c8:	ff 1f       	adc	r31, r31
    63ca:	cf 01       	movw	r24, r30
    63cc:	88 0f       	add	r24, r24
    63ce:	99 1f       	adc	r25, r25
    63d0:	88 0f       	add	r24, r24
    63d2:	99 1f       	adc	r25, r25
    63d4:	e8 0f       	add	r30, r24
    63d6:	f9 1f       	adc	r31, r25
    63d8:	e0 51       	subi	r30, 0x10	; 16
    63da:	fc 4f       	sbci	r31, 0xFC	; 252
    63dc:	11 8e       	std	Z+25, r1	; 0x19
    63de:	4f 5f       	subi	r20, 0xFF	; 255
    63e0:	5f 4f       	sbci	r21, 0xFF	; 255
            }
          }
          break;

        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    63e2:	44 30       	cpi	r20, 0x04	; 4
    63e4:	51 05       	cpc	r21, r1
    63e6:	09 f0       	breq	.+2      	; 0x63ea <updateMenu+0x65c>
    63e8:	91 cf       	rjmp	.-222    	; 0x630c <updateMenu+0x57e>
    63ea:	f5 cc       	rjmp	.-1558   	; 0x5dd6 <updateMenu+0x48>
    63ec:	40 e0       	ldi	r20, 0x00	; 0
    63ee:	50 e0       	ldi	r21, 0x00	; 0
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].waitBetweenSteps += rotEncVal;
    63f0:	61 2f       	mov	r22, r17
    63f2:	77 27       	eor	r23, r23
    63f4:	67 fd       	sbrc	r22, 7
    63f6:	70 95       	com	r23
              if(motor[i].waitBetweenSteps < 1){
                /* wait time is at least 1 ms */
                motor[i].waitBetweenSteps = 1;
    63f8:	c1 e0       	ldi	r28, 0x01	; 1
    63fa:	d0 e0       	ldi	r29, 0x00	; 0
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    63fc:	80 91 e5 02 	lds	r24, 0x02E5
    6400:	da 01       	movw	r26, r20
    6402:	90 e0       	ldi	r25, 0x00	; 0
    6404:	04 2e       	mov	r0, r20
    6406:	02 c0       	rjmp	.+4      	; 0x640c <updateMenu+0x67e>
    6408:	95 95       	asr	r25
    640a:	87 95       	ror	r24
    640c:	0a 94       	dec	r0
    640e:	e2 f7       	brpl	.-8      	; 0x6408 <updateMenu+0x67a>
    6410:	80 ff       	sbrs	r24, 0
    6412:	74 c0       	rjmp	.+232    	; 0x64fc <updateMenu+0x76e>
              motor[i].waitBetweenSteps += rotEncVal;
    6414:	fa 01       	movw	r30, r20
    6416:	ee 0f       	add	r30, r30
    6418:	ff 1f       	adc	r31, r31
    641a:	ee 0f       	add	r30, r30
    641c:	ff 1f       	adc	r31, r31
    641e:	ee 0f       	add	r30, r30
    6420:	ff 1f       	adc	r31, r31
    6422:	cf 01       	movw	r24, r30
    6424:	88 0f       	add	r24, r24
    6426:	99 1f       	adc	r25, r25
    6428:	88 0f       	add	r24, r24
    642a:	99 1f       	adc	r25, r25
    642c:	e8 0f       	add	r30, r24
    642e:	f9 1f       	adc	r31, r25
    6430:	e0 51       	subi	r30, 0x10	; 16
    6432:	fc 4f       	sbci	r31, 0xFC	; 252
    6434:	26 8d       	ldd	r18, Z+30	; 0x1e
    6436:	37 8d       	ldd	r19, Z+31	; 0x1f
    6438:	26 0f       	add	r18, r22
    643a:	37 1f       	adc	r19, r23
    643c:	fa 01       	movw	r30, r20
    643e:	ee 0f       	add	r30, r30
    6440:	ff 1f       	adc	r31, r31
    6442:	ee 0f       	add	r30, r30
    6444:	ff 1f       	adc	r31, r31
    6446:	ee 0f       	add	r30, r30
    6448:	ff 1f       	adc	r31, r31
    644a:	cf 01       	movw	r24, r30
    644c:	88 0f       	add	r24, r24
    644e:	99 1f       	adc	r25, r25
    6450:	88 0f       	add	r24, r24
    6452:	99 1f       	adc	r25, r25
    6454:	e8 0f       	add	r30, r24
    6456:	f9 1f       	adc	r31, r25
    6458:	e0 51       	subi	r30, 0x10	; 16
    645a:	fc 4f       	sbci	r31, 0xFC	; 252
    645c:	37 8f       	std	Z+31, r19	; 0x1f
    645e:	26 8f       	std	Z+30, r18	; 0x1e
              if(motor[i].waitBetweenSteps < 1){
    6460:	fa 01       	movw	r30, r20
    6462:	ee 0f       	add	r30, r30
    6464:	ff 1f       	adc	r31, r31
    6466:	ee 0f       	add	r30, r30
    6468:	ff 1f       	adc	r31, r31
    646a:	ee 0f       	add	r30, r30
    646c:	ff 1f       	adc	r31, r31
    646e:	cf 01       	movw	r24, r30
    6470:	88 0f       	add	r24, r24
    6472:	99 1f       	adc	r25, r25
    6474:	88 0f       	add	r24, r24
    6476:	99 1f       	adc	r25, r25
    6478:	e8 0f       	add	r30, r24
    647a:	f9 1f       	adc	r31, r25
    647c:	e0 51       	subi	r30, 0x10	; 16
    647e:	fc 4f       	sbci	r31, 0xFC	; 252
    6480:	86 8d       	ldd	r24, Z+30	; 0x1e
    6482:	97 8d       	ldd	r25, Z+31	; 0x1f
    6484:	89 2b       	or	r24, r25
    6486:	91 f4       	brne	.+36     	; 0x64ac <updateMenu+0x71e>
                /* wait time is at least 1 ms */
                motor[i].waitBetweenSteps = 1;
    6488:	fa 01       	movw	r30, r20
    648a:	ee 0f       	add	r30, r30
    648c:	ff 1f       	adc	r31, r31
    648e:	ee 0f       	add	r30, r30
    6490:	ff 1f       	adc	r31, r31
    6492:	ee 0f       	add	r30, r30
    6494:	ff 1f       	adc	r31, r31
    6496:	cf 01       	movw	r24, r30
    6498:	88 0f       	add	r24, r24
    649a:	99 1f       	adc	r25, r25
    649c:	88 0f       	add	r24, r24
    649e:	99 1f       	adc	r25, r25
    64a0:	e8 0f       	add	r30, r24
    64a2:	f9 1f       	adc	r31, r25
    64a4:	e0 51       	subi	r30, 0x10	; 16
    64a6:	fc 4f       	sbci	r31, 0xFC	; 252
    64a8:	d7 8f       	std	Z+31, r29	; 0x1f
    64aa:	c6 8f       	std	Z+30, r28	; 0x1e
              }
              motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    64ac:	fd 01       	movw	r30, r26
    64ae:	ee 0f       	add	r30, r30
    64b0:	ff 1f       	adc	r31, r31
    64b2:	ee 0f       	add	r30, r30
    64b4:	ff 1f       	adc	r31, r31
    64b6:	ee 0f       	add	r30, r30
    64b8:	ff 1f       	adc	r31, r31
    64ba:	cf 01       	movw	r24, r30
    64bc:	88 0f       	add	r24, r24
    64be:	99 1f       	adc	r25, r25
    64c0:	88 0f       	add	r24, r24
    64c2:	99 1f       	adc	r25, r25
    64c4:	e8 0f       	add	r30, r24
    64c6:	f9 1f       	adc	r31, r25
    64c8:	e0 51       	subi	r30, 0x10	; 16
    64ca:	fc 4f       	sbci	r31, 0xFC	; 252
    64cc:	26 8d       	ldd	r18, Z+30	; 0x1e
    64ce:	37 8d       	ldd	r19, Z+31	; 0x1f
    64d0:	22 0f       	add	r18, r18
    64d2:	33 1f       	adc	r19, r19
    64d4:	21 50       	subi	r18, 0x01	; 1
    64d6:	30 40       	sbci	r19, 0x00	; 0
    64d8:	fd 01       	movw	r30, r26
    64da:	ee 0f       	add	r30, r30
    64dc:	ff 1f       	adc	r31, r31
    64de:	ee 0f       	add	r30, r30
    64e0:	ff 1f       	adc	r31, r31
    64e2:	ee 0f       	add	r30, r30
    64e4:	ff 1f       	adc	r31, r31
    64e6:	cf 01       	movw	r24, r30
    64e8:	88 0f       	add	r24, r24
    64ea:	99 1f       	adc	r25, r25
    64ec:	88 0f       	add	r24, r24
    64ee:	99 1f       	adc	r25, r25
    64f0:	e8 0f       	add	r30, r24
    64f2:	f9 1f       	adc	r31, r25
    64f4:	e0 51       	subi	r30, 0x10	; 16
    64f6:	fc 4f       	sbci	r31, 0xFC	; 252
    64f8:	31 a3       	std	Z+33, r19	; 0x21
    64fa:	20 a3       	std	Z+32, r18	; 0x20
    64fc:	4f 5f       	subi	r20, 0xFF	; 255
    64fe:	5f 4f       	sbci	r21, 0xFF	; 255
            }
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6500:	44 30       	cpi	r20, 0x04	; 4
    6502:	51 05       	cpc	r21, r1
    6504:	09 f0       	breq	.+2      	; 0x6508 <updateMenu+0x77a>
    6506:	7a cf       	rjmp	.-268    	; 0x63fc <updateMenu+0x66e>
    6508:	66 cc       	rjmp	.-1844   	; 0x5dd6 <updateMenu+0x48>
            }
          }
          break;

        case MENU_SAVE_CONFIG:   /* save current configuration */
          saveConfigToEEPROM();
    650a:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <saveConfigToEEPROM>
          //lcd_clear();
          //lcd_string("saved");
          OLEDclear();
    650e:	0e 94 d5 3a 	call	0x75aa	; 0x75aa <OLEDclear>
          OLEDsetCursor(0, 0);
    6512:	80 e0       	ldi	r24, 0x00	; 0
    6514:	60 e0       	ldi	r22, 0x00	; 0
    6516:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
          OLEDprintCC("saved");
    651a:	8c eb       	ldi	r24, 0xBC	; 188
    651c:	92 e0       	ldi	r25, 0x02	; 2
    651e:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
    6522:	59 cc       	rjmp	.-1870   	; 0x5dd6 <updateMenu+0x48>
            }
          }
          break;

        case MENU_RUN_PROGRAM:  /* run an internal program defined by CLI */
          if(rotEncVal > 0){
    6524:	11 16       	cp	r1, r17
    6526:	0c f0       	brlt	.+2      	; 0x652a <updateMenu+0x79c>
    6528:	1b c3       	rjmp	.+1590   	; 0x6b60 <updateMenu+0xdd2>
            do{
              /* find the next active program step */
              menu.currentProgramStep += 1;
    652a:	80 91 e3 02 	lds	r24, 0x02E3
    652e:	8f 5f       	subi	r24, 0xFF	; 255
    6530:	80 93 e3 02 	sts	0x02E3, r24
              if(menu.currentProgramStep >= MAX_PROGRAM_STEPS){
    6534:	80 91 e3 02 	lds	r24, 0x02E3
    6538:	80 31       	cpi	r24, 0x10	; 16
    653a:	14 f0       	brlt	.+4      	; 0x6540 <updateMenu+0x7b2>
                menu.currentProgramStep = 0;
    653c:	10 92 e3 02 	sts	0x02E3, r1
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
    6540:	80 91 e3 02 	lds	r24, 0x02E3
    6544:	99 27       	eor	r25, r25
    6546:	87 fd       	sbrc	r24, 7
    6548:	90 95       	com	r25
    654a:	fc 01       	movw	r30, r24
    654c:	ee 0f       	add	r30, r30
    654e:	ff 1f       	adc	r31, r31
    6550:	ee 0f       	add	r30, r30
    6552:	ff 1f       	adc	r31, r31
    6554:	ee 0f       	add	r30, r30
    6556:	ff 1f       	adc	r31, r31
    6558:	88 0f       	add	r24, r24
    655a:	99 1f       	adc	r25, r25
    655c:	e8 0f       	add	r30, r24
    655e:	f9 1f       	adc	r31, r25
    6560:	ed 50       	subi	r30, 0x0D	; 13
    6562:	fd 4f       	sbci	r31, 0xFD	; 253
    6564:	80 81       	ld	r24, Z
    6566:	88 23       	and	r24, r24
    6568:	01 f3       	breq	.-64     	; 0x652a <updateMenu+0x79c>
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
          }

          if(programList[menu.currentProgramStep].absRel == PROG_ABSOLUTE_MOVEMENT){
    656a:	80 91 e3 02 	lds	r24, 0x02E3
    656e:	99 27       	eor	r25, r25
    6570:	87 fd       	sbrc	r24, 7
    6572:	90 95       	com	r25
    6574:	fc 01       	movw	r30, r24
    6576:	ee 0f       	add	r30, r30
    6578:	ff 1f       	adc	r31, r31
    657a:	ee 0f       	add	r30, r30
    657c:	ff 1f       	adc	r31, r31
    657e:	ee 0f       	add	r30, r30
    6580:	ff 1f       	adc	r31, r31
    6582:	88 0f       	add	r24, r24
    6584:	99 1f       	adc	r25, r25
    6586:	e8 0f       	add	r30, r24
    6588:	f9 1f       	adc	r31, r25
    658a:	ed 50       	subi	r30, 0x0D	; 13
    658c:	fd 4f       	sbci	r31, 0xFD	; 253
    658e:	81 85       	ldd	r24, Z+9	; 0x09
    6590:	88 23       	and	r24, r24
    6592:	09 f0       	breq	.+2      	; 0x6596 <updateMenu+0x808>
    6594:	3c c2       	rjmp	.+1144   	; 0x6a0e <updateMenu+0xc80>
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
    6596:	80 91 e3 02 	lds	r24, 0x02E3
    659a:	99 27       	eor	r25, r25
    659c:	87 fd       	sbrc	r24, 7
    659e:	90 95       	com	r25
    65a0:	fc 01       	movw	r30, r24
    65a2:	ee 0f       	add	r30, r30
    65a4:	ff 1f       	adc	r31, r31
    65a6:	ee 0f       	add	r30, r30
    65a8:	ff 1f       	adc	r31, r31
    65aa:	ee 0f       	add	r30, r30
    65ac:	ff 1f       	adc	r31, r31
    65ae:	88 0f       	add	r24, r24
    65b0:	99 1f       	adc	r25, r25
    65b2:	e8 0f       	add	r30, r24
    65b4:	f9 1f       	adc	r31, r25
    65b6:	ed 50       	subi	r30, 0x0D	; 13
    65b8:	fd 4f       	sbci	r31, 0xFD	; 253
    65ba:	81 81       	ldd	r24, Z+1	; 0x01
    65bc:	92 81       	ldd	r25, Z+2	; 0x02
    65be:	90 93 f3 03 	sts	0x03F3, r25
    65c2:	80 93 f2 03 	sts	0x03F2, r24
    65c6:	80 91 e3 02 	lds	r24, 0x02E3
    65ca:	99 27       	eor	r25, r25
    65cc:	87 fd       	sbrc	r24, 7
    65ce:	90 95       	com	r25
    65d0:	fc 01       	movw	r30, r24
    65d2:	ee 0f       	add	r30, r30
    65d4:	ff 1f       	adc	r31, r31
    65d6:	ee 0f       	add	r30, r30
    65d8:	ff 1f       	adc	r31, r31
    65da:	ee 0f       	add	r30, r30
    65dc:	ff 1f       	adc	r31, r31
    65de:	88 0f       	add	r24, r24
    65e0:	99 1f       	adc	r25, r25
    65e2:	e8 0f       	add	r30, r24
    65e4:	f9 1f       	adc	r31, r25
    65e6:	ed 50       	subi	r30, 0x0D	; 13
    65e8:	fd 4f       	sbci	r31, 0xFD	; 253
    65ea:	83 81       	ldd	r24, Z+3	; 0x03
    65ec:	94 81       	ldd	r25, Z+4	; 0x04
    65ee:	90 93 1b 04 	sts	0x041B, r25
    65f2:	80 93 1a 04 	sts	0x041A, r24
    65f6:	80 91 e3 02 	lds	r24, 0x02E3
    65fa:	99 27       	eor	r25, r25
    65fc:	87 fd       	sbrc	r24, 7
    65fe:	90 95       	com	r25
    6600:	fc 01       	movw	r30, r24
    6602:	ee 0f       	add	r30, r30
    6604:	ff 1f       	adc	r31, r31
    6606:	ee 0f       	add	r30, r30
    6608:	ff 1f       	adc	r31, r31
    660a:	ee 0f       	add	r30, r30
    660c:	ff 1f       	adc	r31, r31
    660e:	88 0f       	add	r24, r24
    6610:	99 1f       	adc	r25, r25
    6612:	e8 0f       	add	r30, r24
    6614:	f9 1f       	adc	r31, r25
    6616:	ed 50       	subi	r30, 0x0D	; 13
    6618:	fd 4f       	sbci	r31, 0xFD	; 253
    661a:	85 81       	ldd	r24, Z+5	; 0x05
    661c:	96 81       	ldd	r25, Z+6	; 0x06
    661e:	90 93 43 04 	sts	0x0443, r25
    6622:	80 93 42 04 	sts	0x0442, r24
    6626:	80 91 e3 02 	lds	r24, 0x02E3
    662a:	99 27       	eor	r25, r25
    662c:	87 fd       	sbrc	r24, 7
    662e:	90 95       	com	r25
    6630:	fc 01       	movw	r30, r24
    6632:	ee 0f       	add	r30, r30
    6634:	ff 1f       	adc	r31, r31
    6636:	ee 0f       	add	r30, r30
    6638:	ff 1f       	adc	r31, r31
    663a:	ee 0f       	add	r30, r30
    663c:	ff 1f       	adc	r31, r31
    663e:	88 0f       	add	r24, r24
    6640:	99 1f       	adc	r25, r25
    6642:	e8 0f       	add	r30, r24
    6644:	f9 1f       	adc	r31, r25
    6646:	ed 50       	subi	r30, 0x0D	; 13
    6648:	fd 4f       	sbci	r31, 0xFD	; 253
    664a:	87 81       	ldd	r24, Z+7	; 0x07
    664c:	90 85       	ldd	r25, Z+8	; 0x08
    664e:	90 93 6b 04 	sts	0x046B, r25
    6652:	80 93 6a 04 	sts	0x046A, r24
    6656:	bf cb       	rjmp	.-2178   	; 0x5dd6 <updateMenu+0x48>
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6658:	c0 e0       	ldi	r28, 0x00	; 0
    665a:	d0 e0       	ldi	r29, 0x00	; 0
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
              if(motor[i].angularVelocity < 0){
                motor[i].angularVelocity = 2;
    665c:	02 e0       	ldi	r16, 0x02	; 2
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    665e:	4c 2f       	mov	r20, r28
          }
          break;

        case MENU_CONST_ANGULAR_SPEED:  /* enter constant moving mode */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6660:	80 91 e5 02 	lds	r24, 0x02E5
    6664:	90 e0       	ldi	r25, 0x00	; 0
    6666:	0c 2e       	mov	r0, r28
    6668:	02 c0       	rjmp	.+4      	; 0x666e <updateMenu+0x8e0>
    666a:	95 95       	asr	r25
    666c:	87 95       	ror	r24
    666e:	0a 94       	dec	r0
    6670:	e2 f7       	brpl	.-8      	; 0x666a <updateMenu+0x8dc>
    6672:	80 ff       	sbrs	r24, 0
    6674:	3d c0       	rjmp	.+122    	; 0x66f0 <updateMenu+0x962>
              if(forbiddenZone[i].active){
    6676:	fe 01       	movw	r30, r28
    6678:	ee 0f       	add	r30, r30
    667a:	ff 1f       	adc	r31, r31
    667c:	ee 0f       	add	r30, r30
    667e:	ff 1f       	adc	r31, r31
    6680:	ec 0f       	add	r30, r28
    6682:	fd 1f       	adc	r31, r29
    6684:	ed 52       	subi	r30, 0x2D	; 45
    6686:	fc 4f       	sbci	r31, 0xFC	; 252
    6688:	84 81       	ldd	r24, Z+4	; 0x04
    668a:	88 23       	and	r24, r24
    668c:	09 f0       	breq	.+2      	; 0x6690 <updateMenu+0x902>
    668e:	a3 cb       	rjmp	.-2234   	; 0x5dd6 <updateMenu+0x48>
                /* const angular speed not allowed if
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
    6690:	9e 01       	movw	r18, r28
    6692:	22 0f       	add	r18, r18
    6694:	33 1f       	adc	r19, r19
    6696:	22 0f       	add	r18, r18
    6698:	33 1f       	adc	r19, r19
    669a:	22 0f       	add	r18, r18
    669c:	33 1f       	adc	r19, r19
    669e:	f9 01       	movw	r30, r18
    66a0:	ee 0f       	add	r30, r30
    66a2:	ff 1f       	adc	r31, r31
    66a4:	ee 0f       	add	r30, r30
    66a6:	ff 1f       	adc	r31, r31
    66a8:	e2 0f       	add	r30, r18
    66aa:	f3 1f       	adc	r31, r19
    66ac:	e0 51       	subi	r30, 0x10	; 16
    66ae:	fc 4f       	sbci	r31, 0xFC	; 252
    66b0:	82 a1       	ldd	r24, Z+34	; 0x22
    66b2:	81 0f       	add	r24, r17
    66b4:	82 a3       	std	Z+34, r24	; 0x22
              if(motor[i].angularVelocity < 0){
    66b6:	82 a1       	ldd	r24, Z+34	; 0x22
    66b8:	87 fd       	sbrc	r24, 7
    66ba:	a7 c1       	rjmp	.+846    	; 0x6a0a <updateMenu+0xc7c>
                motor[i].angularVelocity = 2;
              }
              if(motor[i].angularVelocity > 2){
    66bc:	f9 01       	movw	r30, r18
    66be:	ee 0f       	add	r30, r30
    66c0:	ff 1f       	adc	r31, r31
    66c2:	ee 0f       	add	r30, r30
    66c4:	ff 1f       	adc	r31, r31
    66c6:	e2 0f       	add	r30, r18
    66c8:	f3 1f       	adc	r31, r19
    66ca:	e0 51       	subi	r30, 0x10	; 16
    66cc:	fc 4f       	sbci	r31, 0xFC	; 252
    66ce:	82 a1       	ldd	r24, Z+34	; 0x22
    66d0:	83 30       	cpi	r24, 0x03	; 3
    66d2:	0c f0       	brlt	.+2      	; 0x66d6 <updateMenu+0x948>
                motor[i].angularVelocity = 0;
    66d4:	12 a2       	std	Z+34, r1	; 0x22
              }
              setConstSpeed(i, motor[i].angularVelocity);
    66d6:	f9 01       	movw	r30, r18
    66d8:	ee 0f       	add	r30, r30
    66da:	ff 1f       	adc	r31, r31
    66dc:	ee 0f       	add	r30, r30
    66de:	ff 1f       	adc	r31, r31
    66e0:	e2 0f       	add	r30, r18
    66e2:	f3 1f       	adc	r31, r19
    66e4:	e0 51       	subi	r30, 0x10	; 16
    66e6:	fc 4f       	sbci	r31, 0xFC	; 252
    66e8:	62 a1       	ldd	r22, Z+34	; 0x22
    66ea:	84 2f       	mov	r24, r20
    66ec:	0e 94 a8 08 	call	0x1150	; 0x1150 <setConstSpeed>
    66f0:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_CONST_ANGULAR_SPEED:  /* enter constant moving mode */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    66f2:	c4 30       	cpi	r28, 0x04	; 4
    66f4:	d1 05       	cpc	r29, r1
    66f6:	09 f0       	breq	.+2      	; 0x66fa <updateMenu+0x96c>
    66f8:	b2 cf       	rjmp	.-156    	; 0x665e <updateMenu+0x8d0>
    66fa:	6d cb       	rjmp	.-2342   	; 0x5dd6 <updateMenu+0x48>
            }
          }
          break;
          
        case MENU_SETTINGS:        
          OLEDclear();
    66fc:	0e 94 d5 3a 	call	0x75aa	; 0x75aa <OLEDclear>
          OLEDsetCursor(0, 0);
    6700:	80 e0       	ldi	r24, 0x00	; 0
    6702:	60 e0       	ldi	r22, 0x00	; 0
    6704:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
          OLEDprintCC("hello"); //should never show up
    6708:	89 ec       	ldi	r24, 0xC9	; 201
    670a:	92 e0       	ldi	r25, 0x02	; 2
    670c:	0e 94 06 3a 	call	0x740c	; 0x740c <OLEDprintCC>
    6710:	62 cb       	rjmp	.-2364   	; 0x5dd6 <updateMenu+0x48>
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    6712:	c0 e0       	ldi	r28, 0x00	; 0
    6714:	d0 e0       	ldi	r29, 0x00	; 0
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].current += (rotEncVal)/10.0;
    6716:	61 2e       	mov	r6, r17
    6718:	77 24       	eor	r7, r7
    671a:	67 fc       	sbrc	r6, 7
    671c:	70 94       	com	r7
    671e:	87 2c       	mov	r8, r7
    6720:	97 2c       	mov	r9, r7
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    6722:	bc 2e       	mov	r11, r28
          }
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6724:	80 91 e5 02 	lds	r24, 0x02E5
    6728:	dc 2e       	mov	r13, r28
    672a:	cd 2e       	mov	r12, r29
    672c:	90 e0       	ldi	r25, 0x00	; 0
    672e:	0c 2e       	mov	r0, r28
    6730:	02 c0       	rjmp	.+4      	; 0x6736 <updateMenu+0x9a8>
    6732:	95 95       	asr	r25
    6734:	87 95       	ror	r24
    6736:	0a 94       	dec	r0
    6738:	e2 f7       	brpl	.-8      	; 0x6732 <updateMenu+0x9a4>
    673a:	80 ff       	sbrs	r24, 0
    673c:	a3 c0       	rjmp	.+326    	; 0x6884 <updateMenu+0xaf6>
              motor[i].current += (rotEncVal)/10.0;
    673e:	fe 01       	movw	r30, r28
    6740:	ee 0f       	add	r30, r30
    6742:	ff 1f       	adc	r31, r31
    6744:	ee 0f       	add	r30, r30
    6746:	ff 1f       	adc	r31, r31
    6748:	ee 0f       	add	r30, r30
    674a:	ff 1f       	adc	r31, r31
    674c:	cf 01       	movw	r24, r30
    674e:	88 0f       	add	r24, r24
    6750:	99 1f       	adc	r25, r25
    6752:	88 0f       	add	r24, r24
    6754:	99 1f       	adc	r25, r25
    6756:	e8 0f       	add	r30, r24
    6758:	f9 1f       	adc	r31, r25
    675a:	e0 51       	subi	r30, 0x10	; 16
    675c:	fc 4f       	sbci	r31, 0xFC	; 252
    675e:	e3 a0       	ldd	r14, Z+35	; 0x23
    6760:	f4 a0       	ldd	r15, Z+36	; 0x24
    6762:	05 a1       	ldd	r16, Z+37	; 0x25
    6764:	16 a1       	ldd	r17, Z+38	; 0x26
    6766:	c4 01       	movw	r24, r8
    6768:	b3 01       	movw	r22, r6
    676a:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    676e:	20 e0       	ldi	r18, 0x00	; 0
    6770:	30 e0       	ldi	r19, 0x00	; 0
    6772:	40 e2       	ldi	r20, 0x20	; 32
    6774:	51 e4       	ldi	r21, 0x41	; 65
    6776:	0e 94 c8 3f 	call	0x7f90	; 0x7f90 <__divsf3>
    677a:	9b 01       	movw	r18, r22
    677c:	ac 01       	movw	r20, r24
    677e:	c8 01       	movw	r24, r16
    6780:	b7 01       	movw	r22, r14
    6782:	0e 94 60 3f 	call	0x7ec0	; 0x7ec0 <__addsf3>
    6786:	fe 01       	movw	r30, r28
    6788:	ee 0f       	add	r30, r30
    678a:	ff 1f       	adc	r31, r31
    678c:	ee 0f       	add	r30, r30
    678e:	ff 1f       	adc	r31, r31
    6790:	ee 0f       	add	r30, r30
    6792:	ff 1f       	adc	r31, r31
    6794:	9f 01       	movw	r18, r30
    6796:	22 0f       	add	r18, r18
    6798:	33 1f       	adc	r19, r19
    679a:	22 0f       	add	r18, r18
    679c:	33 1f       	adc	r19, r19
    679e:	e2 0f       	add	r30, r18
    67a0:	f3 1f       	adc	r31, r19
    67a2:	e0 51       	subi	r30, 0x10	; 16
    67a4:	fc 4f       	sbci	r31, 0xFC	; 252
    67a6:	63 a3       	std	Z+35, r22	; 0x23
    67a8:	74 a3       	std	Z+36, r23	; 0x24
    67aa:	85 a3       	std	Z+37, r24	; 0x25
    67ac:	96 a3       	std	Z+38, r25	; 0x26
              if(motor[i].current < 0){
    67ae:	fe 01       	movw	r30, r28
    67b0:	ee 0f       	add	r30, r30
    67b2:	ff 1f       	adc	r31, r31
    67b4:	ee 0f       	add	r30, r30
    67b6:	ff 1f       	adc	r31, r31
    67b8:	ee 0f       	add	r30, r30
    67ba:	ff 1f       	adc	r31, r31
    67bc:	cf 01       	movw	r24, r30
    67be:	88 0f       	add	r24, r24
    67c0:	99 1f       	adc	r25, r25
    67c2:	88 0f       	add	r24, r24
    67c4:	99 1f       	adc	r25, r25
    67c6:	e8 0f       	add	r30, r24
    67c8:	f9 1f       	adc	r31, r25
    67ca:	e0 51       	subi	r30, 0x10	; 16
    67cc:	fc 4f       	sbci	r31, 0xFC	; 252
    67ce:	63 a1       	ldd	r22, Z+35	; 0x23
    67d0:	74 a1       	ldd	r23, Z+36	; 0x24
    67d2:	85 a1       	ldd	r24, Z+37	; 0x25
    67d4:	96 a1       	ldd	r25, Z+38	; 0x26
    67d6:	20 e0       	ldi	r18, 0x00	; 0
    67d8:	30 e0       	ldi	r19, 0x00	; 0
    67da:	40 e0       	ldi	r20, 0x00	; 0
    67dc:	50 e0       	ldi	r21, 0x00	; 0
    67de:	0e 94 c4 3f 	call	0x7f88	; 0x7f88 <__cmpsf2>
    67e2:	88 23       	and	r24, r24
    67e4:	0c f4       	brge	.+2      	; 0x67e8 <updateMenu+0xa5a>
    67e6:	d3 c0       	rjmp	.+422    	; 0x698e <updateMenu+0xc00>
                motor[i].current = 0;
              }
              if(motor[i].current > 2.5){
    67e8:	ed 2d       	mov	r30, r13
    67ea:	fc 2d       	mov	r31, r12
    67ec:	ee 0f       	add	r30, r30
    67ee:	ff 1f       	adc	r31, r31
    67f0:	ee 0f       	add	r30, r30
    67f2:	ff 1f       	adc	r31, r31
    67f4:	ee 0f       	add	r30, r30
    67f6:	ff 1f       	adc	r31, r31
    67f8:	cf 01       	movw	r24, r30
    67fa:	88 0f       	add	r24, r24
    67fc:	99 1f       	adc	r25, r25
    67fe:	88 0f       	add	r24, r24
    6800:	99 1f       	adc	r25, r25
    6802:	e8 0f       	add	r30, r24
    6804:	f9 1f       	adc	r31, r25
    6806:	e0 51       	subi	r30, 0x10	; 16
    6808:	fc 4f       	sbci	r31, 0xFC	; 252
    680a:	63 a1       	ldd	r22, Z+35	; 0x23
    680c:	74 a1       	ldd	r23, Z+36	; 0x24
    680e:	85 a1       	ldd	r24, Z+37	; 0x25
    6810:	96 a1       	ldd	r25, Z+38	; 0x26
    6812:	20 e0       	ldi	r18, 0x00	; 0
    6814:	30 e0       	ldi	r19, 0x00	; 0
    6816:	40 e2       	ldi	r20, 0x20	; 32
    6818:	50 e4       	ldi	r21, 0x40	; 64
    681a:	0e 94 66 41 	call	0x82cc	; 0x82cc <__gesf2>
    681e:	18 16       	cp	r1, r24
    6820:	cc f4       	brge	.+50     	; 0x6854 <updateMenu+0xac6>
                motor[i].current = 2.5;
    6822:	ed 2d       	mov	r30, r13
    6824:	fc 2d       	mov	r31, r12
    6826:	ee 0f       	add	r30, r30
    6828:	ff 1f       	adc	r31, r31
    682a:	ee 0f       	add	r30, r30
    682c:	ff 1f       	adc	r31, r31
    682e:	ee 0f       	add	r30, r30
    6830:	ff 1f       	adc	r31, r31
    6832:	cf 01       	movw	r24, r30
    6834:	88 0f       	add	r24, r24
    6836:	99 1f       	adc	r25, r25
    6838:	88 0f       	add	r24, r24
    683a:	99 1f       	adc	r25, r25
    683c:	e8 0f       	add	r30, r24
    683e:	f9 1f       	adc	r31, r25
    6840:	e0 51       	subi	r30, 0x10	; 16
    6842:	fc 4f       	sbci	r31, 0xFC	; 252
    6844:	80 e0       	ldi	r24, 0x00	; 0
    6846:	90 e0       	ldi	r25, 0x00	; 0
    6848:	a0 e2       	ldi	r26, 0x20	; 32
    684a:	b0 e4       	ldi	r27, 0x40	; 64
    684c:	83 a3       	std	Z+35, r24	; 0x23
    684e:	94 a3       	std	Z+36, r25	; 0x24
    6850:	a5 a3       	std	Z+37, r26	; 0x25
    6852:	b6 a3       	std	Z+38, r27	; 0x26
              }
              setMotorCurrent(i, motor[i].current);
    6854:	ed 2d       	mov	r30, r13
    6856:	fc 2d       	mov	r31, r12
    6858:	ee 0f       	add	r30, r30
    685a:	ff 1f       	adc	r31, r31
    685c:	ee 0f       	add	r30, r30
    685e:	ff 1f       	adc	r31, r31
    6860:	ee 0f       	add	r30, r30
    6862:	ff 1f       	adc	r31, r31
    6864:	cf 01       	movw	r24, r30
    6866:	88 0f       	add	r24, r24
    6868:	99 1f       	adc	r25, r25
    686a:	88 0f       	add	r24, r24
    686c:	99 1f       	adc	r25, r25
    686e:	e8 0f       	add	r30, r24
    6870:	f9 1f       	adc	r31, r25
    6872:	e0 51       	subi	r30, 0x10	; 16
    6874:	fc 4f       	sbci	r31, 0xFC	; 252
    6876:	43 a1       	ldd	r20, Z+35	; 0x23
    6878:	54 a1       	ldd	r21, Z+36	; 0x24
    687a:	65 a1       	ldd	r22, Z+37	; 0x25
    687c:	76 a1       	ldd	r23, Z+38	; 0x26
    687e:	8b 2d       	mov	r24, r11
    6880:	0e 94 28 2c 	call	0x5850	; 0x5850 <setMotorCurrent>
    6884:	21 96       	adiw	r28, 0x01	; 1
            ;
          }
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6886:	c4 30       	cpi	r28, 0x04	; 4
    6888:	d1 05       	cpc	r29, r1
    688a:	09 f0       	breq	.+2      	; 0x688e <updateMenu+0xb00>
    688c:	4a cf       	rjmp	.-364    	; 0x6722 <updateMenu+0x994>
    688e:	a3 ca       	rjmp	.-2746   	; 0x5dd6 <updateMenu+0x48>
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              switch(motor[i].stepUnit){
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
    6890:	81 2e       	mov	r8, r17
    6892:	99 24       	eor	r9, r9
    6894:	87 fc       	sbrc	r8, 7
    6896:	90 94       	com	r9
    6898:	84 e6       	ldi	r24, 0x64	; 100
    689a:	90 e0       	ldi	r25, 0x00	; 0
    689c:	88 9e       	mul	r8, r24
    689e:	30 01       	movw	r6, r0
    68a0:	89 9e       	mul	r8, r25
    68a2:	70 0c       	add	r7, r0
    68a4:	98 9e       	mul	r9, r24
    68a6:	70 0c       	add	r7, r0
    68a8:	11 24       	eor	r1, r1
    68aa:	c0 e0       	ldi	r28, 0x00	; 0
    68ac:	d0 e0       	ldi	r29, 0x00	; 0
                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
                  }
                  else{
                    degreeToSteps(i, rotEncVal, motor[i].stepMultiplier);
    68ae:	a1 2e       	mov	r10, r17
    68b0:	bb 24       	eor	r11, r11
    68b2:	a7 fc       	sbrc	r10, 7
    68b4:	b0 94       	com	r11
    68b6:	cb 2c       	mov	r12, r11
    68b8:	db 2c       	mov	r13, r11
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    68ba:	80 91 e5 02 	lds	r24, 0x02E5
    68be:	90 e0       	ldi	r25, 0x00	; 0
    68c0:	0c 2e       	mov	r0, r28
    68c2:	02 c0       	rjmp	.+4      	; 0x68c8 <updateMenu+0xb3a>
    68c4:	95 95       	asr	r25
    68c6:	87 95       	ror	r24
    68c8:	0a 94       	dec	r0
    68ca:	e2 f7       	brpl	.-8      	; 0x68c4 <updateMenu+0xb36>
    68cc:	80 ff       	sbrs	r24, 0
    68ce:	44 c0       	rjmp	.+136    	; 0x6958 <updateMenu+0xbca>
              switch(motor[i].stepUnit){
    68d0:	fe 01       	movw	r30, r28
    68d2:	ee 0f       	add	r30, r30
    68d4:	ff 1f       	adc	r31, r31
    68d6:	ee 0f       	add	r30, r30
    68d8:	ff 1f       	adc	r31, r31
    68da:	ee 0f       	add	r30, r30
    68dc:	ff 1f       	adc	r31, r31
    68de:	cf 01       	movw	r24, r30
    68e0:	88 0f       	add	r24, r24
    68e2:	99 1f       	adc	r25, r25
    68e4:	88 0f       	add	r24, r24
    68e6:	99 1f       	adc	r25, r25
    68e8:	e8 0f       	add	r30, r24
    68ea:	f9 1f       	adc	r31, r25
    68ec:	e0 51       	subi	r30, 0x10	; 16
    68ee:	fc 4f       	sbci	r31, 0xFC	; 252
    68f0:	81 8d       	ldd	r24, Z+25	; 0x19
    68f2:	81 30       	cpi	r24, 0x01	; 1
    68f4:	09 f4       	brne	.+2      	; 0x68f8 <updateMenu+0xb6a>
    68f6:	09 c1       	rjmp	.+530    	; 0x6b0a <updateMenu+0xd7c>
    68f8:	82 30       	cpi	r24, 0x02	; 2
    68fa:	09 f4       	brne	.+2      	; 0x68fe <updateMenu+0xb70>
    68fc:	e0 c0       	rjmp	.+448    	; 0x6abe <updateMenu+0xd30>
    68fe:	88 23       	and	r24, r24
    6900:	59 f5       	brne	.+86     	; 0x6958 <updateMenu+0xbca>
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
    6902:	80 91 e2 02 	lds	r24, 0x02E2
    6906:	88 23       	and	r24, r24
    6908:	09 f4       	brne	.+2      	; 0x690c <updateMenu+0xb7e>
    690a:	4e c1       	rjmp	.+668    	; 0x6ba8 <updateMenu+0xe1a>
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
    690c:	fe 01       	movw	r30, r28
    690e:	ee 0f       	add	r30, r30
    6910:	ff 1f       	adc	r31, r31
    6912:	ee 0f       	add	r30, r30
    6914:	ff 1f       	adc	r31, r31
    6916:	cf 01       	movw	r24, r30
    6918:	88 0f       	add	r24, r24
    691a:	99 1f       	adc	r25, r25
    691c:	88 0f       	add	r24, r24
    691e:	99 1f       	adc	r25, r25
    6920:	e8 0f       	add	r30, r24
    6922:	f9 1f       	adc	r31, r25
    6924:	ee 0f       	add	r30, r30
    6926:	ff 1f       	adc	r31, r31
    6928:	ee 50       	subi	r30, 0x0E	; 14
    692a:	fc 4f       	sbci	r31, 0xFC	; 252
    692c:	20 81       	ld	r18, Z
    692e:	31 81       	ldd	r19, Z+1	; 0x01
    6930:	26 0d       	add	r18, r6
    6932:	37 1d       	adc	r19, r7
                  }
                  else{
                    motor[i].desiredPosition += (int16_t)rotEncVal;
    6934:	fe 01       	movw	r30, r28
    6936:	ee 0f       	add	r30, r30
    6938:	ff 1f       	adc	r31, r31
    693a:	ee 0f       	add	r30, r30
    693c:	ff 1f       	adc	r31, r31
    693e:	cf 01       	movw	r24, r30
    6940:	88 0f       	add	r24, r24
    6942:	99 1f       	adc	r25, r25
    6944:	88 0f       	add	r24, r24
    6946:	99 1f       	adc	r25, r25
    6948:	e8 0f       	add	r30, r24
    694a:	f9 1f       	adc	r31, r25
    694c:	ee 0f       	add	r30, r30
    694e:	ff 1f       	adc	r31, r31
    6950:	ee 50       	subi	r30, 0x0E	; 14
    6952:	fc 4f       	sbci	r31, 0xFC	; 252
    6954:	31 83       	std	Z+1, r19	; 0x01
    6956:	20 83       	st	Z, r18
                  break;

                case MOTOR_STEP_UNIT_RADIAN:
                  /* default step is pi/8 */
                  /* pi/8 is far enough, so no fast moving mode here */
                  radiansToSteps(i, (rotEncVal)*0.125, motor[i].stepMultiplier);
    6958:	21 96       	adiw	r28, 0x01	; 1
      switch(state){
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    695a:	c4 30       	cpi	r28, 0x04	; 4
    695c:	d1 05       	cpc	r29, r1
    695e:	09 f0       	breq	.+2      	; 0x6962 <updateMenu+0xbd4>
    6960:	ac cf       	rjmp	.-168    	; 0x68ba <updateMenu+0xb2c>
    6962:	39 ca       	rjmp	.-2958   	; 0x5dd6 <updateMenu+0x48>
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
    6964:	fa 01       	movw	r30, r20
    6966:	ee 0f       	add	r30, r30
    6968:	ff 1f       	adc	r31, r31
    696a:	ee 0f       	add	r30, r30
    696c:	ff 1f       	adc	r31, r31
    696e:	ee 0f       	add	r30, r30
    6970:	ff 1f       	adc	r31, r31
    6972:	cf 01       	movw	r24, r30
    6974:	88 0f       	add	r24, r24
    6976:	99 1f       	adc	r25, r25
    6978:	88 0f       	add	r24, r24
    697a:	99 1f       	adc	r25, r25
    697c:	e8 0f       	add	r30, r24
    697e:	f9 1f       	adc	r31, r25
    6980:	e0 51       	subi	r30, 0x10	; 16
    6982:	fc 4f       	sbci	r31, 0xFC	; 252
    6984:	20 81       	ld	r18, Z
    6986:	31 81       	ldd	r19, Z+1	; 0x01
    6988:	26 0f       	add	r18, r22
    698a:	37 1f       	adc	r19, r23
    698c:	69 cc       	rjmp	.-1838   	; 0x6260 <updateMenu+0x4d2>
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].current += (rotEncVal)/10.0;
              if(motor[i].current < 0){
                motor[i].current = 0;
    698e:	fe 01       	movw	r30, r28
    6990:	ee 0f       	add	r30, r30
    6992:	ff 1f       	adc	r31, r31
    6994:	ee 0f       	add	r30, r30
    6996:	ff 1f       	adc	r31, r31
    6998:	ee 0f       	add	r30, r30
    699a:	ff 1f       	adc	r31, r31
    699c:	cf 01       	movw	r24, r30
    699e:	88 0f       	add	r24, r24
    69a0:	99 1f       	adc	r25, r25
    69a2:	88 0f       	add	r24, r24
    69a4:	99 1f       	adc	r25, r25
    69a6:	e8 0f       	add	r30, r24
    69a8:	f9 1f       	adc	r31, r25
    69aa:	e0 51       	subi	r30, 0x10	; 16
    69ac:	fc 4f       	sbci	r31, 0xFC	; 252
    69ae:	80 e0       	ldi	r24, 0x00	; 0
    69b0:	90 e0       	ldi	r25, 0x00	; 0
    69b2:	a0 e0       	ldi	r26, 0x00	; 0
    69b4:	b0 e0       	ldi	r27, 0x00	; 0
    69b6:	83 a3       	std	Z+35, r24	; 0x23
    69b8:	94 a3       	std	Z+36, r25	; 0x24
    69ba:	a5 a3       	std	Z+37, r26	; 0x25
    69bc:	b6 a3       	std	Z+38, r27	; 0x26
    69be:	14 cf       	rjmp	.-472    	; 0x67e8 <updateMenu+0xa5a>
        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepUnit += rotEncVal;
              if(motor[i].stepUnit < 0){
                motor[i].stepUnit = 2;
    69c0:	fa 01       	movw	r30, r20
    69c2:	ee 0f       	add	r30, r30
    69c4:	ff 1f       	adc	r31, r31
    69c6:	ee 0f       	add	r30, r30
    69c8:	ff 1f       	adc	r31, r31
    69ca:	ee 0f       	add	r30, r30
    69cc:	ff 1f       	adc	r31, r31
    69ce:	cf 01       	movw	r24, r30
    69d0:	88 0f       	add	r24, r24
    69d2:	99 1f       	adc	r25, r25
    69d4:	88 0f       	add	r24, r24
    69d6:	99 1f       	adc	r25, r25
    69d8:	e8 0f       	add	r30, r24
    69da:	f9 1f       	adc	r31, r25
    69dc:	e0 51       	subi	r30, 0x10	; 16
    69de:	fc 4f       	sbci	r31, 0xFC	; 252
    69e0:	71 8f       	std	Z+25, r23	; 0x19
    69e2:	d7 cc       	rjmp	.-1618   	; 0x6392 <updateMenu+0x604>
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
              }
              if(motor[i].subSteps < 1){
    69e4:	01 e0       	ldi	r16, 0x01	; 1
    69e6:	c3 cb       	rjmp	.-2170   	; 0x616e <updateMenu+0x3e0>
                //motor[i].subSteps *= 2.0;
                tmp *= 2.0;
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
    69e8:	70 e0       	ldi	r23, 0x00	; 0
    69ea:	88 27       	eor	r24, r24
    69ec:	77 fd       	sbrc	r23, 7
    69ee:	80 95       	com	r24
    69f0:	98 2f       	mov	r25, r24
    69f2:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    69f6:	20 e0       	ldi	r18, 0x00	; 0
    69f8:	30 e0       	ldi	r19, 0x00	; 0
    69fa:	40 e0       	ldi	r20, 0x00	; 0
    69fc:	5f e3       	ldi	r21, 0x3F	; 63
    69fe:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    6a02:	0e 94 35 40 	call	0x806a	; 0x806a <__fixunssfsi>
    6a06:	06 2f       	mov	r16, r22
    6a08:	94 cb       	rjmp	.-2264   	; 0x6132 <updateMenu+0x3a4>
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
              if(motor[i].angularVelocity < 0){
                motor[i].angularVelocity = 2;
    6a0a:	02 a3       	std	Z+34, r16	; 0x22
    6a0c:	57 ce       	rjmp	.-850    	; 0x66bc <updateMenu+0x92e>
          if(programList[menu.currentProgramStep].absRel == PROG_ABSOLUTE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
    6a0e:	80 91 e3 02 	lds	r24, 0x02E3
    6a12:	99 27       	eor	r25, r25
    6a14:	87 fd       	sbrc	r24, 7
    6a16:	90 95       	com	r25
    6a18:	fc 01       	movw	r30, r24
    6a1a:	ee 0f       	add	r30, r30
    6a1c:	ff 1f       	adc	r31, r31
    6a1e:	ee 0f       	add	r30, r30
    6a20:	ff 1f       	adc	r31, r31
    6a22:	ee 0f       	add	r30, r30
    6a24:	ff 1f       	adc	r31, r31
    6a26:	88 0f       	add	r24, r24
    6a28:	99 1f       	adc	r25, r25
    6a2a:	e8 0f       	add	r30, r24
    6a2c:	f9 1f       	adc	r31, r25
    6a2e:	ed 50       	subi	r30, 0x0D	; 13
    6a30:	fd 4f       	sbci	r31, 0xFD	; 253
    6a32:	81 85       	ldd	r24, Z+9	; 0x09
    6a34:	81 30       	cpi	r24, 0x01	; 1
    6a36:	09 f0       	breq	.+2      	; 0x6a3a <updateMenu+0xcac>
    6a38:	ce c9       	rjmp	.-3172   	; 0x5dd6 <updateMenu+0x48>
    6a3a:	60 e0       	ldi	r22, 0x00	; 0
    6a3c:	70 e0       	ldi	r23, 0x00	; 0
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = motor[i].actualPosition
    6a3e:	fb 01       	movw	r30, r22
    6a40:	ee 0f       	add	r30, r30
    6a42:	ff 1f       	adc	r31, r31
    6a44:	ee 0f       	add	r30, r30
    6a46:	ff 1f       	adc	r31, r31
    6a48:	ee 0f       	add	r30, r30
    6a4a:	ff 1f       	adc	r31, r31
    6a4c:	cf 01       	movw	r24, r30
    6a4e:	88 0f       	add	r24, r24
    6a50:	99 1f       	adc	r25, r25
    6a52:	88 0f       	add	r24, r24
    6a54:	99 1f       	adc	r25, r25
    6a56:	e8 0f       	add	r30, r24
    6a58:	f9 1f       	adc	r31, r25
    6a5a:	e0 51       	subi	r30, 0x10	; 16
    6a5c:	fc 4f       	sbci	r31, 0xFC	; 252
    6a5e:	40 81       	ld	r20, Z
    6a60:	51 81       	ldd	r21, Z+1	; 0x01
    6a62:	80 91 e3 02 	lds	r24, 0x02E3
    6a66:	99 27       	eor	r25, r25
    6a68:	87 fd       	sbrc	r24, 7
    6a6a:	90 95       	com	r25
    6a6c:	fc 01       	movw	r30, r24
    6a6e:	ee 0f       	add	r30, r30
    6a70:	ff 1f       	adc	r31, r31
    6a72:	ee 0f       	add	r30, r30
    6a74:	ff 1f       	adc	r31, r31
    6a76:	e8 0f       	add	r30, r24
    6a78:	f9 1f       	adc	r31, r25
    6a7a:	e6 0f       	add	r30, r22
    6a7c:	f7 1f       	adc	r31, r23
    6a7e:	ee 0f       	add	r30, r30
    6a80:	ff 1f       	adc	r31, r31
    6a82:	ed 50       	subi	r30, 0x0D	; 13
    6a84:	fd 4f       	sbci	r31, 0xFD	; 253
    6a86:	21 81       	ldd	r18, Z+1	; 0x01
    6a88:	32 81       	ldd	r19, Z+2	; 0x02
    6a8a:	24 0f       	add	r18, r20
    6a8c:	35 1f       	adc	r19, r21
    6a8e:	fb 01       	movw	r30, r22
    6a90:	ee 0f       	add	r30, r30
    6a92:	ff 1f       	adc	r31, r31
    6a94:	ee 0f       	add	r30, r30
    6a96:	ff 1f       	adc	r31, r31
    6a98:	cf 01       	movw	r24, r30
    6a9a:	88 0f       	add	r24, r24
    6a9c:	99 1f       	adc	r25, r25
    6a9e:	88 0f       	add	r24, r24
    6aa0:	99 1f       	adc	r25, r25
    6aa2:	e8 0f       	add	r30, r24
    6aa4:	f9 1f       	adc	r31, r25
    6aa6:	ee 0f       	add	r30, r30
    6aa8:	ff 1f       	adc	r31, r31
    6aaa:	ee 50       	subi	r30, 0x0E	; 14
    6aac:	fc 4f       	sbci	r31, 0xFC	; 252
    6aae:	31 83       	std	Z+1, r19	; 0x01
    6ab0:	20 83       	st	Z, r18
    6ab2:	6f 5f       	subi	r22, 0xFF	; 255
    6ab4:	7f 4f       	sbci	r23, 0xFF	; 255
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    6ab6:	64 30       	cpi	r22, 0x04	; 4
    6ab8:	71 05       	cpc	r23, r1
    6aba:	09 f6       	brne	.-126    	; 0x6a3e <updateMenu+0xcb0>
    6abc:	8c c9       	rjmp	.-3304   	; 0x5dd6 <updateMenu+0x48>
                  break;

                case MOTOR_STEP_UNIT_RADIAN:
                  /* default step is pi/8 */
                  /* pi/8 is far enough, so no fast moving mode here */
                  radiansToSteps(i, (rotEncVal)*0.125, motor[i].stepMultiplier);
    6abe:	fe 01       	movw	r30, r28
    6ac0:	ee 0f       	add	r30, r30
    6ac2:	ff 1f       	adc	r31, r31
    6ac4:	ee 0f       	add	r30, r30
    6ac6:	ff 1f       	adc	r31, r31
    6ac8:	ee 0f       	add	r30, r30
    6aca:	ff 1f       	adc	r31, r31
    6acc:	cf 01       	movw	r24, r30
    6ace:	88 0f       	add	r24, r24
    6ad0:	99 1f       	adc	r25, r25
    6ad2:	88 0f       	add	r24, r24
    6ad4:	99 1f       	adc	r25, r25
    6ad6:	e8 0f       	add	r30, r24
    6ad8:	f9 1f       	adc	r31, r25
    6ada:	e0 51       	subi	r30, 0x10	; 16
    6adc:	fc 4f       	sbci	r31, 0xFC	; 252
    6ade:	e2 8c       	ldd	r14, Z+26	; 0x1a
    6ae0:	f3 8c       	ldd	r15, Z+27	; 0x1b
    6ae2:	04 8d       	ldd	r16, Z+28	; 0x1c
    6ae4:	15 8d       	ldd	r17, Z+29	; 0x1d
    6ae6:	c6 01       	movw	r24, r12
    6ae8:	b5 01       	movw	r22, r10
    6aea:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    6aee:	20 e0       	ldi	r18, 0x00	; 0
    6af0:	30 e0       	ldi	r19, 0x00	; 0
    6af2:	40 e0       	ldi	r20, 0x00	; 0
    6af4:	5e e3       	ldi	r21, 0x3E	; 62
    6af6:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    6afa:	ab 01       	movw	r20, r22
    6afc:	bc 01       	movw	r22, r24
    6afe:	8c 2f       	mov	r24, r28
    6b00:	98 01       	movw	r18, r16
    6b02:	87 01       	movw	r16, r14
    6b04:	0e 94 36 13 	call	0x266c	; 0x266c <radiansToSteps>
    6b08:	27 cf       	rjmp	.-434    	; 0x6958 <updateMenu+0xbca>
                    motor[i].desiredPosition += (int16_t)rotEncVal;
                  }
                  break;

                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
    6b0a:	80 91 e2 02 	lds	r24, 0x02E2
    6b0e:	88 23       	and	r24, r24
    6b10:	09 f4       	brne	.+2      	; 0x6b14 <updateMenu+0xd86>
    6b12:	5f c0       	rjmp	.+190    	; 0x6bd2 <updateMenu+0xe44>
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
    6b14:	fe 01       	movw	r30, r28
    6b16:	ee 0f       	add	r30, r30
    6b18:	ff 1f       	adc	r31, r31
    6b1a:	ee 0f       	add	r30, r30
    6b1c:	ff 1f       	adc	r31, r31
    6b1e:	ee 0f       	add	r30, r30
    6b20:	ff 1f       	adc	r31, r31
    6b22:	cf 01       	movw	r24, r30
    6b24:	88 0f       	add	r24, r24
    6b26:	99 1f       	adc	r25, r25
    6b28:	88 0f       	add	r24, r24
    6b2a:	99 1f       	adc	r25, r25
    6b2c:	e8 0f       	add	r30, r24
    6b2e:	f9 1f       	adc	r31, r25
    6b30:	e0 51       	subi	r30, 0x10	; 16
    6b32:	fc 4f       	sbci	r31, 0xFC	; 252
    6b34:	e2 8c       	ldd	r14, Z+26	; 0x1a
    6b36:	f3 8c       	ldd	r15, Z+27	; 0x1b
    6b38:	04 8d       	ldd	r16, Z+28	; 0x1c
    6b3a:	15 8d       	ldd	r17, Z+29	; 0x1d
    6b3c:	c6 01       	movw	r24, r12
    6b3e:	b5 01       	movw	r22, r10
    6b40:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    6b44:	20 e0       	ldi	r18, 0x00	; 0
    6b46:	30 e0       	ldi	r19, 0x00	; 0
    6b48:	40 e2       	ldi	r20, 0x20	; 32
    6b4a:	51 e4       	ldi	r21, 0x41	; 65
    6b4c:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    6b50:	ab 01       	movw	r20, r22
    6b52:	bc 01       	movw	r22, r24
    6b54:	8c 2f       	mov	r24, r28
    6b56:	98 01       	movw	r18, r16
    6b58:	87 01       	movw	r16, r14
    6b5a:	0e 94 7d 14 	call	0x28fa	; 0x28fa <degreeToSteps>
    6b5e:	fc ce       	rjmp	.-520    	; 0x6958 <updateMenu+0xbca>
          if(rotEncVal < 0){
            do{
              /* find the next active program step */
              menu.currentProgramStep += -1;
              if(menu.currentProgramStep < 0){
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
    6b60:	2f e0       	ldi	r18, 0x0F	; 15
    6b62:	16 c0       	rjmp	.+44     	; 0x6b90 <updateMenu+0xe02>
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
    6b64:	80 91 e3 02 	lds	r24, 0x02E3
    6b68:	99 27       	eor	r25, r25
    6b6a:	87 fd       	sbrc	r24, 7
    6b6c:	90 95       	com	r25
    6b6e:	fc 01       	movw	r30, r24
    6b70:	ee 0f       	add	r30, r30
    6b72:	ff 1f       	adc	r31, r31
    6b74:	ee 0f       	add	r30, r30
    6b76:	ff 1f       	adc	r31, r31
    6b78:	ee 0f       	add	r30, r30
    6b7a:	ff 1f       	adc	r31, r31
    6b7c:	88 0f       	add	r24, r24
    6b7e:	99 1f       	adc	r25, r25
    6b80:	e8 0f       	add	r30, r24
    6b82:	f9 1f       	adc	r31, r25
    6b84:	ed 50       	subi	r30, 0x0D	; 13
    6b86:	fd 4f       	sbci	r31, 0xFD	; 253
    6b88:	80 81       	ld	r24, Z
    6b8a:	88 23       	and	r24, r24
    6b8c:	09 f0       	breq	.+2      	; 0x6b90 <updateMenu+0xe02>
    6b8e:	ed cc       	rjmp	.-1574   	; 0x656a <updateMenu+0x7dc>
          }

          if(rotEncVal < 0){
            do{
              /* find the next active program step */
              menu.currentProgramStep += -1;
    6b90:	80 91 e3 02 	lds	r24, 0x02E3
    6b94:	81 50       	subi	r24, 0x01	; 1
    6b96:	80 93 e3 02 	sts	0x02E3, r24
              if(menu.currentProgramStep < 0){
    6b9a:	80 91 e3 02 	lds	r24, 0x02E3
    6b9e:	87 ff       	sbrs	r24, 7
    6ba0:	e1 cf       	rjmp	.-62     	; 0x6b64 <updateMenu+0xdd6>
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
    6ba2:	20 93 e3 02 	sts	0x02E3, r18
    6ba6:	de cf       	rjmp	.-68     	; 0x6b64 <updateMenu+0xdd6>
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
                  }
                  else{
                    motor[i].desiredPosition += (int16_t)rotEncVal;
    6ba8:	fe 01       	movw	r30, r28
    6baa:	ee 0f       	add	r30, r30
    6bac:	ff 1f       	adc	r31, r31
    6bae:	ee 0f       	add	r30, r30
    6bb0:	ff 1f       	adc	r31, r31
    6bb2:	cf 01       	movw	r24, r30
    6bb4:	88 0f       	add	r24, r24
    6bb6:	99 1f       	adc	r25, r25
    6bb8:	88 0f       	add	r24, r24
    6bba:	99 1f       	adc	r25, r25
    6bbc:	e8 0f       	add	r30, r24
    6bbe:	f9 1f       	adc	r31, r25
    6bc0:	ee 0f       	add	r30, r30
    6bc2:	ff 1f       	adc	r31, r31
    6bc4:	ee 50       	subi	r30, 0x0E	; 14
    6bc6:	fc 4f       	sbci	r31, 0xFC	; 252
    6bc8:	20 81       	ld	r18, Z
    6bca:	31 81       	ldd	r19, Z+1	; 0x01
    6bcc:	28 0d       	add	r18, r8
    6bce:	39 1d       	adc	r19, r9
    6bd0:	b1 ce       	rjmp	.-670    	; 0x6934 <updateMenu+0xba6>
                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
                  }
                  else{
                    degreeToSteps(i, rotEncVal, motor[i].stepMultiplier);
    6bd2:	fe 01       	movw	r30, r28
    6bd4:	ee 0f       	add	r30, r30
    6bd6:	ff 1f       	adc	r31, r31
    6bd8:	ee 0f       	add	r30, r30
    6bda:	ff 1f       	adc	r31, r31
    6bdc:	ee 0f       	add	r30, r30
    6bde:	ff 1f       	adc	r31, r31
    6be0:	cf 01       	movw	r24, r30
    6be2:	88 0f       	add	r24, r24
    6be4:	99 1f       	adc	r25, r25
    6be6:	88 0f       	add	r24, r24
    6be8:	99 1f       	adc	r25, r25
    6bea:	e8 0f       	add	r30, r24
    6bec:	f9 1f       	adc	r31, r25
    6bee:	e0 51       	subi	r30, 0x10	; 16
    6bf0:	fc 4f       	sbci	r31, 0xFC	; 252
    6bf2:	e2 8c       	ldd	r14, Z+26	; 0x1a
    6bf4:	f3 8c       	ldd	r15, Z+27	; 0x1b
    6bf6:	04 8d       	ldd	r16, Z+28	; 0x1c
    6bf8:	15 8d       	ldd	r17, Z+29	; 0x1d
    6bfa:	c6 01       	movw	r24, r12
    6bfc:	b5 01       	movw	r22, r10
    6bfe:	0e 94 63 40 	call	0x80c6	; 0x80c6 <__floatsisf>
    6c02:	ab 01       	movw	r20, r22
    6c04:	bc 01       	movw	r22, r24
    6c06:	8c 2f       	mov	r24, r28
    6c08:	98 01       	movw	r18, r16
    6c0a:	87 01       	movw	r16, r14
    6c0c:	0e 94 7d 14 	call	0x28fa	; 0x28fa <degreeToSteps>
    6c10:	a3 ce       	rjmp	.-698    	; 0x6958 <updateMenu+0xbca>

00006c12 <main>:


/* =====================================================================
    main loop
====================================================================== */
int main(void){
    6c12:	ef 92       	push	r14
    6c14:	ff 92       	push	r15
    6c16:	0f 93       	push	r16
    6c18:	1f 93       	push	r17
    6c1a:	cf 93       	push	r28
    6c1c:	df 93       	push	r29

  uint8_t i;
  uint8_t commandCode;

  /* initialize command parameter list */
  commandParam = (char**)malloc(NUMBER_OF_PARAMETERS * sizeof(char*));
    6c1e:	84 e1       	ldi	r24, 0x14	; 20
    6c20:	90 e0       	ldi	r25, 0x00	; 0
    6c22:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6c26:	80 93 d6 02 	sts	0x02D6, r24
    6c2a:	90 93 d7 02 	sts	0x02D7, r25
    6c2e:	c0 e0       	ldi	r28, 0x00	; 0
    6c30:	d0 e0       	ldi	r29, 0x00	; 0
  for(i = 0; i < NUMBER_OF_PARAMETERS; i++){
    commandParam[i] = (char*)malloc(PARAMETER_LENGTH * sizeof(char));
    6c32:	00 91 d6 02 	lds	r16, 0x02D6
    6c36:	10 91 d7 02 	lds	r17, 0x02D7
    6c3a:	0c 0f       	add	r16, r28
    6c3c:	1d 1f       	adc	r17, r29
    6c3e:	84 e1       	ldi	r24, 0x14	; 20
    6c40:	90 e0       	ldi	r25, 0x00	; 0
    6c42:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6c46:	f8 01       	movw	r30, r16
    6c48:	80 83       	st	Z, r24
    6c4a:	91 83       	std	Z+1, r25	; 0x01
    6c4c:	22 96       	adiw	r28, 0x02	; 2
  uint8_t i;
  uint8_t commandCode;

  /* initialize command parameter list */
  commandParam = (char**)malloc(NUMBER_OF_PARAMETERS * sizeof(char*));
  for(i = 0; i < NUMBER_OF_PARAMETERS; i++){
    6c4e:	c4 31       	cpi	r28, 0x14	; 20
    6c50:	d1 05       	cpc	r29, r1
    6c52:	79 f7       	brne	.-34     	; 0x6c32 <main+0x20>
    commandParam[i] = (char*)malloc(PARAMETER_LENGTH * sizeof(char));
  }

  /* initialize menu strings */
  menu.currentDisplayValue = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
    6c54:	88 e0       	ldi	r24, 0x08	; 8
    6c56:	90 e0       	ldi	r25, 0x00	; 0
    6c58:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6c5c:	90 93 e7 02 	sts	0x02E7, r25
    6c60:	80 93 e6 02 	sts	0x02E6, r24
  menu.newDisplayValue     = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
    6c64:	88 e0       	ldi	r24, 0x08	; 8
    6c66:	90 e0       	ldi	r25, 0x00	; 0
    6c68:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6c6c:	90 93 e9 02 	sts	0x02E9, r25
    6c70:	80 93 e8 02 	sts	0x02E8, r24
    6c74:	c0 e0       	ldi	r28, 0x00	; 0
    6c76:	d0 e0       	ldi	r29, 0x00	; 0
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    menu.currentDisplayValue[i] = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    6c78:	00 91 e6 02 	lds	r16, 0x02E6
    6c7c:	10 91 e7 02 	lds	r17, 0x02E7
    6c80:	89 e0       	ldi	r24, 0x09	; 9
    6c82:	90 e0       	ldi	r25, 0x00	; 0
    6c84:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6c88:	0c 0f       	add	r16, r28
    6c8a:	1d 1f       	adc	r17, r29
    6c8c:	f8 01       	movw	r30, r16
    6c8e:	80 83       	st	Z, r24
    6c90:	91 83       	std	Z+1, r25	; 0x01
    menu.newDisplayValue[i]     = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    6c92:	00 91 e8 02 	lds	r16, 0x02E8
    6c96:	10 91 e9 02 	lds	r17, 0x02E9
    6c9a:	89 e0       	ldi	r24, 0x09	; 9
    6c9c:	90 e0       	ldi	r25, 0x00	; 0
    6c9e:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6ca2:	0c 0f       	add	r16, r28
    6ca4:	1d 1f       	adc	r17, r29
    6ca6:	f8 01       	movw	r30, r16
    6ca8:	80 83       	st	Z, r24
    6caa:	91 83       	std	Z+1, r25	; 0x01
    6cac:	22 96       	adiw	r28, 0x02	; 2
  }

  /* initialize menu strings */
  menu.currentDisplayValue = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
  menu.newDisplayValue     = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    6cae:	c8 30       	cpi	r28, 0x08	; 8
    6cb0:	d1 05       	cpc	r29, r1
    6cb2:	11 f7       	brne	.-60     	; 0x6c78 <main+0x66>
    menu.currentDisplayValue[i] = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    menu.newDisplayValue[i]     = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
  }

  menu.currentMenuText     = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
    6cb4:	84 e0       	ldi	r24, 0x04	; 4
    6cb6:	90 e0       	ldi	r25, 0x00	; 0
    6cb8:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6cbc:	90 93 eb 02 	sts	0x02EB, r25
    6cc0:	80 93 ea 02 	sts	0x02EA, r24
  menu.newMenuText         = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
    6cc4:	84 e0       	ldi	r24, 0x04	; 4
    6cc6:	90 e0       	ldi	r25, 0x00	; 0
    6cc8:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6ccc:	90 93 ed 02 	sts	0x02ED, r25
    6cd0:	80 93 ec 02 	sts	0x02EC, r24
  for(i = 0; i < NUMBER_DISPLAY_MENU_STRINGS; i++){
    menu.currentMenuText[i] = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6cd4:	00 91 ea 02 	lds	r16, 0x02EA
    6cd8:	10 91 eb 02 	lds	r17, 0x02EB
    6cdc:	81 e1       	ldi	r24, 0x11	; 17
    6cde:	90 e0       	ldi	r25, 0x00	; 0
    6ce0:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6ce4:	f8 01       	movw	r30, r16
    6ce6:	80 83       	st	Z, r24
    6ce8:	91 83       	std	Z+1, r25	; 0x01
    menu.newMenuText[i]     = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6cea:	00 91 ec 02 	lds	r16, 0x02EC
    6cee:	10 91 ed 02 	lds	r17, 0x02ED
    6cf2:	81 e1       	ldi	r24, 0x11	; 17
    6cf4:	90 e0       	ldi	r25, 0x00	; 0
    6cf6:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6cfa:	f8 01       	movw	r30, r16
    6cfc:	80 83       	st	Z, r24
    6cfe:	91 83       	std	Z+1, r25	; 0x01
  }

  menu.currentMenuText     = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
  menu.newMenuText         = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
  for(i = 0; i < NUMBER_DISPLAY_MENU_STRINGS; i++){
    menu.currentMenuText[i] = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6d00:	00 91 ea 02 	lds	r16, 0x02EA
    6d04:	10 91 eb 02 	lds	r17, 0x02EB
    6d08:	81 e1       	ldi	r24, 0x11	; 17
    6d0a:	90 e0       	ldi	r25, 0x00	; 0
    6d0c:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6d10:	f8 01       	movw	r30, r16
    6d12:	82 83       	std	Z+2, r24	; 0x02
    6d14:	93 83       	std	Z+3, r25	; 0x03
    menu.newMenuText[i]     = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    6d16:	00 91 ec 02 	lds	r16, 0x02EC
    6d1a:	10 91 ed 02 	lds	r17, 0x02ED
    6d1e:	81 e1       	ldi	r24, 0x11	; 17
    6d20:	90 e0       	ldi	r25, 0x00	; 0
    6d22:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6d26:	f8 01       	movw	r30, r16
    6d28:	82 83       	std	Z+2, r24	; 0x02
    6d2a:	93 83       	std	Z+3, r25	; 0x03
  }

  /* initialize TX and RX buffers for USART serial interface */
  rxString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    6d2c:	80 e4       	ldi	r24, 0x40	; 64
    6d2e:	90 e0       	ldi	r25, 0x00	; 0
    6d30:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6d34:	90 93 ef 02 	sts	0x02EF, r25
    6d38:	80 93 ee 02 	sts	0x02EE, r24
  txString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    6d3c:	80 e4       	ldi	r24, 0x40	; 64
    6d3e:	90 e0       	ldi	r25, 0x00	; 0
    6d40:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6d44:	90 93 e8 03 	sts	0x03E8, r25
    6d48:	80 93 e7 03 	sts	0x03E7, r24
  commandString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    6d4c:	80 e4       	ldi	r24, 0x40	; 64
    6d4e:	90 e0       	ldi	r25, 0x00	; 0
    6d50:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6d54:	90 93 91 04 	sts	0x0491, r25
    6d58:	80 93 90 04 	sts	0x0490, r24

  /* initialize IIC data buffer */
  IIC.data = (char*)malloc(21 * sizeof(char));
    6d5c:	85 e1       	ldi	r24, 0x15	; 21
    6d5e:	90 e0       	ldi	r25, 0x00	; 0
    6d60:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6d64:	90 93 ee 03 	sts	0x03EE, r25
    6d68:	80 93 ed 03 	sts	0x03ED, r24

  /* initialize displayBuffer */
  displayBuffer = (char*)malloc(DISPLAY_BUFFER_SIZE * sizeof(char));
    6d6c:	88 e2       	ldi	r24, 0x28	; 40
    6d6e:	90 e0       	ldi	r25, 0x00	; 0
    6d70:	0e 94 14 42 	call	0x8428	; 0x8428 <malloc>
    6d74:	80 93 eb 03 	sts	0x03EB, r24
    6d78:	90 93 ec 03 	sts	0x03EC, r25
    6d7c:	80 e0       	ldi	r24, 0x00	; 0
    6d7e:	90 e0       	ldi	r25, 0x00	; 0

  /* initialize data for LEDs and WS2803 output pins */
  for(i = 0; i < BUTT_LED_CHANNELS; i++){
    buttLedData[i] = 0;
    6d80:	fc 01       	movw	r30, r24
    6d82:	eb 56       	subi	r30, 0x6B	; 107
    6d84:	fc 4f       	sbci	r31, 0xFC	; 252
    6d86:	10 82       	st	Z, r1
    6d88:	01 96       	adiw	r24, 0x01	; 1

  /* initialize displayBuffer */
  displayBuffer = (char*)malloc(DISPLAY_BUFFER_SIZE * sizeof(char));

  /* initialize data for LEDs and WS2803 output pins */
  for(i = 0; i < BUTT_LED_CHANNELS; i++){
    6d8a:	80 33       	cpi	r24, 0x30	; 48
    6d8c:	91 05       	cpc	r25, r1
    6d8e:	c1 f7       	brne	.-16     	; 0x6d80 <main+0x16e>
    buttLedData[i] = 0;
  }
  DDRC |= (1 << WS2803_CKI) | (1 << WS2803_SDI);
    6d90:	87 b1       	in	r24, 0x07	; 7
    6d92:	80 6c       	ori	r24, 0xC0	; 192
    6d94:	87 b9       	out	0x07, r24	; 7
  PORTC |= (1 << WS2803_CKI) | (1 << WS2803_SDI);
    6d96:	88 b1       	in	r24, 0x08	; 8
    6d98:	80 6c       	ori	r24, 0xC0	; 192
    6d9a:	88 b9       	out	0x08, r24	; 8

  /* initialize PORTA as output for motor Step/Direction */
  DDRA  = 0xFF;
    6d9c:	8f ef       	ldi	r24, 0xFF	; 255
    6d9e:	81 b9       	out	0x01, r24	; 1
  PORTA = 0;
    6da0:	12 b8       	out	0x02, r1	; 2

  //lcd_init();
  //lcd_home();

  /* OLED setup */
  OLEDinit(OLED_V2);
    6da2:	82 e0       	ldi	r24, 0x02	; 2
    6da4:	0e 94 87 3b 	call	0x770e	; 0x770e <OLEDinit>
    6da8:	28 e8       	ldi	r18, 0x88	; 136
    6daa:	33 e1       	ldi	r19, 0x13	; 19
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    6dac:	44 ef       	ldi	r20, 0xF4	; 244
    6dae:	51 e0       	ldi	r21, 0x01	; 1
    6db0:	ca 01       	movw	r24, r20
    6db2:	01 97       	sbiw	r24, 0x01	; 1
    6db4:	f1 f7       	brne	.-4      	; 0x6db2 <main+0x1a0>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    6db6:	21 50       	subi	r18, 0x01	; 1
    6db8:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6dba:	d1 f7       	brne	.-12     	; 0x6db0 <main+0x19e>
  _delay_ms(500);
  OLEDclear();
    6dbc:	0e 94 d5 3a 	call	0x75aa	; 0x75aa <OLEDclear>
  OLEDsetCursor(0, 0);
    6dc0:	80 e0       	ldi	r24, 0x00	; 0
    6dc2:	60 e0       	ldi	r22, 0x00	; 0
    6dc4:	0e 94 74 3a 	call	0x74e8	; 0x74e8 <OLEDsetCursor>
   - 8 bit character size
   - no flow control
  */

  /* set baud rate registers */
  UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
    6dc8:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = (uint8_t)(UBRR_VALUE & 0xFF);
    6dcc:	85 e1       	ldi	r24, 0x15	; 21
    6dce:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B |= (1<<TXEN0) | (1<<RXEN0)        /* enable RX and TX */
    6dd2:	80 91 c1 00 	lds	r24, 0x00C1
    6dd6:	88 69       	ori	r24, 0x98	; 152
    6dd8:	80 93 c1 00 	sts	0x00C1, r24
  OLEDclear();
  OLEDsetCursor(0, 0);

  initUSART();

  initDataStructs();  /* must be the first function after reset! */
    6ddc:	0e 94 40 03 	call	0x680	; 0x680 <initDataStructs>
  initBuffers();
    6de0:	0e 94 93 2b 	call	0x5726	; 0x5726 <initBuffers>
/* ---------------------------------------------------------------------
   initialize I2C system
 --------------------------------------------------------------------- */
void initIIC(void){

  TWBR = TWBR_VALUE;    /* see macro above */
    6de4:	81 e1       	ldi	r24, 0x11	; 17
    6de6:	80 93 b8 00 	sts	0x00B8, r24
  TWSR &= ~((1<<TWPS0) | (1<<TWPS1));
    6dea:	80 91 b9 00 	lds	r24, 0x00B9
    6dee:	8c 7f       	andi	r24, 0xFC	; 252
    6df0:	80 93 b9 00 	sts	0x00B9, r24
  TWCR = (1<<TWEN);
    6df4:	84 e0       	ldi	r24, 0x04	; 4
    6df6:	80 93 bc 00 	sts	0x00BC, r24
  initBuffers();
  //initADC();
  initIIC();
  
RESET:
  initDataStructs();  /* must be the first function after reset! */ 
    6dfa:	0e 94 40 03 	call	0x680	; 0x680 <initDataStructs>
  initMotorDelayTimer();
    6dfe:	0e 94 c3 05 	call	0xb86	; 0xb86 <initMotorDelayTimer>
  initManualOperatingButtons();
    6e02:	0e 94 c8 0c 	call	0x1990	; 0x1990 <initManualOperatingButtons>
  
  /* TODO: detect motors if connected */
  
  loadConfigFromEEPROM();
    6e06:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <loadConfigFromEEPROM>
    6e0a:	10 e0       	ldi	r17, 0x00	; 0

  /* init all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    initPortExpander(getPortExpanderAddress(i));
    6e0c:	81 2f       	mov	r24, r17
    6e0e:	0e 94 31 0a 	call	0x1462	; 0x1462 <getPortExpanderAddress>
    6e12:	0e 94 55 0a 	call	0x14aa	; 0x14aa <initPortExpander>
    initDAC(i);
    6e16:	81 2f       	mov	r24, r17
    6e18:	0e 94 8a 0c 	call	0x1914	; 0x1914 <initDAC>
  /* TODO: detect motors if connected */
  
  loadConfigFromEEPROM();

  /* init all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    6e1c:	1f 5f       	subi	r17, 0xFF	; 255
    6e1e:	14 30       	cpi	r17, 0x04	; 4
    6e20:	a9 f7       	brne	.-22     	; 0x6e0c <main+0x1fa>
    initPortExpander(getPortExpanderAddress(i));
    initDAC(i);
  }
  
  updateIICvalues();
    6e22:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <updateIICvalues>
  
  /* turn on all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorState(i, ON);
    6e26:	80 e0       	ldi	r24, 0x00	; 0
    6e28:	61 e0       	ldi	r22, 0x01	; 1
    6e2a:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
    6e2e:	81 e0       	ldi	r24, 0x01	; 1
    6e30:	61 e0       	ldi	r22, 0x01	; 1
    6e32:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
    6e36:	82 e0       	ldi	r24, 0x02	; 2
    6e38:	61 e0       	ldi	r22, 0x01	; 1
    6e3a:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
    6e3e:	83 e0       	ldi	r24, 0x03	; 3
    6e40:	61 e0       	ldi	r22, 0x01	; 1
    6e42:	0e 94 cd 0b 	call	0x179a	; 0x179a <setMotorState>
  }

  updateMenu();
    6e46:	0e 94 c7 2e 	call	0x5d8e	; 0x5d8e <updateMenu>
  
  updateDisplay();
    6e4a:	0e 94 37 2d 	call	0x5a6e	; 0x5a6e <updateDisplay>
  /*
  for(i = 0; i < 4; i++){
    changeButtonLED(i, GREEN, 0x0F);
  }
  */
  changeButtonLED(LED_MESC, RED, 0x0F);
    6e4e:	84 e0       	ldi	r24, 0x04	; 4
    6e50:	62 e0       	ldi	r22, 0x02	; 2
    6e52:	4f e0       	ldi	r20, 0x0F	; 15
    6e54:	0e 94 e5 06 	call	0xdca	; 0xdca <changeButtonLED>
  //updateLEDs();
  updateMotorButtonLEDs();
    6e58:	0e 94 7d 07 	call	0xefa	; 0xefa <updateMotorButtonLEDs>
  
  commandCode = 0x80;

  sei();  /* turn on interrupts */
    6e5c:	78 94       	sei

  /* start the never ending story */
  for(;;){

    /* check for manual done changes */
    updateMenu();
    6e5e:	0e 94 c7 2e 	call	0x5d8e	; 0x5d8e <updateMenu>

    /* check for changed values and update them on the display */
    updateDisplay();
    6e62:	0e 94 37 2d 	call	0x5a6e	; 0x5a6e <updateDisplay>
    
    //updateMotorButtonLEDs();

    /* check for new received command */
    if(rxString.readyToProcess){
    6e66:	80 91 f0 02 	lds	r24, 0x02F0
    6e6a:	88 23       	and	r24, r24
    6e6c:	c1 f3       	breq	.-16     	; 0x6e5e <main+0x24c>
      copyRXstring();
    6e6e:	0e 94 06 2c 	call	0x580c	; 0x580c <copyRXstring>
      commandCode = parseCommand();
    6e72:	0e 94 9b 24 	call	0x4936	; 0x4936 <parseCommand>
    }

    switch(commandCode){
    6e76:	90 e0       	ldi	r25, 0x00	; 0
    6e78:	fc 01       	movw	r30, r24
    6e7a:	e1 58       	subi	r30, 0x81	; 129
    6e7c:	f0 40       	sbci	r31, 0x00	; 0
    6e7e:	e4 32       	cpi	r30, 0x24	; 36
    6e80:	f1 05       	cpc	r31, r1
    6e82:	68 f7       	brcc	.-38     	; 0x6e5e <main+0x24c>
    6e84:	ea 5b       	subi	r30, 0xBA	; 186
    6e86:	ff 4f       	sbci	r31, 0xFF	; 255
    6e88:	ee 0f       	add	r30, r30
    6e8a:	ff 1f       	adc	r31, r31
    6e8c:	05 90       	lpm	r0, Z+
    6e8e:	f4 91       	lpm	r31, Z+
    6e90:	e0 2d       	mov	r30, r0
    6e92:	09 94       	ijmp
      case 0xA2:    /* GETDECAY */
        sendText(commandGetMotorDecay(commandParam[1]));
        break;

      case 0xA3:    /* SETDECAY */
        commandSetMotorDecay(commandParam[1], commandParam[2]);
    6e94:	e0 91 d6 02 	lds	r30, 0x02D6
    6e98:	f0 91 d7 02 	lds	r31, 0x02D7
    6e9c:	64 81       	ldd	r22, Z+4	; 0x04
    6e9e:	75 81       	ldd	r23, Z+5	; 0x05
    6ea0:	82 81       	ldd	r24, Z+2	; 0x02
    6ea2:	93 81       	ldd	r25, Z+3	; 0x03
    6ea4:	0e 94 43 26 	call	0x4c86	; 0x4c86 <commandSetMotorDecay>
    6ea8:	da cf       	rjmp	.-76     	; 0x6e5e <main+0x24c>
      case 0xA1:    /* SETCURR */
        commandSetMotorCurrent(commandParam[1], commandParam[2]);
        break;
        
      case 0xA2:    /* GETDECAY */
        sendText(commandGetMotorDecay(commandParam[1]));
    6eaa:	e0 91 d6 02 	lds	r30, 0x02D6
    6eae:	f0 91 d7 02 	lds	r31, 0x02D7
    6eb2:	82 81       	ldd	r24, Z+2	; 0x02
    6eb4:	93 81       	ldd	r25, Z+3	; 0x03
    6eb6:	0e 94 ef 16 	call	0x2dde	; 0x2dde <commandGetMotorDecay>
    6eba:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    6ebe:	cf cf       	rjmp	.-98     	; 0x6e5e <main+0x24c>
      case 0xA0:    /* GETCURR */
        sendText(commandGetMotorCurrent(commandParam[1]));
        break;

      case 0xA1:    /* SETCURR */
        commandSetMotorCurrent(commandParam[1], commandParam[2]);
    6ec0:	e0 91 d6 02 	lds	r30, 0x02D6
    6ec4:	f0 91 d7 02 	lds	r31, 0x02D7
    6ec8:	64 81       	ldd	r22, Z+4	; 0x04
    6eca:	75 81       	ldd	r23, Z+5	; 0x05
    6ecc:	82 81       	ldd	r24, Z+2	; 0x02
    6ece:	93 81       	ldd	r25, Z+3	; 0x03
    6ed0:	0e 94 76 2c 	call	0x58ec	; 0x58ec <commandSetMotorCurrent>
    6ed4:	c4 cf       	rjmp	.-120    	; 0x6e5e <main+0x24c>
      case 0x9F:    /* LED */
        commandLED(commandParam[1], commandParam[2], commandParam[3]);
        break;
		
      case 0xA0:    /* GETCURR */
        sendText(commandGetMotorCurrent(commandParam[1]));
    6ed6:	e0 91 d6 02 	lds	r30, 0x02D6
    6eda:	f0 91 d7 02 	lds	r31, 0x02D7
    6ede:	82 81       	ldd	r24, Z+2	; 0x02
    6ee0:	93 81       	ldd	r25, Z+3	; 0x03
    6ee2:	0e 94 58 17 	call	0x2eb0	; 0x2eb0 <commandGetMotorCurrent>
    6ee6:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    6eea:	b9 cf       	rjmp	.-142    	; 0x6e5e <main+0x24c>
      case 0x9E:
        commandDebugReadout();
        break;

      case 0x9F:    /* LED */
        commandLED(commandParam[1], commandParam[2], commandParam[3]);
    6eec:	e0 91 d6 02 	lds	r30, 0x02D6
    6ef0:	f0 91 d7 02 	lds	r31, 0x02D7
    6ef4:	64 81       	ldd	r22, Z+4	; 0x04
    6ef6:	75 81       	ldd	r23, Z+5	; 0x05
    6ef8:	46 81       	ldd	r20, Z+6	; 0x06
    6efa:	57 81       	ldd	r21, Z+7	; 0x07
    6efc:	82 81       	ldd	r24, Z+2	; 0x02
    6efe:	93 81       	ldd	r25, Z+3	; 0x03
    6f00:	0e 94 36 25 	call	0x4a6c	; 0x4a6c <commandLED>
    6f04:	ac cf       	rjmp	.-168    	; 0x6e5e <main+0x24c>
      case 0x9D:    /* GETMOTSTATE */
        commandGetMotorState(commandParam[1]);
        break;

      case 0x9E:
        commandDebugReadout();
    6f06:	0e 94 92 25 	call	0x4b24	; 0x4b24 <commandDebugReadout>
    6f0a:	a9 cf       	rjmp	.-174    	; 0x6e5e <main+0x24c>
        commandSetProgStep(commandParam[1], commandParam[2], commandParam[3],
                           commandParam[4], commandParam[5], commandParam[6]);
        break;

      case 0x9D:    /* GETMOTSTATE */
        commandGetMotorState(commandParam[1]);
    6f0c:	e0 91 d6 02 	lds	r30, 0x02D6
    6f10:	f0 91 d7 02 	lds	r31, 0x02D7
    6f14:	82 81       	ldd	r24, Z+2	; 0x02
    6f16:	93 81       	ldd	r25, Z+3	; 0x03
    6f18:	0e 94 ab 26 	call	0x4d56	; 0x4d56 <commandGetMotorState>
    6f1c:	a0 cf       	rjmp	.-192    	; 0x6e5e <main+0x24c>
      case 0x9B:    /* ENABFORBZONE */
        commandEnableForbiddenZone(commandParam[1], commandParam[2]);
        break;

      case 0x9C:    /* SETPROGSTEP */
        commandSetProgStep(commandParam[1], commandParam[2], commandParam[3],
    6f1e:	e0 91 d6 02 	lds	r30, 0x02D6
    6f22:	f0 91 d7 02 	lds	r31, 0x02D7
    6f26:	64 81       	ldd	r22, Z+4	; 0x04
    6f28:	75 81       	ldd	r23, Z+5	; 0x05
    6f2a:	46 81       	ldd	r20, Z+6	; 0x06
    6f2c:	57 81       	ldd	r21, Z+7	; 0x07
    6f2e:	20 85       	ldd	r18, Z+8	; 0x08
    6f30:	31 85       	ldd	r19, Z+9	; 0x09
    6f32:	02 85       	ldd	r16, Z+10	; 0x0a
    6f34:	13 85       	ldd	r17, Z+11	; 0x0b
    6f36:	e4 84       	ldd	r14, Z+12	; 0x0c
    6f38:	f5 84       	ldd	r15, Z+13	; 0x0d
    6f3a:	82 81       	ldd	r24, Z+2	; 0x02
    6f3c:	93 81       	ldd	r25, Z+3	; 0x03
    6f3e:	0e 94 1b 22 	call	0x4436	; 0x4436 <commandSetProgStep>
    6f42:	8d cf       	rjmp	.-230    	; 0x6e5e <main+0x24c>
      case 0x9A:    /* SETFORBZONE */
        commandSetForbiddenZone(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x9B:    /* ENABFORBZONE */
        commandEnableForbiddenZone(commandParam[1], commandParam[2]);
    6f44:	e0 91 d6 02 	lds	r30, 0x02D6
    6f48:	f0 91 d7 02 	lds	r31, 0x02D7
    6f4c:	64 81       	ldd	r22, Z+4	; 0x04
    6f4e:	75 81       	ldd	r23, Z+5	; 0x05
    6f50:	82 81       	ldd	r24, Z+2	; 0x02
    6f52:	93 81       	ldd	r25, Z+3	; 0x03
    6f54:	0e 94 f1 26 	call	0x4de2	; 0x4de2 <commandEnableForbiddenZone>
    6f58:	82 cf       	rjmp	.-252    	; 0x6e5e <main+0x24c>
          }
        }
        break;

      case 0x9A:    /* SETFORBZONE */
        commandSetForbiddenZone(commandParam[1], commandParam[2], commandParam[3]);
    6f5a:	e0 91 d6 02 	lds	r30, 0x02D6
    6f5e:	f0 91 d7 02 	lds	r31, 0x02D7
    6f62:	64 81       	ldd	r22, Z+4	; 0x04
    6f64:	75 81       	ldd	r23, Z+5	; 0x05
    6f66:	46 81       	ldd	r20, Z+6	; 0x06
    6f68:	57 81       	ldd	r21, Z+7	; 0x07
    6f6a:	82 81       	ldd	r24, Z+2	; 0x02
    6f6c:	93 81       	ldd	r25, Z+3	; 0x03
    6f6e:	0e 94 27 27 	call	0x4e4e	; 0x4e4e <commandSetForbiddenZone>
    6f72:	75 cf       	rjmp	.-278    	; 0x6e5e <main+0x24c>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    6f74:	f8 94       	cli
    6f76:	40 e0       	ldi	r20, 0x00	; 0
    6f78:	50 e0       	ldi	r21, 0x00	; 0
        break;

      case 0x99:    /* STOPALL */
        ATOMIC_BLOCK(ATOMIC_FORCEON){
          for(i = 0; i <= MAX_MOTOR; i++){
            motor[i].desiredPosition = motor[i].actualPosition;
    6f7a:	fa 01       	movw	r30, r20
    6f7c:	ee 0f       	add	r30, r30
    6f7e:	ff 1f       	adc	r31, r31
    6f80:	ee 0f       	add	r30, r30
    6f82:	ff 1f       	adc	r31, r31
    6f84:	ee 0f       	add	r30, r30
    6f86:	ff 1f       	adc	r31, r31
    6f88:	cf 01       	movw	r24, r30
    6f8a:	88 0f       	add	r24, r24
    6f8c:	99 1f       	adc	r25, r25
    6f8e:	88 0f       	add	r24, r24
    6f90:	99 1f       	adc	r25, r25
    6f92:	e8 0f       	add	r30, r24
    6f94:	f9 1f       	adc	r31, r25
    6f96:	e0 51       	subi	r30, 0x10	; 16
    6f98:	fc 4f       	sbci	r31, 0xFC	; 252
    6f9a:	20 81       	ld	r18, Z
    6f9c:	31 81       	ldd	r19, Z+1	; 0x01
    6f9e:	fa 01       	movw	r30, r20
    6fa0:	ee 0f       	add	r30, r30
    6fa2:	ff 1f       	adc	r31, r31
    6fa4:	ee 0f       	add	r30, r30
    6fa6:	ff 1f       	adc	r31, r31
    6fa8:	cf 01       	movw	r24, r30
    6faa:	88 0f       	add	r24, r24
    6fac:	99 1f       	adc	r25, r25
    6fae:	88 0f       	add	r24, r24
    6fb0:	99 1f       	adc	r25, r25
    6fb2:	e8 0f       	add	r30, r24
    6fb4:	f9 1f       	adc	r31, r25
    6fb6:	ee 0f       	add	r30, r30
    6fb8:	ff 1f       	adc	r31, r31
    6fba:	ee 50       	subi	r30, 0x0E	; 14
    6fbc:	fc 4f       	sbci	r31, 0xFC	; 252
    6fbe:	31 83       	std	Z+1, r19	; 0x01
    6fc0:	20 83       	st	Z, r18
            motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    6fc2:	fa 01       	movw	r30, r20
    6fc4:	ee 0f       	add	r30, r30
    6fc6:	ff 1f       	adc	r31, r31
    6fc8:	ee 0f       	add	r30, r30
    6fca:	ff 1f       	adc	r31, r31
    6fcc:	ee 0f       	add	r30, r30
    6fce:	ff 1f       	adc	r31, r31
    6fd0:	cf 01       	movw	r24, r30
    6fd2:	88 0f       	add	r24, r24
    6fd4:	99 1f       	adc	r25, r25
    6fd6:	88 0f       	add	r24, r24
    6fd8:	99 1f       	adc	r25, r25
    6fda:	e8 0f       	add	r30, r24
    6fdc:	f9 1f       	adc	r31, r25
    6fde:	e0 51       	subi	r30, 0x10	; 16
    6fe0:	fc 4f       	sbci	r31, 0xFC	; 252
    6fe2:	14 86       	std	Z+12, r1	; 0x0c
    6fe4:	4f 5f       	subi	r20, 0xFF	; 255
    6fe6:	5f 4f       	sbci	r21, 0xFF	; 255
        goto RESET;
        break;

      case 0x99:    /* STOPALL */
        ATOMIC_BLOCK(ATOMIC_FORCEON){
          for(i = 0; i <= MAX_MOTOR; i++){
    6fe8:	44 30       	cpi	r20, 0x04	; 4
    6fea:	51 05       	cpc	r21, r1
    6fec:	31 f6       	brne	.-116    	; 0x6f7a <main+0x368>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    6fee:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    6ff0:	36 cf       	rjmp	.-404    	; 0x6e5e <main+0x24c>
      case 0x97:    /* SETCONSTSPEED */
        commandSetConstSpeed(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x98:    /* FACTORYRESET */
        commandFactoryReset();
    6ff2:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <commandFactoryReset>
        cli();
    6ff6:	f8 94       	cli
        prepareReset();
    6ff8:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <prepareReset>
    6ffc:	fe ce       	rjmp	.-516    	; 0x6dfa <main+0x1e8>
      case 0x96:    /* SETWAITTIME */
        commandSetWaitTime(commandParam[1], commandParam[2]);
        break;

      case 0x97:    /* SETCONSTSPEED */
        commandSetConstSpeed(commandParam[1], commandParam[2], commandParam[3]);
    6ffe:	e0 91 d6 02 	lds	r30, 0x02D6
    7002:	f0 91 d7 02 	lds	r31, 0x02D7
    7006:	64 81       	ldd	r22, Z+4	; 0x04
    7008:	75 81       	ldd	r23, Z+5	; 0x05
    700a:	46 81       	ldd	r20, Z+6	; 0x06
    700c:	57 81       	ldd	r21, Z+7	; 0x07
    700e:	82 81       	ldd	r24, Z+2	; 0x02
    7010:	93 81       	ldd	r25, Z+3	; 0x03
    7012:	0e 94 88 27 	call	0x4f10	; 0x4f10 <commandSetConstSpeed>
    7016:	23 cf       	rjmp	.-442    	; 0x6e5e <main+0x24c>
      case 0x95:    /* GETWAITTIME */
        sendText(commandGetWaitTime(commandParam[1]));
        break;

      case 0x96:    /* SETWAITTIME */
        commandSetWaitTime(commandParam[1], commandParam[2]);
    7018:	e0 91 d6 02 	lds	r30, 0x02D6
    701c:	f0 91 d7 02 	lds	r31, 0x02D7
    7020:	64 81       	ldd	r22, Z+4	; 0x04
    7022:	75 81       	ldd	r23, Z+5	; 0x05
    7024:	82 81       	ldd	r24, Z+2	; 0x02
    7026:	93 81       	ldd	r25, Z+3	; 0x03
    7028:	0e 94 e4 28 	call	0x51c8	; 0x51c8 <commandSetWaitTime>
    702c:	18 cf       	rjmp	.-464    	; 0x6e5e <main+0x24c>
      case 0x94:    /* SETSUBSTEPS */
        commandSetSubSteps(commandParam[1], commandParam[2]);
        break;

      case 0x95:    /* GETWAITTIME */
        sendText(commandGetWaitTime(commandParam[1]));
    702e:	e0 91 d6 02 	lds	r30, 0x02D6
    7032:	f0 91 d7 02 	lds	r31, 0x02D7
    7036:	82 81       	ldd	r24, Z+2	; 0x02
    7038:	93 81       	ldd	r25, Z+3	; 0x03
    703a:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <commandGetWaitTime>
    703e:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    7042:	0d cf       	rjmp	.-486    	; 0x6e5e <main+0x24c>
      case 0x93:    /* GETSUBSTEPS */
        sendText(commandGetSubSteps(commandParam[1]));
        break;

      case 0x94:    /* SETSUBSTEPS */
        commandSetSubSteps(commandParam[1], commandParam[2]);
    7044:	e0 91 d6 02 	lds	r30, 0x02D6
    7048:	f0 91 d7 02 	lds	r31, 0x02D7
    704c:	64 81       	ldd	r22, Z+4	; 0x04
    704e:	75 81       	ldd	r23, Z+5	; 0x05
    7050:	82 81       	ldd	r24, Z+2	; 0x02
    7052:	93 81       	ldd	r25, Z+3	; 0x03
    7054:	0e 94 1e 29 	call	0x523c	; 0x523c <commandSetSubSteps>
    7058:	02 cf       	rjmp	.-508    	; 0x6e5e <main+0x24c>
      case 0x92:    /* SETFULLROT */
        commandSetFullRotation(commandParam[1], commandParam[2]);
        break;

      case 0x93:    /* GETSUBSTEPS */
        sendText(commandGetSubSteps(commandParam[1]));
    705a:	e0 91 d6 02 	lds	r30, 0x02D6
    705e:	f0 91 d7 02 	lds	r31, 0x02D7
    7062:	82 81       	ldd	r24, Z+2	; 0x02
    7064:	93 81       	ldd	r25, Z+3	; 0x03
    7066:	0e 94 1d 18 	call	0x303a	; 0x303a <commandGetSubSteps>
    706a:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    706e:	f7 ce       	rjmp	.-530    	; 0x6e5e <main+0x24c>
      case 0x91:    /* GETFULLROT */
        sendText(commandGetFullRotation(commandParam[1]));
        break;

      case 0x92:    /* SETFULLROT */
        commandSetFullRotation(commandParam[1], commandParam[2]);
    7070:	e0 91 d6 02 	lds	r30, 0x02D6
    7074:	f0 91 d7 02 	lds	r31, 0x02D7
    7078:	64 81       	ldd	r22, Z+4	; 0x04
    707a:	75 81       	ldd	r23, Z+5	; 0x05
    707c:	82 81       	ldd	r24, Z+2	; 0x02
    707e:	93 81       	ldd	r25, Z+3	; 0x03
    7080:	0e 94 67 29 	call	0x52ce	; 0x52ce <commandSetFullRotation>
    7084:	ec ce       	rjmp	.-552    	; 0x6e5e <main+0x24c>
      case 0x90:    /* SETGEARRATIO */
        commandSetGearRatio(commandParam[1], commandParam[2]);
        break;

      case 0x91:    /* GETFULLROT */
        sendText(commandGetFullRotation(commandParam[1]));
    7086:	e0 91 d6 02 	lds	r30, 0x02D6
    708a:	f0 91 d7 02 	lds	r31, 0x02D7
    708e:	82 81       	ldd	r24, Z+2	; 0x02
    7090:	93 81       	ldd	r25, Z+3	; 0x03
    7092:	0e 94 8d 18 	call	0x311a	; 0x311a <commandGetFullRotation>
    7096:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    709a:	e1 ce       	rjmp	.-574    	; 0x6e5e <main+0x24c>
      case 0x8F:    /* GETGEARRATIO */
        sendText(commandGetGearRatio(commandParam[1]));
        break;

      case 0x90:    /* SETGEARRATIO */
        commandSetGearRatio(commandParam[1], commandParam[2]);
    709c:	e0 91 d6 02 	lds	r30, 0x02D6
    70a0:	f0 91 d7 02 	lds	r31, 0x02D7
    70a4:	64 81       	ldd	r22, Z+4	; 0x04
    70a6:	75 81       	ldd	r23, Z+5	; 0x05
    70a8:	82 81       	ldd	r24, Z+2	; 0x02
    70aa:	93 81       	ldd	r25, Z+3	; 0x03
    70ac:	0e 94 bb 29 	call	0x5376	; 0x5376 <commandSetGearRatio>
    70b0:	d6 ce       	rjmp	.-596    	; 0x6e5e <main+0x24c>
      case 0x8E:    /* SETZEROPOS */
        commandSetOptZeroPos(commandParam[1], commandParam[2]);
        break;

      case 0x8F:    /* GETGEARRATIO */
        sendText(commandGetGearRatio(commandParam[1]));
    70b2:	e0 91 d6 02 	lds	r30, 0x02D6
    70b6:	f0 91 d7 02 	lds	r31, 0x02D7
    70ba:	82 81       	ldd	r24, Z+2	; 0x02
    70bc:	93 81       	ldd	r25, Z+3	; 0x03
    70be:	0e 94 fd 18 	call	0x31fa	; 0x31fa <commandGetGearRatio>
    70c2:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    70c6:	cb ce       	rjmp	.-618    	; 0x6e5e <main+0x24c>
      case 0x8D:    /* GETZEROPOS */
        sendText(commandGetOptZeroPos(commandParam[1]));
        break;

      case 0x8E:    /* SETZEROPOS */
        commandSetOptZeroPos(commandParam[1], commandParam[2]);
    70c8:	e0 91 d6 02 	lds	r30, 0x02D6
    70cc:	f0 91 d7 02 	lds	r31, 0x02D7
    70d0:	64 81       	ldd	r22, Z+4	; 0x04
    70d2:	75 81       	ldd	r23, Z+5	; 0x05
    70d4:	82 81       	ldd	r24, Z+2	; 0x02
    70d6:	93 81       	ldd	r25, Z+3	; 0x03
    70d8:	0e 94 0f 2a 	call	0x541e	; 0x541e <commandSetOptZeroPos>
    70dc:	c0 ce       	rjmp	.-640    	; 0x6e5e <main+0x24c>
      case 0x8C:    /* GETANALOG */
        sendText(commandGetAnalog(commandParam[1]));
        break;

      case 0x8D:    /* GETZEROPOS */
        sendText(commandGetOptZeroPos(commandParam[1]));
    70de:	e0 91 d6 02 	lds	r30, 0x02D6
    70e2:	f0 91 d7 02 	lds	r31, 0x02D7
    70e6:	82 81       	ldd	r24, Z+2	; 0x02
    70e8:	93 81       	ldd	r25, Z+3	; 0x03
    70ea:	0e 94 6d 19 	call	0x32da	; 0x32da <commandGetOptZeroPos>
    70ee:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    70f2:	b5 ce       	rjmp	.-662    	; 0x6e5e <main+0x24c>
      case 0x8B:    /* ISMOVING */
        sendText(commandIsMoving(commandParam[1]));
        break;

      case 0x8C:    /* GETANALOG */
        sendText(commandGetAnalog(commandParam[1]));
    70f4:	e0 91 d6 02 	lds	r30, 0x02D6
    70f8:	f0 91 d7 02 	lds	r31, 0x02D7
    70fc:	82 81       	ldd	r24, Z+2	; 0x02
    70fe:	93 81       	ldd	r25, Z+3	; 0x03
    7100:	0e 94 d6 19 	call	0x33ac	; 0x33ac <commandGetAnalog>
    7104:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    7108:	aa ce       	rjmp	.-684    	; 0x6e5e <main+0x24c>
        loadConfigFromEEPROM();
        updateIICvalues();
        break;

      case 0x8B:    /* ISMOVING */
        sendText(commandIsMoving(commandParam[1]));
    710a:	e0 91 d6 02 	lds	r30, 0x02D6
    710e:	f0 91 d7 02 	lds	r31, 0x02D7
    7112:	82 81       	ldd	r24, Z+2	; 0x02
    7114:	93 81       	ldd	r25, Z+3	; 0x03
    7116:	0e 94 82 1a 	call	0x3504	; 0x3504 <commandIsMoving>
    711a:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    711e:	9f ce       	rjmp	.-706    	; 0x6e5e <main+0x24c>
      case 0x89:    /* SAVECONF: save current machine configuration */
        saveConfigToEEPROM();
        break;

      case 0x8A:    /* LOADCONF: load last saved machine configuration */
        loadConfigFromEEPROM();
    7120:	0e 94 0d 0e 	call	0x1c1a	; 0x1c1a <loadConfigFromEEPROM>
        updateIICvalues();
    7124:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <updateIICvalues>
    7128:	9a ce       	rjmp	.-716    	; 0x6e5e <main+0x24c>
      case 0x88:    /* GETPOS --> get position in [unit] */
        sendText(commandGetMotorPosition(commandParam[1], commandParam[2]));
        break;

      case 0x89:    /* SAVECONF: save current machine configuration */
        saveConfigToEEPROM();
    712a:	0e 94 e6 0e 	call	0x1dcc	; 0x1dcc <saveConfigToEEPROM>
    712e:	97 ce       	rjmp	.-722    	; 0x6e5e <main+0x24c>
      case 0x87:    /* ENABLE */
        commandEnable(commandParam[1], commandParam[2]);
        break;

      case 0x88:    /* GETPOS --> get position in [unit] */
        sendText(commandGetMotorPosition(commandParam[1], commandParam[2]));
    7130:	e0 91 d6 02 	lds	r30, 0x02D6
    7134:	f0 91 d7 02 	lds	r31, 0x02D7
    7138:	64 81       	ldd	r22, Z+4	; 0x04
    713a:	75 81       	ldd	r23, Z+5	; 0x05
    713c:	82 81       	ldd	r24, Z+2	; 0x02
    713e:	93 81       	ldd	r25, Z+3	; 0x03
    7140:	0e 94 51 23 	call	0x46a2	; 0x46a2 <commandGetMotorPosition>
    7144:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    7148:	8a ce       	rjmp	.-748    	; 0x6e5e <main+0x24c>
      case 0x86:    /* ZERORUN */
        motorZeroRun((uint8_t)atoi(commandParam[1]));
        break;

      case 0x87:    /* ENABLE */
        commandEnable(commandParam[1], commandParam[2]);
    714a:	e0 91 d6 02 	lds	r30, 0x02D6
    714e:	f0 91 d7 02 	lds	r31, 0x02D7
    7152:	64 81       	ldd	r22, Z+4	; 0x04
    7154:	75 81       	ldd	r23, Z+5	; 0x05
    7156:	82 81       	ldd	r24, Z+2	; 0x02
    7158:	93 81       	ldd	r25, Z+3	; 0x03
    715a:	0e 94 c0 16 	call	0x2d80	; 0x2d80 <commandEnable>
    715e:	7f ce       	rjmp	.-770    	; 0x6e5e <main+0x24c>
      case 0x85:    /* MOVEREL */
        commandMoveRel(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x86:    /* ZERORUN */
        motorZeroRun((uint8_t)atoi(commandParam[1]));
    7160:	e0 91 d6 02 	lds	r30, 0x02D6
    7164:	f0 91 d7 02 	lds	r31, 0x02D7
    7168:	82 81       	ldd	r24, Z+2	; 0x02
    716a:	93 81       	ldd	r25, Z+3	; 0x03
    716c:	0e 94 4c 44 	call	0x8898	; 0x8898 <atoi>
    7170:	0e 94 c4 15 	call	0x2b88	; 0x2b88 <motorZeroRun>
    7174:	74 ce       	rjmp	.-792    	; 0x6e5e <main+0x24c>
      case 0x84:    /* MOVEABS */
        commandMoveAbs(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x85:    /* MOVEREL */
        commandMoveRel(commandParam[1], commandParam[2], commandParam[3]);
    7176:	e0 91 d6 02 	lds	r30, 0x02D6
    717a:	f0 91 d7 02 	lds	r31, 0x02D7
    717e:	64 81       	ldd	r22, Z+4	; 0x04
    7180:	75 81       	ldd	r23, Z+5	; 0x05
    7182:	46 81       	ldd	r20, Z+6	; 0x06
    7184:	57 81       	ldd	r21, Z+7	; 0x07
    7186:	82 81       	ldd	r24, Z+2	; 0x02
    7188:	93 81       	ldd	r25, Z+3	; 0x03
    718a:	0e 94 67 2a 	call	0x54ce	; 0x54ce <commandMoveRel>
    718e:	67 ce       	rjmp	.-818    	; 0x6e5e <main+0x24c>
        }
        eeprom_update_block((const void*)commandParam[1], (void*)IDNtext, IDN_STRING_LENGTH + 1);
        break;

      case 0x84:    /* MOVEABS */
        commandMoveAbs(commandParam[1], commandParam[2], commandParam[3]);
    7190:	e0 91 d6 02 	lds	r30, 0x02D6
    7194:	f0 91 d7 02 	lds	r31, 0x02D7
    7198:	64 81       	ldd	r22, Z+4	; 0x04
    719a:	75 81       	ldd	r23, Z+5	; 0x05
    719c:	46 81       	ldd	r20, Z+6	; 0x06
    719e:	57 81       	ldd	r21, Z+7	; 0x07
    71a0:	82 81       	ldd	r24, Z+2	; 0x02
    71a2:	93 81       	ldd	r25, Z+3	; 0x03
    71a4:	0e 94 e9 2a 	call	0x55d2	; 0x55d2 <commandMoveAbs>
    71a8:	5a ce       	rjmp	.-844    	; 0x6e5e <main+0x24c>
        eeprom_read_block((void*)txString.buffer, (const void*)IDNtext, IDN_STRING_LENGTH + 1);
        sendText(txString.buffer);
        break;

      case 0x83:    /* set IDN */
        if(strlen(commandParam[1]) > IDN_STRING_LENGTH){
    71aa:	e0 91 d6 02 	lds	r30, 0x02D6
    71ae:	f0 91 d7 02 	lds	r31, 0x02D7
    71b2:	82 81       	ldd	r24, Z+2	; 0x02
    71b4:	93 81       	ldd	r25, Z+3	; 0x03
    71b6:	dc 01       	movw	r26, r24
    71b8:	fd 01       	movw	r30, r26
    71ba:	01 90       	ld	r0, Z+
    71bc:	00 20       	and	r0, r0
    71be:	e9 f7       	brne	.-6      	; 0x71ba <main+0x5a8>
    71c0:	31 97       	sbiw	r30, 0x01	; 1
    71c2:	ea 1b       	sub	r30, r26
    71c4:	fb 0b       	sbc	r31, r27
    71c6:	f3 97       	sbiw	r30, 0x33	; 51
    71c8:	08 f0       	brcs	.+2      	; 0x71cc <main+0x5ba>
    71ca:	49 ce       	rjmp	.-878    	; 0x6e5e <main+0x24c>
          break;
        }
        eeprom_update_block((const void*)commandParam[1], (void*)IDNtext, IDN_STRING_LENGTH + 1);
    71cc:	60 e0       	ldi	r22, 0x00	; 0
    71ce:	70 e0       	ldi	r23, 0x00	; 0
    71d0:	43 e3       	ldi	r20, 0x33	; 51
    71d2:	50 e0       	ldi	r21, 0x00	; 0
    71d4:	0e 94 76 46 	call	0x8cec	; 0x8cec <__eeupd_block_m1284p>
    71d8:	42 ce       	rjmp	.-892    	; 0x6e5e <main+0x24c>
        prepareReset();
        goto RESET;
        break;

      case 0x82:    /* *IDN? */
        eeprom_read_block((void*)txString.buffer, (const void*)IDNtext, IDN_STRING_LENGTH + 1);
    71da:	80 91 e7 03 	lds	r24, 0x03E7
    71de:	90 91 e8 03 	lds	r25, 0x03E8
    71e2:	60 e0       	ldi	r22, 0x00	; 0
    71e4:	70 e0       	ldi	r23, 0x00	; 0
    71e6:	43 e3       	ldi	r20, 0x33	; 51
    71e8:	50 e0       	ldi	r21, 0x00	; 0
    71ea:	0e 94 66 46 	call	0x8ccc	; 0x8ccc <__eerd_block_m1284p>
        sendText(txString.buffer);
    71ee:	80 91 e7 03 	lds	r24, 0x03E7
    71f2:	90 91 e8 03 	lds	r25, 0x03E8
    71f6:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    71fa:	31 ce       	rjmp	.-926    	; 0x6e5e <main+0x24c>
      case 0x80:    /* no or unknown command, ignore it */
        break;

      case 0x81:    /* *RST */
        //sendText("reset\0");
        cli();
    71fc:	f8 94       	cli
        prepareReset();
    71fe:	0e 94 f9 0b 	call	0x17f2	; 0x17f2 <prepareReset>
    7202:	fb cd       	rjmp	.-1034   	; 0x6dfa <main+0x1e8>
      case 0xA3:    /* SETDECAY */
        commandSetMotorDecay(commandParam[1], commandParam[2]);
        break;
        
      case 0xA4:    /* ISCON */
        sendText(commandIsConnected(commandParam[1]));
    7204:	e0 91 d6 02 	lds	r30, 0x02D6
    7208:	f0 91 d7 02 	lds	r31, 0x02D7
    720c:	82 81       	ldd	r24, Z+2	; 0x02
    720e:	93 81       	ldd	r25, Z+3	; 0x03
    7210:	0e 94 2d 1a 	call	0x345a	; 0x345a <commandIsConnected>
    7214:	0e 94 17 25 	call	0x4a2e	; 0x4a2e <sendText>
    7218:	22 ce       	rjmp	.-956    	; 0x6e5e <main+0x24c>

0000721a <OLEDpinMode>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDpinMode(uint8_t pin, uint8_t mode){
    721a:	38 2f       	mov	r19, r24

  if (mode) {
    721c:	66 23       	and	r22, r22
    721e:	61 f4       	brne	.+24     	; 0x7238 <OLEDpinMode+0x1e>
    LCD_DDR |= (1 << pin);
  } //output
  else {
    LCD_DDR &= ~(1 << pin);
    7220:	24 b1       	in	r18, 0x04	; 4
    7222:	81 e0       	ldi	r24, 0x01	; 1
    7224:	90 e0       	ldi	r25, 0x00	; 0
    7226:	02 c0       	rjmp	.+4      	; 0x722c <OLEDpinMode+0x12>
    7228:	88 0f       	add	r24, r24
    722a:	99 1f       	adc	r25, r25
    722c:	3a 95       	dec	r19
    722e:	e2 f7       	brpl	.-8      	; 0x7228 <OLEDpinMode+0xe>
    7230:	80 95       	com	r24
    7232:	82 23       	and	r24, r18
    7234:	84 b9       	out	0x04, r24	; 4
    7236:	08 95       	ret
    unknown
 --------------------------------------------------------------------- */
void OLEDpinMode(uint8_t pin, uint8_t mode){

  if (mode) {
    LCD_DDR |= (1 << pin);
    7238:	24 b1       	in	r18, 0x04	; 4
    723a:	81 e0       	ldi	r24, 0x01	; 1
    723c:	90 e0       	ldi	r25, 0x00	; 0
    723e:	02 c0       	rjmp	.+4      	; 0x7244 <OLEDpinMode+0x2a>
    7240:	88 0f       	add	r24, r24
    7242:	99 1f       	adc	r25, r25
    7244:	3a 95       	dec	r19
    7246:	e2 f7       	brpl	.-8      	; 0x7240 <OLEDpinMode+0x26>
    7248:	28 2b       	or	r18, r24
    724a:	24 b9       	out	0x04, r18	; 4
    724c:	08 95       	ret

0000724e <OLEDdigitalWrite>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDdigitalWrite(uint8_t pin,uint8_t value){
    724e:	38 2f       	mov	r19, r24

  if (value == LOW) {
    7250:	66 23       	and	r22, r22
    7252:	59 f0       	breq	.+22     	; 0x726a <OLEDdigitalWrite+0x1c>
    LCD_PORT &= ~(1 << pin);
  } //If low, write 0
  else {
    LCD_PORT |= (1 << pin);
    7254:	25 b1       	in	r18, 0x05	; 5
    7256:	81 e0       	ldi	r24, 0x01	; 1
    7258:	90 e0       	ldi	r25, 0x00	; 0
    725a:	02 c0       	rjmp	.+4      	; 0x7260 <OLEDdigitalWrite+0x12>
    725c:	88 0f       	add	r24, r24
    725e:	99 1f       	adc	r25, r25
    7260:	3a 95       	dec	r19
    7262:	e2 f7       	brpl	.-8      	; 0x725c <OLEDdigitalWrite+0xe>
    7264:	28 2b       	or	r18, r24
    7266:	25 b9       	out	0x05, r18	; 5
    7268:	08 95       	ret
    unknown
 --------------------------------------------------------------------- */
void OLEDdigitalWrite(uint8_t pin,uint8_t value){

  if (value == LOW) {
    LCD_PORT &= ~(1 << pin);
    726a:	25 b1       	in	r18, 0x05	; 5
    726c:	81 e0       	ldi	r24, 0x01	; 1
    726e:	90 e0       	ldi	r25, 0x00	; 0
    7270:	02 c0       	rjmp	.+4      	; 0x7276 <OLEDdigitalWrite+0x28>
    7272:	88 0f       	add	r24, r24
    7274:	99 1f       	adc	r25, r25
    7276:	3a 95       	dec	r19
    7278:	e2 f7       	brpl	.-8      	; 0x7272 <OLEDdigitalWrite+0x24>
    727a:	80 95       	com	r24
    727c:	82 23       	and	r24, r18
    727e:	85 b9       	out	0x05, r24	; 5
    7280:	08 95       	ret

00007282 <OLEDdigitalRead>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
uint8_t OLEDdigitalRead(uint8_t pin){

  return (LCD_PIN & (1 << pin));
    7282:	93 b1       	in	r25, 0x03	; 3
    7284:	21 e0       	ldi	r18, 0x01	; 1
    7286:	30 e0       	ldi	r19, 0x00	; 0
    7288:	02 c0       	rjmp	.+4      	; 0x728e <OLEDdigitalRead+0xc>
    728a:	22 0f       	add	r18, r18
    728c:	33 1f       	adc	r19, r19
    728e:	8a 95       	dec	r24
    7290:	e2 f7       	brpl	.-8      	; 0x728a <OLEDdigitalRead+0x8>
}
    7292:	89 2f       	mov	r24, r25
    7294:	82 23       	and	r24, r18
    7296:	08 95       	ret

00007298 <OLEDpulseEnable>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDpulseEnable(void){

  OLEDdigitalWrite(_enable_pin, HIGH);
    7298:	83 e0       	ldi	r24, 0x03	; 3
    729a:	61 e0       	ldi	r22, 0x01	; 1
    729c:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
    72a0:	8a ef       	ldi	r24, 0xFA	; 250
    72a2:	90 e0       	ldi	r25, 0x00	; 0
    72a4:	01 97       	sbiw	r24, 0x01	; 1
    72a6:	f1 f7       	brne	.-4      	; 0x72a4 <OLEDpulseEnable+0xc>
  _delay_us(50);    // TODO: Timing Spec?
  OLEDdigitalWrite(_enable_pin, LOW);
    72a8:	83 e0       	ldi	r24, 0x03	; 3
    72aa:	60 e0       	ldi	r22, 0x00	; 0
    72ac:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
}
    72b0:	08 95       	ret

000072b2 <OLEDwrite4bits>:

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDwrite4bits(uint8_t value){
    72b2:	ef 92       	push	r14
    72b4:	ff 92       	push	r15
    72b6:	0f 93       	push	r16
    72b8:	1f 93       	push	r17
    72ba:	cf 93       	push	r28
    72bc:	df 93       	push	r29
    72be:	e8 2e       	mov	r14, r24
    72c0:	ff 24       	eor	r15, r15
    72c2:	05 ec       	ldi	r16, 0xC5	; 197
    72c4:	13 e0       	ldi	r17, 0x03	; 3
    72c6:	c0 e0       	ldi	r28, 0x00	; 0
    72c8:	d0 e0       	ldi	r29, 0x00	; 0

  for(int i = 0; i < 4; i++){
    OLEDpinMode(_data_pins[i], OUTPUT);
    72ca:	f8 01       	movw	r30, r16
    72cc:	80 81       	ld	r24, Z
    72ce:	61 e0       	ldi	r22, 0x01	; 1
    72d0:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
    OLEDdigitalWrite(_data_pins[i], (value >> i) & 0x01);
    72d4:	b7 01       	movw	r22, r14
    72d6:	0c 2e       	mov	r0, r28
    72d8:	02 c0       	rjmp	.+4      	; 0x72de <OLEDwrite4bits+0x2c>
    72da:	75 95       	asr	r23
    72dc:	67 95       	ror	r22
    72de:	0a 94       	dec	r0
    72e0:	e2 f7       	brpl	.-8      	; 0x72da <OLEDwrite4bits+0x28>
    72e2:	61 70       	andi	r22, 0x01	; 1
    72e4:	f8 01       	movw	r30, r16
    72e6:	81 91       	ld	r24, Z+
    72e8:	8f 01       	movw	r16, r30
    72ea:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDwrite4bits(uint8_t value){

  for(int i = 0; i < 4; i++){
    72ee:	21 96       	adiw	r28, 0x01	; 1
    72f0:	c4 30       	cpi	r28, 0x04	; 4
    72f2:	d1 05       	cpc	r29, r1
    72f4:	51 f7       	brne	.-44     	; 0x72ca <OLEDwrite4bits+0x18>
    72f6:	8a ef       	ldi	r24, 0xFA	; 250
    72f8:	90 e0       	ldi	r25, 0x00	; 0
    72fa:	01 97       	sbiw	r24, 0x01	; 1
    72fc:	f1 f7       	brne	.-4      	; 0x72fa <OLEDwrite4bits+0x48>
    OLEDpinMode(_data_pins[i], OUTPUT);
    OLEDdigitalWrite(_data_pins[i], (value >> i) & 0x01);
  }

  _delay_us(50); // Timing spec?
  OLEDpulseEnable();
    72fe:	0e 94 4c 39 	call	0x7298	; 0x7298 <OLEDpulseEnable>
}
    7302:	df 91       	pop	r29
    7304:	cf 91       	pop	r28
    7306:	1f 91       	pop	r17
    7308:	0f 91       	pop	r16
    730a:	ff 90       	pop	r15
    730c:	ef 90       	pop	r14
    730e:	08 95       	ret

00007310 <OLEDsend>:
}

/* ---------------------------------------------------------------------
    write either command or data
 --------------------------------------------------------------------- */
void OLEDsend(uint8_t value, uint8_t mode){
    7310:	1f 93       	push	r17
    7312:	18 2f       	mov	r17, r24

  OLEDdigitalWrite(rs_pin, mode);
    7314:	81 e0       	ldi	r24, 0x01	; 1
    7316:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
  OLEDpinMode(_rw_pin, OUTPUT);
    731a:	82 e0       	ldi	r24, 0x02	; 2
    731c:	61 e0       	ldi	r22, 0x01	; 1
    731e:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
  OLEDdigitalWrite(_rw_pin, LOW);
    7322:	82 e0       	ldi	r24, 0x02	; 2
    7324:	60 e0       	ldi	r22, 0x00	; 0
    7326:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>

  OLEDwrite4bits(value >> 4);
    732a:	81 2f       	mov	r24, r17
    732c:	82 95       	swap	r24
    732e:	8f 70       	andi	r24, 0x0F	; 15
    7330:	0e 94 59 39 	call	0x72b2	; 0x72b2 <OLEDwrite4bits>
  OLEDwrite4bits(value);
    7334:	81 2f       	mov	r24, r17
    7336:	0e 94 59 39 	call	0x72b2	; 0x72b2 <OLEDwrite4bits>
}
    733a:	1f 91       	pop	r17
    733c:	08 95       	ret

0000733e <OLEDwaitForReady>:
}

/* ---------------------------------------------------------------------
    Poll the busy bit until it goes LOW
 --------------------------------------------------------------------- */
void OLEDwaitForReady(void){
    733e:	0f 93       	push	r16
    7340:	1f 93       	push	r17

  unsigned char busy = 1;
  OLEDpinMode(_busy_pin, INPUT);
    7342:	87 e0       	ldi	r24, 0x07	; 7
    7344:	60 e0       	ldi	r22, 0x00	; 0
    7346:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
  OLEDdigitalWrite(rs_pin, LOW);
    734a:	81 e0       	ldi	r24, 0x01	; 1
    734c:	60 e0       	ldi	r22, 0x00	; 0
    734e:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, HIGH);
    7352:	82 e0       	ldi	r24, 0x02	; 2
    7354:	61 e0       	ldi	r22, 0x01	; 1
    7356:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    735a:	02 e4       	ldi	r16, 0x42	; 66

  do{
    OLEDdigitalWrite(_enable_pin, LOW);
    735c:	83 e0       	ldi	r24, 0x03	; 3
    735e:	60 e0       	ldi	r22, 0x00	; 0
    7360:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
    OLEDdigitalWrite(_enable_pin, HIGH);
    7364:	83 e0       	ldi	r24, 0x03	; 3
    7366:	61 e0       	ldi	r22, 0x01	; 1
    7368:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
    736c:	80 2f       	mov	r24, r16
    736e:	8a 95       	dec	r24
    7370:	f1 f7       	brne	.-4      	; 0x736e <OLEDwaitForReady+0x30>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
uint8_t OLEDdigitalRead(uint8_t pin){

  return (LCD_PIN & (1 << pin));
    7372:	13 b1       	in	r17, 0x03	; 3
    OLEDdigitalWrite(_enable_pin, LOW);
    OLEDdigitalWrite(_enable_pin, HIGH);

    _delay_us(10);
    busy = OLEDdigitalRead(_busy_pin);
    OLEDdigitalWrite(_enable_pin, LOW);
    7374:	83 e0       	ldi	r24, 0x03	; 3
    7376:	60 e0       	ldi	r22, 0x00	; 0
    7378:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>

    OLEDpulseEnable();    // get remaining 4 bits, which are not used.
    737c:	0e 94 4c 39 	call	0x7298	; 0x7298 <OLEDpulseEnable>
  } while(busy);
    7380:	17 fd       	sbrc	r17, 7
    7382:	ec cf       	rjmp	.-40     	; 0x735c <OLEDwaitForReady+0x1e>

  OLEDpinMode(_busy_pin, OUTPUT);
    7384:	87 e0       	ldi	r24, 0x07	; 7
    7386:	61 e0       	ldi	r22, 0x01	; 1
    7388:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
  OLEDdigitalWrite(_rw_pin, LOW);
    738c:	82 e0       	ldi	r24, 0x02	; 2
    738e:	60 e0       	ldi	r22, 0x00	; 0
    7390:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
}
    7394:	1f 91       	pop	r17
    7396:	0f 91       	pop	r16
    7398:	08 95       	ret

0000739a <OLEDwriteC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    739a:	61 e0       	ldi	r22, 0x01	; 1
    739c:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    73a0:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
}
    73a4:	08 95       	ret

000073a6 <OLEDcommand>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    73a6:	60 e0       	ldi	r22, 0x00	; 0
    73a8:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    73ac:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
}
    73b0:	08 95       	ret

000073b2 <OLEDwriteCCC>:
}

/* ---------------------------------------------------------------------
    send a string with length to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCCC(const uint8_t *buffer, size_t size){
    73b2:	0f 93       	push	r16
    73b4:	1f 93       	push	r17
    73b6:	cf 93       	push	r28
    73b8:	df 93       	push	r29
    73ba:	8c 01       	movw	r16, r24
    73bc:	eb 01       	movw	r28, r22

  size_t n = 0;
  while(size--){
    73be:	61 15       	cp	r22, r1
    73c0:	71 05       	cpc	r23, r1
    73c2:	51 f0       	breq	.+20     	; 0x73d8 <OLEDwriteCCC+0x26>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    73c4:	f8 01       	movw	r30, r16
    73c6:	81 91       	ld	r24, Z+
    73c8:	8f 01       	movw	r16, r30
    73ca:	61 e0       	ldi	r22, 0x01	; 1
    73cc:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    73d0:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    73d4:	21 97       	sbiw	r28, 0x01	; 1
    send a string with length to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCCC(const uint8_t *buffer, size_t size){

  size_t n = 0;
  while(size--){
    73d6:	b1 f7       	brne	.-20     	; 0x73c4 <OLEDwriteCCC+0x12>
    n += OLEDwriteC(*buffer++);
  }

  return n;
}
    73d8:	80 e0       	ldi	r24, 0x00	; 0
    73da:	90 e0       	ldi	r25, 0x00	; 0
    73dc:	df 91       	pop	r29
    73de:	cf 91       	pop	r28
    73e0:	1f 91       	pop	r17
    73e2:	0f 91       	pop	r16
    73e4:	08 95       	ret

000073e6 <OLEDwriteCC>:
/* ---------------------------------------------------------------------
    send a string to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCC(const char *str){

  if(str == NULL){
    73e6:	00 97       	sbiw	r24, 0x00	; 0
    73e8:	69 f0       	breq	.+26     	; 0x7404 <OLEDwriteCC+0x1e>
    return 0;
  }

  return OLEDwriteCCC((const uint8_t *)str, strlen(str));
    73ea:	fc 01       	movw	r30, r24
    73ec:	01 90       	ld	r0, Z+
    73ee:	00 20       	and	r0, r0
    73f0:	e9 f7       	brne	.-6      	; 0x73ec <OLEDwriteCC+0x6>
    73f2:	31 97       	sbiw	r30, 0x01	; 1
    73f4:	e8 1b       	sub	r30, r24
    73f6:	f9 0b       	sbc	r31, r25
    73f8:	bf 01       	movw	r22, r30
    73fa:	0e 94 d9 39 	call	0x73b2	; 0x73b2 <OLEDwriteCCC>
    73fe:	9c 01       	movw	r18, r24
}
    7400:	c9 01       	movw	r24, r18
    7402:	08 95       	ret
/* ---------------------------------------------------------------------
    send a string to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCC(const char *str){

  if(str == NULL){
    7404:	20 e0       	ldi	r18, 0x00	; 0
    7406:	30 e0       	ldi	r19, 0x00	; 0
    return 0;
  }

  return OLEDwriteCCC((const uint8_t *)str, strlen(str));
}
    7408:	c9 01       	movw	r24, r18
    740a:	08 95       	ret

0000740c <OLEDprintCC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
size_t OLEDprintCC(const char str[]){

  return OLEDwriteCC(str);
    740c:	0e 94 f3 39 	call	0x73e6	; 0x73e6 <OLEDwriteCC>
}
    7410:	08 95       	ret

00007412 <OLEDprintC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    7412:	61 e0       	ldi	r22, 0x01	; 1
    7414:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    7418:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    unknown
 --------------------------------------------------------------------- */
size_t OLEDprintC(char c){

  return OLEDwriteC(c);
}
    741c:	80 e0       	ldi	r24, 0x00	; 0
    741e:	90 e0       	ldi	r25, 0x00	; 0
    7420:	08 95       	ret

00007422 <OLEDcreateChar>:

/* ---------------------------------------------------------------------
    Allows us to fill the first 8 CGRAM locations
    with custom characters
 --------------------------------------------------------------------- */
void OLEDcreateChar(uint8_t location, uint8_t charmap[]){
    7422:	0f 93       	push	r16
    7424:	1f 93       	push	r17
    7426:	cf 93       	push	r28
    7428:	df 93       	push	r29
    742a:	8b 01       	movw	r16, r22
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    742c:	87 70       	andi	r24, 0x07	; 7
    742e:	88 0f       	add	r24, r24
    7430:	88 0f       	add	r24, r24
    7432:	88 0f       	add	r24, r24
    7434:	80 64       	ori	r24, 0x40	; 64
    7436:	60 e0       	ldi	r22, 0x00	; 0
    7438:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    743c:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    7440:	c0 e0       	ldi	r28, 0x00	; 0
    7442:	d0 e0       	ldi	r29, 0x00	; 0
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    7444:	f8 01       	movw	r30, r16
    7446:	ec 0f       	add	r30, r28
    7448:	fd 1f       	adc	r31, r29
    744a:	80 81       	ld	r24, Z
    744c:	61 e0       	ldi	r22, 0x01	; 1
    744e:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    7452:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDcreateChar(uint8_t location, uint8_t charmap[]){

  location &= 0x7; // we only have 8 locations 0-7
  OLEDcommand(LCD_SETCGRAMADDR | (location << 3));
  for (int i=0; i<8; i++){
    7456:	21 96       	adiw	r28, 0x01	; 1
    7458:	c8 30       	cpi	r28, 0x08	; 8
    745a:	d1 05       	cpc	r29, r1
    745c:	99 f7       	brne	.-26     	; 0x7444 <OLEDcreateChar+0x22>
    OLEDwriteC(charmap[i]);
  }
}
    745e:	df 91       	pop	r29
    7460:	cf 91       	pop	r28
    7462:	1f 91       	pop	r17
    7464:	0f 91       	pop	r16
    7466:	08 95       	ret

00007468 <OLEDnoAutoscroll>:
/* ---------------------------------------------------------------------
    This will 'left justify' text from the cursor
 --------------------------------------------------------------------- */
void OLEDnoAutoscroll(void){

  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
    7468:	80 91 c9 03 	lds	r24, 0x03C9
    746c:	8e 7f       	andi	r24, 0xFE	; 254
    746e:	80 93 c9 03 	sts	0x03C9, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7472:	84 60       	ori	r24, 0x04	; 4
    7474:	60 e0       	ldi	r22, 0x00	; 0
    7476:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    747a:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoAutoscroll(void){

  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    747e:	08 95       	ret

00007480 <OLEDautoscroll>:
/* ---------------------------------------------------------------------
    This will 'right justify' text from the cursor
 --------------------------------------------------------------------- */
void OLEDautoscroll(void){

  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
    7480:	80 91 c9 03 	lds	r24, 0x03C9
    7484:	98 2f       	mov	r25, r24
    7486:	91 60       	ori	r25, 0x01	; 1
    7488:	90 93 c9 03 	sts	0x03C9, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    748c:	85 60       	ori	r24, 0x05	; 5
    748e:	60 e0       	ldi	r22, 0x00	; 0
    7490:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    7494:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDautoscroll(void){

  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    7498:	08 95       	ret

0000749a <OLEDscrollDisplayRight>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    749a:	8c e1       	ldi	r24, 0x1C	; 28
    749c:	60 e0       	ldi	r22, 0x00	; 0
    749e:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    74a2:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    unknown
 --------------------------------------------------------------------- */
void OLEDscrollDisplayRight(void){

  OLEDcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
}
    74a6:	08 95       	ret

000074a8 <OLEDscrollDisplayLeft>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    74a8:	88 e1       	ldi	r24, 0x18	; 24
    74aa:	60 e0       	ldi	r22, 0x00	; 0
    74ac:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    74b0:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    These commands scroll the display without changing the RAM
 --------------------------------------------------------------------- */
void OLEDscrollDisplayLeft(void){

  OLEDcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
}
    74b4:	08 95       	ret

000074b6 <OLEDrightToLeft>:
/* ---------------------------------------------------------------------
    This is for text that flows Right to Left
 --------------------------------------------------------------------- */
void OLEDrightToLeft(void){

  _displaymode &= ~LCD_ENTRYLEFT;
    74b6:	80 91 c9 03 	lds	r24, 0x03C9
    74ba:	8d 7f       	andi	r24, 0xFD	; 253
    74bc:	80 93 c9 03 	sts	0x03C9, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    74c0:	84 60       	ori	r24, 0x04	; 4
    74c2:	60 e0       	ldi	r22, 0x00	; 0
    74c4:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    74c8:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDrightToLeft(void){

  _displaymode &= ~LCD_ENTRYLEFT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    74cc:	08 95       	ret

000074ce <OLEDleftToRight>:
/* ---------------------------------------------------------------------
    This is for text that flows Left to Right
 --------------------------------------------------------------------- */
void OLEDleftToRight(void){

  _displaymode |= LCD_ENTRYLEFT;
    74ce:	80 91 c9 03 	lds	r24, 0x03C9
    74d2:	98 2f       	mov	r25, r24
    74d4:	92 60       	ori	r25, 0x02	; 2
    74d6:	90 93 c9 03 	sts	0x03C9, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    74da:	86 60       	ori	r24, 0x06	; 6
    74dc:	60 e0       	ldi	r22, 0x00	; 0
    74de:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    74e2:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDleftToRight(void){

  _displaymode |= LCD_ENTRYLEFT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    74e6:	08 95       	ret

000074e8 <OLEDsetCursor>:
}

/* ---------------------------------------------------------------------
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){
    74e8:	df 93       	push	r29
    74ea:	cf 93       	push	r28
    74ec:	00 d0       	rcall	.+0      	; 0x74ee <OLEDsetCursor+0x6>
    74ee:	00 d0       	rcall	.+0      	; 0x74f0 <OLEDsetCursor+0x8>
    74f0:	cd b7       	in	r28, 0x3d	; 61
    74f2:	de b7       	in	r29, 0x3e	; 62
    74f4:	98 2f       	mov	r25, r24

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
  if (row >= _numlines){
    74f6:	80 91 94 03 	lds	r24, 0x0394
    74fa:	68 17       	cp	r22, r24
    74fc:	d0 f0       	brcs	.+52     	; 0x7532 <OLEDsetCursor+0x4a>
    74fe:	e0 e0       	ldi	r30, 0x00	; 0
    7500:	f0 e0       	ldi	r31, 0x00	; 0
/* ---------------------------------------------------------------------
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
    7502:	19 82       	std	Y+1, r1	; 0x01
    7504:	80 e4       	ldi	r24, 0x40	; 64
    7506:	8a 83       	std	Y+2, r24	; 0x02
    7508:	84 e1       	ldi	r24, 0x14	; 20
    750a:	8b 83       	std	Y+3, r24	; 0x03
    750c:	84 e5       	ldi	r24, 0x54	; 84
    750e:	8c 83       	std	Y+4, r24	; 0x04
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7510:	ec 0f       	add	r30, r28
    7512:	fd 1f       	adc	r31, r29
    7514:	81 81       	ldd	r24, Z+1	; 0x01
    7516:	89 0f       	add	r24, r25
    7518:	80 68       	ori	r24, 0x80	; 128
    751a:	60 e0       	ldi	r22, 0x00	; 0
    751c:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    7520:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
  if (row >= _numlines){
    row = 0;  //write to first line if out off bounds
  }

  OLEDcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}
    7524:	0f 90       	pop	r0
    7526:	0f 90       	pop	r0
    7528:	0f 90       	pop	r0
    752a:	0f 90       	pop	r0
    752c:	cf 91       	pop	r28
    752e:	df 91       	pop	r29
    7530:	08 95       	ret
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
  if (row >= _numlines){
    7532:	e6 2f       	mov	r30, r22
    7534:	f0 e0       	ldi	r31, 0x00	; 0
    7536:	e5 cf       	rjmp	.-54     	; 0x7502 <OLEDsetCursor+0x1a>

00007538 <OLEDhome>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7538:	82 e0       	ldi	r24, 0x02	; 2
    753a:	60 e0       	ldi	r22, 0x00	; 0
    753c:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    7540:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    set cursor to home position
 --------------------------------------------------------------------- */
void OLEDhome(void){
  OLEDcommand(LCD_RETURNHOME);  // set cursor position to zero
  //  _delay_us(2000);  // this command takes a long time!
}
    7544:	08 95       	ret

00007546 <OLEDcursor>:
/* ---------------------------------------------------------------------
    Turns the underline cursor on
 --------------------------------------------------------------------- */
void OLEDcursor(void){

  _displaycontrol |= LCD_CURSORON;
    7546:	80 91 93 03 	lds	r24, 0x0393
    754a:	98 2f       	mov	r25, r24
    754c:	92 60       	ori	r25, 0x02	; 2
    754e:	90 93 93 03 	sts	0x0393, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7552:	8a 60       	ori	r24, 0x0A	; 10
    7554:	60 e0       	ldi	r22, 0x00	; 0
    7556:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    755a:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDcursor(void){

  _displaycontrol |= LCD_CURSORON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    755e:	08 95       	ret

00007560 <OLEDnoCursor>:
/* ---------------------------------------------------------------------
    Turns the underline cursor off
 --------------------------------------------------------------------- */
void OLEDnoCursor(void){

  _displaycontrol &= ~LCD_CURSORON;
    7560:	80 91 93 03 	lds	r24, 0x0393
    7564:	8d 7f       	andi	r24, 0xFD	; 253
    7566:	80 93 93 03 	sts	0x0393, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    756a:	88 60       	ori	r24, 0x08	; 8
    756c:	60 e0       	ldi	r22, 0x00	; 0
    756e:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    7572:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoCursor(void){

  _displaycontrol &= ~LCD_CURSORON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7576:	08 95       	ret

00007578 <OLEDblink>:
/* ---------------------------------------------------------------------
    Turn on the blinking cursor
 --------------------------------------------------------------------- */
void OLEDblink(void){

  _displaycontrol |= LCD_BLINKON;
    7578:	80 91 93 03 	lds	r24, 0x0393
    757c:	98 2f       	mov	r25, r24
    757e:	91 60       	ori	r25, 0x01	; 1
    7580:	90 93 93 03 	sts	0x0393, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7584:	89 60       	ori	r24, 0x09	; 9
    7586:	60 e0       	ldi	r22, 0x00	; 0
    7588:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    758c:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDblink(void){

  _displaycontrol |= LCD_BLINKON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7590:	08 95       	ret

00007592 <OLEDnoBlink>:
/* ---------------------------------------------------------------------
    Turn off the blinking cursor
 --------------------------------------------------------------------- */
void OLEDnoBlink(void){

  _displaycontrol &= ~LCD_BLINKON;
    7592:	80 91 93 03 	lds	r24, 0x0393
    7596:	8e 7f       	andi	r24, 0xFE	; 254
    7598:	80 93 93 03 	sts	0x0393, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    759c:	88 60       	ori	r24, 0x08	; 8
    759e:	60 e0       	ldi	r22, 0x00	; 0
    75a0:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    75a4:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoBlink(void){

  _displaycontrol &= ~LCD_BLINKON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    75a8:	08 95       	ret

000075aa <OLEDclear>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    75aa:	81 e0       	ldi	r24, 0x01	; 1
    75ac:	60 e0       	ldi	r22, 0x00	; 0
    75ae:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    75b2:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDclear(void){

  OLEDcommand(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
  //  _delay_us(2000);  // this command takes a long time!
}
    75b6:	08 95       	ret

000075b8 <OLEDdisplay>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDdisplay(void){

  _displaycontrol |= LCD_DISPLAYON;
    75b8:	80 91 93 03 	lds	r24, 0x0393
    75bc:	98 2f       	mov	r25, r24
    75be:	94 60       	ori	r25, 0x04	; 4
    75c0:	90 93 93 03 	sts	0x0393, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    75c4:	8c 60       	ori	r24, 0x0C	; 12
    75c6:	60 e0       	ldi	r22, 0x00	; 0
    75c8:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    75cc:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDdisplay(void){

  _displaycontrol |= LCD_DISPLAYON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    75d0:	08 95       	ret

000075d2 <OLEDnoDisplay>:
/* ---------------------------------------------------------------------
    Turn the display on/off (quickly)
 --------------------------------------------------------------------- */
void OLEDnoDisplay(void){

  _displaycontrol &= ~LCD_DISPLAYON;
    75d2:	80 91 93 03 	lds	r24, 0x0393
    75d6:	8b 7f       	andi	r24, 0xFB	; 251
    75d8:	80 93 93 03 	sts	0x0393, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    75dc:	88 60       	ori	r24, 0x08	; 8
    75de:	60 e0       	ldi	r22, 0x00	; 0
    75e0:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    75e4:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoDisplay(void){

  _displaycontrol &= ~LCD_DISPLAYON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    75e8:	08 95       	ret

000075ea <OLEDbegin>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDbegin(uint8_t cols, uint8_t lines){
    75ea:	0f 93       	push	r16
    75ec:	1f 93       	push	r17
    75ee:	cf 93       	push	r28
    75f0:	df 93       	push	r29

  _numlines = lines;
    75f2:	60 93 94 03 	sts	0x0394, r22
  _currline = 0;
    75f6:	10 92 f2 02 	sts	0x02F2, r1

  OLEDpinMode(rs_pin, OUTPUT);
    75fa:	81 e0       	ldi	r24, 0x01	; 1
    75fc:	61 e0       	ldi	r22, 0x01	; 1
    75fe:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
  OLEDpinMode(_rw_pin, OUTPUT);
    7602:	82 e0       	ldi	r24, 0x02	; 2
    7604:	61 e0       	ldi	r22, 0x01	; 1
    7606:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
  OLEDpinMode(_enable_pin, OUTPUT);
    760a:	83 e0       	ldi	r24, 0x03	; 3
    760c:	61 e0       	ldi	r22, 0x01	; 1
    760e:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>

  OLEDdigitalWrite(rs_pin, LOW);
    7612:	81 e0       	ldi	r24, 0x01	; 1
    7614:	60 e0       	ldi	r22, 0x00	; 0
    7616:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
  OLEDdigitalWrite(_enable_pin, LOW);
    761a:	83 e0       	ldi	r24, 0x03	; 3
    761c:	60 e0       	ldi	r22, 0x00	; 0
    761e:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, LOW);
    7622:	82 e0       	ldi	r24, 0x02	; 2
    7624:	60 e0       	ldi	r22, 0x00	; 0
    7626:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
    762a:	24 ef       	ldi	r18, 0xF4	; 244
    762c:	31 e0       	ldi	r19, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    762e:	44 ef       	ldi	r20, 0xF4	; 244
    7630:	51 e0       	ldi	r21, 0x01	; 1
    7632:	ca 01       	movw	r24, r20
    7634:	01 97       	sbiw	r24, 0x01	; 1
    7636:	f1 f7       	brne	.-4      	; 0x7634 <OLEDbegin+0x4a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7638:	21 50       	subi	r18, 0x01	; 1
    763a:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    763c:	d1 f7       	brne	.-12     	; 0x7632 <OLEDbegin+0x48>
    763e:	c5 ec       	ldi	r28, 0xC5	; 197
    7640:	d3 e0       	ldi	r29, 0x03	; 3

  _delay_us(50000); // give it some time to power up

  // Now we pull both RS and R/W low to begin commands
  for(int i = 0; i < 4; i++){
    OLEDpinMode(_data_pins[i], OUTPUT);
    7642:	88 81       	ld	r24, Y
    7644:	61 e0       	ldi	r22, 0x01	; 1
    7646:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
    OLEDdigitalWrite(_data_pins[i], LOW);
    764a:	89 91       	ld	r24, Y+
    764c:	60 e0       	ldi	r22, 0x00	; 0
    764e:	0e 94 27 39 	call	0x724e	; 0x724e <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, LOW);

  _delay_us(50000); // give it some time to power up

  // Now we pull both RS and R/W low to begin commands
  for(int i = 0; i < 4; i++){
    7652:	83 e0       	ldi	r24, 0x03	; 3
    7654:	c9 3c       	cpi	r28, 0xC9	; 201
    7656:	d8 07       	cpc	r29, r24
    7658:	a1 f7       	brne	.-24     	; 0x7642 <OLEDbegin+0x58>
  //
  // In the data sheet, the timing specs are all zeros(!).  These have been tested to
  // reliably handle both warm & cold starts.

  // 4-Bit initialization sequence from Technobly
  OLEDwrite4bits(0x03); // Put back into 8-bit mode
    765a:	83 e0       	ldi	r24, 0x03	; 3
    765c:	0e 94 59 39 	call	0x72b2	; 0x72b2 <OLEDwrite4bits>
    7660:	c8 ea       	ldi	r28, 0xA8	; 168
    7662:	d1 e6       	ldi	r29, 0x61	; 97
    7664:	ce 01       	movw	r24, r28
    7666:	01 97       	sbiw	r24, 0x01	; 1
    7668:	f1 f7       	brne	.-4      	; 0x7666 <OLEDbegin+0x7c>
  _delay_us(5000);
  if(_oled_ver == OLED_V2){  // only run extra command for newer displays
    766a:	80 91 97 04 	lds	r24, 0x0497
    766e:	82 30       	cpi	r24, 0x02	; 2
    7670:	09 f4       	brne	.+2      	; 0x7674 <OLEDbegin+0x8a>
    7672:	46 c0       	rjmp	.+140    	; 0x7700 <OLEDbegin+0x116>
    OLEDwrite4bits(0x08);
    _delay_us(5000);
  }

  OLEDwrite4bits(0x02); // Put into 4-bit mode
    7674:	82 e0       	ldi	r24, 0x02	; 2
    7676:	0e 94 59 39 	call	0x72b2	; 0x72b2 <OLEDwrite4bits>
    767a:	08 ea       	ldi	r16, 0xA8	; 168
    767c:	11 e6       	ldi	r17, 0x61	; 97
    767e:	c8 01       	movw	r24, r16
    7680:	01 97       	sbiw	r24, 0x01	; 1
    7682:	f1 f7       	brne	.-4      	; 0x7680 <OLEDbegin+0x96>
  _delay_us(5000);
  OLEDwrite4bits(0x02);
    7684:	82 e0       	ldi	r24, 0x02	; 2
    7686:	0e 94 59 39 	call	0x72b2	; 0x72b2 <OLEDwrite4bits>
    768a:	c8 01       	movw	r24, r16
    768c:	01 97       	sbiw	r24, 0x01	; 1
    768e:	f1 f7       	brne	.-4      	; 0x768c <OLEDbegin+0xa2>
  _delay_us(5000);
  OLEDwrite4bits(0x08);
    7690:	88 e0       	ldi	r24, 0x08	; 8
    7692:	0e 94 59 39 	call	0x72b2	; 0x72b2 <OLEDwrite4bits>
    7696:	c8 01       	movw	r24, r16
    7698:	01 97       	sbiw	r24, 0x01	; 1
    769a:	f1 f7       	brne	.-4      	; 0x7698 <OLEDbegin+0xae>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    769c:	88 e0       	ldi	r24, 0x08	; 8
    769e:	60 e0       	ldi	r22, 0x00	; 0
    76a0:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    76a4:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    76a8:	c8 01       	movw	r24, r16
    76aa:	01 97       	sbiw	r24, 0x01	; 1
    76ac:	f1 f7       	brne	.-4      	; 0x76aa <OLEDbegin+0xc0>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    76ae:	81 e0       	ldi	r24, 0x01	; 1
    76b0:	60 e0       	ldi	r22, 0x00	; 0
    76b2:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    76b6:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    76ba:	c8 01       	movw	r24, r16
    76bc:	01 97       	sbiw	r24, 0x01	; 1
    76be:	f1 f7       	brne	.-4      	; 0x76bc <OLEDbegin+0xd2>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    76c0:	86 e0       	ldi	r24, 0x06	; 6
    76c2:	60 e0       	ldi	r22, 0x00	; 0
    76c4:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    76c8:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    76cc:	c8 01       	movw	r24, r16
    76ce:	01 97       	sbiw	r24, 0x01	; 1
    76d0:	f1 f7       	brne	.-4      	; 0x76ce <OLEDbegin+0xe4>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    76d2:	82 e0       	ldi	r24, 0x02	; 2
    76d4:	60 e0       	ldi	r22, 0x00	; 0
    76d6:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    76da:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    76de:	c8 01       	movw	r24, r16
    76e0:	01 97       	sbiw	r24, 0x01	; 1
    76e2:	f1 f7       	brne	.-4      	; 0x76e0 <OLEDbegin+0xf6>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    76e4:	8c e0       	ldi	r24, 0x0C	; 12
    76e6:	60 e0       	ldi	r22, 0x00	; 0
    76e8:	0e 94 88 39 	call	0x7310	; 0x7310 <OLEDsend>
  OLEDwaitForReady();
    76ec:	0e 94 9f 39 	call	0x733e	; 0x733e <OLEDwaitForReady>
    76f0:	c8 01       	movw	r24, r16
    76f2:	01 97       	sbiw	r24, 0x01	; 1
    76f4:	f1 f7       	brne	.-4      	; 0x76f2 <OLEDbegin+0x108>
  _delay_us(5000);
  OLEDcommand(0x02);  // Home Cursor
  _delay_us(5000);
  OLEDcommand(0x0C);  // Turn On - enable cursor & blink
  _delay_us(5000);
}
    76f6:	df 91       	pop	r29
    76f8:	cf 91       	pop	r28
    76fa:	1f 91       	pop	r17
    76fc:	0f 91       	pop	r16
    76fe:	08 95       	ret

  // 4-Bit initialization sequence from Technobly
  OLEDwrite4bits(0x03); // Put back into 8-bit mode
  _delay_us(5000);
  if(_oled_ver == OLED_V2){  // only run extra command for newer displays
    OLEDwrite4bits(0x08);
    7700:	88 e0       	ldi	r24, 0x08	; 8
    7702:	0e 94 59 39 	call	0x72b2	; 0x72b2 <OLEDwrite4bits>
    7706:	ce 01       	movw	r24, r28
    7708:	01 97       	sbiw	r24, 0x01	; 1
    770a:	f1 f7       	brne	.-4      	; 0x7708 <OLEDbegin+0x11e>
    770c:	b3 cf       	rjmp	.-154    	; 0x7674 <OLEDbegin+0x8a>

0000770e <OLEDinit>:
/* ---------------------------------------------------------------------
    initialize OLED display
 --------------------------------------------------------------------- */
void OLEDinit(uint8_t ver){

  _oled_ver = ver;
    770e:	80 93 97 04 	sts	0x0497, r24
  if(_oled_ver != OLED_V1 && _oled_ver != OLED_V2){
    7712:	81 50       	subi	r24, 0x01	; 1
    7714:	82 30       	cpi	r24, 0x02	; 2
    7716:	18 f0       	brcs	.+6      	; 0x771e <OLEDinit+0x10>
    _oled_ver = OLED_V2; // if error, default to newer version
    7718:	82 e0       	ldi	r24, 0x02	; 2
    771a:	80 93 97 04 	sts	0x0497, r24
  }

  _data_pins[0] = data4;
    771e:	84 e0       	ldi	r24, 0x04	; 4
    7720:	80 93 c5 03 	sts	0x03C5, r24
  _data_pins[1] = data5;
    7724:	85 e0       	ldi	r24, 0x05	; 5
    7726:	80 93 c6 03 	sts	0x03C6, r24
  _data_pins[2] = data6;
    772a:	86 e0       	ldi	r24, 0x06	; 6
    772c:	80 93 c7 03 	sts	0x03C7, r24
  _data_pins[3] = data7;
    7730:	87 e0       	ldi	r24, 0x07	; 7
    7732:	80 93 c8 03 	sts	0x03C8, r24

  OLEDpinMode(rs_pin, OUTPUT);
    7736:	81 e0       	ldi	r24, 0x01	; 1
    7738:	61 e0       	ldi	r22, 0x01	; 1
    773a:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
  OLEDpinMode(_rw_pin, OUTPUT);
    773e:	82 e0       	ldi	r24, 0x02	; 2
    7740:	61 e0       	ldi	r22, 0x01	; 1
    7742:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>
  OLEDpinMode(_enable_pin, OUTPUT);
    7746:	83 e0       	ldi	r24, 0x03	; 3
    7748:	61 e0       	ldi	r22, 0x01	; 1
    774a:	0e 94 0d 39 	call	0x721a	; 0x721a <OLEDpinMode>

  _displayfunction = LCD_FUNCTIONSET | LCD_4BITMODE;
    774e:	88 e2       	ldi	r24, 0x28	; 40
    7750:	80 93 ca 03 	sts	0x03CA, r24

  OLEDbegin(16, 2);
    7754:	80 e1       	ldi	r24, 0x10	; 16
    7756:	62 e0       	ldi	r22, 0x02	; 2
    7758:	0e 94 f5 3a 	call	0x75ea	; 0x75ea <OLEDbegin>
}
    775c:	08 95       	ret

0000775e <vfprintf>:
    775e:	2f 92       	push	r2
    7760:	3f 92       	push	r3
    7762:	4f 92       	push	r4
    7764:	5f 92       	push	r5
    7766:	6f 92       	push	r6
    7768:	7f 92       	push	r7
    776a:	8f 92       	push	r8
    776c:	9f 92       	push	r9
    776e:	af 92       	push	r10
    7770:	bf 92       	push	r11
    7772:	cf 92       	push	r12
    7774:	df 92       	push	r13
    7776:	ef 92       	push	r14
    7778:	ff 92       	push	r15
    777a:	0f 93       	push	r16
    777c:	1f 93       	push	r17
    777e:	df 93       	push	r29
    7780:	cf 93       	push	r28
    7782:	cd b7       	in	r28, 0x3d	; 61
    7784:	de b7       	in	r29, 0x3e	; 62
    7786:	61 97       	sbiw	r28, 0x11	; 17
    7788:	0f b6       	in	r0, 0x3f	; 63
    778a:	f8 94       	cli
    778c:	de bf       	out	0x3e, r29	; 62
    778e:	0f be       	out	0x3f, r0	; 63
    7790:	cd bf       	out	0x3d, r28	; 61
    7792:	3c 01       	movw	r6, r24
    7794:	7f 87       	std	Y+15, r23	; 0x0f
    7796:	6e 87       	std	Y+14, r22	; 0x0e
    7798:	6a 01       	movw	r12, r20
    779a:	fc 01       	movw	r30, r24
    779c:	17 82       	std	Z+7, r1	; 0x07
    779e:	16 82       	std	Z+6, r1	; 0x06
    77a0:	83 81       	ldd	r24, Z+3	; 0x03
    77a2:	81 fd       	sbrc	r24, 1
    77a4:	03 c0       	rjmp	.+6      	; 0x77ac <vfprintf+0x4e>
    77a6:	6f ef       	ldi	r22, 0xFF	; 255
    77a8:	7f ef       	ldi	r23, 0xFF	; 255
    77aa:	6f c3       	rjmp	.+1758   	; 0x7e8a <vfprintf+0x72c>
    77ac:	9e 01       	movw	r18, r28
    77ae:	2f 5f       	subi	r18, 0xFF	; 255
    77b0:	3f 4f       	sbci	r19, 0xFF	; 255
    77b2:	39 8b       	std	Y+17, r19	; 0x11
    77b4:	28 8b       	std	Y+16, r18	; 0x10
    77b6:	f3 01       	movw	r30, r6
    77b8:	23 81       	ldd	r18, Z+3	; 0x03
    77ba:	ee 85       	ldd	r30, Y+14	; 0x0e
    77bc:	ff 85       	ldd	r31, Y+15	; 0x0f
    77be:	23 fd       	sbrc	r18, 3
    77c0:	85 91       	lpm	r24, Z+
    77c2:	23 ff       	sbrs	r18, 3
    77c4:	81 91       	ld	r24, Z+
    77c6:	ff 87       	std	Y+15, r31	; 0x0f
    77c8:	ee 87       	std	Y+14, r30	; 0x0e
    77ca:	88 23       	and	r24, r24
    77cc:	09 f4       	brne	.+2      	; 0x77d0 <vfprintf+0x72>
    77ce:	5a c3       	rjmp	.+1716   	; 0x7e84 <vfprintf+0x726>
    77d0:	85 32       	cpi	r24, 0x25	; 37
    77d2:	51 f4       	brne	.+20     	; 0x77e8 <vfprintf+0x8a>
    77d4:	ee 85       	ldd	r30, Y+14	; 0x0e
    77d6:	ff 85       	ldd	r31, Y+15	; 0x0f
    77d8:	23 fd       	sbrc	r18, 3
    77da:	85 91       	lpm	r24, Z+
    77dc:	23 ff       	sbrs	r18, 3
    77de:	81 91       	ld	r24, Z+
    77e0:	ff 87       	std	Y+15, r31	; 0x0f
    77e2:	ee 87       	std	Y+14, r30	; 0x0e
    77e4:	85 32       	cpi	r24, 0x25	; 37
    77e6:	29 f4       	brne	.+10     	; 0x77f2 <vfprintf+0x94>
    77e8:	90 e0       	ldi	r25, 0x00	; 0
    77ea:	b3 01       	movw	r22, r6
    77ec:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    77f0:	e2 cf       	rjmp	.-60     	; 0x77b6 <vfprintf+0x58>
    77f2:	98 2f       	mov	r25, r24
    77f4:	10 e0       	ldi	r17, 0x00	; 0
    77f6:	88 24       	eor	r8, r8
    77f8:	99 24       	eor	r9, r9
    77fa:	10 32       	cpi	r17, 0x20	; 32
    77fc:	b0 f4       	brcc	.+44     	; 0x782a <vfprintf+0xcc>
    77fe:	9b 32       	cpi	r25, 0x2B	; 43
    7800:	69 f0       	breq	.+26     	; 0x781c <vfprintf+0xbe>
    7802:	9c 32       	cpi	r25, 0x2C	; 44
    7804:	28 f4       	brcc	.+10     	; 0x7810 <vfprintf+0xb2>
    7806:	90 32       	cpi	r25, 0x20	; 32
    7808:	51 f0       	breq	.+20     	; 0x781e <vfprintf+0xc0>
    780a:	93 32       	cpi	r25, 0x23	; 35
    780c:	71 f4       	brne	.+28     	; 0x782a <vfprintf+0xcc>
    780e:	0b c0       	rjmp	.+22     	; 0x7826 <vfprintf+0xc8>
    7810:	9d 32       	cpi	r25, 0x2D	; 45
    7812:	39 f0       	breq	.+14     	; 0x7822 <vfprintf+0xc4>
    7814:	90 33       	cpi	r25, 0x30	; 48
    7816:	49 f4       	brne	.+18     	; 0x782a <vfprintf+0xcc>
    7818:	11 60       	ori	r17, 0x01	; 1
    781a:	28 c0       	rjmp	.+80     	; 0x786c <vfprintf+0x10e>
    781c:	12 60       	ori	r17, 0x02	; 2
    781e:	14 60       	ori	r17, 0x04	; 4
    7820:	25 c0       	rjmp	.+74     	; 0x786c <vfprintf+0x10e>
    7822:	18 60       	ori	r17, 0x08	; 8
    7824:	23 c0       	rjmp	.+70     	; 0x786c <vfprintf+0x10e>
    7826:	10 61       	ori	r17, 0x10	; 16
    7828:	21 c0       	rjmp	.+66     	; 0x786c <vfprintf+0x10e>
    782a:	17 fd       	sbrc	r17, 7
    782c:	2a c0       	rjmp	.+84     	; 0x7882 <vfprintf+0x124>
    782e:	89 2f       	mov	r24, r25
    7830:	80 53       	subi	r24, 0x30	; 48
    7832:	8a 30       	cpi	r24, 0x0A	; 10
    7834:	78 f4       	brcc	.+30     	; 0x7854 <vfprintf+0xf6>
    7836:	16 ff       	sbrs	r17, 6
    7838:	06 c0       	rjmp	.+12     	; 0x7846 <vfprintf+0xe8>
    783a:	fa e0       	ldi	r31, 0x0A	; 10
    783c:	9f 9e       	mul	r9, r31
    783e:	90 2c       	mov	r9, r0
    7840:	11 24       	eor	r1, r1
    7842:	98 0e       	add	r9, r24
    7844:	13 c0       	rjmp	.+38     	; 0x786c <vfprintf+0x10e>
    7846:	3a e0       	ldi	r19, 0x0A	; 10
    7848:	83 9e       	mul	r8, r19
    784a:	80 2c       	mov	r8, r0
    784c:	11 24       	eor	r1, r1
    784e:	88 0e       	add	r8, r24
    7850:	10 62       	ori	r17, 0x20	; 32
    7852:	0c c0       	rjmp	.+24     	; 0x786c <vfprintf+0x10e>
    7854:	9e 32       	cpi	r25, 0x2E	; 46
    7856:	21 f4       	brne	.+8      	; 0x7860 <vfprintf+0x102>
    7858:	16 fd       	sbrc	r17, 6
    785a:	14 c3       	rjmp	.+1576   	; 0x7e84 <vfprintf+0x726>
    785c:	10 64       	ori	r17, 0x40	; 64
    785e:	06 c0       	rjmp	.+12     	; 0x786c <vfprintf+0x10e>
    7860:	9c 36       	cpi	r25, 0x6C	; 108
    7862:	11 f4       	brne	.+4      	; 0x7868 <vfprintf+0x10a>
    7864:	10 68       	ori	r17, 0x80	; 128
    7866:	02 c0       	rjmp	.+4      	; 0x786c <vfprintf+0x10e>
    7868:	98 36       	cpi	r25, 0x68	; 104
    786a:	59 f4       	brne	.+22     	; 0x7882 <vfprintf+0x124>
    786c:	ee 85       	ldd	r30, Y+14	; 0x0e
    786e:	ff 85       	ldd	r31, Y+15	; 0x0f
    7870:	23 fd       	sbrc	r18, 3
    7872:	95 91       	lpm	r25, Z+
    7874:	23 ff       	sbrs	r18, 3
    7876:	91 91       	ld	r25, Z+
    7878:	ff 87       	std	Y+15, r31	; 0x0f
    787a:	ee 87       	std	Y+14, r30	; 0x0e
    787c:	99 23       	and	r25, r25
    787e:	09 f0       	breq	.+2      	; 0x7882 <vfprintf+0x124>
    7880:	bc cf       	rjmp	.-136    	; 0x77fa <vfprintf+0x9c>
    7882:	89 2f       	mov	r24, r25
    7884:	85 54       	subi	r24, 0x45	; 69
    7886:	83 30       	cpi	r24, 0x03	; 3
    7888:	20 f4       	brcc	.+8      	; 0x7892 <vfprintf+0x134>
    788a:	81 2f       	mov	r24, r17
    788c:	80 61       	ori	r24, 0x10	; 16
    788e:	90 5e       	subi	r25, 0xE0	; 224
    7890:	07 c0       	rjmp	.+14     	; 0x78a0 <vfprintf+0x142>
    7892:	89 2f       	mov	r24, r25
    7894:	85 56       	subi	r24, 0x65	; 101
    7896:	83 30       	cpi	r24, 0x03	; 3
    7898:	08 f0       	brcs	.+2      	; 0x789c <vfprintf+0x13e>
    789a:	9f c1       	rjmp	.+830    	; 0x7bda <vfprintf+0x47c>
    789c:	81 2f       	mov	r24, r17
    789e:	8f 7e       	andi	r24, 0xEF	; 239
    78a0:	86 fd       	sbrc	r24, 6
    78a2:	02 c0       	rjmp	.+4      	; 0x78a8 <vfprintf+0x14a>
    78a4:	76 e0       	ldi	r23, 0x06	; 6
    78a6:	97 2e       	mov	r9, r23
    78a8:	6f e3       	ldi	r22, 0x3F	; 63
    78aa:	f6 2e       	mov	r15, r22
    78ac:	f8 22       	and	r15, r24
    78ae:	95 36       	cpi	r25, 0x65	; 101
    78b0:	19 f4       	brne	.+6      	; 0x78b8 <vfprintf+0x15a>
    78b2:	f0 e4       	ldi	r31, 0x40	; 64
    78b4:	ff 2a       	or	r15, r31
    78b6:	07 c0       	rjmp	.+14     	; 0x78c6 <vfprintf+0x168>
    78b8:	96 36       	cpi	r25, 0x66	; 102
    78ba:	19 f4       	brne	.+6      	; 0x78c2 <vfprintf+0x164>
    78bc:	20 e8       	ldi	r18, 0x80	; 128
    78be:	f2 2a       	or	r15, r18
    78c0:	02 c0       	rjmp	.+4      	; 0x78c6 <vfprintf+0x168>
    78c2:	91 10       	cpse	r9, r1
    78c4:	9a 94       	dec	r9
    78c6:	f7 fe       	sbrs	r15, 7
    78c8:	0a c0       	rjmp	.+20     	; 0x78de <vfprintf+0x180>
    78ca:	3b e3       	ldi	r19, 0x3B	; 59
    78cc:	39 15       	cp	r19, r9
    78ce:	18 f4       	brcc	.+6      	; 0x78d6 <vfprintf+0x178>
    78d0:	5c e3       	ldi	r21, 0x3C	; 60
    78d2:	b5 2e       	mov	r11, r21
    78d4:	02 c0       	rjmp	.+4      	; 0x78da <vfprintf+0x17c>
    78d6:	b9 2c       	mov	r11, r9
    78d8:	b3 94       	inc	r11
    78da:	27 e0       	ldi	r18, 0x07	; 7
    78dc:	09 c0       	rjmp	.+18     	; 0x78f0 <vfprintf+0x192>
    78de:	47 e0       	ldi	r20, 0x07	; 7
    78e0:	49 15       	cp	r20, r9
    78e2:	20 f4       	brcc	.+8      	; 0x78ec <vfprintf+0x18e>
    78e4:	bb 24       	eor	r11, r11
    78e6:	47 e0       	ldi	r20, 0x07	; 7
    78e8:	94 2e       	mov	r9, r20
    78ea:	f7 cf       	rjmp	.-18     	; 0x78da <vfprintf+0x17c>
    78ec:	29 2d       	mov	r18, r9
    78ee:	bb 24       	eor	r11, r11
    78f0:	c6 01       	movw	r24, r12
    78f2:	04 96       	adiw	r24, 0x04	; 4
    78f4:	9d 87       	std	Y+13, r25	; 0x0d
    78f6:	8c 87       	std	Y+12, r24	; 0x0c
    78f8:	f6 01       	movw	r30, r12
    78fa:	60 81       	ld	r22, Z
    78fc:	71 81       	ldd	r23, Z+1	; 0x01
    78fe:	82 81       	ldd	r24, Z+2	; 0x02
    7900:	93 81       	ldd	r25, Z+3	; 0x03
    7902:	ae 01       	movw	r20, r28
    7904:	4f 5f       	subi	r20, 0xFF	; 255
    7906:	5f 4f       	sbci	r21, 0xFF	; 255
    7908:	0b 2d       	mov	r16, r11
    790a:	0e 94 6a 44 	call	0x88d4	; 0x88d4 <__ftoa_engine>
    790e:	6c 01       	movw	r12, r24
    7910:	09 81       	ldd	r16, Y+1	; 0x01
    7912:	20 2e       	mov	r2, r16
    7914:	33 24       	eor	r3, r3
    7916:	00 ff       	sbrs	r16, 0
    7918:	04 c0       	rjmp	.+8      	; 0x7922 <vfprintf+0x1c4>
    791a:	03 fd       	sbrc	r16, 3
    791c:	02 c0       	rjmp	.+4      	; 0x7922 <vfprintf+0x1c4>
    791e:	1d e2       	ldi	r17, 0x2D	; 45
    7920:	09 c0       	rjmp	.+18     	; 0x7934 <vfprintf+0x1d6>
    7922:	f1 fe       	sbrs	r15, 1
    7924:	02 c0       	rjmp	.+4      	; 0x792a <vfprintf+0x1cc>
    7926:	1b e2       	ldi	r17, 0x2B	; 43
    7928:	05 c0       	rjmp	.+10     	; 0x7934 <vfprintf+0x1d6>
    792a:	f2 fc       	sbrc	r15, 2
    792c:	02 c0       	rjmp	.+4      	; 0x7932 <vfprintf+0x1d4>
    792e:	10 e0       	ldi	r17, 0x00	; 0
    7930:	01 c0       	rjmp	.+2      	; 0x7934 <vfprintf+0x1d6>
    7932:	10 e2       	ldi	r17, 0x20	; 32
    7934:	c1 01       	movw	r24, r2
    7936:	8c 70       	andi	r24, 0x0C	; 12
    7938:	90 70       	andi	r25, 0x00	; 0
    793a:	89 2b       	or	r24, r25
    793c:	b9 f1       	breq	.+110    	; 0x79ac <vfprintf+0x24e>
    793e:	11 23       	and	r17, r17
    7940:	11 f4       	brne	.+4      	; 0x7946 <vfprintf+0x1e8>
    7942:	83 e0       	ldi	r24, 0x03	; 3
    7944:	01 c0       	rjmp	.+2      	; 0x7948 <vfprintf+0x1ea>
    7946:	84 e0       	ldi	r24, 0x04	; 4
    7948:	88 15       	cp	r24, r8
    794a:	10 f0       	brcs	.+4      	; 0x7950 <vfprintf+0x1f2>
    794c:	88 24       	eor	r8, r8
    794e:	0a c0       	rjmp	.+20     	; 0x7964 <vfprintf+0x206>
    7950:	88 1a       	sub	r8, r24
    7952:	f3 fc       	sbrc	r15, 3
    7954:	07 c0       	rjmp	.+14     	; 0x7964 <vfprintf+0x206>
    7956:	80 e2       	ldi	r24, 0x20	; 32
    7958:	90 e0       	ldi	r25, 0x00	; 0
    795a:	b3 01       	movw	r22, r6
    795c:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7960:	8a 94       	dec	r8
    7962:	c9 f7       	brne	.-14     	; 0x7956 <vfprintf+0x1f8>
    7964:	11 23       	and	r17, r17
    7966:	29 f0       	breq	.+10     	; 0x7972 <vfprintf+0x214>
    7968:	81 2f       	mov	r24, r17
    796a:	90 e0       	ldi	r25, 0x00	; 0
    796c:	b3 01       	movw	r22, r6
    796e:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7972:	23 fe       	sbrs	r2, 3
    7974:	03 c0       	rjmp	.+6      	; 0x797c <vfprintf+0x21e>
    7976:	00 e0       	ldi	r16, 0x00	; 0
    7978:	15 e0       	ldi	r17, 0x05	; 5
    797a:	0e c0       	rjmp	.+28     	; 0x7998 <vfprintf+0x23a>
    797c:	04 e0       	ldi	r16, 0x04	; 4
    797e:	15 e0       	ldi	r17, 0x05	; 5
    7980:	0b c0       	rjmp	.+22     	; 0x7998 <vfprintf+0x23a>
    7982:	e1 14       	cp	r14, r1
    7984:	f1 04       	cpc	r15, r1
    7986:	09 f0       	breq	.+2      	; 0x798a <vfprintf+0x22c>
    7988:	80 52       	subi	r24, 0x20	; 32
    798a:	90 e0       	ldi	r25, 0x00	; 0
    798c:	b3 01       	movw	r22, r6
    798e:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7992:	0f 5f       	subi	r16, 0xFF	; 255
    7994:	1f 4f       	sbci	r17, 0xFF	; 255
    7996:	05 c0       	rjmp	.+10     	; 0x79a2 <vfprintf+0x244>
    7998:	ef 2c       	mov	r14, r15
    799a:	ff 24       	eor	r15, r15
    799c:	f0 e1       	ldi	r31, 0x10	; 16
    799e:	ef 22       	and	r14, r31
    79a0:	ff 24       	eor	r15, r15
    79a2:	f8 01       	movw	r30, r16
    79a4:	84 91       	lpm	r24, Z+
    79a6:	88 23       	and	r24, r24
    79a8:	61 f7       	brne	.-40     	; 0x7982 <vfprintf+0x224>
    79aa:	14 c1       	rjmp	.+552    	; 0x7bd4 <vfprintf+0x476>
    79ac:	f7 fe       	sbrs	r15, 7
    79ae:	12 c0       	rjmp	.+36     	; 0x79d4 <vfprintf+0x276>
    79b0:	bc 0c       	add	r11, r12
    79b2:	24 fe       	sbrs	r2, 4
    79b4:	04 c0       	rjmp	.+8      	; 0x79be <vfprintf+0x260>
    79b6:	8a 81       	ldd	r24, Y+2	; 0x02
    79b8:	81 33       	cpi	r24, 0x31	; 49
    79ba:	09 f4       	brne	.+2      	; 0x79be <vfprintf+0x260>
    79bc:	ba 94       	dec	r11
    79be:	1b 14       	cp	r1, r11
    79c0:	1c f0       	brlt	.+6      	; 0x79c8 <vfprintf+0x26a>
    79c2:	bb 24       	eor	r11, r11
    79c4:	b3 94       	inc	r11
    79c6:	2d c0       	rjmp	.+90     	; 0x7a22 <vfprintf+0x2c4>
    79c8:	f8 e0       	ldi	r31, 0x08	; 8
    79ca:	fb 15       	cp	r31, r11
    79cc:	50 f5       	brcc	.+84     	; 0x7a22 <vfprintf+0x2c4>
    79ce:	38 e0       	ldi	r19, 0x08	; 8
    79d0:	b3 2e       	mov	r11, r19
    79d2:	27 c0       	rjmp	.+78     	; 0x7a22 <vfprintf+0x2c4>
    79d4:	f6 fc       	sbrc	r15, 6
    79d6:	25 c0       	rjmp	.+74     	; 0x7a22 <vfprintf+0x2c4>
    79d8:	89 2d       	mov	r24, r9
    79da:	90 e0       	ldi	r25, 0x00	; 0
    79dc:	8c 15       	cp	r24, r12
    79de:	9d 05       	cpc	r25, r13
    79e0:	4c f0       	brlt	.+18     	; 0x79f4 <vfprintf+0x296>
    79e2:	2c ef       	ldi	r18, 0xFC	; 252
    79e4:	c2 16       	cp	r12, r18
    79e6:	2f ef       	ldi	r18, 0xFF	; 255
    79e8:	d2 06       	cpc	r13, r18
    79ea:	24 f0       	brlt	.+8      	; 0x79f4 <vfprintf+0x296>
    79ec:	30 e8       	ldi	r19, 0x80	; 128
    79ee:	f3 2a       	or	r15, r19
    79f0:	01 c0       	rjmp	.+2      	; 0x79f4 <vfprintf+0x296>
    79f2:	9a 94       	dec	r9
    79f4:	99 20       	and	r9, r9
    79f6:	49 f0       	breq	.+18     	; 0x7a0a <vfprintf+0x2ac>
    79f8:	e2 e0       	ldi	r30, 0x02	; 2
    79fa:	f0 e0       	ldi	r31, 0x00	; 0
    79fc:	ec 0f       	add	r30, r28
    79fe:	fd 1f       	adc	r31, r29
    7a00:	e9 0d       	add	r30, r9
    7a02:	f1 1d       	adc	r31, r1
    7a04:	80 81       	ld	r24, Z
    7a06:	80 33       	cpi	r24, 0x30	; 48
    7a08:	a1 f3       	breq	.-24     	; 0x79f2 <vfprintf+0x294>
    7a0a:	f7 fe       	sbrs	r15, 7
    7a0c:	0a c0       	rjmp	.+20     	; 0x7a22 <vfprintf+0x2c4>
    7a0e:	b9 2c       	mov	r11, r9
    7a10:	b3 94       	inc	r11
    7a12:	89 2d       	mov	r24, r9
    7a14:	90 e0       	ldi	r25, 0x00	; 0
    7a16:	c8 16       	cp	r12, r24
    7a18:	d9 06       	cpc	r13, r25
    7a1a:	14 f0       	brlt	.+4      	; 0x7a20 <vfprintf+0x2c2>
    7a1c:	99 24       	eor	r9, r9
    7a1e:	01 c0       	rjmp	.+2      	; 0x7a22 <vfprintf+0x2c4>
    7a20:	9c 18       	sub	r9, r12
    7a22:	f7 fc       	sbrc	r15, 7
    7a24:	03 c0       	rjmp	.+6      	; 0x7a2c <vfprintf+0x2ce>
    7a26:	25 e0       	ldi	r18, 0x05	; 5
    7a28:	30 e0       	ldi	r19, 0x00	; 0
    7a2a:	09 c0       	rjmp	.+18     	; 0x7a3e <vfprintf+0x2e0>
    7a2c:	1c 14       	cp	r1, r12
    7a2e:	1d 04       	cpc	r1, r13
    7a30:	1c f0       	brlt	.+6      	; 0x7a38 <vfprintf+0x2da>
    7a32:	21 e0       	ldi	r18, 0x01	; 1
    7a34:	30 e0       	ldi	r19, 0x00	; 0
    7a36:	03 c0       	rjmp	.+6      	; 0x7a3e <vfprintf+0x2e0>
    7a38:	96 01       	movw	r18, r12
    7a3a:	2f 5f       	subi	r18, 0xFF	; 255
    7a3c:	3f 4f       	sbci	r19, 0xFF	; 255
    7a3e:	11 23       	and	r17, r17
    7a40:	11 f0       	breq	.+4      	; 0x7a46 <vfprintf+0x2e8>
    7a42:	2f 5f       	subi	r18, 0xFF	; 255
    7a44:	3f 4f       	sbci	r19, 0xFF	; 255
    7a46:	99 20       	and	r9, r9
    7a48:	29 f0       	breq	.+10     	; 0x7a54 <vfprintf+0x2f6>
    7a4a:	89 2d       	mov	r24, r9
    7a4c:	90 e0       	ldi	r25, 0x00	; 0
    7a4e:	01 96       	adiw	r24, 0x01	; 1
    7a50:	28 0f       	add	r18, r24
    7a52:	39 1f       	adc	r19, r25
    7a54:	88 2d       	mov	r24, r8
    7a56:	90 e0       	ldi	r25, 0x00	; 0
    7a58:	28 17       	cp	r18, r24
    7a5a:	39 07       	cpc	r19, r25
    7a5c:	14 f0       	brlt	.+4      	; 0x7a62 <vfprintf+0x304>
    7a5e:	88 24       	eor	r8, r8
    7a60:	01 c0       	rjmp	.+2      	; 0x7a64 <vfprintf+0x306>
    7a62:	82 1a       	sub	r8, r18
    7a64:	4f 2c       	mov	r4, r15
    7a66:	55 24       	eor	r5, r5
    7a68:	c2 01       	movw	r24, r4
    7a6a:	89 70       	andi	r24, 0x09	; 9
    7a6c:	90 70       	andi	r25, 0x00	; 0
    7a6e:	89 2b       	or	r24, r25
    7a70:	39 f0       	breq	.+14     	; 0x7a80 <vfprintf+0x322>
    7a72:	08 c0       	rjmp	.+16     	; 0x7a84 <vfprintf+0x326>
    7a74:	80 e2       	ldi	r24, 0x20	; 32
    7a76:	90 e0       	ldi	r25, 0x00	; 0
    7a78:	b3 01       	movw	r22, r6
    7a7a:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7a7e:	8a 94       	dec	r8
    7a80:	88 20       	and	r8, r8
    7a82:	c1 f7       	brne	.-16     	; 0x7a74 <vfprintf+0x316>
    7a84:	11 23       	and	r17, r17
    7a86:	29 f0       	breq	.+10     	; 0x7a92 <vfprintf+0x334>
    7a88:	81 2f       	mov	r24, r17
    7a8a:	90 e0       	ldi	r25, 0x00	; 0
    7a8c:	b3 01       	movw	r22, r6
    7a8e:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7a92:	43 fe       	sbrs	r4, 3
    7a94:	07 c0       	rjmp	.+14     	; 0x7aa4 <vfprintf+0x346>
    7a96:	08 c0       	rjmp	.+16     	; 0x7aa8 <vfprintf+0x34a>
    7a98:	80 e3       	ldi	r24, 0x30	; 48
    7a9a:	90 e0       	ldi	r25, 0x00	; 0
    7a9c:	b3 01       	movw	r22, r6
    7a9e:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7aa2:	8a 94       	dec	r8
    7aa4:	88 20       	and	r8, r8
    7aa6:	c1 f7       	brne	.-16     	; 0x7a98 <vfprintf+0x33a>
    7aa8:	f7 fe       	sbrs	r15, 7
    7aaa:	46 c0       	rjmp	.+140    	; 0x7b38 <vfprintf+0x3da>
    7aac:	86 01       	movw	r16, r12
    7aae:	d7 fe       	sbrs	r13, 7
    7ab0:	02 c0       	rjmp	.+4      	; 0x7ab6 <vfprintf+0x358>
    7ab2:	00 e0       	ldi	r16, 0x00	; 0
    7ab4:	10 e0       	ldi	r17, 0x00	; 0
    7ab6:	76 01       	movw	r14, r12
    7ab8:	08 94       	sec
    7aba:	e1 1c       	adc	r14, r1
    7abc:	f1 1c       	adc	r15, r1
    7abe:	e0 1a       	sub	r14, r16
    7ac0:	f1 0a       	sbc	r15, r17
    7ac2:	41 e0       	ldi	r20, 0x01	; 1
    7ac4:	50 e0       	ldi	r21, 0x00	; 0
    7ac6:	4c 0f       	add	r20, r28
    7ac8:	5d 1f       	adc	r21, r29
    7aca:	e4 0e       	add	r14, r20
    7acc:	f5 1e       	adc	r15, r21
    7ace:	26 01       	movw	r4, r12
    7ad0:	4b 18       	sub	r4, r11
    7ad2:	51 08       	sbc	r5, r1
    7ad4:	89 2d       	mov	r24, r9
    7ad6:	90 e0       	ldi	r25, 0x00	; 0
    7ad8:	aa 24       	eor	r10, r10
    7ada:	bb 24       	eor	r11, r11
    7adc:	a8 1a       	sub	r10, r24
    7ade:	b9 0a       	sbc	r11, r25
    7ae0:	5f ef       	ldi	r21, 0xFF	; 255
    7ae2:	0f 3f       	cpi	r16, 0xFF	; 255
    7ae4:	15 07       	cpc	r17, r21
    7ae6:	29 f4       	brne	.+10     	; 0x7af2 <vfprintf+0x394>
    7ae8:	8e e2       	ldi	r24, 0x2E	; 46
    7aea:	90 e0       	ldi	r25, 0x00	; 0
    7aec:	b3 01       	movw	r22, r6
    7aee:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7af2:	c0 16       	cp	r12, r16
    7af4:	d1 06       	cpc	r13, r17
    7af6:	34 f0       	brlt	.+12     	; 0x7b04 <vfprintf+0x3a6>
    7af8:	40 16       	cp	r4, r16
    7afa:	51 06       	cpc	r5, r17
    7afc:	1c f4       	brge	.+6      	; 0x7b04 <vfprintf+0x3a6>
    7afe:	f7 01       	movw	r30, r14
    7b00:	80 81       	ld	r24, Z
    7b02:	01 c0       	rjmp	.+2      	; 0x7b06 <vfprintf+0x3a8>
    7b04:	80 e3       	ldi	r24, 0x30	; 48
    7b06:	01 50       	subi	r16, 0x01	; 1
    7b08:	10 40       	sbci	r17, 0x00	; 0
    7b0a:	08 94       	sec
    7b0c:	e1 1c       	adc	r14, r1
    7b0e:	f1 1c       	adc	r15, r1
    7b10:	0a 15       	cp	r16, r10
    7b12:	1b 05       	cpc	r17, r11
    7b14:	2c f0       	brlt	.+10     	; 0x7b20 <vfprintf+0x3c2>
    7b16:	90 e0       	ldi	r25, 0x00	; 0
    7b18:	b3 01       	movw	r22, r6
    7b1a:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7b1e:	e0 cf       	rjmp	.-64     	; 0x7ae0 <vfprintf+0x382>
    7b20:	0c 15       	cp	r16, r12
    7b22:	1d 05       	cpc	r17, r13
    7b24:	39 f4       	brne	.+14     	; 0x7b34 <vfprintf+0x3d6>
    7b26:	9a 81       	ldd	r25, Y+2	; 0x02
    7b28:	96 33       	cpi	r25, 0x36	; 54
    7b2a:	18 f4       	brcc	.+6      	; 0x7b32 <vfprintf+0x3d4>
    7b2c:	95 33       	cpi	r25, 0x35	; 53
    7b2e:	11 f4       	brne	.+4      	; 0x7b34 <vfprintf+0x3d6>
    7b30:	24 fe       	sbrs	r2, 4
    7b32:	81 e3       	ldi	r24, 0x31	; 49
    7b34:	90 e0       	ldi	r25, 0x00	; 0
    7b36:	4b c0       	rjmp	.+150    	; 0x7bce <vfprintf+0x470>
    7b38:	8a 81       	ldd	r24, Y+2	; 0x02
    7b3a:	81 33       	cpi	r24, 0x31	; 49
    7b3c:	09 f0       	breq	.+2      	; 0x7b40 <vfprintf+0x3e2>
    7b3e:	0f 7e       	andi	r16, 0xEF	; 239
    7b40:	90 e0       	ldi	r25, 0x00	; 0
    7b42:	b3 01       	movw	r22, r6
    7b44:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7b48:	99 20       	and	r9, r9
    7b4a:	a1 f0       	breq	.+40     	; 0x7b74 <vfprintf+0x416>
    7b4c:	8e e2       	ldi	r24, 0x2E	; 46
    7b4e:	90 e0       	ldi	r25, 0x00	; 0
    7b50:	b3 01       	movw	r22, r6
    7b52:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7b56:	12 e0       	ldi	r17, 0x02	; 2
    7b58:	e1 e0       	ldi	r30, 0x01	; 1
    7b5a:	f0 e0       	ldi	r31, 0x00	; 0
    7b5c:	ec 0f       	add	r30, r28
    7b5e:	fd 1f       	adc	r31, r29
    7b60:	e1 0f       	add	r30, r17
    7b62:	f1 1d       	adc	r31, r1
    7b64:	1f 5f       	subi	r17, 0xFF	; 255
    7b66:	80 81       	ld	r24, Z
    7b68:	90 e0       	ldi	r25, 0x00	; 0
    7b6a:	b3 01       	movw	r22, r6
    7b6c:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7b70:	9a 94       	dec	r9
    7b72:	91 f7       	brne	.-28     	; 0x7b58 <vfprintf+0x3fa>
    7b74:	44 fc       	sbrc	r4, 4
    7b76:	03 c0       	rjmp	.+6      	; 0x7b7e <vfprintf+0x420>
    7b78:	85 e6       	ldi	r24, 0x65	; 101
    7b7a:	90 e0       	ldi	r25, 0x00	; 0
    7b7c:	02 c0       	rjmp	.+4      	; 0x7b82 <vfprintf+0x424>
    7b7e:	85 e4       	ldi	r24, 0x45	; 69
    7b80:	90 e0       	ldi	r25, 0x00	; 0
    7b82:	b3 01       	movw	r22, r6
    7b84:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7b88:	d7 fc       	sbrc	r13, 7
    7b8a:	05 c0       	rjmp	.+10     	; 0x7b96 <vfprintf+0x438>
    7b8c:	c1 14       	cp	r12, r1
    7b8e:	d1 04       	cpc	r13, r1
    7b90:	41 f4       	brne	.+16     	; 0x7ba2 <vfprintf+0x444>
    7b92:	04 ff       	sbrs	r16, 4
    7b94:	06 c0       	rjmp	.+12     	; 0x7ba2 <vfprintf+0x444>
    7b96:	d0 94       	com	r13
    7b98:	c1 94       	neg	r12
    7b9a:	d1 08       	sbc	r13, r1
    7b9c:	d3 94       	inc	r13
    7b9e:	8d e2       	ldi	r24, 0x2D	; 45
    7ba0:	01 c0       	rjmp	.+2      	; 0x7ba4 <vfprintf+0x446>
    7ba2:	8b e2       	ldi	r24, 0x2B	; 43
    7ba4:	90 e0       	ldi	r25, 0x00	; 0
    7ba6:	b3 01       	movw	r22, r6
    7ba8:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7bac:	80 e3       	ldi	r24, 0x30	; 48
    7bae:	05 c0       	rjmp	.+10     	; 0x7bba <vfprintf+0x45c>
    7bb0:	8f 5f       	subi	r24, 0xFF	; 255
    7bb2:	26 ef       	ldi	r18, 0xF6	; 246
    7bb4:	3f ef       	ldi	r19, 0xFF	; 255
    7bb6:	c2 0e       	add	r12, r18
    7bb8:	d3 1e       	adc	r13, r19
    7bba:	3a e0       	ldi	r19, 0x0A	; 10
    7bbc:	c3 16       	cp	r12, r19
    7bbe:	d1 04       	cpc	r13, r1
    7bc0:	bc f7       	brge	.-18     	; 0x7bb0 <vfprintf+0x452>
    7bc2:	90 e0       	ldi	r25, 0x00	; 0
    7bc4:	b3 01       	movw	r22, r6
    7bc6:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7bca:	c6 01       	movw	r24, r12
    7bcc:	c0 96       	adiw	r24, 0x30	; 48
    7bce:	b3 01       	movw	r22, r6
    7bd0:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7bd4:	cc 84       	ldd	r12, Y+12	; 0x0c
    7bd6:	dd 84       	ldd	r13, Y+13	; 0x0d
    7bd8:	52 c1       	rjmp	.+676    	; 0x7e7e <vfprintf+0x720>
    7bda:	93 36       	cpi	r25, 0x63	; 99
    7bdc:	31 f0       	breq	.+12     	; 0x7bea <vfprintf+0x48c>
    7bde:	93 37       	cpi	r25, 0x73	; 115
    7be0:	99 f0       	breq	.+38     	; 0x7c08 <vfprintf+0x4aa>
    7be2:	93 35       	cpi	r25, 0x53	; 83
    7be4:	09 f0       	breq	.+2      	; 0x7be8 <vfprintf+0x48a>
    7be6:	59 c0       	rjmp	.+178    	; 0x7c9a <vfprintf+0x53c>
    7be8:	23 c0       	rjmp	.+70     	; 0x7c30 <vfprintf+0x4d2>
    7bea:	f6 01       	movw	r30, r12
    7bec:	80 81       	ld	r24, Z
    7bee:	89 83       	std	Y+1, r24	; 0x01
    7bf0:	5e 01       	movw	r10, r28
    7bf2:	08 94       	sec
    7bf4:	a1 1c       	adc	r10, r1
    7bf6:	b1 1c       	adc	r11, r1
    7bf8:	22 e0       	ldi	r18, 0x02	; 2
    7bfa:	30 e0       	ldi	r19, 0x00	; 0
    7bfc:	c2 0e       	add	r12, r18
    7bfe:	d3 1e       	adc	r13, r19
    7c00:	21 e0       	ldi	r18, 0x01	; 1
    7c02:	e2 2e       	mov	r14, r18
    7c04:	f1 2c       	mov	r15, r1
    7c06:	12 c0       	rjmp	.+36     	; 0x7c2c <vfprintf+0x4ce>
    7c08:	f6 01       	movw	r30, r12
    7c0a:	a0 80       	ld	r10, Z
    7c0c:	b1 80       	ldd	r11, Z+1	; 0x01
    7c0e:	16 fd       	sbrc	r17, 6
    7c10:	03 c0       	rjmp	.+6      	; 0x7c18 <vfprintf+0x4ba>
    7c12:	6f ef       	ldi	r22, 0xFF	; 255
    7c14:	7f ef       	ldi	r23, 0xFF	; 255
    7c16:	02 c0       	rjmp	.+4      	; 0x7c1c <vfprintf+0x4be>
    7c18:	69 2d       	mov	r22, r9
    7c1a:	70 e0       	ldi	r23, 0x00	; 0
    7c1c:	22 e0       	ldi	r18, 0x02	; 2
    7c1e:	30 e0       	ldi	r19, 0x00	; 0
    7c20:	c2 0e       	add	r12, r18
    7c22:	d3 1e       	adc	r13, r19
    7c24:	c5 01       	movw	r24, r10
    7c26:	0e 94 71 45 	call	0x8ae2	; 0x8ae2 <strnlen>
    7c2a:	7c 01       	movw	r14, r24
    7c2c:	1f 77       	andi	r17, 0x7F	; 127
    7c2e:	13 c0       	rjmp	.+38     	; 0x7c56 <vfprintf+0x4f8>
    7c30:	f6 01       	movw	r30, r12
    7c32:	a0 80       	ld	r10, Z
    7c34:	b1 80       	ldd	r11, Z+1	; 0x01
    7c36:	16 fd       	sbrc	r17, 6
    7c38:	03 c0       	rjmp	.+6      	; 0x7c40 <vfprintf+0x4e2>
    7c3a:	6f ef       	ldi	r22, 0xFF	; 255
    7c3c:	7f ef       	ldi	r23, 0xFF	; 255
    7c3e:	02 c0       	rjmp	.+4      	; 0x7c44 <vfprintf+0x4e6>
    7c40:	69 2d       	mov	r22, r9
    7c42:	70 e0       	ldi	r23, 0x00	; 0
    7c44:	22 e0       	ldi	r18, 0x02	; 2
    7c46:	30 e0       	ldi	r19, 0x00	; 0
    7c48:	c2 0e       	add	r12, r18
    7c4a:	d3 1e       	adc	r13, r19
    7c4c:	c5 01       	movw	r24, r10
    7c4e:	0e 94 51 45 	call	0x8aa2	; 0x8aa2 <strnlen_P>
    7c52:	7c 01       	movw	r14, r24
    7c54:	10 68       	ori	r17, 0x80	; 128
    7c56:	13 ff       	sbrs	r17, 3
    7c58:	07 c0       	rjmp	.+14     	; 0x7c68 <vfprintf+0x50a>
    7c5a:	1b c0       	rjmp	.+54     	; 0x7c92 <vfprintf+0x534>
    7c5c:	80 e2       	ldi	r24, 0x20	; 32
    7c5e:	90 e0       	ldi	r25, 0x00	; 0
    7c60:	b3 01       	movw	r22, r6
    7c62:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7c66:	8a 94       	dec	r8
    7c68:	88 2d       	mov	r24, r8
    7c6a:	90 e0       	ldi	r25, 0x00	; 0
    7c6c:	e8 16       	cp	r14, r24
    7c6e:	f9 06       	cpc	r15, r25
    7c70:	a8 f3       	brcs	.-22     	; 0x7c5c <vfprintf+0x4fe>
    7c72:	0f c0       	rjmp	.+30     	; 0x7c92 <vfprintf+0x534>
    7c74:	f5 01       	movw	r30, r10
    7c76:	17 fd       	sbrc	r17, 7
    7c78:	85 91       	lpm	r24, Z+
    7c7a:	17 ff       	sbrs	r17, 7
    7c7c:	81 91       	ld	r24, Z+
    7c7e:	5f 01       	movw	r10, r30
    7c80:	90 e0       	ldi	r25, 0x00	; 0
    7c82:	b3 01       	movw	r22, r6
    7c84:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7c88:	81 10       	cpse	r8, r1
    7c8a:	8a 94       	dec	r8
    7c8c:	08 94       	sec
    7c8e:	e1 08       	sbc	r14, r1
    7c90:	f1 08       	sbc	r15, r1
    7c92:	e1 14       	cp	r14, r1
    7c94:	f1 04       	cpc	r15, r1
    7c96:	71 f7       	brne	.-36     	; 0x7c74 <vfprintf+0x516>
    7c98:	f2 c0       	rjmp	.+484    	; 0x7e7e <vfprintf+0x720>
    7c9a:	94 36       	cpi	r25, 0x64	; 100
    7c9c:	11 f0       	breq	.+4      	; 0x7ca2 <vfprintf+0x544>
    7c9e:	99 36       	cpi	r25, 0x69	; 105
    7ca0:	89 f5       	brne	.+98     	; 0x7d04 <vfprintf+0x5a6>
    7ca2:	17 ff       	sbrs	r17, 7
    7ca4:	08 c0       	rjmp	.+16     	; 0x7cb6 <vfprintf+0x558>
    7ca6:	f6 01       	movw	r30, r12
    7ca8:	20 81       	ld	r18, Z
    7caa:	31 81       	ldd	r19, Z+1	; 0x01
    7cac:	42 81       	ldd	r20, Z+2	; 0x02
    7cae:	53 81       	ldd	r21, Z+3	; 0x03
    7cb0:	84 e0       	ldi	r24, 0x04	; 4
    7cb2:	90 e0       	ldi	r25, 0x00	; 0
    7cb4:	0a c0       	rjmp	.+20     	; 0x7cca <vfprintf+0x56c>
    7cb6:	f6 01       	movw	r30, r12
    7cb8:	80 81       	ld	r24, Z
    7cba:	91 81       	ldd	r25, Z+1	; 0x01
    7cbc:	9c 01       	movw	r18, r24
    7cbe:	44 27       	eor	r20, r20
    7cc0:	37 fd       	sbrc	r19, 7
    7cc2:	40 95       	com	r20
    7cc4:	54 2f       	mov	r21, r20
    7cc6:	82 e0       	ldi	r24, 0x02	; 2
    7cc8:	90 e0       	ldi	r25, 0x00	; 0
    7cca:	c8 0e       	add	r12, r24
    7ccc:	d9 1e       	adc	r13, r25
    7cce:	9f e6       	ldi	r25, 0x6F	; 111
    7cd0:	f9 2e       	mov	r15, r25
    7cd2:	f1 22       	and	r15, r17
    7cd4:	57 ff       	sbrs	r21, 7
    7cd6:	09 c0       	rjmp	.+18     	; 0x7cea <vfprintf+0x58c>
    7cd8:	50 95       	com	r21
    7cda:	40 95       	com	r20
    7cdc:	30 95       	com	r19
    7cde:	21 95       	neg	r18
    7ce0:	3f 4f       	sbci	r19, 0xFF	; 255
    7ce2:	4f 4f       	sbci	r20, 0xFF	; 255
    7ce4:	5f 4f       	sbci	r21, 0xFF	; 255
    7ce6:	90 e8       	ldi	r25, 0x80	; 128
    7ce8:	f9 2a       	or	r15, r25
    7cea:	ca 01       	movw	r24, r20
    7cec:	b9 01       	movw	r22, r18
    7cee:	ae 01       	movw	r20, r28
    7cf0:	4f 5f       	subi	r20, 0xFF	; 255
    7cf2:	5f 4f       	sbci	r21, 0xFF	; 255
    7cf4:	2a e0       	ldi	r18, 0x0A	; 10
    7cf6:	30 e0       	ldi	r19, 0x00	; 0
    7cf8:	0e 94 08 46 	call	0x8c10	; 0x8c10 <__ultoa_invert>
    7cfc:	e8 2e       	mov	r14, r24
    7cfe:	e8 89       	ldd	r30, Y+16	; 0x10
    7d00:	ee 1a       	sub	r14, r30
    7d02:	41 c0       	rjmp	.+130    	; 0x7d86 <vfprintf+0x628>
    7d04:	95 37       	cpi	r25, 0x75	; 117
    7d06:	21 f4       	brne	.+8      	; 0x7d10 <vfprintf+0x5b2>
    7d08:	1f 7e       	andi	r17, 0xEF	; 239
    7d0a:	2a e0       	ldi	r18, 0x0A	; 10
    7d0c:	30 e0       	ldi	r19, 0x00	; 0
    7d0e:	1c c0       	rjmp	.+56     	; 0x7d48 <vfprintf+0x5ea>
    7d10:	19 7f       	andi	r17, 0xF9	; 249
    7d12:	9f 36       	cpi	r25, 0x6F	; 111
    7d14:	61 f0       	breq	.+24     	; 0x7d2e <vfprintf+0x5d0>
    7d16:	90 37       	cpi	r25, 0x70	; 112
    7d18:	20 f4       	brcc	.+8      	; 0x7d22 <vfprintf+0x5c4>
    7d1a:	98 35       	cpi	r25, 0x58	; 88
    7d1c:	09 f0       	breq	.+2      	; 0x7d20 <vfprintf+0x5c2>
    7d1e:	b2 c0       	rjmp	.+356    	; 0x7e84 <vfprintf+0x726>
    7d20:	0f c0       	rjmp	.+30     	; 0x7d40 <vfprintf+0x5e2>
    7d22:	90 37       	cpi	r25, 0x70	; 112
    7d24:	39 f0       	breq	.+14     	; 0x7d34 <vfprintf+0x5d6>
    7d26:	98 37       	cpi	r25, 0x78	; 120
    7d28:	09 f0       	breq	.+2      	; 0x7d2c <vfprintf+0x5ce>
    7d2a:	ac c0       	rjmp	.+344    	; 0x7e84 <vfprintf+0x726>
    7d2c:	04 c0       	rjmp	.+8      	; 0x7d36 <vfprintf+0x5d8>
    7d2e:	28 e0       	ldi	r18, 0x08	; 8
    7d30:	30 e0       	ldi	r19, 0x00	; 0
    7d32:	0a c0       	rjmp	.+20     	; 0x7d48 <vfprintf+0x5ea>
    7d34:	10 61       	ori	r17, 0x10	; 16
    7d36:	14 fd       	sbrc	r17, 4
    7d38:	14 60       	ori	r17, 0x04	; 4
    7d3a:	20 e1       	ldi	r18, 0x10	; 16
    7d3c:	30 e0       	ldi	r19, 0x00	; 0
    7d3e:	04 c0       	rjmp	.+8      	; 0x7d48 <vfprintf+0x5ea>
    7d40:	14 fd       	sbrc	r17, 4
    7d42:	16 60       	ori	r17, 0x06	; 6
    7d44:	20 e1       	ldi	r18, 0x10	; 16
    7d46:	32 e0       	ldi	r19, 0x02	; 2
    7d48:	17 ff       	sbrs	r17, 7
    7d4a:	08 c0       	rjmp	.+16     	; 0x7d5c <vfprintf+0x5fe>
    7d4c:	f6 01       	movw	r30, r12
    7d4e:	60 81       	ld	r22, Z
    7d50:	71 81       	ldd	r23, Z+1	; 0x01
    7d52:	82 81       	ldd	r24, Z+2	; 0x02
    7d54:	93 81       	ldd	r25, Z+3	; 0x03
    7d56:	44 e0       	ldi	r20, 0x04	; 4
    7d58:	50 e0       	ldi	r21, 0x00	; 0
    7d5a:	08 c0       	rjmp	.+16     	; 0x7d6c <vfprintf+0x60e>
    7d5c:	f6 01       	movw	r30, r12
    7d5e:	80 81       	ld	r24, Z
    7d60:	91 81       	ldd	r25, Z+1	; 0x01
    7d62:	bc 01       	movw	r22, r24
    7d64:	80 e0       	ldi	r24, 0x00	; 0
    7d66:	90 e0       	ldi	r25, 0x00	; 0
    7d68:	42 e0       	ldi	r20, 0x02	; 2
    7d6a:	50 e0       	ldi	r21, 0x00	; 0
    7d6c:	c4 0e       	add	r12, r20
    7d6e:	d5 1e       	adc	r13, r21
    7d70:	ae 01       	movw	r20, r28
    7d72:	4f 5f       	subi	r20, 0xFF	; 255
    7d74:	5f 4f       	sbci	r21, 0xFF	; 255
    7d76:	0e 94 08 46 	call	0x8c10	; 0x8c10 <__ultoa_invert>
    7d7a:	e8 2e       	mov	r14, r24
    7d7c:	58 89       	ldd	r21, Y+16	; 0x10
    7d7e:	e5 1a       	sub	r14, r21
    7d80:	8f e7       	ldi	r24, 0x7F	; 127
    7d82:	f8 2e       	mov	r15, r24
    7d84:	f1 22       	and	r15, r17
    7d86:	f6 fe       	sbrs	r15, 6
    7d88:	0b c0       	rjmp	.+22     	; 0x7da0 <vfprintf+0x642>
    7d8a:	8e ef       	ldi	r24, 0xFE	; 254
    7d8c:	f8 22       	and	r15, r24
    7d8e:	e9 14       	cp	r14, r9
    7d90:	38 f4       	brcc	.+14     	; 0x7da0 <vfprintf+0x642>
    7d92:	f4 fe       	sbrs	r15, 4
    7d94:	07 c0       	rjmp	.+14     	; 0x7da4 <vfprintf+0x646>
    7d96:	f2 fc       	sbrc	r15, 2
    7d98:	05 c0       	rjmp	.+10     	; 0x7da4 <vfprintf+0x646>
    7d9a:	9f ee       	ldi	r25, 0xEF	; 239
    7d9c:	f9 22       	and	r15, r25
    7d9e:	02 c0       	rjmp	.+4      	; 0x7da4 <vfprintf+0x646>
    7da0:	1e 2d       	mov	r17, r14
    7da2:	01 c0       	rjmp	.+2      	; 0x7da6 <vfprintf+0x648>
    7da4:	19 2d       	mov	r17, r9
    7da6:	f4 fe       	sbrs	r15, 4
    7da8:	0d c0       	rjmp	.+26     	; 0x7dc4 <vfprintf+0x666>
    7daa:	fe 01       	movw	r30, r28
    7dac:	ee 0d       	add	r30, r14
    7dae:	f1 1d       	adc	r31, r1
    7db0:	80 81       	ld	r24, Z
    7db2:	80 33       	cpi	r24, 0x30	; 48
    7db4:	19 f4       	brne	.+6      	; 0x7dbc <vfprintf+0x65e>
    7db6:	e9 ee       	ldi	r30, 0xE9	; 233
    7db8:	fe 22       	and	r15, r30
    7dba:	08 c0       	rjmp	.+16     	; 0x7dcc <vfprintf+0x66e>
    7dbc:	1f 5f       	subi	r17, 0xFF	; 255
    7dbe:	f2 fe       	sbrs	r15, 2
    7dc0:	05 c0       	rjmp	.+10     	; 0x7dcc <vfprintf+0x66e>
    7dc2:	03 c0       	rjmp	.+6      	; 0x7dca <vfprintf+0x66c>
    7dc4:	8f 2d       	mov	r24, r15
    7dc6:	86 78       	andi	r24, 0x86	; 134
    7dc8:	09 f0       	breq	.+2      	; 0x7dcc <vfprintf+0x66e>
    7dca:	1f 5f       	subi	r17, 0xFF	; 255
    7dcc:	0f 2d       	mov	r16, r15
    7dce:	f3 fc       	sbrc	r15, 3
    7dd0:	14 c0       	rjmp	.+40     	; 0x7dfa <vfprintf+0x69c>
    7dd2:	f0 fe       	sbrs	r15, 0
    7dd4:	0f c0       	rjmp	.+30     	; 0x7df4 <vfprintf+0x696>
    7dd6:	18 15       	cp	r17, r8
    7dd8:	10 f0       	brcs	.+4      	; 0x7dde <vfprintf+0x680>
    7dda:	9e 2c       	mov	r9, r14
    7ddc:	0b c0       	rjmp	.+22     	; 0x7df4 <vfprintf+0x696>
    7dde:	9e 2c       	mov	r9, r14
    7de0:	98 0c       	add	r9, r8
    7de2:	91 1a       	sub	r9, r17
    7de4:	18 2d       	mov	r17, r8
    7de6:	06 c0       	rjmp	.+12     	; 0x7df4 <vfprintf+0x696>
    7de8:	80 e2       	ldi	r24, 0x20	; 32
    7dea:	90 e0       	ldi	r25, 0x00	; 0
    7dec:	b3 01       	movw	r22, r6
    7dee:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7df2:	1f 5f       	subi	r17, 0xFF	; 255
    7df4:	18 15       	cp	r17, r8
    7df6:	c0 f3       	brcs	.-16     	; 0x7de8 <vfprintf+0x68a>
    7df8:	04 c0       	rjmp	.+8      	; 0x7e02 <vfprintf+0x6a4>
    7dfa:	18 15       	cp	r17, r8
    7dfc:	10 f4       	brcc	.+4      	; 0x7e02 <vfprintf+0x6a4>
    7dfe:	81 1a       	sub	r8, r17
    7e00:	01 c0       	rjmp	.+2      	; 0x7e04 <vfprintf+0x6a6>
    7e02:	88 24       	eor	r8, r8
    7e04:	04 ff       	sbrs	r16, 4
    7e06:	0f c0       	rjmp	.+30     	; 0x7e26 <vfprintf+0x6c8>
    7e08:	80 e3       	ldi	r24, 0x30	; 48
    7e0a:	90 e0       	ldi	r25, 0x00	; 0
    7e0c:	b3 01       	movw	r22, r6
    7e0e:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7e12:	02 ff       	sbrs	r16, 2
    7e14:	1d c0       	rjmp	.+58     	; 0x7e50 <vfprintf+0x6f2>
    7e16:	01 fd       	sbrc	r16, 1
    7e18:	03 c0       	rjmp	.+6      	; 0x7e20 <vfprintf+0x6c2>
    7e1a:	88 e7       	ldi	r24, 0x78	; 120
    7e1c:	90 e0       	ldi	r25, 0x00	; 0
    7e1e:	0e c0       	rjmp	.+28     	; 0x7e3c <vfprintf+0x6de>
    7e20:	88 e5       	ldi	r24, 0x58	; 88
    7e22:	90 e0       	ldi	r25, 0x00	; 0
    7e24:	0b c0       	rjmp	.+22     	; 0x7e3c <vfprintf+0x6de>
    7e26:	80 2f       	mov	r24, r16
    7e28:	86 78       	andi	r24, 0x86	; 134
    7e2a:	91 f0       	breq	.+36     	; 0x7e50 <vfprintf+0x6f2>
    7e2c:	01 ff       	sbrs	r16, 1
    7e2e:	02 c0       	rjmp	.+4      	; 0x7e34 <vfprintf+0x6d6>
    7e30:	8b e2       	ldi	r24, 0x2B	; 43
    7e32:	01 c0       	rjmp	.+2      	; 0x7e36 <vfprintf+0x6d8>
    7e34:	80 e2       	ldi	r24, 0x20	; 32
    7e36:	f7 fc       	sbrc	r15, 7
    7e38:	8d e2       	ldi	r24, 0x2D	; 45
    7e3a:	90 e0       	ldi	r25, 0x00	; 0
    7e3c:	b3 01       	movw	r22, r6
    7e3e:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7e42:	06 c0       	rjmp	.+12     	; 0x7e50 <vfprintf+0x6f2>
    7e44:	80 e3       	ldi	r24, 0x30	; 48
    7e46:	90 e0       	ldi	r25, 0x00	; 0
    7e48:	b3 01       	movw	r22, r6
    7e4a:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7e4e:	9a 94       	dec	r9
    7e50:	e9 14       	cp	r14, r9
    7e52:	c0 f3       	brcs	.-16     	; 0x7e44 <vfprintf+0x6e6>
    7e54:	ea 94       	dec	r14
    7e56:	e1 e0       	ldi	r30, 0x01	; 1
    7e58:	f0 e0       	ldi	r31, 0x00	; 0
    7e5a:	ec 0f       	add	r30, r28
    7e5c:	fd 1f       	adc	r31, r29
    7e5e:	ee 0d       	add	r30, r14
    7e60:	f1 1d       	adc	r31, r1
    7e62:	80 81       	ld	r24, Z
    7e64:	90 e0       	ldi	r25, 0x00	; 0
    7e66:	b3 01       	movw	r22, r6
    7e68:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7e6c:	ee 20       	and	r14, r14
    7e6e:	91 f7       	brne	.-28     	; 0x7e54 <vfprintf+0x6f6>
    7e70:	06 c0       	rjmp	.+12     	; 0x7e7e <vfprintf+0x720>
    7e72:	80 e2       	ldi	r24, 0x20	; 32
    7e74:	90 e0       	ldi	r25, 0x00	; 0
    7e76:	b3 01       	movw	r22, r6
    7e78:	0e 94 ab 45 	call	0x8b56	; 0x8b56 <fputc>
    7e7c:	8a 94       	dec	r8
    7e7e:	88 20       	and	r8, r8
    7e80:	c1 f7       	brne	.-16     	; 0x7e72 <vfprintf+0x714>
    7e82:	99 cc       	rjmp	.-1742   	; 0x77b6 <vfprintf+0x58>
    7e84:	f3 01       	movw	r30, r6
    7e86:	66 81       	ldd	r22, Z+6	; 0x06
    7e88:	77 81       	ldd	r23, Z+7	; 0x07
    7e8a:	cb 01       	movw	r24, r22
    7e8c:	61 96       	adiw	r28, 0x11	; 17
    7e8e:	0f b6       	in	r0, 0x3f	; 63
    7e90:	f8 94       	cli
    7e92:	de bf       	out	0x3e, r29	; 62
    7e94:	0f be       	out	0x3f, r0	; 63
    7e96:	cd bf       	out	0x3d, r28	; 61
    7e98:	cf 91       	pop	r28
    7e9a:	df 91       	pop	r29
    7e9c:	1f 91       	pop	r17
    7e9e:	0f 91       	pop	r16
    7ea0:	ff 90       	pop	r15
    7ea2:	ef 90       	pop	r14
    7ea4:	df 90       	pop	r13
    7ea6:	cf 90       	pop	r12
    7ea8:	bf 90       	pop	r11
    7eaa:	af 90       	pop	r10
    7eac:	9f 90       	pop	r9
    7eae:	8f 90       	pop	r8
    7eb0:	7f 90       	pop	r7
    7eb2:	6f 90       	pop	r6
    7eb4:	5f 90       	pop	r5
    7eb6:	4f 90       	pop	r4
    7eb8:	3f 90       	pop	r3
    7eba:	2f 90       	pop	r2
    7ebc:	08 95       	ret

00007ebe <__subsf3>:
    7ebe:	50 58       	subi	r21, 0x80	; 128

00007ec0 <__addsf3>:
    7ec0:	bb 27       	eor	r27, r27
    7ec2:	aa 27       	eor	r26, r26
    7ec4:	0e d0       	rcall	.+28     	; 0x7ee2 <__addsf3x>
    7ec6:	b1 c1       	rjmp	.+866    	; 0x822a <__fp_round>
    7ec8:	a2 d1       	rcall	.+836    	; 0x820e <__fp_pscA>
    7eca:	30 f0       	brcs	.+12     	; 0x7ed8 <__addsf3+0x18>
    7ecc:	a7 d1       	rcall	.+846    	; 0x821c <__fp_pscB>
    7ece:	20 f0       	brcs	.+8      	; 0x7ed8 <__addsf3+0x18>
    7ed0:	31 f4       	brne	.+12     	; 0x7ede <__addsf3+0x1e>
    7ed2:	9f 3f       	cpi	r25, 0xFF	; 255
    7ed4:	11 f4       	brne	.+4      	; 0x7eda <__addsf3+0x1a>
    7ed6:	1e f4       	brtc	.+6      	; 0x7ede <__addsf3+0x1e>
    7ed8:	97 c1       	rjmp	.+814    	; 0x8208 <__fp_nan>
    7eda:	0e f4       	brtc	.+2      	; 0x7ede <__addsf3+0x1e>
    7edc:	e0 95       	com	r30
    7ede:	e7 fb       	bst	r30, 7
    7ee0:	64 c1       	rjmp	.+712    	; 0x81aa <__fp_inf>

00007ee2 <__addsf3x>:
    7ee2:	e9 2f       	mov	r30, r25
    7ee4:	b3 d1       	rcall	.+870    	; 0x824c <__fp_split3>
    7ee6:	80 f3       	brcs	.-32     	; 0x7ec8 <__addsf3+0x8>
    7ee8:	ba 17       	cp	r27, r26
    7eea:	62 07       	cpc	r22, r18
    7eec:	73 07       	cpc	r23, r19
    7eee:	84 07       	cpc	r24, r20
    7ef0:	95 07       	cpc	r25, r21
    7ef2:	18 f0       	brcs	.+6      	; 0x7efa <__addsf3x+0x18>
    7ef4:	71 f4       	brne	.+28     	; 0x7f12 <__addsf3x+0x30>
    7ef6:	9e f5       	brtc	.+102    	; 0x7f5e <__addsf3x+0x7c>
    7ef8:	e2 c1       	rjmp	.+964    	; 0x82be <__fp_zero>
    7efa:	0e f4       	brtc	.+2      	; 0x7efe <__addsf3x+0x1c>
    7efc:	e0 95       	com	r30
    7efe:	0b 2e       	mov	r0, r27
    7f00:	ba 2f       	mov	r27, r26
    7f02:	a0 2d       	mov	r26, r0
    7f04:	0b 01       	movw	r0, r22
    7f06:	b9 01       	movw	r22, r18
    7f08:	90 01       	movw	r18, r0
    7f0a:	0c 01       	movw	r0, r24
    7f0c:	ca 01       	movw	r24, r20
    7f0e:	a0 01       	movw	r20, r0
    7f10:	11 24       	eor	r1, r1
    7f12:	ff 27       	eor	r31, r31
    7f14:	59 1b       	sub	r21, r25
    7f16:	99 f0       	breq	.+38     	; 0x7f3e <__addsf3x+0x5c>
    7f18:	59 3f       	cpi	r21, 0xF9	; 249
    7f1a:	50 f4       	brcc	.+20     	; 0x7f30 <__addsf3x+0x4e>
    7f1c:	50 3e       	cpi	r21, 0xE0	; 224
    7f1e:	68 f1       	brcs	.+90     	; 0x7f7a <__addsf3x+0x98>
    7f20:	1a 16       	cp	r1, r26
    7f22:	f0 40       	sbci	r31, 0x00	; 0
    7f24:	a2 2f       	mov	r26, r18
    7f26:	23 2f       	mov	r18, r19
    7f28:	34 2f       	mov	r19, r20
    7f2a:	44 27       	eor	r20, r20
    7f2c:	58 5f       	subi	r21, 0xF8	; 248
    7f2e:	f3 cf       	rjmp	.-26     	; 0x7f16 <__addsf3x+0x34>
    7f30:	46 95       	lsr	r20
    7f32:	37 95       	ror	r19
    7f34:	27 95       	ror	r18
    7f36:	a7 95       	ror	r26
    7f38:	f0 40       	sbci	r31, 0x00	; 0
    7f3a:	53 95       	inc	r21
    7f3c:	c9 f7       	brne	.-14     	; 0x7f30 <__addsf3x+0x4e>
    7f3e:	7e f4       	brtc	.+30     	; 0x7f5e <__addsf3x+0x7c>
    7f40:	1f 16       	cp	r1, r31
    7f42:	ba 0b       	sbc	r27, r26
    7f44:	62 0b       	sbc	r22, r18
    7f46:	73 0b       	sbc	r23, r19
    7f48:	84 0b       	sbc	r24, r20
    7f4a:	ba f0       	brmi	.+46     	; 0x7f7a <__addsf3x+0x98>
    7f4c:	91 50       	subi	r25, 0x01	; 1
    7f4e:	a1 f0       	breq	.+40     	; 0x7f78 <__addsf3x+0x96>
    7f50:	ff 0f       	add	r31, r31
    7f52:	bb 1f       	adc	r27, r27
    7f54:	66 1f       	adc	r22, r22
    7f56:	77 1f       	adc	r23, r23
    7f58:	88 1f       	adc	r24, r24
    7f5a:	c2 f7       	brpl	.-16     	; 0x7f4c <__addsf3x+0x6a>
    7f5c:	0e c0       	rjmp	.+28     	; 0x7f7a <__addsf3x+0x98>
    7f5e:	ba 0f       	add	r27, r26
    7f60:	62 1f       	adc	r22, r18
    7f62:	73 1f       	adc	r23, r19
    7f64:	84 1f       	adc	r24, r20
    7f66:	48 f4       	brcc	.+18     	; 0x7f7a <__addsf3x+0x98>
    7f68:	87 95       	ror	r24
    7f6a:	77 95       	ror	r23
    7f6c:	67 95       	ror	r22
    7f6e:	b7 95       	ror	r27
    7f70:	f7 95       	ror	r31
    7f72:	9e 3f       	cpi	r25, 0xFE	; 254
    7f74:	08 f0       	brcs	.+2      	; 0x7f78 <__addsf3x+0x96>
    7f76:	b3 cf       	rjmp	.-154    	; 0x7ede <__addsf3+0x1e>
    7f78:	93 95       	inc	r25
    7f7a:	88 0f       	add	r24, r24
    7f7c:	08 f0       	brcs	.+2      	; 0x7f80 <__addsf3x+0x9e>
    7f7e:	99 27       	eor	r25, r25
    7f80:	ee 0f       	add	r30, r30
    7f82:	97 95       	ror	r25
    7f84:	87 95       	ror	r24
    7f86:	08 95       	ret

00007f88 <__cmpsf2>:
    7f88:	ec d0       	rcall	.+472    	; 0x8162 <__fp_cmp>
    7f8a:	08 f4       	brcc	.+2      	; 0x7f8e <__cmpsf2+0x6>
    7f8c:	81 e0       	ldi	r24, 0x01	; 1
    7f8e:	08 95       	ret

00007f90 <__divsf3>:
    7f90:	0c d0       	rcall	.+24     	; 0x7faa <__divsf3x>
    7f92:	4b c1       	rjmp	.+662    	; 0x822a <__fp_round>
    7f94:	43 d1       	rcall	.+646    	; 0x821c <__fp_pscB>
    7f96:	40 f0       	brcs	.+16     	; 0x7fa8 <__divsf3+0x18>
    7f98:	3a d1       	rcall	.+628    	; 0x820e <__fp_pscA>
    7f9a:	30 f0       	brcs	.+12     	; 0x7fa8 <__divsf3+0x18>
    7f9c:	21 f4       	brne	.+8      	; 0x7fa6 <__divsf3+0x16>
    7f9e:	5f 3f       	cpi	r21, 0xFF	; 255
    7fa0:	19 f0       	breq	.+6      	; 0x7fa8 <__divsf3+0x18>
    7fa2:	03 c1       	rjmp	.+518    	; 0x81aa <__fp_inf>
    7fa4:	51 11       	cpse	r21, r1
    7fa6:	8c c1       	rjmp	.+792    	; 0x82c0 <__fp_szero>
    7fa8:	2f c1       	rjmp	.+606    	; 0x8208 <__fp_nan>

00007faa <__divsf3x>:
    7faa:	50 d1       	rcall	.+672    	; 0x824c <__fp_split3>
    7fac:	98 f3       	brcs	.-26     	; 0x7f94 <__divsf3+0x4>

00007fae <__divsf3_pse>:
    7fae:	99 23       	and	r25, r25
    7fb0:	c9 f3       	breq	.-14     	; 0x7fa4 <__divsf3+0x14>
    7fb2:	55 23       	and	r21, r21
    7fb4:	b1 f3       	breq	.-20     	; 0x7fa2 <__divsf3+0x12>
    7fb6:	95 1b       	sub	r25, r21
    7fb8:	55 0b       	sbc	r21, r21
    7fba:	bb 27       	eor	r27, r27
    7fbc:	aa 27       	eor	r26, r26
    7fbe:	62 17       	cp	r22, r18
    7fc0:	73 07       	cpc	r23, r19
    7fc2:	84 07       	cpc	r24, r20
    7fc4:	38 f0       	brcs	.+14     	; 0x7fd4 <__divsf3_pse+0x26>
    7fc6:	9f 5f       	subi	r25, 0xFF	; 255
    7fc8:	5f 4f       	sbci	r21, 0xFF	; 255
    7fca:	22 0f       	add	r18, r18
    7fcc:	33 1f       	adc	r19, r19
    7fce:	44 1f       	adc	r20, r20
    7fd0:	aa 1f       	adc	r26, r26
    7fd2:	a9 f3       	breq	.-22     	; 0x7fbe <__divsf3_pse+0x10>
    7fd4:	33 d0       	rcall	.+102    	; 0x803c <__divsf3_pse+0x8e>
    7fd6:	0e 2e       	mov	r0, r30
    7fd8:	3a f0       	brmi	.+14     	; 0x7fe8 <__divsf3_pse+0x3a>
    7fda:	e0 e8       	ldi	r30, 0x80	; 128
    7fdc:	30 d0       	rcall	.+96     	; 0x803e <__divsf3_pse+0x90>
    7fde:	91 50       	subi	r25, 0x01	; 1
    7fe0:	50 40       	sbci	r21, 0x00	; 0
    7fe2:	e6 95       	lsr	r30
    7fe4:	00 1c       	adc	r0, r0
    7fe6:	ca f7       	brpl	.-14     	; 0x7fda <__divsf3_pse+0x2c>
    7fe8:	29 d0       	rcall	.+82     	; 0x803c <__divsf3_pse+0x8e>
    7fea:	fe 2f       	mov	r31, r30
    7fec:	27 d0       	rcall	.+78     	; 0x803c <__divsf3_pse+0x8e>
    7fee:	66 0f       	add	r22, r22
    7ff0:	77 1f       	adc	r23, r23
    7ff2:	88 1f       	adc	r24, r24
    7ff4:	bb 1f       	adc	r27, r27
    7ff6:	26 17       	cp	r18, r22
    7ff8:	37 07       	cpc	r19, r23
    7ffa:	48 07       	cpc	r20, r24
    7ffc:	ab 07       	cpc	r26, r27
    7ffe:	b0 e8       	ldi	r27, 0x80	; 128
    8000:	09 f0       	breq	.+2      	; 0x8004 <__divsf3_pse+0x56>
    8002:	bb 0b       	sbc	r27, r27
    8004:	80 2d       	mov	r24, r0
    8006:	bf 01       	movw	r22, r30
    8008:	ff 27       	eor	r31, r31
    800a:	93 58       	subi	r25, 0x83	; 131
    800c:	5f 4f       	sbci	r21, 0xFF	; 255
    800e:	2a f0       	brmi	.+10     	; 0x801a <__divsf3_pse+0x6c>
    8010:	9e 3f       	cpi	r25, 0xFE	; 254
    8012:	51 05       	cpc	r21, r1
    8014:	68 f0       	brcs	.+26     	; 0x8030 <__divsf3_pse+0x82>
    8016:	c9 c0       	rjmp	.+402    	; 0x81aa <__fp_inf>
    8018:	53 c1       	rjmp	.+678    	; 0x82c0 <__fp_szero>
    801a:	5f 3f       	cpi	r21, 0xFF	; 255
    801c:	ec f3       	brlt	.-6      	; 0x8018 <__divsf3_pse+0x6a>
    801e:	98 3e       	cpi	r25, 0xE8	; 232
    8020:	dc f3       	brlt	.-10     	; 0x8018 <__divsf3_pse+0x6a>
    8022:	86 95       	lsr	r24
    8024:	77 95       	ror	r23
    8026:	67 95       	ror	r22
    8028:	b7 95       	ror	r27
    802a:	f7 95       	ror	r31
    802c:	9f 5f       	subi	r25, 0xFF	; 255
    802e:	c9 f7       	brne	.-14     	; 0x8022 <__divsf3_pse+0x74>
    8030:	88 0f       	add	r24, r24
    8032:	91 1d       	adc	r25, r1
    8034:	96 95       	lsr	r25
    8036:	87 95       	ror	r24
    8038:	97 f9       	bld	r25, 7
    803a:	08 95       	ret
    803c:	e1 e0       	ldi	r30, 0x01	; 1
    803e:	66 0f       	add	r22, r22
    8040:	77 1f       	adc	r23, r23
    8042:	88 1f       	adc	r24, r24
    8044:	bb 1f       	adc	r27, r27
    8046:	62 17       	cp	r22, r18
    8048:	73 07       	cpc	r23, r19
    804a:	84 07       	cpc	r24, r20
    804c:	ba 07       	cpc	r27, r26
    804e:	20 f0       	brcs	.+8      	; 0x8058 <__divsf3_pse+0xaa>
    8050:	62 1b       	sub	r22, r18
    8052:	73 0b       	sbc	r23, r19
    8054:	84 0b       	sbc	r24, r20
    8056:	ba 0b       	sbc	r27, r26
    8058:	ee 1f       	adc	r30, r30
    805a:	88 f7       	brcc	.-30     	; 0x803e <__divsf3_pse+0x90>
    805c:	e0 95       	com	r30
    805e:	08 95       	ret

00008060 <__fixsfsi>:
    8060:	04 d0       	rcall	.+8      	; 0x806a <__fixunssfsi>
    8062:	68 94       	set
    8064:	b1 11       	cpse	r27, r1
    8066:	2c c1       	rjmp	.+600    	; 0x82c0 <__fp_szero>
    8068:	08 95       	ret

0000806a <__fixunssfsi>:
    806a:	f8 d0       	rcall	.+496    	; 0x825c <__fp_splitA>
    806c:	88 f0       	brcs	.+34     	; 0x8090 <__fixunssfsi+0x26>
    806e:	9f 57       	subi	r25, 0x7F	; 127
    8070:	90 f0       	brcs	.+36     	; 0x8096 <__fixunssfsi+0x2c>
    8072:	b9 2f       	mov	r27, r25
    8074:	99 27       	eor	r25, r25
    8076:	b7 51       	subi	r27, 0x17	; 23
    8078:	a0 f0       	brcs	.+40     	; 0x80a2 <__fixunssfsi+0x38>
    807a:	d1 f0       	breq	.+52     	; 0x80b0 <__fixunssfsi+0x46>
    807c:	66 0f       	add	r22, r22
    807e:	77 1f       	adc	r23, r23
    8080:	88 1f       	adc	r24, r24
    8082:	99 1f       	adc	r25, r25
    8084:	1a f0       	brmi	.+6      	; 0x808c <__fixunssfsi+0x22>
    8086:	ba 95       	dec	r27
    8088:	c9 f7       	brne	.-14     	; 0x807c <__fixunssfsi+0x12>
    808a:	12 c0       	rjmp	.+36     	; 0x80b0 <__fixunssfsi+0x46>
    808c:	b1 30       	cpi	r27, 0x01	; 1
    808e:	81 f0       	breq	.+32     	; 0x80b0 <__fixunssfsi+0x46>
    8090:	16 d1       	rcall	.+556    	; 0x82be <__fp_zero>
    8092:	b1 e0       	ldi	r27, 0x01	; 1
    8094:	08 95       	ret
    8096:	13 c1       	rjmp	.+550    	; 0x82be <__fp_zero>
    8098:	67 2f       	mov	r22, r23
    809a:	78 2f       	mov	r23, r24
    809c:	88 27       	eor	r24, r24
    809e:	b8 5f       	subi	r27, 0xF8	; 248
    80a0:	39 f0       	breq	.+14     	; 0x80b0 <__fixunssfsi+0x46>
    80a2:	b9 3f       	cpi	r27, 0xF9	; 249
    80a4:	cc f3       	brlt	.-14     	; 0x8098 <__fixunssfsi+0x2e>
    80a6:	86 95       	lsr	r24
    80a8:	77 95       	ror	r23
    80aa:	67 95       	ror	r22
    80ac:	b3 95       	inc	r27
    80ae:	d9 f7       	brne	.-10     	; 0x80a6 <__fixunssfsi+0x3c>
    80b0:	3e f4       	brtc	.+14     	; 0x80c0 <__fixunssfsi+0x56>
    80b2:	90 95       	com	r25
    80b4:	80 95       	com	r24
    80b6:	70 95       	com	r23
    80b8:	61 95       	neg	r22
    80ba:	7f 4f       	sbci	r23, 0xFF	; 255
    80bc:	8f 4f       	sbci	r24, 0xFF	; 255
    80be:	9f 4f       	sbci	r25, 0xFF	; 255
    80c0:	08 95       	ret

000080c2 <__floatunsisf>:
    80c2:	e8 94       	clt
    80c4:	09 c0       	rjmp	.+18     	; 0x80d8 <__floatsisf+0x12>

000080c6 <__floatsisf>:
    80c6:	97 fb       	bst	r25, 7
    80c8:	3e f4       	brtc	.+14     	; 0x80d8 <__floatsisf+0x12>
    80ca:	90 95       	com	r25
    80cc:	80 95       	com	r24
    80ce:	70 95       	com	r23
    80d0:	61 95       	neg	r22
    80d2:	7f 4f       	sbci	r23, 0xFF	; 255
    80d4:	8f 4f       	sbci	r24, 0xFF	; 255
    80d6:	9f 4f       	sbci	r25, 0xFF	; 255
    80d8:	99 23       	and	r25, r25
    80da:	a9 f0       	breq	.+42     	; 0x8106 <__floatsisf+0x40>
    80dc:	f9 2f       	mov	r31, r25
    80de:	96 e9       	ldi	r25, 0x96	; 150
    80e0:	bb 27       	eor	r27, r27
    80e2:	93 95       	inc	r25
    80e4:	f6 95       	lsr	r31
    80e6:	87 95       	ror	r24
    80e8:	77 95       	ror	r23
    80ea:	67 95       	ror	r22
    80ec:	b7 95       	ror	r27
    80ee:	f1 11       	cpse	r31, r1
    80f0:	f8 cf       	rjmp	.-16     	; 0x80e2 <__floatsisf+0x1c>
    80f2:	fa f4       	brpl	.+62     	; 0x8132 <__floatsisf+0x6c>
    80f4:	bb 0f       	add	r27, r27
    80f6:	11 f4       	brne	.+4      	; 0x80fc <__floatsisf+0x36>
    80f8:	60 ff       	sbrs	r22, 0
    80fa:	1b c0       	rjmp	.+54     	; 0x8132 <__floatsisf+0x6c>
    80fc:	6f 5f       	subi	r22, 0xFF	; 255
    80fe:	7f 4f       	sbci	r23, 0xFF	; 255
    8100:	8f 4f       	sbci	r24, 0xFF	; 255
    8102:	9f 4f       	sbci	r25, 0xFF	; 255
    8104:	16 c0       	rjmp	.+44     	; 0x8132 <__floatsisf+0x6c>
    8106:	88 23       	and	r24, r24
    8108:	11 f0       	breq	.+4      	; 0x810e <__floatsisf+0x48>
    810a:	96 e9       	ldi	r25, 0x96	; 150
    810c:	11 c0       	rjmp	.+34     	; 0x8130 <__floatsisf+0x6a>
    810e:	77 23       	and	r23, r23
    8110:	21 f0       	breq	.+8      	; 0x811a <__floatsisf+0x54>
    8112:	9e e8       	ldi	r25, 0x8E	; 142
    8114:	87 2f       	mov	r24, r23
    8116:	76 2f       	mov	r23, r22
    8118:	05 c0       	rjmp	.+10     	; 0x8124 <__floatsisf+0x5e>
    811a:	66 23       	and	r22, r22
    811c:	71 f0       	breq	.+28     	; 0x813a <__floatsisf+0x74>
    811e:	96 e8       	ldi	r25, 0x86	; 134
    8120:	86 2f       	mov	r24, r22
    8122:	70 e0       	ldi	r23, 0x00	; 0
    8124:	60 e0       	ldi	r22, 0x00	; 0
    8126:	2a f0       	brmi	.+10     	; 0x8132 <__floatsisf+0x6c>
    8128:	9a 95       	dec	r25
    812a:	66 0f       	add	r22, r22
    812c:	77 1f       	adc	r23, r23
    812e:	88 1f       	adc	r24, r24
    8130:	da f7       	brpl	.-10     	; 0x8128 <__floatsisf+0x62>
    8132:	88 0f       	add	r24, r24
    8134:	96 95       	lsr	r25
    8136:	87 95       	ror	r24
    8138:	97 f9       	bld	r25, 7
    813a:	08 95       	ret

0000813c <floor>:
    813c:	a9 d0       	rcall	.+338    	; 0x8290 <__fp_trunc>
    813e:	80 f0       	brcs	.+32     	; 0x8160 <floor+0x24>
    8140:	9f 37       	cpi	r25, 0x7F	; 127
    8142:	40 f4       	brcc	.+16     	; 0x8154 <floor+0x18>
    8144:	91 11       	cpse	r25, r1
    8146:	0e f0       	brts	.+2      	; 0x814a <floor+0xe>
    8148:	bb c0       	rjmp	.+374    	; 0x82c0 <__fp_szero>
    814a:	60 e0       	ldi	r22, 0x00	; 0
    814c:	70 e0       	ldi	r23, 0x00	; 0
    814e:	80 e8       	ldi	r24, 0x80	; 128
    8150:	9f eb       	ldi	r25, 0xBF	; 191
    8152:	08 95       	ret
    8154:	26 f4       	brtc	.+8      	; 0x815e <floor+0x22>
    8156:	1b 16       	cp	r1, r27
    8158:	61 1d       	adc	r22, r1
    815a:	71 1d       	adc	r23, r1
    815c:	81 1d       	adc	r24, r1
    815e:	2b c0       	rjmp	.+86     	; 0x81b6 <__fp_mintl>
    8160:	45 c0       	rjmp	.+138    	; 0x81ec <__fp_mpack>

00008162 <__fp_cmp>:
    8162:	99 0f       	add	r25, r25
    8164:	00 08       	sbc	r0, r0
    8166:	55 0f       	add	r21, r21
    8168:	aa 0b       	sbc	r26, r26
    816a:	e0 e8       	ldi	r30, 0x80	; 128
    816c:	fe ef       	ldi	r31, 0xFE	; 254
    816e:	16 16       	cp	r1, r22
    8170:	17 06       	cpc	r1, r23
    8172:	e8 07       	cpc	r30, r24
    8174:	f9 07       	cpc	r31, r25
    8176:	c0 f0       	brcs	.+48     	; 0x81a8 <__fp_cmp+0x46>
    8178:	12 16       	cp	r1, r18
    817a:	13 06       	cpc	r1, r19
    817c:	e4 07       	cpc	r30, r20
    817e:	f5 07       	cpc	r31, r21
    8180:	98 f0       	brcs	.+38     	; 0x81a8 <__fp_cmp+0x46>
    8182:	62 1b       	sub	r22, r18
    8184:	73 0b       	sbc	r23, r19
    8186:	84 0b       	sbc	r24, r20
    8188:	95 0b       	sbc	r25, r21
    818a:	39 f4       	brne	.+14     	; 0x819a <__fp_cmp+0x38>
    818c:	0a 26       	eor	r0, r26
    818e:	61 f0       	breq	.+24     	; 0x81a8 <__fp_cmp+0x46>
    8190:	23 2b       	or	r18, r19
    8192:	24 2b       	or	r18, r20
    8194:	25 2b       	or	r18, r21
    8196:	21 f4       	brne	.+8      	; 0x81a0 <__fp_cmp+0x3e>
    8198:	08 95       	ret
    819a:	0a 26       	eor	r0, r26
    819c:	09 f4       	brne	.+2      	; 0x81a0 <__fp_cmp+0x3e>
    819e:	a1 40       	sbci	r26, 0x01	; 1
    81a0:	a6 95       	lsr	r26
    81a2:	8f ef       	ldi	r24, 0xFF	; 255
    81a4:	81 1d       	adc	r24, r1
    81a6:	81 1d       	adc	r24, r1
    81a8:	08 95       	ret

000081aa <__fp_inf>:
    81aa:	97 f9       	bld	r25, 7
    81ac:	9f 67       	ori	r25, 0x7F	; 127
    81ae:	80 e8       	ldi	r24, 0x80	; 128
    81b0:	70 e0       	ldi	r23, 0x00	; 0
    81b2:	60 e0       	ldi	r22, 0x00	; 0
    81b4:	08 95       	ret

000081b6 <__fp_mintl>:
    81b6:	88 23       	and	r24, r24
    81b8:	71 f4       	brne	.+28     	; 0x81d6 <__fp_mintl+0x20>
    81ba:	77 23       	and	r23, r23
    81bc:	21 f0       	breq	.+8      	; 0x81c6 <__fp_mintl+0x10>
    81be:	98 50       	subi	r25, 0x08	; 8
    81c0:	87 2b       	or	r24, r23
    81c2:	76 2f       	mov	r23, r22
    81c4:	07 c0       	rjmp	.+14     	; 0x81d4 <__fp_mintl+0x1e>
    81c6:	66 23       	and	r22, r22
    81c8:	11 f4       	brne	.+4      	; 0x81ce <__fp_mintl+0x18>
    81ca:	99 27       	eor	r25, r25
    81cc:	0d c0       	rjmp	.+26     	; 0x81e8 <__fp_mintl+0x32>
    81ce:	90 51       	subi	r25, 0x10	; 16
    81d0:	86 2b       	or	r24, r22
    81d2:	70 e0       	ldi	r23, 0x00	; 0
    81d4:	60 e0       	ldi	r22, 0x00	; 0
    81d6:	2a f0       	brmi	.+10     	; 0x81e2 <__fp_mintl+0x2c>
    81d8:	9a 95       	dec	r25
    81da:	66 0f       	add	r22, r22
    81dc:	77 1f       	adc	r23, r23
    81de:	88 1f       	adc	r24, r24
    81e0:	da f7       	brpl	.-10     	; 0x81d8 <__fp_mintl+0x22>
    81e2:	88 0f       	add	r24, r24
    81e4:	96 95       	lsr	r25
    81e6:	87 95       	ror	r24
    81e8:	97 f9       	bld	r25, 7
    81ea:	08 95       	ret

000081ec <__fp_mpack>:
    81ec:	9f 3f       	cpi	r25, 0xFF	; 255
    81ee:	31 f0       	breq	.+12     	; 0x81fc <__fp_mpack_finite+0xc>

000081f0 <__fp_mpack_finite>:
    81f0:	91 50       	subi	r25, 0x01	; 1
    81f2:	20 f4       	brcc	.+8      	; 0x81fc <__fp_mpack_finite+0xc>
    81f4:	87 95       	ror	r24
    81f6:	77 95       	ror	r23
    81f8:	67 95       	ror	r22
    81fa:	b7 95       	ror	r27
    81fc:	88 0f       	add	r24, r24
    81fe:	91 1d       	adc	r25, r1
    8200:	96 95       	lsr	r25
    8202:	87 95       	ror	r24
    8204:	97 f9       	bld	r25, 7
    8206:	08 95       	ret

00008208 <__fp_nan>:
    8208:	9f ef       	ldi	r25, 0xFF	; 255
    820a:	80 ec       	ldi	r24, 0xC0	; 192
    820c:	08 95       	ret

0000820e <__fp_pscA>:
    820e:	00 24       	eor	r0, r0
    8210:	0a 94       	dec	r0
    8212:	16 16       	cp	r1, r22
    8214:	17 06       	cpc	r1, r23
    8216:	18 06       	cpc	r1, r24
    8218:	09 06       	cpc	r0, r25
    821a:	08 95       	ret

0000821c <__fp_pscB>:
    821c:	00 24       	eor	r0, r0
    821e:	0a 94       	dec	r0
    8220:	12 16       	cp	r1, r18
    8222:	13 06       	cpc	r1, r19
    8224:	14 06       	cpc	r1, r20
    8226:	05 06       	cpc	r0, r21
    8228:	08 95       	ret

0000822a <__fp_round>:
    822a:	09 2e       	mov	r0, r25
    822c:	03 94       	inc	r0
    822e:	00 0c       	add	r0, r0
    8230:	11 f4       	brne	.+4      	; 0x8236 <__fp_round+0xc>
    8232:	88 23       	and	r24, r24
    8234:	52 f0       	brmi	.+20     	; 0x824a <__fp_round+0x20>
    8236:	bb 0f       	add	r27, r27
    8238:	40 f4       	brcc	.+16     	; 0x824a <__fp_round+0x20>
    823a:	bf 2b       	or	r27, r31
    823c:	11 f4       	brne	.+4      	; 0x8242 <__fp_round+0x18>
    823e:	60 ff       	sbrs	r22, 0
    8240:	04 c0       	rjmp	.+8      	; 0x824a <__fp_round+0x20>
    8242:	6f 5f       	subi	r22, 0xFF	; 255
    8244:	7f 4f       	sbci	r23, 0xFF	; 255
    8246:	8f 4f       	sbci	r24, 0xFF	; 255
    8248:	9f 4f       	sbci	r25, 0xFF	; 255
    824a:	08 95       	ret

0000824c <__fp_split3>:
    824c:	57 fd       	sbrc	r21, 7
    824e:	90 58       	subi	r25, 0x80	; 128
    8250:	44 0f       	add	r20, r20
    8252:	55 1f       	adc	r21, r21
    8254:	59 f0       	breq	.+22     	; 0x826c <__fp_splitA+0x10>
    8256:	5f 3f       	cpi	r21, 0xFF	; 255
    8258:	71 f0       	breq	.+28     	; 0x8276 <__fp_splitA+0x1a>
    825a:	47 95       	ror	r20

0000825c <__fp_splitA>:
    825c:	88 0f       	add	r24, r24
    825e:	97 fb       	bst	r25, 7
    8260:	99 1f       	adc	r25, r25
    8262:	61 f0       	breq	.+24     	; 0x827c <__fp_splitA+0x20>
    8264:	9f 3f       	cpi	r25, 0xFF	; 255
    8266:	79 f0       	breq	.+30     	; 0x8286 <__fp_splitA+0x2a>
    8268:	87 95       	ror	r24
    826a:	08 95       	ret
    826c:	12 16       	cp	r1, r18
    826e:	13 06       	cpc	r1, r19
    8270:	14 06       	cpc	r1, r20
    8272:	55 1f       	adc	r21, r21
    8274:	f2 cf       	rjmp	.-28     	; 0x825a <__fp_split3+0xe>
    8276:	46 95       	lsr	r20
    8278:	f1 df       	rcall	.-30     	; 0x825c <__fp_splitA>
    827a:	08 c0       	rjmp	.+16     	; 0x828c <__fp_splitA+0x30>
    827c:	16 16       	cp	r1, r22
    827e:	17 06       	cpc	r1, r23
    8280:	18 06       	cpc	r1, r24
    8282:	99 1f       	adc	r25, r25
    8284:	f1 cf       	rjmp	.-30     	; 0x8268 <__fp_splitA+0xc>
    8286:	86 95       	lsr	r24
    8288:	71 05       	cpc	r23, r1
    828a:	61 05       	cpc	r22, r1
    828c:	08 94       	sec
    828e:	08 95       	ret

00008290 <__fp_trunc>:
    8290:	e5 df       	rcall	.-54     	; 0x825c <__fp_splitA>
    8292:	a0 f0       	brcs	.+40     	; 0x82bc <__fp_trunc+0x2c>
    8294:	be e7       	ldi	r27, 0x7E	; 126
    8296:	b9 17       	cp	r27, r25
    8298:	88 f4       	brcc	.+34     	; 0x82bc <__fp_trunc+0x2c>
    829a:	bb 27       	eor	r27, r27
    829c:	9f 38       	cpi	r25, 0x8F	; 143
    829e:	60 f4       	brcc	.+24     	; 0x82b8 <__fp_trunc+0x28>
    82a0:	16 16       	cp	r1, r22
    82a2:	b1 1d       	adc	r27, r1
    82a4:	67 2f       	mov	r22, r23
    82a6:	78 2f       	mov	r23, r24
    82a8:	88 27       	eor	r24, r24
    82aa:	98 5f       	subi	r25, 0xF8	; 248
    82ac:	f7 cf       	rjmp	.-18     	; 0x829c <__fp_trunc+0xc>
    82ae:	86 95       	lsr	r24
    82b0:	77 95       	ror	r23
    82b2:	67 95       	ror	r22
    82b4:	b1 1d       	adc	r27, r1
    82b6:	93 95       	inc	r25
    82b8:	96 39       	cpi	r25, 0x96	; 150
    82ba:	c8 f3       	brcs	.-14     	; 0x82ae <__fp_trunc+0x1e>
    82bc:	08 95       	ret

000082be <__fp_zero>:
    82be:	e8 94       	clt

000082c0 <__fp_szero>:
    82c0:	bb 27       	eor	r27, r27
    82c2:	66 27       	eor	r22, r22
    82c4:	77 27       	eor	r23, r23
    82c6:	cb 01       	movw	r24, r22
    82c8:	97 f9       	bld	r25, 7
    82ca:	08 95       	ret

000082cc <__gesf2>:
    82cc:	4a df       	rcall	.-364    	; 0x8162 <__fp_cmp>
    82ce:	08 f4       	brcc	.+2      	; 0x82d2 <__gesf2+0x6>
    82d0:	8f ef       	ldi	r24, 0xFF	; 255
    82d2:	08 95       	ret

000082d4 <__mulsf3>:
    82d4:	0b d0       	rcall	.+22     	; 0x82ec <__mulsf3x>
    82d6:	a9 cf       	rjmp	.-174    	; 0x822a <__fp_round>
    82d8:	9a df       	rcall	.-204    	; 0x820e <__fp_pscA>
    82da:	28 f0       	brcs	.+10     	; 0x82e6 <__mulsf3+0x12>
    82dc:	9f df       	rcall	.-194    	; 0x821c <__fp_pscB>
    82de:	18 f0       	brcs	.+6      	; 0x82e6 <__mulsf3+0x12>
    82e0:	95 23       	and	r25, r21
    82e2:	09 f0       	breq	.+2      	; 0x82e6 <__mulsf3+0x12>
    82e4:	62 cf       	rjmp	.-316    	; 0x81aa <__fp_inf>
    82e6:	90 cf       	rjmp	.-224    	; 0x8208 <__fp_nan>
    82e8:	11 24       	eor	r1, r1
    82ea:	ea cf       	rjmp	.-44     	; 0x82c0 <__fp_szero>

000082ec <__mulsf3x>:
    82ec:	af df       	rcall	.-162    	; 0x824c <__fp_split3>
    82ee:	a0 f3       	brcs	.-24     	; 0x82d8 <__mulsf3+0x4>

000082f0 <__mulsf3_pse>:
    82f0:	95 9f       	mul	r25, r21
    82f2:	d1 f3       	breq	.-12     	; 0x82e8 <__mulsf3+0x14>
    82f4:	95 0f       	add	r25, r21
    82f6:	50 e0       	ldi	r21, 0x00	; 0
    82f8:	55 1f       	adc	r21, r21
    82fa:	62 9f       	mul	r22, r18
    82fc:	f0 01       	movw	r30, r0
    82fe:	72 9f       	mul	r23, r18
    8300:	bb 27       	eor	r27, r27
    8302:	f0 0d       	add	r31, r0
    8304:	b1 1d       	adc	r27, r1
    8306:	63 9f       	mul	r22, r19
    8308:	aa 27       	eor	r26, r26
    830a:	f0 0d       	add	r31, r0
    830c:	b1 1d       	adc	r27, r1
    830e:	aa 1f       	adc	r26, r26
    8310:	64 9f       	mul	r22, r20
    8312:	66 27       	eor	r22, r22
    8314:	b0 0d       	add	r27, r0
    8316:	a1 1d       	adc	r26, r1
    8318:	66 1f       	adc	r22, r22
    831a:	82 9f       	mul	r24, r18
    831c:	22 27       	eor	r18, r18
    831e:	b0 0d       	add	r27, r0
    8320:	a1 1d       	adc	r26, r1
    8322:	62 1f       	adc	r22, r18
    8324:	73 9f       	mul	r23, r19
    8326:	b0 0d       	add	r27, r0
    8328:	a1 1d       	adc	r26, r1
    832a:	62 1f       	adc	r22, r18
    832c:	83 9f       	mul	r24, r19
    832e:	a0 0d       	add	r26, r0
    8330:	61 1d       	adc	r22, r1
    8332:	22 1f       	adc	r18, r18
    8334:	74 9f       	mul	r23, r20
    8336:	33 27       	eor	r19, r19
    8338:	a0 0d       	add	r26, r0
    833a:	61 1d       	adc	r22, r1
    833c:	23 1f       	adc	r18, r19
    833e:	84 9f       	mul	r24, r20
    8340:	60 0d       	add	r22, r0
    8342:	21 1d       	adc	r18, r1
    8344:	82 2f       	mov	r24, r18
    8346:	76 2f       	mov	r23, r22
    8348:	6a 2f       	mov	r22, r26
    834a:	11 24       	eor	r1, r1
    834c:	9f 57       	subi	r25, 0x7F	; 127
    834e:	50 40       	sbci	r21, 0x00	; 0
    8350:	8a f0       	brmi	.+34     	; 0x8374 <__mulsf3_pse+0x84>
    8352:	e1 f0       	breq	.+56     	; 0x838c <__mulsf3_pse+0x9c>
    8354:	88 23       	and	r24, r24
    8356:	4a f0       	brmi	.+18     	; 0x836a <__mulsf3_pse+0x7a>
    8358:	ee 0f       	add	r30, r30
    835a:	ff 1f       	adc	r31, r31
    835c:	bb 1f       	adc	r27, r27
    835e:	66 1f       	adc	r22, r22
    8360:	77 1f       	adc	r23, r23
    8362:	88 1f       	adc	r24, r24
    8364:	91 50       	subi	r25, 0x01	; 1
    8366:	50 40       	sbci	r21, 0x00	; 0
    8368:	a9 f7       	brne	.-22     	; 0x8354 <__mulsf3_pse+0x64>
    836a:	9e 3f       	cpi	r25, 0xFE	; 254
    836c:	51 05       	cpc	r21, r1
    836e:	70 f0       	brcs	.+28     	; 0x838c <__mulsf3_pse+0x9c>
    8370:	1c cf       	rjmp	.-456    	; 0x81aa <__fp_inf>
    8372:	a6 cf       	rjmp	.-180    	; 0x82c0 <__fp_szero>
    8374:	5f 3f       	cpi	r21, 0xFF	; 255
    8376:	ec f3       	brlt	.-6      	; 0x8372 <__mulsf3_pse+0x82>
    8378:	98 3e       	cpi	r25, 0xE8	; 232
    837a:	dc f3       	brlt	.-10     	; 0x8372 <__mulsf3_pse+0x82>
    837c:	86 95       	lsr	r24
    837e:	77 95       	ror	r23
    8380:	67 95       	ror	r22
    8382:	b7 95       	ror	r27
    8384:	f7 95       	ror	r31
    8386:	e7 95       	ror	r30
    8388:	9f 5f       	subi	r25, 0xFF	; 255
    838a:	c1 f7       	brne	.-16     	; 0x837c <__mulsf3_pse+0x8c>
    838c:	fe 2b       	or	r31, r30
    838e:	88 0f       	add	r24, r24
    8390:	91 1d       	adc	r25, r1
    8392:	96 95       	lsr	r25
    8394:	87 95       	ror	r24
    8396:	97 f9       	bld	r25, 7
    8398:	08 95       	ret

0000839a <round>:
    839a:	60 df       	rcall	.-320    	; 0x825c <__fp_splitA>
    839c:	e0 f0       	brcs	.+56     	; 0x83d6 <round+0x3c>
    839e:	9e 37       	cpi	r25, 0x7E	; 126
    83a0:	d8 f0       	brcs	.+54     	; 0x83d8 <round+0x3e>
    83a2:	96 39       	cpi	r25, 0x96	; 150
    83a4:	b8 f4       	brcc	.+46     	; 0x83d4 <round+0x3a>
    83a6:	9e 38       	cpi	r25, 0x8E	; 142
    83a8:	48 f4       	brcc	.+18     	; 0x83bc <round+0x22>
    83aa:	67 2f       	mov	r22, r23
    83ac:	78 2f       	mov	r23, r24
    83ae:	88 27       	eor	r24, r24
    83b0:	98 5f       	subi	r25, 0xF8	; 248
    83b2:	f9 cf       	rjmp	.-14     	; 0x83a6 <round+0xc>
    83b4:	86 95       	lsr	r24
    83b6:	77 95       	ror	r23
    83b8:	67 95       	ror	r22
    83ba:	93 95       	inc	r25
    83bc:	95 39       	cpi	r25, 0x95	; 149
    83be:	d0 f3       	brcs	.-12     	; 0x83b4 <round+0x1a>
    83c0:	b6 2f       	mov	r27, r22
    83c2:	b1 70       	andi	r27, 0x01	; 1
    83c4:	6b 0f       	add	r22, r27
    83c6:	71 1d       	adc	r23, r1
    83c8:	81 1d       	adc	r24, r1
    83ca:	20 f4       	brcc	.+8      	; 0x83d4 <round+0x3a>
    83cc:	87 95       	ror	r24
    83ce:	77 95       	ror	r23
    83d0:	67 95       	ror	r22
    83d2:	93 95       	inc	r25
    83d4:	f0 ce       	rjmp	.-544    	; 0x81b6 <__fp_mintl>
    83d6:	0a cf       	rjmp	.-492    	; 0x81ec <__fp_mpack>
    83d8:	73 cf       	rjmp	.-282    	; 0x82c0 <__fp_szero>

000083da <__udivmodhi4>:
    83da:	aa 1b       	sub	r26, r26
    83dc:	bb 1b       	sub	r27, r27
    83de:	51 e1       	ldi	r21, 0x11	; 17
    83e0:	07 c0       	rjmp	.+14     	; 0x83f0 <__udivmodhi4_ep>

000083e2 <__udivmodhi4_loop>:
    83e2:	aa 1f       	adc	r26, r26
    83e4:	bb 1f       	adc	r27, r27
    83e6:	a6 17       	cp	r26, r22
    83e8:	b7 07       	cpc	r27, r23
    83ea:	10 f0       	brcs	.+4      	; 0x83f0 <__udivmodhi4_ep>
    83ec:	a6 1b       	sub	r26, r22
    83ee:	b7 0b       	sbc	r27, r23

000083f0 <__udivmodhi4_ep>:
    83f0:	88 1f       	adc	r24, r24
    83f2:	99 1f       	adc	r25, r25
    83f4:	5a 95       	dec	r21
    83f6:	a9 f7       	brne	.-22     	; 0x83e2 <__udivmodhi4_loop>
    83f8:	80 95       	com	r24
    83fa:	90 95       	com	r25
    83fc:	bc 01       	movw	r22, r24
    83fe:	cd 01       	movw	r24, r26
    8400:	08 95       	ret

00008402 <__divmodhi4>:
    8402:	97 fb       	bst	r25, 7
    8404:	09 2e       	mov	r0, r25
    8406:	07 26       	eor	r0, r23
    8408:	0a d0       	rcall	.+20     	; 0x841e <__divmodhi4_neg1>
    840a:	77 fd       	sbrc	r23, 7
    840c:	04 d0       	rcall	.+8      	; 0x8416 <__divmodhi4_neg2>
    840e:	e5 df       	rcall	.-54     	; 0x83da <__udivmodhi4>
    8410:	06 d0       	rcall	.+12     	; 0x841e <__divmodhi4_neg1>
    8412:	00 20       	and	r0, r0
    8414:	1a f4       	brpl	.+6      	; 0x841c <__divmodhi4_exit>

00008416 <__divmodhi4_neg2>:
    8416:	70 95       	com	r23
    8418:	61 95       	neg	r22
    841a:	7f 4f       	sbci	r23, 0xFF	; 255

0000841c <__divmodhi4_exit>:
    841c:	08 95       	ret

0000841e <__divmodhi4_neg1>:
    841e:	f6 f7       	brtc	.-4      	; 0x841c <__divmodhi4_exit>
    8420:	90 95       	com	r25
    8422:	81 95       	neg	r24
    8424:	9f 4f       	sbci	r25, 0xFF	; 255
    8426:	08 95       	ret

00008428 <malloc>:
    8428:	cf 93       	push	r28
    842a:	df 93       	push	r29
    842c:	bc 01       	movw	r22, r24
    842e:	82 30       	cpi	r24, 0x02	; 2
    8430:	91 05       	cpc	r25, r1
    8432:	10 f4       	brcc	.+4      	; 0x8438 <malloc+0x10>
    8434:	62 e0       	ldi	r22, 0x02	; 2
    8436:	70 e0       	ldi	r23, 0x00	; 0
    8438:	a0 91 9a 04 	lds	r26, 0x049A
    843c:	b0 91 9b 04 	lds	r27, 0x049B
    8440:	ed 01       	movw	r28, r26
    8442:	e0 e0       	ldi	r30, 0x00	; 0
    8444:	f0 e0       	ldi	r31, 0x00	; 0
    8446:	40 e0       	ldi	r20, 0x00	; 0
    8448:	50 e0       	ldi	r21, 0x00	; 0
    844a:	21 c0       	rjmp	.+66     	; 0x848e <malloc+0x66>
    844c:	88 81       	ld	r24, Y
    844e:	99 81       	ldd	r25, Y+1	; 0x01
    8450:	86 17       	cp	r24, r22
    8452:	97 07       	cpc	r25, r23
    8454:	69 f4       	brne	.+26     	; 0x8470 <malloc+0x48>
    8456:	8a 81       	ldd	r24, Y+2	; 0x02
    8458:	9b 81       	ldd	r25, Y+3	; 0x03
    845a:	30 97       	sbiw	r30, 0x00	; 0
    845c:	19 f0       	breq	.+6      	; 0x8464 <malloc+0x3c>
    845e:	93 83       	std	Z+3, r25	; 0x03
    8460:	82 83       	std	Z+2, r24	; 0x02
    8462:	04 c0       	rjmp	.+8      	; 0x846c <malloc+0x44>
    8464:	90 93 9b 04 	sts	0x049B, r25
    8468:	80 93 9a 04 	sts	0x049A, r24
    846c:	fe 01       	movw	r30, r28
    846e:	34 c0       	rjmp	.+104    	; 0x84d8 <malloc+0xb0>
    8470:	68 17       	cp	r22, r24
    8472:	79 07       	cpc	r23, r25
    8474:	38 f4       	brcc	.+14     	; 0x8484 <malloc+0x5c>
    8476:	41 15       	cp	r20, r1
    8478:	51 05       	cpc	r21, r1
    847a:	19 f0       	breq	.+6      	; 0x8482 <malloc+0x5a>
    847c:	84 17       	cp	r24, r20
    847e:	95 07       	cpc	r25, r21
    8480:	08 f4       	brcc	.+2      	; 0x8484 <malloc+0x5c>
    8482:	ac 01       	movw	r20, r24
    8484:	fe 01       	movw	r30, r28
    8486:	8a 81       	ldd	r24, Y+2	; 0x02
    8488:	9b 81       	ldd	r25, Y+3	; 0x03
    848a:	9c 01       	movw	r18, r24
    848c:	e9 01       	movw	r28, r18
    848e:	20 97       	sbiw	r28, 0x00	; 0
    8490:	e9 f6       	brne	.-70     	; 0x844c <malloc+0x24>
    8492:	41 15       	cp	r20, r1
    8494:	51 05       	cpc	r21, r1
    8496:	a9 f1       	breq	.+106    	; 0x8502 <malloc+0xda>
    8498:	ca 01       	movw	r24, r20
    849a:	86 1b       	sub	r24, r22
    849c:	97 0b       	sbc	r25, r23
    849e:	04 97       	sbiw	r24, 0x04	; 4
    84a0:	08 f4       	brcc	.+2      	; 0x84a4 <malloc+0x7c>
    84a2:	ba 01       	movw	r22, r20
    84a4:	e0 e0       	ldi	r30, 0x00	; 0
    84a6:	f0 e0       	ldi	r31, 0x00	; 0
    84a8:	2a c0       	rjmp	.+84     	; 0x84fe <malloc+0xd6>
    84aa:	8d 91       	ld	r24, X+
    84ac:	9c 91       	ld	r25, X
    84ae:	11 97       	sbiw	r26, 0x01	; 1
    84b0:	84 17       	cp	r24, r20
    84b2:	95 07       	cpc	r25, r21
    84b4:	f9 f4       	brne	.+62     	; 0x84f4 <malloc+0xcc>
    84b6:	64 17       	cp	r22, r20
    84b8:	75 07       	cpc	r23, r21
    84ba:	81 f4       	brne	.+32     	; 0x84dc <malloc+0xb4>
    84bc:	12 96       	adiw	r26, 0x02	; 2
    84be:	8d 91       	ld	r24, X+
    84c0:	9c 91       	ld	r25, X
    84c2:	13 97       	sbiw	r26, 0x03	; 3
    84c4:	30 97       	sbiw	r30, 0x00	; 0
    84c6:	19 f0       	breq	.+6      	; 0x84ce <malloc+0xa6>
    84c8:	93 83       	std	Z+3, r25	; 0x03
    84ca:	82 83       	std	Z+2, r24	; 0x02
    84cc:	04 c0       	rjmp	.+8      	; 0x84d6 <malloc+0xae>
    84ce:	90 93 9b 04 	sts	0x049B, r25
    84d2:	80 93 9a 04 	sts	0x049A, r24
    84d6:	fd 01       	movw	r30, r26
    84d8:	32 96       	adiw	r30, 0x02	; 2
    84da:	4f c0       	rjmp	.+158    	; 0x857a <malloc+0x152>
    84dc:	ca 01       	movw	r24, r20
    84de:	86 1b       	sub	r24, r22
    84e0:	97 0b       	sbc	r25, r23
    84e2:	fd 01       	movw	r30, r26
    84e4:	e8 0f       	add	r30, r24
    84e6:	f9 1f       	adc	r31, r25
    84e8:	61 93       	st	Z+, r22
    84ea:	71 93       	st	Z+, r23
    84ec:	02 97       	sbiw	r24, 0x02	; 2
    84ee:	8d 93       	st	X+, r24
    84f0:	9c 93       	st	X, r25
    84f2:	43 c0       	rjmp	.+134    	; 0x857a <malloc+0x152>
    84f4:	fd 01       	movw	r30, r26
    84f6:	82 81       	ldd	r24, Z+2	; 0x02
    84f8:	93 81       	ldd	r25, Z+3	; 0x03
    84fa:	9c 01       	movw	r18, r24
    84fc:	d9 01       	movw	r26, r18
    84fe:	10 97       	sbiw	r26, 0x00	; 0
    8500:	a1 f6       	brne	.-88     	; 0x84aa <malloc+0x82>
    8502:	80 91 98 04 	lds	r24, 0x0498
    8506:	90 91 99 04 	lds	r25, 0x0499
    850a:	89 2b       	or	r24, r25
    850c:	41 f4       	brne	.+16     	; 0x851e <malloc+0xf6>
    850e:	80 91 d1 02 	lds	r24, 0x02D1
    8512:	90 91 d2 02 	lds	r25, 0x02D2
    8516:	90 93 99 04 	sts	0x0499, r25
    851a:	80 93 98 04 	sts	0x0498, r24
    851e:	40 91 d3 02 	lds	r20, 0x02D3
    8522:	50 91 d4 02 	lds	r21, 0x02D4
    8526:	41 15       	cp	r20, r1
    8528:	51 05       	cpc	r21, r1
    852a:	41 f4       	brne	.+16     	; 0x853c <malloc+0x114>
    852c:	4d b7       	in	r20, 0x3d	; 61
    852e:	5e b7       	in	r21, 0x3e	; 62
    8530:	80 91 cf 02 	lds	r24, 0x02CF
    8534:	90 91 d0 02 	lds	r25, 0x02D0
    8538:	48 1b       	sub	r20, r24
    853a:	59 0b       	sbc	r21, r25
    853c:	20 91 98 04 	lds	r18, 0x0498
    8540:	30 91 99 04 	lds	r19, 0x0499
    8544:	24 17       	cp	r18, r20
    8546:	35 07       	cpc	r19, r21
    8548:	b0 f4       	brcc	.+44     	; 0x8576 <malloc+0x14e>
    854a:	ca 01       	movw	r24, r20
    854c:	82 1b       	sub	r24, r18
    854e:	93 0b       	sbc	r25, r19
    8550:	86 17       	cp	r24, r22
    8552:	97 07       	cpc	r25, r23
    8554:	80 f0       	brcs	.+32     	; 0x8576 <malloc+0x14e>
    8556:	ab 01       	movw	r20, r22
    8558:	4e 5f       	subi	r20, 0xFE	; 254
    855a:	5f 4f       	sbci	r21, 0xFF	; 255
    855c:	84 17       	cp	r24, r20
    855e:	95 07       	cpc	r25, r21
    8560:	50 f0       	brcs	.+20     	; 0x8576 <malloc+0x14e>
    8562:	42 0f       	add	r20, r18
    8564:	53 1f       	adc	r21, r19
    8566:	50 93 99 04 	sts	0x0499, r21
    856a:	40 93 98 04 	sts	0x0498, r20
    856e:	f9 01       	movw	r30, r18
    8570:	61 93       	st	Z+, r22
    8572:	71 93       	st	Z+, r23
    8574:	02 c0       	rjmp	.+4      	; 0x857a <malloc+0x152>
    8576:	e0 e0       	ldi	r30, 0x00	; 0
    8578:	f0 e0       	ldi	r31, 0x00	; 0
    857a:	cf 01       	movw	r24, r30
    857c:	df 91       	pop	r29
    857e:	cf 91       	pop	r28
    8580:	08 95       	ret

00008582 <free>:
    8582:	cf 93       	push	r28
    8584:	df 93       	push	r29
    8586:	00 97       	sbiw	r24, 0x00	; 0
    8588:	09 f4       	brne	.+2      	; 0x858c <free+0xa>
    858a:	50 c0       	rjmp	.+160    	; 0x862c <free+0xaa>
    858c:	ec 01       	movw	r28, r24
    858e:	22 97       	sbiw	r28, 0x02	; 2
    8590:	1b 82       	std	Y+3, r1	; 0x03
    8592:	1a 82       	std	Y+2, r1	; 0x02
    8594:	a0 91 9a 04 	lds	r26, 0x049A
    8598:	b0 91 9b 04 	lds	r27, 0x049B
    859c:	10 97       	sbiw	r26, 0x00	; 0
    859e:	09 f1       	breq	.+66     	; 0x85e2 <free+0x60>
    85a0:	40 e0       	ldi	r20, 0x00	; 0
    85a2:	50 e0       	ldi	r21, 0x00	; 0
    85a4:	ac 17       	cp	r26, r28
    85a6:	bd 07       	cpc	r27, r29
    85a8:	08 f1       	brcs	.+66     	; 0x85ec <free+0x6a>
    85aa:	bb 83       	std	Y+3, r27	; 0x03
    85ac:	aa 83       	std	Y+2, r26	; 0x02
    85ae:	fe 01       	movw	r30, r28
    85b0:	21 91       	ld	r18, Z+
    85b2:	31 91       	ld	r19, Z+
    85b4:	e2 0f       	add	r30, r18
    85b6:	f3 1f       	adc	r31, r19
    85b8:	ae 17       	cp	r26, r30
    85ba:	bf 07       	cpc	r27, r31
    85bc:	79 f4       	brne	.+30     	; 0x85dc <free+0x5a>
    85be:	8d 91       	ld	r24, X+
    85c0:	9c 91       	ld	r25, X
    85c2:	11 97       	sbiw	r26, 0x01	; 1
    85c4:	28 0f       	add	r18, r24
    85c6:	39 1f       	adc	r19, r25
    85c8:	2e 5f       	subi	r18, 0xFE	; 254
    85ca:	3f 4f       	sbci	r19, 0xFF	; 255
    85cc:	39 83       	std	Y+1, r19	; 0x01
    85ce:	28 83       	st	Y, r18
    85d0:	12 96       	adiw	r26, 0x02	; 2
    85d2:	8d 91       	ld	r24, X+
    85d4:	9c 91       	ld	r25, X
    85d6:	13 97       	sbiw	r26, 0x03	; 3
    85d8:	9b 83       	std	Y+3, r25	; 0x03
    85da:	8a 83       	std	Y+2, r24	; 0x02
    85dc:	41 15       	cp	r20, r1
    85de:	51 05       	cpc	r21, r1
    85e0:	71 f4       	brne	.+28     	; 0x85fe <free+0x7c>
    85e2:	d0 93 9b 04 	sts	0x049B, r29
    85e6:	c0 93 9a 04 	sts	0x049A, r28
    85ea:	20 c0       	rjmp	.+64     	; 0x862c <free+0xaa>
    85ec:	12 96       	adiw	r26, 0x02	; 2
    85ee:	8d 91       	ld	r24, X+
    85f0:	9c 91       	ld	r25, X
    85f2:	13 97       	sbiw	r26, 0x03	; 3
    85f4:	ad 01       	movw	r20, r26
    85f6:	00 97       	sbiw	r24, 0x00	; 0
    85f8:	11 f0       	breq	.+4      	; 0x85fe <free+0x7c>
    85fa:	dc 01       	movw	r26, r24
    85fc:	d3 cf       	rjmp	.-90     	; 0x85a4 <free+0x22>
    85fe:	fa 01       	movw	r30, r20
    8600:	d3 83       	std	Z+3, r29	; 0x03
    8602:	c2 83       	std	Z+2, r28	; 0x02
    8604:	21 91       	ld	r18, Z+
    8606:	31 91       	ld	r19, Z+
    8608:	e2 0f       	add	r30, r18
    860a:	f3 1f       	adc	r31, r19
    860c:	ce 17       	cp	r28, r30
    860e:	df 07       	cpc	r29, r31
    8610:	69 f4       	brne	.+26     	; 0x862c <free+0xaa>
    8612:	88 81       	ld	r24, Y
    8614:	99 81       	ldd	r25, Y+1	; 0x01
    8616:	28 0f       	add	r18, r24
    8618:	39 1f       	adc	r19, r25
    861a:	2e 5f       	subi	r18, 0xFE	; 254
    861c:	3f 4f       	sbci	r19, 0xFF	; 255
    861e:	fa 01       	movw	r30, r20
    8620:	31 83       	std	Z+1, r19	; 0x01
    8622:	20 83       	st	Z, r18
    8624:	8a 81       	ldd	r24, Y+2	; 0x02
    8626:	9b 81       	ldd	r25, Y+3	; 0x03
    8628:	93 83       	std	Z+3, r25	; 0x03
    862a:	82 83       	std	Z+2, r24	; 0x02
    862c:	df 91       	pop	r29
    862e:	cf 91       	pop	r28
    8630:	08 95       	ret

00008632 <strtol>:
    8632:	2f 92       	push	r2
    8634:	3f 92       	push	r3
    8636:	5f 92       	push	r5
    8638:	6f 92       	push	r6
    863a:	7f 92       	push	r7
    863c:	8f 92       	push	r8
    863e:	9f 92       	push	r9
    8640:	af 92       	push	r10
    8642:	bf 92       	push	r11
    8644:	cf 92       	push	r12
    8646:	df 92       	push	r13
    8648:	ef 92       	push	r14
    864a:	ff 92       	push	r15
    864c:	0f 93       	push	r16
    864e:	1f 93       	push	r17
    8650:	cf 93       	push	r28
    8652:	df 93       	push	r29
    8654:	8c 01       	movw	r16, r24
    8656:	1b 01       	movw	r2, r22
    8658:	ea 01       	movw	r28, r20
    865a:	61 15       	cp	r22, r1
    865c:	71 05       	cpc	r23, r1
    865e:	19 f0       	breq	.+6      	; 0x8666 <strtol+0x34>
    8660:	fb 01       	movw	r30, r22
    8662:	91 83       	std	Z+1, r25	; 0x01
    8664:	80 83       	st	Z, r24
    8666:	20 97       	sbiw	r28, 0x00	; 0
    8668:	49 f0       	breq	.+18     	; 0x867c <strtol+0x4a>
    866a:	ce 01       	movw	r24, r28
    866c:	02 97       	sbiw	r24, 0x02	; 2
    866e:	83 97       	sbiw	r24, 0x23	; 35
    8670:	28 f0       	brcs	.+10     	; 0x867c <strtol+0x4a>
    8672:	20 e0       	ldi	r18, 0x00	; 0
    8674:	30 e0       	ldi	r19, 0x00	; 0
    8676:	40 e0       	ldi	r20, 0x00	; 0
    8678:	50 e0       	ldi	r21, 0x00	; 0
    867a:	f6 c0       	rjmp	.+492    	; 0x8868 <strtol+0x236>
    867c:	f8 01       	movw	r30, r16
    867e:	a1 90       	ld	r10, Z+
    8680:	8f 01       	movw	r16, r30
    8682:	8a 2d       	mov	r24, r10
    8684:	90 e0       	ldi	r25, 0x00	; 0
    8686:	0e 94 42 45 	call	0x8a84	; 0x8a84 <isspace>
    868a:	89 2b       	or	r24, r25
    868c:	b9 f7       	brne	.-18     	; 0x867c <strtol+0x4a>
    868e:	fd e2       	ldi	r31, 0x2D	; 45
    8690:	af 16       	cp	r10, r31
    8692:	31 f4       	brne	.+12     	; 0x86a0 <strtol+0x6e>
    8694:	f8 01       	movw	r30, r16
    8696:	a1 90       	ld	r10, Z+
    8698:	8f 01       	movw	r16, r30
    869a:	55 24       	eor	r5, r5
    869c:	53 94       	inc	r5
    869e:	07 c0       	rjmp	.+14     	; 0x86ae <strtol+0x7c>
    86a0:	fb e2       	ldi	r31, 0x2B	; 43
    86a2:	af 16       	cp	r10, r31
    86a4:	19 f4       	brne	.+6      	; 0x86ac <strtol+0x7a>
    86a6:	f8 01       	movw	r30, r16
    86a8:	a1 90       	ld	r10, Z+
    86aa:	8f 01       	movw	r16, r30
    86ac:	55 24       	eor	r5, r5
    86ae:	20 97       	sbiw	r28, 0x00	; 0
    86b0:	19 f0       	breq	.+6      	; 0x86b8 <strtol+0x86>
    86b2:	c0 31       	cpi	r28, 0x10	; 16
    86b4:	d1 05       	cpc	r29, r1
    86b6:	c1 f4       	brne	.+48     	; 0x86e8 <strtol+0xb6>
    86b8:	f0 e3       	ldi	r31, 0x30	; 48
    86ba:	af 16       	cp	r10, r31
    86bc:	79 f4       	brne	.+30     	; 0x86dc <strtol+0xaa>
    86be:	f8 01       	movw	r30, r16
    86c0:	80 81       	ld	r24, Z
    86c2:	88 37       	cpi	r24, 0x78	; 120
    86c4:	11 f0       	breq	.+4      	; 0x86ca <strtol+0x98>
    86c6:	88 35       	cpi	r24, 0x58	; 88
    86c8:	49 f4       	brne	.+18     	; 0x86dc <strtol+0xaa>
    86ca:	f8 01       	movw	r30, r16
    86cc:	a1 80       	ldd	r10, Z+1	; 0x01
    86ce:	0e 5f       	subi	r16, 0xFE	; 254
    86d0:	1f 4f       	sbci	r17, 0xFF	; 255
    86d2:	f2 e0       	ldi	r31, 0x02	; 2
    86d4:	5f 2a       	or	r5, r31
    86d6:	c0 e1       	ldi	r28, 0x10	; 16
    86d8:	d0 e0       	ldi	r29, 0x00	; 0
    86da:	06 c0       	rjmp	.+12     	; 0x86e8 <strtol+0xb6>
    86dc:	20 97       	sbiw	r28, 0x00	; 0
    86de:	21 f4       	brne	.+8      	; 0x86e8 <strtol+0xb6>
    86e0:	80 e3       	ldi	r24, 0x30	; 48
    86e2:	a8 16       	cp	r10, r24
    86e4:	e9 f4       	brne	.+58     	; 0x8720 <strtol+0xee>
    86e6:	27 c0       	rjmp	.+78     	; 0x8736 <strtol+0x104>
    86e8:	c8 30       	cpi	r28, 0x08	; 8
    86ea:	d1 05       	cpc	r29, r1
    86ec:	31 f1       	breq	.+76     	; 0x873a <strtol+0x108>
    86ee:	c9 30       	cpi	r28, 0x09	; 9
    86f0:	d1 05       	cpc	r29, r1
    86f2:	24 f4       	brge	.+8      	; 0x86fc <strtol+0xca>
    86f4:	c2 30       	cpi	r28, 0x02	; 2
    86f6:	d1 05       	cpc	r29, r1
    86f8:	31 f5       	brne	.+76     	; 0x8746 <strtol+0x114>
    86fa:	0c c0       	rjmp	.+24     	; 0x8714 <strtol+0xe2>
    86fc:	ca 30       	cpi	r28, 0x0A	; 10
    86fe:	d1 05       	cpc	r29, r1
    8700:	89 f0       	breq	.+34     	; 0x8724 <strtol+0xf2>
    8702:	c0 31       	cpi	r28, 0x10	; 16
    8704:	d1 05       	cpc	r29, r1
    8706:	f9 f4       	brne	.+62     	; 0x8746 <strtol+0x114>
    8708:	c1 2c       	mov	r12, r1
    870a:	d1 2c       	mov	r13, r1
    870c:	e1 2c       	mov	r14, r1
    870e:	b8 e0       	ldi	r27, 0x08	; 8
    8710:	fb 2e       	mov	r15, r27
    8712:	28 c0       	rjmp	.+80     	; 0x8764 <strtol+0x132>
    8714:	c1 2c       	mov	r12, r1
    8716:	d1 2c       	mov	r13, r1
    8718:	e1 2c       	mov	r14, r1
    871a:	a0 e4       	ldi	r26, 0x40	; 64
    871c:	fa 2e       	mov	r15, r26
    871e:	22 c0       	rjmp	.+68     	; 0x8764 <strtol+0x132>
    8720:	ca e0       	ldi	r28, 0x0A	; 10
    8722:	d0 e0       	ldi	r29, 0x00	; 0
    8724:	fc ec       	ldi	r31, 0xCC	; 204
    8726:	cf 2e       	mov	r12, r31
    8728:	fc ec       	ldi	r31, 0xCC	; 204
    872a:	df 2e       	mov	r13, r31
    872c:	fc ec       	ldi	r31, 0xCC	; 204
    872e:	ef 2e       	mov	r14, r31
    8730:	fc e0       	ldi	r31, 0x0C	; 12
    8732:	ff 2e       	mov	r15, r31
    8734:	17 c0       	rjmp	.+46     	; 0x8764 <strtol+0x132>
    8736:	c8 e0       	ldi	r28, 0x08	; 8
    8738:	d0 e0       	ldi	r29, 0x00	; 0
    873a:	c1 2c       	mov	r12, r1
    873c:	d1 2c       	mov	r13, r1
    873e:	e1 2c       	mov	r14, r1
    8740:	e0 e1       	ldi	r30, 0x10	; 16
    8742:	fe 2e       	mov	r15, r30
    8744:	0f c0       	rjmp	.+30     	; 0x8764 <strtol+0x132>
    8746:	9e 01       	movw	r18, r28
    8748:	44 27       	eor	r20, r20
    874a:	37 fd       	sbrc	r19, 7
    874c:	40 95       	com	r20
    874e:	54 2f       	mov	r21, r20
    8750:	60 e0       	ldi	r22, 0x00	; 0
    8752:	70 e0       	ldi	r23, 0x00	; 0
    8754:	80 e0       	ldi	r24, 0x00	; 0
    8756:	90 e8       	ldi	r25, 0x80	; 128
    8758:	0e 94 40 48 	call	0x9080	; 0x9080 <__udivmodsi4>
    875c:	c9 01       	movw	r24, r18
    875e:	da 01       	movw	r26, r20
    8760:	6c 01       	movw	r12, r24
    8762:	7d 01       	movw	r14, r26
    8764:	20 e0       	ldi	r18, 0x00	; 0
    8766:	30 e0       	ldi	r19, 0x00	; 0
    8768:	40 e0       	ldi	r20, 0x00	; 0
    876a:	50 e0       	ldi	r21, 0x00	; 0
    876c:	60 e0       	ldi	r22, 0x00	; 0
    876e:	3e 01       	movw	r6, r28
    8770:	88 24       	eor	r8, r8
    8772:	77 fc       	sbrc	r7, 7
    8774:	80 94       	com	r8
    8776:	98 2c       	mov	r9, r8
    8778:	70 ed       	ldi	r23, 0xD0	; 208
    877a:	b7 2e       	mov	r11, r23
    877c:	ba 0c       	add	r11, r10
    877e:	e9 e0       	ldi	r30, 0x09	; 9
    8780:	eb 15       	cp	r30, r11
    8782:	70 f4       	brcc	.+28     	; 0x87a0 <strtol+0x16e>
    8784:	8a 2d       	mov	r24, r10
    8786:	81 54       	subi	r24, 0x41	; 65
    8788:	8a 31       	cpi	r24, 0x1A	; 26
    878a:	18 f4       	brcc	.+6      	; 0x8792 <strtol+0x160>
    878c:	99 ec       	ldi	r25, 0xC9	; 201
    878e:	b9 2e       	mov	r11, r25
    8790:	06 c0       	rjmp	.+12     	; 0x879e <strtol+0x16c>
    8792:	8a 2d       	mov	r24, r10
    8794:	81 56       	subi	r24, 0x61	; 97
    8796:	8a 31       	cpi	r24, 0x1A	; 26
    8798:	50 f5       	brcc	.+84     	; 0x87ee <strtol+0x1bc>
    879a:	89 ea       	ldi	r24, 0xA9	; 169
    879c:	b8 2e       	mov	r11, r24
    879e:	ba 0c       	add	r11, r10
    87a0:	8b 2d       	mov	r24, r11
    87a2:	90 e0       	ldi	r25, 0x00	; 0
    87a4:	8c 17       	cp	r24, r28
    87a6:	9d 07       	cpc	r25, r29
    87a8:	14 f5       	brge	.+68     	; 0x87ee <strtol+0x1bc>
    87aa:	6f 3f       	cpi	r22, 0xFF	; 255
    87ac:	e1 f0       	breq	.+56     	; 0x87e6 <strtol+0x1b4>
    87ae:	c2 16       	cp	r12, r18
    87b0:	d3 06       	cpc	r13, r19
    87b2:	e4 06       	cpc	r14, r20
    87b4:	f5 06       	cpc	r15, r21
    87b6:	b0 f0       	brcs	.+44     	; 0x87e4 <strtol+0x1b2>
    87b8:	ca 01       	movw	r24, r20
    87ba:	b9 01       	movw	r22, r18
    87bc:	a4 01       	movw	r20, r8
    87be:	93 01       	movw	r18, r6
    87c0:	0e 94 21 48 	call	0x9042	; 0x9042 <__mulsi3>
    87c4:	9b 01       	movw	r18, r22
    87c6:	ac 01       	movw	r20, r24
    87c8:	2b 0d       	add	r18, r11
    87ca:	31 1d       	adc	r19, r1
    87cc:	41 1d       	adc	r20, r1
    87ce:	51 1d       	adc	r21, r1
    87d0:	21 30       	cpi	r18, 0x01	; 1
    87d2:	f0 e0       	ldi	r31, 0x00	; 0
    87d4:	3f 07       	cpc	r19, r31
    87d6:	f0 e0       	ldi	r31, 0x00	; 0
    87d8:	4f 07       	cpc	r20, r31
    87da:	f0 e8       	ldi	r31, 0x80	; 128
    87dc:	5f 07       	cpc	r21, r31
    87de:	10 f4       	brcc	.+4      	; 0x87e4 <strtol+0x1b2>
    87e0:	61 e0       	ldi	r22, 0x01	; 1
    87e2:	01 c0       	rjmp	.+2      	; 0x87e6 <strtol+0x1b4>
    87e4:	6f ef       	ldi	r22, 0xFF	; 255
    87e6:	f8 01       	movw	r30, r16
    87e8:	a1 90       	ld	r10, Z+
    87ea:	8f 01       	movw	r16, r30
    87ec:	c5 cf       	rjmp	.-118    	; 0x8778 <strtol+0x146>
    87ee:	21 14       	cp	r2, r1
    87f0:	31 04       	cpc	r3, r1
    87f2:	81 f0       	breq	.+32     	; 0x8814 <strtol+0x1e2>
    87f4:	66 23       	and	r22, r22
    87f6:	31 f0       	breq	.+12     	; 0x8804 <strtol+0x1d2>
    87f8:	01 50       	subi	r16, 0x01	; 1
    87fa:	10 40       	sbci	r17, 0x00	; 0
    87fc:	f1 01       	movw	r30, r2
    87fe:	11 83       	std	Z+1, r17	; 0x01
    8800:	00 83       	st	Z, r16
    8802:	08 c0       	rjmp	.+16     	; 0x8814 <strtol+0x1e2>
    8804:	51 fe       	sbrs	r5, 1
    8806:	1a c0       	rjmp	.+52     	; 0x883c <strtol+0x20a>
    8808:	02 50       	subi	r16, 0x02	; 2
    880a:	10 40       	sbci	r17, 0x00	; 0
    880c:	f1 01       	movw	r30, r2
    880e:	11 83       	std	Z+1, r17	; 0x01
    8810:	00 83       	st	Z, r16
    8812:	14 c0       	rjmp	.+40     	; 0x883c <strtol+0x20a>
    8814:	67 ff       	sbrs	r22, 7
    8816:	12 c0       	rjmp	.+36     	; 0x883c <strtol+0x20a>
    8818:	50 fc       	sbrc	r5, 0
    881a:	05 c0       	rjmp	.+10     	; 0x8826 <strtol+0x1f4>
    881c:	2f ef       	ldi	r18, 0xFF	; 255
    881e:	3f ef       	ldi	r19, 0xFF	; 255
    8820:	4f ef       	ldi	r20, 0xFF	; 255
    8822:	5f e7       	ldi	r21, 0x7F	; 127
    8824:	04 c0       	rjmp	.+8      	; 0x882e <strtol+0x1fc>
    8826:	20 e0       	ldi	r18, 0x00	; 0
    8828:	30 e0       	ldi	r19, 0x00	; 0
    882a:	40 e0       	ldi	r20, 0x00	; 0
    882c:	50 e8       	ldi	r21, 0x80	; 128
    882e:	82 e2       	ldi	r24, 0x22	; 34
    8830:	90 e0       	ldi	r25, 0x00	; 0
    8832:	90 93 9d 04 	sts	0x049D, r25
    8836:	80 93 9c 04 	sts	0x049C, r24
    883a:	16 c0       	rjmp	.+44     	; 0x8868 <strtol+0x236>
    883c:	50 fe       	sbrs	r5, 0
    883e:	08 c0       	rjmp	.+16     	; 0x8850 <strtol+0x21e>
    8840:	50 95       	com	r21
    8842:	40 95       	com	r20
    8844:	30 95       	com	r19
    8846:	21 95       	neg	r18
    8848:	3f 4f       	sbci	r19, 0xFF	; 255
    884a:	4f 4f       	sbci	r20, 0xFF	; 255
    884c:	5f 4f       	sbci	r21, 0xFF	; 255
    884e:	0c c0       	rjmp	.+24     	; 0x8868 <strtol+0x236>
    8850:	57 ff       	sbrs	r21, 7
    8852:	0a c0       	rjmp	.+20     	; 0x8868 <strtol+0x236>
    8854:	82 e2       	ldi	r24, 0x22	; 34
    8856:	90 e0       	ldi	r25, 0x00	; 0
    8858:	90 93 9d 04 	sts	0x049D, r25
    885c:	80 93 9c 04 	sts	0x049C, r24
    8860:	2f ef       	ldi	r18, 0xFF	; 255
    8862:	3f ef       	ldi	r19, 0xFF	; 255
    8864:	4f ef       	ldi	r20, 0xFF	; 255
    8866:	5f e7       	ldi	r21, 0x7F	; 127
    8868:	b9 01       	movw	r22, r18
    886a:	ca 01       	movw	r24, r20
    886c:	df 91       	pop	r29
    886e:	cf 91       	pop	r28
    8870:	1f 91       	pop	r17
    8872:	0f 91       	pop	r16
    8874:	ff 90       	pop	r15
    8876:	ef 90       	pop	r14
    8878:	df 90       	pop	r13
    887a:	cf 90       	pop	r12
    887c:	bf 90       	pop	r11
    887e:	af 90       	pop	r10
    8880:	9f 90       	pop	r9
    8882:	8f 90       	pop	r8
    8884:	7f 90       	pop	r7
    8886:	6f 90       	pop	r6
    8888:	5f 90       	pop	r5
    888a:	3f 90       	pop	r3
    888c:	2f 90       	pop	r2
    888e:	08 95       	ret

00008890 <atof>:
    8890:	66 27       	eor	r22, r22
    8892:	77 27       	eor	r23, r23
    8894:	0c 94 98 46 	jmp	0x8d30	; 0x8d30 <strtod>

00008898 <atoi>:
    8898:	fc 01       	movw	r30, r24
    889a:	88 27       	eor	r24, r24
    889c:	99 27       	eor	r25, r25
    889e:	e8 94       	clt
    88a0:	21 91       	ld	r18, Z+
    88a2:	20 32       	cpi	r18, 0x20	; 32
    88a4:	e9 f3       	breq	.-6      	; 0x88a0 <atoi+0x8>
    88a6:	29 30       	cpi	r18, 0x09	; 9
    88a8:	10 f0       	brcs	.+4      	; 0x88ae <atoi+0x16>
    88aa:	2e 30       	cpi	r18, 0x0E	; 14
    88ac:	c8 f3       	brcs	.-14     	; 0x88a0 <atoi+0x8>
    88ae:	2b 32       	cpi	r18, 0x2B	; 43
    88b0:	41 f0       	breq	.+16     	; 0x88c2 <atoi+0x2a>
    88b2:	2d 32       	cpi	r18, 0x2D	; 45
    88b4:	39 f4       	brne	.+14     	; 0x88c4 <atoi+0x2c>
    88b6:	68 94       	set
    88b8:	04 c0       	rjmp	.+8      	; 0x88c2 <atoi+0x2a>
    88ba:	0e 94 a3 45 	call	0x8b46	; 0x8b46 <__mulhi_const_10>
    88be:	82 0f       	add	r24, r18
    88c0:	91 1d       	adc	r25, r1
    88c2:	21 91       	ld	r18, Z+
    88c4:	20 53       	subi	r18, 0x30	; 48
    88c6:	2a 30       	cpi	r18, 0x0A	; 10
    88c8:	c0 f3       	brcs	.-16     	; 0x88ba <atoi+0x22>
    88ca:	1e f4       	brtc	.+6      	; 0x88d2 <atoi+0x3a>
    88cc:	90 95       	com	r25
    88ce:	81 95       	neg	r24
    88d0:	9f 4f       	sbci	r25, 0xFF	; 255
    88d2:	08 95       	ret

000088d4 <__ftoa_engine>:
    88d4:	28 30       	cpi	r18, 0x08	; 8
    88d6:	08 f0       	brcs	.+2      	; 0x88da <__ftoa_engine+0x6>
    88d8:	27 e0       	ldi	r18, 0x07	; 7
    88da:	33 27       	eor	r19, r19
    88dc:	da 01       	movw	r26, r20
    88de:	99 0f       	add	r25, r25
    88e0:	31 1d       	adc	r19, r1
    88e2:	87 fd       	sbrc	r24, 7
    88e4:	91 60       	ori	r25, 0x01	; 1
    88e6:	00 96       	adiw	r24, 0x00	; 0
    88e8:	61 05       	cpc	r22, r1
    88ea:	71 05       	cpc	r23, r1
    88ec:	39 f4       	brne	.+14     	; 0x88fc <__ftoa_engine+0x28>
    88ee:	32 60       	ori	r19, 0x02	; 2
    88f0:	2e 5f       	subi	r18, 0xFE	; 254
    88f2:	3d 93       	st	X+, r19
    88f4:	30 e3       	ldi	r19, 0x30	; 48
    88f6:	2a 95       	dec	r18
    88f8:	e1 f7       	brne	.-8      	; 0x88f2 <__ftoa_engine+0x1e>
    88fa:	08 95       	ret
    88fc:	9f 3f       	cpi	r25, 0xFF	; 255
    88fe:	30 f0       	brcs	.+12     	; 0x890c <__ftoa_engine+0x38>
    8900:	80 38       	cpi	r24, 0x80	; 128
    8902:	71 05       	cpc	r23, r1
    8904:	61 05       	cpc	r22, r1
    8906:	09 f0       	breq	.+2      	; 0x890a <__ftoa_engine+0x36>
    8908:	3c 5f       	subi	r19, 0xFC	; 252
    890a:	3c 5f       	subi	r19, 0xFC	; 252
    890c:	3d 93       	st	X+, r19
    890e:	91 30       	cpi	r25, 0x01	; 1
    8910:	08 f0       	brcs	.+2      	; 0x8914 <__ftoa_engine+0x40>
    8912:	80 68       	ori	r24, 0x80	; 128
    8914:	91 1d       	adc	r25, r1
    8916:	df 93       	push	r29
    8918:	cf 93       	push	r28
    891a:	1f 93       	push	r17
    891c:	0f 93       	push	r16
    891e:	ff 92       	push	r15
    8920:	ef 92       	push	r14
    8922:	19 2f       	mov	r17, r25
    8924:	98 7f       	andi	r25, 0xF8	; 248
    8926:	96 95       	lsr	r25
    8928:	e9 2f       	mov	r30, r25
    892a:	96 95       	lsr	r25
    892c:	96 95       	lsr	r25
    892e:	e9 0f       	add	r30, r25
    8930:	ff 27       	eor	r31, r31
    8932:	ee 59       	subi	r30, 0x9E	; 158
    8934:	fa 4f       	sbci	r31, 0xFA	; 250
    8936:	99 27       	eor	r25, r25
    8938:	33 27       	eor	r19, r19
    893a:	ee 24       	eor	r14, r14
    893c:	ff 24       	eor	r15, r15
    893e:	a7 01       	movw	r20, r14
    8940:	e7 01       	movw	r28, r14
    8942:	05 90       	lpm	r0, Z+
    8944:	08 94       	sec
    8946:	07 94       	ror	r0
    8948:	28 f4       	brcc	.+10     	; 0x8954 <__ftoa_engine+0x80>
    894a:	36 0f       	add	r19, r22
    894c:	e7 1e       	adc	r14, r23
    894e:	f8 1e       	adc	r15, r24
    8950:	49 1f       	adc	r20, r25
    8952:	51 1d       	adc	r21, r1
    8954:	66 0f       	add	r22, r22
    8956:	77 1f       	adc	r23, r23
    8958:	88 1f       	adc	r24, r24
    895a:	99 1f       	adc	r25, r25
    895c:	06 94       	lsr	r0
    895e:	a1 f7       	brne	.-24     	; 0x8948 <__ftoa_engine+0x74>
    8960:	05 90       	lpm	r0, Z+
    8962:	07 94       	ror	r0
    8964:	28 f4       	brcc	.+10     	; 0x8970 <__ftoa_engine+0x9c>
    8966:	e7 0e       	add	r14, r23
    8968:	f8 1e       	adc	r15, r24
    896a:	49 1f       	adc	r20, r25
    896c:	56 1f       	adc	r21, r22
    896e:	c1 1d       	adc	r28, r1
    8970:	77 0f       	add	r23, r23
    8972:	88 1f       	adc	r24, r24
    8974:	99 1f       	adc	r25, r25
    8976:	66 1f       	adc	r22, r22
    8978:	06 94       	lsr	r0
    897a:	a1 f7       	brne	.-24     	; 0x8964 <__ftoa_engine+0x90>
    897c:	05 90       	lpm	r0, Z+
    897e:	07 94       	ror	r0
    8980:	28 f4       	brcc	.+10     	; 0x898c <__ftoa_engine+0xb8>
    8982:	f8 0e       	add	r15, r24
    8984:	49 1f       	adc	r20, r25
    8986:	56 1f       	adc	r21, r22
    8988:	c7 1f       	adc	r28, r23
    898a:	d1 1d       	adc	r29, r1
    898c:	88 0f       	add	r24, r24
    898e:	99 1f       	adc	r25, r25
    8990:	66 1f       	adc	r22, r22
    8992:	77 1f       	adc	r23, r23
    8994:	06 94       	lsr	r0
    8996:	a1 f7       	brne	.-24     	; 0x8980 <__ftoa_engine+0xac>
    8998:	05 90       	lpm	r0, Z+
    899a:	07 94       	ror	r0
    899c:	20 f4       	brcc	.+8      	; 0x89a6 <__ftoa_engine+0xd2>
    899e:	49 0f       	add	r20, r25
    89a0:	56 1f       	adc	r21, r22
    89a2:	c7 1f       	adc	r28, r23
    89a4:	d8 1f       	adc	r29, r24
    89a6:	99 0f       	add	r25, r25
    89a8:	66 1f       	adc	r22, r22
    89aa:	77 1f       	adc	r23, r23
    89ac:	88 1f       	adc	r24, r24
    89ae:	06 94       	lsr	r0
    89b0:	a9 f7       	brne	.-22     	; 0x899c <__ftoa_engine+0xc8>
    89b2:	84 91       	lpm	r24, Z+
    89b4:	10 95       	com	r17
    89b6:	17 70       	andi	r17, 0x07	; 7
    89b8:	41 f0       	breq	.+16     	; 0x89ca <__ftoa_engine+0xf6>
    89ba:	d6 95       	lsr	r29
    89bc:	c7 95       	ror	r28
    89be:	57 95       	ror	r21
    89c0:	47 95       	ror	r20
    89c2:	f7 94       	ror	r15
    89c4:	e7 94       	ror	r14
    89c6:	1a 95       	dec	r17
    89c8:	c1 f7       	brne	.-16     	; 0x89ba <__ftoa_engine+0xe6>
    89ca:	e8 e0       	ldi	r30, 0x08	; 8
    89cc:	f5 e0       	ldi	r31, 0x05	; 5
    89ce:	68 94       	set
    89d0:	15 90       	lpm	r1, Z+
    89d2:	15 91       	lpm	r17, Z+
    89d4:	35 91       	lpm	r19, Z+
    89d6:	65 91       	lpm	r22, Z+
    89d8:	95 91       	lpm	r25, Z+
    89da:	05 90       	lpm	r0, Z+
    89dc:	7f e2       	ldi	r23, 0x2F	; 47
    89de:	73 95       	inc	r23
    89e0:	e1 18       	sub	r14, r1
    89e2:	f1 0a       	sbc	r15, r17
    89e4:	43 0b       	sbc	r20, r19
    89e6:	56 0b       	sbc	r21, r22
    89e8:	c9 0b       	sbc	r28, r25
    89ea:	d0 09       	sbc	r29, r0
    89ec:	c0 f7       	brcc	.-16     	; 0x89de <__ftoa_engine+0x10a>
    89ee:	e1 0c       	add	r14, r1
    89f0:	f1 1e       	adc	r15, r17
    89f2:	43 1f       	adc	r20, r19
    89f4:	56 1f       	adc	r21, r22
    89f6:	c9 1f       	adc	r28, r25
    89f8:	d0 1d       	adc	r29, r0
    89fa:	7e f4       	brtc	.+30     	; 0x8a1a <__ftoa_engine+0x146>
    89fc:	70 33       	cpi	r23, 0x30	; 48
    89fe:	11 f4       	brne	.+4      	; 0x8a04 <__ftoa_engine+0x130>
    8a00:	8a 95       	dec	r24
    8a02:	e6 cf       	rjmp	.-52     	; 0x89d0 <__ftoa_engine+0xfc>
    8a04:	e8 94       	clt
    8a06:	01 50       	subi	r16, 0x01	; 1
    8a08:	30 f0       	brcs	.+12     	; 0x8a16 <__ftoa_engine+0x142>
    8a0a:	08 0f       	add	r16, r24
    8a0c:	0a f4       	brpl	.+2      	; 0x8a10 <__ftoa_engine+0x13c>
    8a0e:	00 27       	eor	r16, r16
    8a10:	02 17       	cp	r16, r18
    8a12:	08 f4       	brcc	.+2      	; 0x8a16 <__ftoa_engine+0x142>
    8a14:	20 2f       	mov	r18, r16
    8a16:	23 95       	inc	r18
    8a18:	02 2f       	mov	r16, r18
    8a1a:	7a 33       	cpi	r23, 0x3A	; 58
    8a1c:	28 f0       	brcs	.+10     	; 0x8a28 <__ftoa_engine+0x154>
    8a1e:	79 e3       	ldi	r23, 0x39	; 57
    8a20:	7d 93       	st	X+, r23
    8a22:	2a 95       	dec	r18
    8a24:	e9 f7       	brne	.-6      	; 0x8a20 <__ftoa_engine+0x14c>
    8a26:	10 c0       	rjmp	.+32     	; 0x8a48 <__ftoa_engine+0x174>
    8a28:	7d 93       	st	X+, r23
    8a2a:	2a 95       	dec	r18
    8a2c:	89 f6       	brne	.-94     	; 0x89d0 <__ftoa_engine+0xfc>
    8a2e:	06 94       	lsr	r0
    8a30:	97 95       	ror	r25
    8a32:	67 95       	ror	r22
    8a34:	37 95       	ror	r19
    8a36:	17 95       	ror	r17
    8a38:	17 94       	ror	r1
    8a3a:	e1 18       	sub	r14, r1
    8a3c:	f1 0a       	sbc	r15, r17
    8a3e:	43 0b       	sbc	r20, r19
    8a40:	56 0b       	sbc	r21, r22
    8a42:	c9 0b       	sbc	r28, r25
    8a44:	d0 09       	sbc	r29, r0
    8a46:	98 f0       	brcs	.+38     	; 0x8a6e <__ftoa_engine+0x19a>
    8a48:	23 95       	inc	r18
    8a4a:	7e 91       	ld	r23, -X
    8a4c:	73 95       	inc	r23
    8a4e:	7a 33       	cpi	r23, 0x3A	; 58
    8a50:	08 f0       	brcs	.+2      	; 0x8a54 <__ftoa_engine+0x180>
    8a52:	70 e3       	ldi	r23, 0x30	; 48
    8a54:	7c 93       	st	X, r23
    8a56:	20 13       	cpse	r18, r16
    8a58:	b8 f7       	brcc	.-18     	; 0x8a48 <__ftoa_engine+0x174>
    8a5a:	7e 91       	ld	r23, -X
    8a5c:	70 61       	ori	r23, 0x10	; 16
    8a5e:	7d 93       	st	X+, r23
    8a60:	30 f0       	brcs	.+12     	; 0x8a6e <__ftoa_engine+0x19a>
    8a62:	83 95       	inc	r24
    8a64:	71 e3       	ldi	r23, 0x31	; 49
    8a66:	7d 93       	st	X+, r23
    8a68:	70 e3       	ldi	r23, 0x30	; 48
    8a6a:	2a 95       	dec	r18
    8a6c:	e1 f7       	brne	.-8      	; 0x8a66 <__ftoa_engine+0x192>
    8a6e:	11 24       	eor	r1, r1
    8a70:	ef 90       	pop	r14
    8a72:	ff 90       	pop	r15
    8a74:	0f 91       	pop	r16
    8a76:	1f 91       	pop	r17
    8a78:	cf 91       	pop	r28
    8a7a:	df 91       	pop	r29
    8a7c:	99 27       	eor	r25, r25
    8a7e:	87 fd       	sbrc	r24, 7
    8a80:	90 95       	com	r25
    8a82:	08 95       	ret

00008a84 <isspace>:
    8a84:	91 11       	cpse	r25, r1
    8a86:	c2 c2       	rjmp	.+1412   	; 0x900c <__ctype_isfalse>
    8a88:	80 32       	cpi	r24, 0x20	; 32
    8a8a:	19 f0       	breq	.+6      	; 0x8a92 <isspace+0xe>
    8a8c:	89 50       	subi	r24, 0x09	; 9
    8a8e:	85 50       	subi	r24, 0x05	; 5
    8a90:	d0 f7       	brcc	.-12     	; 0x8a86 <isspace+0x2>
    8a92:	08 95       	ret

00008a94 <strcpy_P>:
    8a94:	fb 01       	movw	r30, r22
    8a96:	dc 01       	movw	r26, r24
    8a98:	05 90       	lpm	r0, Z+
    8a9a:	0d 92       	st	X+, r0
    8a9c:	00 20       	and	r0, r0
    8a9e:	e1 f7       	brne	.-8      	; 0x8a98 <strcpy_P+0x4>
    8aa0:	08 95       	ret

00008aa2 <strnlen_P>:
    8aa2:	fc 01       	movw	r30, r24
    8aa4:	05 90       	lpm	r0, Z+
    8aa6:	61 50       	subi	r22, 0x01	; 1
    8aa8:	70 40       	sbci	r23, 0x00	; 0
    8aaa:	01 10       	cpse	r0, r1
    8aac:	d8 f7       	brcc	.-10     	; 0x8aa4 <strnlen_P+0x2>
    8aae:	80 95       	com	r24
    8ab0:	90 95       	com	r25
    8ab2:	8e 0f       	add	r24, r30
    8ab4:	9f 1f       	adc	r25, r31
    8ab6:	08 95       	ret

00008ab8 <strtok>:
    8ab8:	4a ed       	ldi	r20, 0xDA	; 218
    8aba:	52 e0       	ldi	r21, 0x02	; 2
    8abc:	0e 94 7c 45 	call	0x8af8	; 0x8af8 <strtok_r>
    8ac0:	08 95       	ret

00008ac2 <strcmp>:
    8ac2:	fb 01       	movw	r30, r22
    8ac4:	dc 01       	movw	r26, r24
    8ac6:	8d 91       	ld	r24, X+
    8ac8:	01 90       	ld	r0, Z+
    8aca:	80 19       	sub	r24, r0
    8acc:	01 10       	cpse	r0, r1
    8ace:	d9 f3       	breq	.-10     	; 0x8ac6 <strcmp+0x4>
    8ad0:	99 0b       	sbc	r25, r25
    8ad2:	08 95       	ret

00008ad4 <strcpy>:
    8ad4:	fb 01       	movw	r30, r22
    8ad6:	dc 01       	movw	r26, r24
    8ad8:	01 90       	ld	r0, Z+
    8ada:	0d 92       	st	X+, r0
    8adc:	00 20       	and	r0, r0
    8ade:	e1 f7       	brne	.-8      	; 0x8ad8 <strcpy+0x4>
    8ae0:	08 95       	ret

00008ae2 <strnlen>:
    8ae2:	fc 01       	movw	r30, r24
    8ae4:	61 50       	subi	r22, 0x01	; 1
    8ae6:	70 40       	sbci	r23, 0x00	; 0
    8ae8:	01 90       	ld	r0, Z+
    8aea:	01 10       	cpse	r0, r1
    8aec:	d8 f7       	brcc	.-10     	; 0x8ae4 <strnlen+0x2>
    8aee:	80 95       	com	r24
    8af0:	90 95       	com	r25
    8af2:	8e 0f       	add	r24, r30
    8af4:	9f 1f       	adc	r25, r31
    8af6:	08 95       	ret

00008af8 <strtok_r>:
    8af8:	fa 01       	movw	r30, r20
    8afa:	a1 91       	ld	r26, Z+
    8afc:	b0 81       	ld	r27, Z
    8afe:	00 97       	sbiw	r24, 0x00	; 0
    8b00:	19 f4       	brne	.+6      	; 0x8b08 <strtok_r+0x10>
    8b02:	10 97       	sbiw	r26, 0x00	; 0
    8b04:	e1 f0       	breq	.+56     	; 0x8b3e <strtok_r+0x46>
    8b06:	cd 01       	movw	r24, r26
    8b08:	dc 01       	movw	r26, r24
    8b0a:	cd 01       	movw	r24, r26
    8b0c:	0d 90       	ld	r0, X+
    8b0e:	00 20       	and	r0, r0
    8b10:	11 f4       	brne	.+4      	; 0x8b16 <strtok_r+0x1e>
    8b12:	c0 01       	movw	r24, r0
    8b14:	13 c0       	rjmp	.+38     	; 0x8b3c <strtok_r+0x44>
    8b16:	fb 01       	movw	r30, r22
    8b18:	21 91       	ld	r18, Z+
    8b1a:	22 23       	and	r18, r18
    8b1c:	19 f0       	breq	.+6      	; 0x8b24 <strtok_r+0x2c>
    8b1e:	20 15       	cp	r18, r0
    8b20:	d9 f7       	brne	.-10     	; 0x8b18 <strtok_r+0x20>
    8b22:	f3 cf       	rjmp	.-26     	; 0x8b0a <strtok_r+0x12>
    8b24:	fb 01       	movw	r30, r22
    8b26:	21 91       	ld	r18, Z+
    8b28:	20 15       	cp	r18, r0
    8b2a:	19 f4       	brne	.+6      	; 0x8b32 <strtok_r+0x3a>
    8b2c:	1e 92       	st	-X, r1
    8b2e:	11 96       	adiw	r26, 0x01	; 1
    8b30:	06 c0       	rjmp	.+12     	; 0x8b3e <strtok_r+0x46>
    8b32:	22 23       	and	r18, r18
    8b34:	c1 f7       	brne	.-16     	; 0x8b26 <strtok_r+0x2e>
    8b36:	0d 90       	ld	r0, X+
    8b38:	00 20       	and	r0, r0
    8b3a:	a1 f7       	brne	.-24     	; 0x8b24 <strtok_r+0x2c>
    8b3c:	d0 01       	movw	r26, r0
    8b3e:	fa 01       	movw	r30, r20
    8b40:	a1 93       	st	Z+, r26
    8b42:	b0 83       	st	Z, r27
    8b44:	08 95       	ret

00008b46 <__mulhi_const_10>:
    8b46:	7a e0       	ldi	r23, 0x0A	; 10
    8b48:	97 9f       	mul	r25, r23
    8b4a:	90 2d       	mov	r25, r0
    8b4c:	87 9f       	mul	r24, r23
    8b4e:	80 2d       	mov	r24, r0
    8b50:	91 0d       	add	r25, r1
    8b52:	11 24       	eor	r1, r1
    8b54:	08 95       	ret

00008b56 <fputc>:
    8b56:	0f 93       	push	r16
    8b58:	1f 93       	push	r17
    8b5a:	cf 93       	push	r28
    8b5c:	df 93       	push	r29
    8b5e:	8c 01       	movw	r16, r24
    8b60:	eb 01       	movw	r28, r22
    8b62:	8b 81       	ldd	r24, Y+3	; 0x03
    8b64:	81 ff       	sbrs	r24, 1
    8b66:	1b c0       	rjmp	.+54     	; 0x8b9e <fputc+0x48>
    8b68:	82 ff       	sbrs	r24, 2
    8b6a:	0d c0       	rjmp	.+26     	; 0x8b86 <fputc+0x30>
    8b6c:	2e 81       	ldd	r18, Y+6	; 0x06
    8b6e:	3f 81       	ldd	r19, Y+7	; 0x07
    8b70:	8c 81       	ldd	r24, Y+4	; 0x04
    8b72:	9d 81       	ldd	r25, Y+5	; 0x05
    8b74:	28 17       	cp	r18, r24
    8b76:	39 07       	cpc	r19, r25
    8b78:	64 f4       	brge	.+24     	; 0x8b92 <fputc+0x3c>
    8b7a:	e8 81       	ld	r30, Y
    8b7c:	f9 81       	ldd	r31, Y+1	; 0x01
    8b7e:	01 93       	st	Z+, r16
    8b80:	f9 83       	std	Y+1, r31	; 0x01
    8b82:	e8 83       	st	Y, r30
    8b84:	06 c0       	rjmp	.+12     	; 0x8b92 <fputc+0x3c>
    8b86:	e8 85       	ldd	r30, Y+8	; 0x08
    8b88:	f9 85       	ldd	r31, Y+9	; 0x09
    8b8a:	80 2f       	mov	r24, r16
    8b8c:	09 95       	icall
    8b8e:	89 2b       	or	r24, r25
    8b90:	31 f4       	brne	.+12     	; 0x8b9e <fputc+0x48>
    8b92:	8e 81       	ldd	r24, Y+6	; 0x06
    8b94:	9f 81       	ldd	r25, Y+7	; 0x07
    8b96:	01 96       	adiw	r24, 0x01	; 1
    8b98:	9f 83       	std	Y+7, r25	; 0x07
    8b9a:	8e 83       	std	Y+6, r24	; 0x06
    8b9c:	02 c0       	rjmp	.+4      	; 0x8ba2 <fputc+0x4c>
    8b9e:	0f ef       	ldi	r16, 0xFF	; 255
    8ba0:	1f ef       	ldi	r17, 0xFF	; 255
    8ba2:	c8 01       	movw	r24, r16
    8ba4:	df 91       	pop	r29
    8ba6:	cf 91       	pop	r28
    8ba8:	1f 91       	pop	r17
    8baa:	0f 91       	pop	r16
    8bac:	08 95       	ret

00008bae <sprintf>:
    8bae:	0f 93       	push	r16
    8bb0:	1f 93       	push	r17
    8bb2:	df 93       	push	r29
    8bb4:	cf 93       	push	r28
    8bb6:	cd b7       	in	r28, 0x3d	; 61
    8bb8:	de b7       	in	r29, 0x3e	; 62
    8bba:	2e 97       	sbiw	r28, 0x0e	; 14
    8bbc:	0f b6       	in	r0, 0x3f	; 63
    8bbe:	f8 94       	cli
    8bc0:	de bf       	out	0x3e, r29	; 62
    8bc2:	0f be       	out	0x3f, r0	; 63
    8bc4:	cd bf       	out	0x3d, r28	; 61
    8bc6:	0d 89       	ldd	r16, Y+21	; 0x15
    8bc8:	1e 89       	ldd	r17, Y+22	; 0x16
    8bca:	86 e0       	ldi	r24, 0x06	; 6
    8bcc:	8c 83       	std	Y+4, r24	; 0x04
    8bce:	1a 83       	std	Y+2, r17	; 0x02
    8bd0:	09 83       	std	Y+1, r16	; 0x01
    8bd2:	8f ef       	ldi	r24, 0xFF	; 255
    8bd4:	9f e7       	ldi	r25, 0x7F	; 127
    8bd6:	9e 83       	std	Y+6, r25	; 0x06
    8bd8:	8d 83       	std	Y+5, r24	; 0x05
    8bda:	9e 01       	movw	r18, r28
    8bdc:	27 5e       	subi	r18, 0xE7	; 231
    8bde:	3f 4f       	sbci	r19, 0xFF	; 255
    8be0:	ce 01       	movw	r24, r28
    8be2:	01 96       	adiw	r24, 0x01	; 1
    8be4:	6f 89       	ldd	r22, Y+23	; 0x17
    8be6:	78 8d       	ldd	r23, Y+24	; 0x18
    8be8:	a9 01       	movw	r20, r18
    8bea:	0e 94 af 3b 	call	0x775e	; 0x775e <vfprintf>
    8bee:	2f 81       	ldd	r18, Y+7	; 0x07
    8bf0:	38 85       	ldd	r19, Y+8	; 0x08
    8bf2:	02 0f       	add	r16, r18
    8bf4:	13 1f       	adc	r17, r19
    8bf6:	f8 01       	movw	r30, r16
    8bf8:	10 82       	st	Z, r1
    8bfa:	2e 96       	adiw	r28, 0x0e	; 14
    8bfc:	0f b6       	in	r0, 0x3f	; 63
    8bfe:	f8 94       	cli
    8c00:	de bf       	out	0x3e, r29	; 62
    8c02:	0f be       	out	0x3f, r0	; 63
    8c04:	cd bf       	out	0x3d, r28	; 61
    8c06:	cf 91       	pop	r28
    8c08:	df 91       	pop	r29
    8c0a:	1f 91       	pop	r17
    8c0c:	0f 91       	pop	r16
    8c0e:	08 95       	ret

00008c10 <__ultoa_invert>:
    8c10:	fa 01       	movw	r30, r20
    8c12:	aa 27       	eor	r26, r26
    8c14:	28 30       	cpi	r18, 0x08	; 8
    8c16:	51 f1       	breq	.+84     	; 0x8c6c <__ultoa_invert+0x5c>
    8c18:	20 31       	cpi	r18, 0x10	; 16
    8c1a:	81 f1       	breq	.+96     	; 0x8c7c <__ultoa_invert+0x6c>
    8c1c:	e8 94       	clt
    8c1e:	6f 93       	push	r22
    8c20:	6e 7f       	andi	r22, 0xFE	; 254
    8c22:	6e 5f       	subi	r22, 0xFE	; 254
    8c24:	7f 4f       	sbci	r23, 0xFF	; 255
    8c26:	8f 4f       	sbci	r24, 0xFF	; 255
    8c28:	9f 4f       	sbci	r25, 0xFF	; 255
    8c2a:	af 4f       	sbci	r26, 0xFF	; 255
    8c2c:	b1 e0       	ldi	r27, 0x01	; 1
    8c2e:	3e d0       	rcall	.+124    	; 0x8cac <__ultoa_invert+0x9c>
    8c30:	b4 e0       	ldi	r27, 0x04	; 4
    8c32:	3c d0       	rcall	.+120    	; 0x8cac <__ultoa_invert+0x9c>
    8c34:	67 0f       	add	r22, r23
    8c36:	78 1f       	adc	r23, r24
    8c38:	89 1f       	adc	r24, r25
    8c3a:	9a 1f       	adc	r25, r26
    8c3c:	a1 1d       	adc	r26, r1
    8c3e:	68 0f       	add	r22, r24
    8c40:	79 1f       	adc	r23, r25
    8c42:	8a 1f       	adc	r24, r26
    8c44:	91 1d       	adc	r25, r1
    8c46:	a1 1d       	adc	r26, r1
    8c48:	6a 0f       	add	r22, r26
    8c4a:	71 1d       	adc	r23, r1
    8c4c:	81 1d       	adc	r24, r1
    8c4e:	91 1d       	adc	r25, r1
    8c50:	a1 1d       	adc	r26, r1
    8c52:	20 d0       	rcall	.+64     	; 0x8c94 <__ultoa_invert+0x84>
    8c54:	09 f4       	brne	.+2      	; 0x8c58 <__ultoa_invert+0x48>
    8c56:	68 94       	set
    8c58:	3f 91       	pop	r19
    8c5a:	2a e0       	ldi	r18, 0x0A	; 10
    8c5c:	26 9f       	mul	r18, r22
    8c5e:	11 24       	eor	r1, r1
    8c60:	30 19       	sub	r19, r0
    8c62:	30 5d       	subi	r19, 0xD0	; 208
    8c64:	31 93       	st	Z+, r19
    8c66:	de f6       	brtc	.-74     	; 0x8c1e <__ultoa_invert+0xe>
    8c68:	cf 01       	movw	r24, r30
    8c6a:	08 95       	ret
    8c6c:	46 2f       	mov	r20, r22
    8c6e:	47 70       	andi	r20, 0x07	; 7
    8c70:	40 5d       	subi	r20, 0xD0	; 208
    8c72:	41 93       	st	Z+, r20
    8c74:	b3 e0       	ldi	r27, 0x03	; 3
    8c76:	0f d0       	rcall	.+30     	; 0x8c96 <__ultoa_invert+0x86>
    8c78:	c9 f7       	brne	.-14     	; 0x8c6c <__ultoa_invert+0x5c>
    8c7a:	f6 cf       	rjmp	.-20     	; 0x8c68 <__ultoa_invert+0x58>
    8c7c:	46 2f       	mov	r20, r22
    8c7e:	4f 70       	andi	r20, 0x0F	; 15
    8c80:	40 5d       	subi	r20, 0xD0	; 208
    8c82:	4a 33       	cpi	r20, 0x3A	; 58
    8c84:	18 f0       	brcs	.+6      	; 0x8c8c <__ultoa_invert+0x7c>
    8c86:	49 5d       	subi	r20, 0xD9	; 217
    8c88:	31 fd       	sbrc	r19, 1
    8c8a:	40 52       	subi	r20, 0x20	; 32
    8c8c:	41 93       	st	Z+, r20
    8c8e:	02 d0       	rcall	.+4      	; 0x8c94 <__ultoa_invert+0x84>
    8c90:	a9 f7       	brne	.-22     	; 0x8c7c <__ultoa_invert+0x6c>
    8c92:	ea cf       	rjmp	.-44     	; 0x8c68 <__ultoa_invert+0x58>
    8c94:	b4 e0       	ldi	r27, 0x04	; 4
    8c96:	a6 95       	lsr	r26
    8c98:	97 95       	ror	r25
    8c9a:	87 95       	ror	r24
    8c9c:	77 95       	ror	r23
    8c9e:	67 95       	ror	r22
    8ca0:	ba 95       	dec	r27
    8ca2:	c9 f7       	brne	.-14     	; 0x8c96 <__ultoa_invert+0x86>
    8ca4:	00 97       	sbiw	r24, 0x00	; 0
    8ca6:	61 05       	cpc	r22, r1
    8ca8:	71 05       	cpc	r23, r1
    8caa:	08 95       	ret
    8cac:	9b 01       	movw	r18, r22
    8cae:	ac 01       	movw	r20, r24
    8cb0:	0a 2e       	mov	r0, r26
    8cb2:	06 94       	lsr	r0
    8cb4:	57 95       	ror	r21
    8cb6:	47 95       	ror	r20
    8cb8:	37 95       	ror	r19
    8cba:	27 95       	ror	r18
    8cbc:	ba 95       	dec	r27
    8cbe:	c9 f7       	brne	.-14     	; 0x8cb2 <__ultoa_invert+0xa2>
    8cc0:	62 0f       	add	r22, r18
    8cc2:	73 1f       	adc	r23, r19
    8cc4:	84 1f       	adc	r24, r20
    8cc6:	95 1f       	adc	r25, r21
    8cc8:	a0 1d       	adc	r26, r0
    8cca:	08 95       	ret

00008ccc <__eerd_block_m1284p>:
    8ccc:	dc 01       	movw	r26, r24
    8cce:	cb 01       	movw	r24, r22

00008cd0 <__eerd_blraw_m1284p>:
    8cd0:	fc 01       	movw	r30, r24
    8cd2:	f9 99       	sbic	0x1f, 1	; 31
    8cd4:	fe cf       	rjmp	.-4      	; 0x8cd2 <__eerd_blraw_m1284p+0x2>
    8cd6:	06 c0       	rjmp	.+12     	; 0x8ce4 <__eerd_blraw_m1284p+0x14>
    8cd8:	f2 bd       	out	0x22, r31	; 34
    8cda:	e1 bd       	out	0x21, r30	; 33
    8cdc:	f8 9a       	sbi	0x1f, 0	; 31
    8cde:	31 96       	adiw	r30, 0x01	; 1
    8ce0:	00 b4       	in	r0, 0x20	; 32
    8ce2:	0d 92       	st	X+, r0
    8ce4:	41 50       	subi	r20, 0x01	; 1
    8ce6:	50 40       	sbci	r21, 0x00	; 0
    8ce8:	b8 f7       	brcc	.-18     	; 0x8cd8 <__eerd_blraw_m1284p+0x8>
    8cea:	08 95       	ret

00008cec <__eeupd_block_m1284p>:
    8cec:	dc 01       	movw	r26, r24
    8cee:	a4 0f       	add	r26, r20
    8cf0:	b5 1f       	adc	r27, r21
    8cf2:	41 50       	subi	r20, 0x01	; 1
    8cf4:	50 40       	sbci	r21, 0x00	; 0
    8cf6:	48 f0       	brcs	.+18     	; 0x8d0a <__eeupd_block_m1284p+0x1e>
    8cf8:	cb 01       	movw	r24, r22
    8cfa:	84 0f       	add	r24, r20
    8cfc:	95 1f       	adc	r25, r21
    8cfe:	2e 91       	ld	r18, -X
    8d00:	0e 94 87 46 	call	0x8d0e	; 0x8d0e <__eeupd_r18_m1284p>
    8d04:	41 50       	subi	r20, 0x01	; 1
    8d06:	50 40       	sbci	r21, 0x00	; 0
    8d08:	d0 f7       	brcc	.-12     	; 0x8cfe <__eeupd_block_m1284p+0x12>
    8d0a:	08 95       	ret

00008d0c <__eeupd_byte_m1284p>:
    8d0c:	26 2f       	mov	r18, r22

00008d0e <__eeupd_r18_m1284p>:
    8d0e:	f9 99       	sbic	0x1f, 1	; 31
    8d10:	fe cf       	rjmp	.-4      	; 0x8d0e <__eeupd_r18_m1284p>
    8d12:	92 bd       	out	0x22, r25	; 34
    8d14:	81 bd       	out	0x21, r24	; 33
    8d16:	f8 9a       	sbi	0x1f, 0	; 31
    8d18:	01 97       	sbiw	r24, 0x01	; 1
    8d1a:	00 b4       	in	r0, 0x20	; 32
    8d1c:	02 16       	cp	r0, r18
    8d1e:	39 f0       	breq	.+14     	; 0x8d2e <__eeupd_r18_m1284p+0x20>
    8d20:	1f ba       	out	0x1f, r1	; 31
    8d22:	20 bd       	out	0x20, r18	; 32
    8d24:	0f b6       	in	r0, 0x3f	; 63
    8d26:	f8 94       	cli
    8d28:	fa 9a       	sbi	0x1f, 2	; 31
    8d2a:	f9 9a       	sbi	0x1f, 1	; 31
    8d2c:	0f be       	out	0x3f, r0	; 63
    8d2e:	08 95       	ret

00008d30 <strtod>:
    8d30:	8f 92       	push	r8
    8d32:	9f 92       	push	r9
    8d34:	af 92       	push	r10
    8d36:	bf 92       	push	r11
    8d38:	cf 92       	push	r12
    8d3a:	df 92       	push	r13
    8d3c:	ef 92       	push	r14
    8d3e:	ff 92       	push	r15
    8d40:	0f 93       	push	r16
    8d42:	1f 93       	push	r17
    8d44:	cf 93       	push	r28
    8d46:	df 93       	push	r29
    8d48:	ec 01       	movw	r28, r24
    8d4a:	5b 01       	movw	r10, r22
    8d4c:	61 15       	cp	r22, r1
    8d4e:	71 05       	cpc	r23, r1
    8d50:	19 f0       	breq	.+6      	; 0x8d58 <strtod+0x28>
    8d52:	fb 01       	movw	r30, r22
    8d54:	91 83       	std	Z+1, r25	; 0x01
    8d56:	80 83       	st	Z, r24
    8d58:	f9 90       	ld	r15, Y+
    8d5a:	8f 2d       	mov	r24, r15
    8d5c:	90 e0       	ldi	r25, 0x00	; 0
    8d5e:	0e 94 42 45 	call	0x8a84	; 0x8a84 <isspace>
    8d62:	89 2b       	or	r24, r25
    8d64:	c9 f7       	brne	.-14     	; 0x8d58 <strtod+0x28>
    8d66:	fd e2       	ldi	r31, 0x2D	; 45
    8d68:	ff 16       	cp	r15, r31
    8d6a:	21 f4       	brne	.+8      	; 0x8d74 <strtod+0x44>
    8d6c:	f9 90       	ld	r15, Y+
    8d6e:	ee 24       	eor	r14, r14
    8d70:	e3 94       	inc	r14
    8d72:	05 c0       	rjmp	.+10     	; 0x8d7e <strtod+0x4e>
    8d74:	2b e2       	ldi	r18, 0x2B	; 43
    8d76:	f2 16       	cp	r15, r18
    8d78:	09 f4       	brne	.+2      	; 0x8d7c <strtod+0x4c>
    8d7a:	f9 90       	ld	r15, Y+
    8d7c:	ee 24       	eor	r14, r14
    8d7e:	8e 01       	movw	r16, r28
    8d80:	01 50       	subi	r16, 0x01	; 1
    8d82:	10 40       	sbci	r17, 0x00	; 0
    8d84:	c8 01       	movw	r24, r16
    8d86:	62 e0       	ldi	r22, 0x02	; 2
    8d88:	76 e0       	ldi	r23, 0x06	; 6
    8d8a:	43 e0       	ldi	r20, 0x03	; 3
    8d8c:	50 e0       	ldi	r21, 0x00	; 0
    8d8e:	0e 94 09 48 	call	0x9012	; 0x9012 <strncasecmp_P>
    8d92:	89 2b       	or	r24, r25
    8d94:	01 f5       	brne	.+64     	; 0x8dd6 <strtod+0xa6>
    8d96:	8e 01       	movw	r16, r28
    8d98:	0e 5f       	subi	r16, 0xFE	; 254
    8d9a:	1f 4f       	sbci	r17, 0xFF	; 255
    8d9c:	c8 01       	movw	r24, r16
    8d9e:	65 e0       	ldi	r22, 0x05	; 5
    8da0:	76 e0       	ldi	r23, 0x06	; 6
    8da2:	45 e0       	ldi	r20, 0x05	; 5
    8da4:	50 e0       	ldi	r21, 0x00	; 0
    8da6:	0e 94 09 48 	call	0x9012	; 0x9012 <strncasecmp_P>
    8daa:	89 2b       	or	r24, r25
    8dac:	19 f4       	brne	.+6      	; 0x8db4 <strtod+0x84>
    8dae:	8e 01       	movw	r16, r28
    8db0:	09 5f       	subi	r16, 0xF9	; 249
    8db2:	1f 4f       	sbci	r17, 0xFF	; 255
    8db4:	a1 14       	cp	r10, r1
    8db6:	b1 04       	cpc	r11, r1
    8db8:	19 f0       	breq	.+6      	; 0x8dc0 <strtod+0x90>
    8dba:	f5 01       	movw	r30, r10
    8dbc:	11 83       	std	Z+1, r17	; 0x01
    8dbe:	00 83       	st	Z, r16
    8dc0:	e0 fc       	sbrc	r14, 0
    8dc2:	04 c0       	rjmp	.+8      	; 0x8dcc <strtod+0x9c>
    8dc4:	70 e0       	ldi	r23, 0x00	; 0
    8dc6:	90 e0       	ldi	r25, 0x00	; 0
    8dc8:	80 e8       	ldi	r24, 0x80	; 128
    8dca:	14 c0       	rjmp	.+40     	; 0x8df4 <strtod+0xc4>
    8dcc:	70 e0       	ldi	r23, 0x00	; 0
    8dce:	90 e0       	ldi	r25, 0x00	; 0
    8dd0:	80 e8       	ldi	r24, 0x80	; 128
    8dd2:	6f ef       	ldi	r22, 0xFF	; 255
    8dd4:	08 c1       	rjmp	.+528    	; 0x8fe6 <strtod+0x2b6>
    8dd6:	c8 01       	movw	r24, r16
    8dd8:	6a e0       	ldi	r22, 0x0A	; 10
    8dda:	76 e0       	ldi	r23, 0x06	; 6
    8ddc:	43 e0       	ldi	r20, 0x03	; 3
    8dde:	50 e0       	ldi	r21, 0x00	; 0
    8de0:	0e 94 09 48 	call	0x9012	; 0x9012 <strncasecmp_P>
    8de4:	89 2b       	or	r24, r25
    8de6:	69 f4       	brne	.+26     	; 0x8e02 <strtod+0xd2>
    8de8:	a1 14       	cp	r10, r1
    8dea:	b1 04       	cpc	r11, r1
    8dec:	29 f4       	brne	.+10     	; 0x8df8 <strtod+0xc8>
    8dee:	70 e0       	ldi	r23, 0x00	; 0
    8df0:	90 e0       	ldi	r25, 0x00	; 0
    8df2:	80 ec       	ldi	r24, 0xC0	; 192
    8df4:	6f e7       	ldi	r22, 0x7F	; 127
    8df6:	f7 c0       	rjmp	.+494    	; 0x8fe6 <strtod+0x2b6>
    8df8:	22 96       	adiw	r28, 0x02	; 2
    8dfa:	f5 01       	movw	r30, r10
    8dfc:	d1 83       	std	Z+1, r29	; 0x01
    8dfe:	c0 83       	st	Z, r28
    8e00:	f6 cf       	rjmp	.-20     	; 0x8dee <strtod+0xbe>
    8e02:	88 24       	eor	r8, r8
    8e04:	99 24       	eor	r9, r9
    8e06:	40 e0       	ldi	r20, 0x00	; 0
    8e08:	50 e0       	ldi	r21, 0x00	; 0
    8e0a:	60 e0       	ldi	r22, 0x00	; 0
    8e0c:	70 e0       	ldi	r23, 0x00	; 0
    8e0e:	ef 2d       	mov	r30, r15
    8e10:	e0 53       	subi	r30, 0x30	; 48
    8e12:	ea 30       	cpi	r30, 0x0A	; 10
    8e14:	a0 f5       	brcc	.+104    	; 0x8e7e <strtod+0x14e>
    8e16:	f2 e0       	ldi	r31, 0x02	; 2
    8e18:	ef 2a       	or	r14, r31
    8e1a:	8e 2d       	mov	r24, r14
    8e1c:	90 e0       	ldi	r25, 0x00	; 0
    8e1e:	9c 01       	movw	r18, r24
    8e20:	28 70       	andi	r18, 0x08	; 8
    8e22:	30 70       	andi	r19, 0x00	; 0
    8e24:	e2 fe       	sbrs	r14, 2
    8e26:	06 c0       	rjmp	.+12     	; 0x8e34 <strtod+0x104>
    8e28:	23 2b       	or	r18, r19
    8e2a:	79 f5       	brne	.+94     	; 0x8e8a <strtod+0x15a>
    8e2c:	08 94       	sec
    8e2e:	81 1c       	adc	r8, r1
    8e30:	91 1c       	adc	r9, r1
    8e32:	2b c0       	rjmp	.+86     	; 0x8e8a <strtod+0x15a>
    8e34:	23 2b       	or	r18, r19
    8e36:	19 f0       	breq	.+6      	; 0x8e3e <strtod+0x10e>
    8e38:	08 94       	sec
    8e3a:	81 08       	sbc	r8, r1
    8e3c:	91 08       	sbc	r9, r1
    8e3e:	db 01       	movw	r26, r22
    8e40:	ca 01       	movw	r24, r20
    8e42:	12 e0       	ldi	r17, 0x02	; 2
    8e44:	88 0f       	add	r24, r24
    8e46:	99 1f       	adc	r25, r25
    8e48:	aa 1f       	adc	r26, r26
    8e4a:	bb 1f       	adc	r27, r27
    8e4c:	1a 95       	dec	r17
    8e4e:	d1 f7       	brne	.-12     	; 0x8e44 <strtod+0x114>
    8e50:	48 0f       	add	r20, r24
    8e52:	59 1f       	adc	r21, r25
    8e54:	6a 1f       	adc	r22, r26
    8e56:	7b 1f       	adc	r23, r27
    8e58:	44 0f       	add	r20, r20
    8e5a:	55 1f       	adc	r21, r21
    8e5c:	66 1f       	adc	r22, r22
    8e5e:	77 1f       	adc	r23, r23
    8e60:	4e 0f       	add	r20, r30
    8e62:	51 1d       	adc	r21, r1
    8e64:	61 1d       	adc	r22, r1
    8e66:	71 1d       	adc	r23, r1
    8e68:	48 39       	cpi	r20, 0x98	; 152
    8e6a:	29 e9       	ldi	r18, 0x99	; 153
    8e6c:	52 07       	cpc	r21, r18
    8e6e:	29 e9       	ldi	r18, 0x99	; 153
    8e70:	62 07       	cpc	r22, r18
    8e72:	29 e1       	ldi	r18, 0x19	; 25
    8e74:	72 07       	cpc	r23, r18
    8e76:	48 f0       	brcs	.+18     	; 0x8e8a <strtod+0x15a>
    8e78:	84 e0       	ldi	r24, 0x04	; 4
    8e7a:	e8 2a       	or	r14, r24
    8e7c:	06 c0       	rjmp	.+12     	; 0x8e8a <strtod+0x15a>
    8e7e:	ee 3f       	cpi	r30, 0xFE	; 254
    8e80:	31 f4       	brne	.+12     	; 0x8e8e <strtod+0x15e>
    8e82:	e3 fc       	sbrc	r14, 3
    8e84:	39 c0       	rjmp	.+114    	; 0x8ef8 <strtod+0x1c8>
    8e86:	98 e0       	ldi	r25, 0x08	; 8
    8e88:	e9 2a       	or	r14, r25
    8e8a:	f9 90       	ld	r15, Y+
    8e8c:	c0 cf       	rjmp	.-128    	; 0x8e0e <strtod+0xde>
    8e8e:	e5 33       	cpi	r30, 0x35	; 53
    8e90:	11 f0       	breq	.+4      	; 0x8e96 <strtod+0x166>
    8e92:	e5 31       	cpi	r30, 0x15	; 21
    8e94:	89 f5       	brne	.+98     	; 0x8ef8 <strtod+0x1c8>
    8e96:	29 91       	ld	r18, Y+
    8e98:	2d 32       	cpi	r18, 0x2D	; 45
    8e9a:	19 f4       	brne	.+6      	; 0x8ea2 <strtod+0x172>
    8e9c:	e0 e1       	ldi	r30, 0x10	; 16
    8e9e:	ee 2a       	or	r14, r30
    8ea0:	05 c0       	rjmp	.+10     	; 0x8eac <strtod+0x17c>
    8ea2:	2b 32       	cpi	r18, 0x2B	; 43
    8ea4:	19 f0       	breq	.+6      	; 0x8eac <strtod+0x17c>
    8ea6:	81 e0       	ldi	r24, 0x01	; 1
    8ea8:	90 e0       	ldi	r25, 0x00	; 0
    8eaa:	03 c0       	rjmp	.+6      	; 0x8eb2 <strtod+0x182>
    8eac:	29 91       	ld	r18, Y+
    8eae:	82 e0       	ldi	r24, 0x02	; 2
    8eb0:	90 e0       	ldi	r25, 0x00	; 0
    8eb2:	e2 2f       	mov	r30, r18
    8eb4:	e0 53       	subi	r30, 0x30	; 48
    8eb6:	ea 30       	cpi	r30, 0x0A	; 10
    8eb8:	18 f0       	brcs	.+6      	; 0x8ec0 <strtod+0x190>
    8eba:	c8 1b       	sub	r28, r24
    8ebc:	d9 0b       	sbc	r29, r25
    8ebe:	1c c0       	rjmp	.+56     	; 0x8ef8 <strtod+0x1c8>
    8ec0:	20 e0       	ldi	r18, 0x00	; 0
    8ec2:	30 e0       	ldi	r19, 0x00	; 0
    8ec4:	fc e0       	ldi	r31, 0x0C	; 12
    8ec6:	20 38       	cpi	r18, 0x80	; 128
    8ec8:	3f 07       	cpc	r19, r31
    8eca:	5c f4       	brge	.+22     	; 0x8ee2 <strtod+0x1b2>
    8ecc:	c9 01       	movw	r24, r18
    8ece:	88 0f       	add	r24, r24
    8ed0:	99 1f       	adc	r25, r25
    8ed2:	88 0f       	add	r24, r24
    8ed4:	99 1f       	adc	r25, r25
    8ed6:	28 0f       	add	r18, r24
    8ed8:	39 1f       	adc	r19, r25
    8eda:	22 0f       	add	r18, r18
    8edc:	33 1f       	adc	r19, r19
    8ede:	2e 0f       	add	r18, r30
    8ee0:	31 1d       	adc	r19, r1
    8ee2:	e9 91       	ld	r30, Y+
    8ee4:	e0 53       	subi	r30, 0x30	; 48
    8ee6:	ea 30       	cpi	r30, 0x0A	; 10
    8ee8:	68 f3       	brcs	.-38     	; 0x8ec4 <strtod+0x194>
    8eea:	e4 fe       	sbrs	r14, 4
    8eec:	03 c0       	rjmp	.+6      	; 0x8ef4 <strtod+0x1c4>
    8eee:	30 95       	com	r19
    8ef0:	21 95       	neg	r18
    8ef2:	3f 4f       	sbci	r19, 0xFF	; 255
    8ef4:	82 0e       	add	r8, r18
    8ef6:	93 1e       	adc	r9, r19
    8ef8:	ce 2c       	mov	r12, r14
    8efa:	dd 24       	eor	r13, r13
    8efc:	e1 fe       	sbrs	r14, 1
    8efe:	07 c0       	rjmp	.+14     	; 0x8f0e <strtod+0x1de>
    8f00:	a1 14       	cp	r10, r1
    8f02:	b1 04       	cpc	r11, r1
    8f04:	21 f0       	breq	.+8      	; 0x8f0e <strtod+0x1de>
    8f06:	21 97       	sbiw	r28, 0x01	; 1
    8f08:	f5 01       	movw	r30, r10
    8f0a:	d1 83       	std	Z+1, r29	; 0x01
    8f0c:	c0 83       	st	Z, r28
    8f0e:	cb 01       	movw	r24, r22
    8f10:	ba 01       	movw	r22, r20
    8f12:	0e 94 61 40 	call	0x80c2	; 0x80c2 <__floatunsisf>
    8f16:	7b 01       	movw	r14, r22
    8f18:	8c 01       	movw	r16, r24
    8f1a:	f3 e0       	ldi	r31, 0x03	; 3
    8f1c:	cf 22       	and	r12, r31
    8f1e:	dd 24       	eor	r13, r13
    8f20:	23 e0       	ldi	r18, 0x03	; 3
    8f22:	c2 16       	cp	r12, r18
    8f24:	d1 04       	cpc	r13, r1
    8f26:	21 f4       	brne	.+8      	; 0x8f30 <strtod+0x200>
    8f28:	17 fb       	bst	r17, 7
    8f2a:	10 95       	com	r17
    8f2c:	17 f9       	bld	r17, 7
    8f2e:	10 95       	com	r17
    8f30:	57 01       	movw	r10, r14
    8f32:	68 01       	movw	r12, r16
    8f34:	c8 01       	movw	r24, r16
    8f36:	b7 01       	movw	r22, r14
    8f38:	20 e0       	ldi	r18, 0x00	; 0
    8f3a:	30 e0       	ldi	r19, 0x00	; 0
    8f3c:	40 e0       	ldi	r20, 0x00	; 0
    8f3e:	50 e0       	ldi	r21, 0x00	; 0
    8f40:	0e 94 c4 3f 	call	0x7f88	; 0x7f88 <__cmpsf2>
    8f44:	88 23       	and	r24, r24
    8f46:	09 f4       	brne	.+2      	; 0x8f4a <strtod+0x21a>
    8f48:	4a c0       	rjmp	.+148    	; 0x8fde <strtod+0x2ae>
    8f4a:	97 fe       	sbrs	r9, 7
    8f4c:	0d c0       	rjmp	.+26     	; 0x8f68 <strtod+0x238>
    8f4e:	21 e2       	ldi	r18, 0x21	; 33
    8f50:	e2 2e       	mov	r14, r18
    8f52:	26 e0       	ldi	r18, 0x06	; 6
    8f54:	f2 2e       	mov	r15, r18
    8f56:	90 94       	com	r9
    8f58:	81 94       	neg	r8
    8f5a:	91 08       	sbc	r9, r1
    8f5c:	93 94       	inc	r9
    8f5e:	c0 e2       	ldi	r28, 0x20	; 32
    8f60:	d0 e0       	ldi	r29, 0x00	; 0
    8f62:	00 e0       	ldi	r16, 0x00	; 0
    8f64:	10 e0       	ldi	r17, 0x00	; 0
    8f66:	12 c0       	rjmp	.+36     	; 0x8f8c <strtod+0x25c>
    8f68:	99 e3       	ldi	r25, 0x39	; 57
    8f6a:	e9 2e       	mov	r14, r25
    8f6c:	96 e0       	ldi	r25, 0x06	; 6
    8f6e:	f9 2e       	mov	r15, r25
    8f70:	f6 cf       	rjmp	.-20     	; 0x8f5e <strtod+0x22e>
    8f72:	f7 01       	movw	r30, r14
    8f74:	25 91       	lpm	r18, Z+
    8f76:	35 91       	lpm	r19, Z+
    8f78:	45 91       	lpm	r20, Z+
    8f7a:	54 91       	lpm	r21, Z+
    8f7c:	c6 01       	movw	r24, r12
    8f7e:	b5 01       	movw	r22, r10
    8f80:	0e 94 6a 41 	call	0x82d4	; 0x82d4 <__mulsf3>
    8f84:	5b 01       	movw	r10, r22
    8f86:	6c 01       	movw	r12, r24
    8f88:	8c 1a       	sub	r8, r28
    8f8a:	9d 0a       	sbc	r9, r29
    8f8c:	8c 16       	cp	r8, r28
    8f8e:	9d 06       	cpc	r9, r29
    8f90:	84 f7       	brge	.-32     	; 0x8f72 <strtod+0x242>
    8f92:	d5 95       	asr	r29
    8f94:	c7 95       	ror	r28
    8f96:	0f 5f       	subi	r16, 0xFF	; 255
    8f98:	1f 4f       	sbci	r17, 0xFF	; 255
    8f9a:	06 30       	cpi	r16, 0x06	; 6
    8f9c:	11 05       	cpc	r17, r1
    8f9e:	29 f0       	breq	.+10     	; 0x8faa <strtod+0x27a>
    8fa0:	8c ef       	ldi	r24, 0xFC	; 252
    8fa2:	9f ef       	ldi	r25, 0xFF	; 255
    8fa4:	e8 0e       	add	r14, r24
    8fa6:	f9 1e       	adc	r15, r25
    8fa8:	f1 cf       	rjmp	.-30     	; 0x8f8c <strtod+0x25c>
    8faa:	c5 01       	movw	r24, r10
    8fac:	d6 01       	movw	r26, r12
    8fae:	7c 01       	movw	r14, r24
    8fb0:	8d 01       	movw	r16, r26
    8fb2:	8c 2d       	mov	r24, r12
    8fb4:	88 0f       	add	r24, r24
    8fb6:	8d 2d       	mov	r24, r13
    8fb8:	88 1f       	adc	r24, r24
    8fba:	8f 3f       	cpi	r24, 0xFF	; 255
    8fbc:	51 f0       	breq	.+20     	; 0x8fd2 <strtod+0x2a2>
    8fbe:	c6 01       	movw	r24, r12
    8fc0:	b5 01       	movw	r22, r10
    8fc2:	20 e0       	ldi	r18, 0x00	; 0
    8fc4:	30 e0       	ldi	r19, 0x00	; 0
    8fc6:	40 e0       	ldi	r20, 0x00	; 0
    8fc8:	50 e0       	ldi	r21, 0x00	; 0
    8fca:	0e 94 c4 3f 	call	0x7f88	; 0x7f88 <__cmpsf2>
    8fce:	88 23       	and	r24, r24
    8fd0:	31 f4       	brne	.+12     	; 0x8fde <strtod+0x2ae>
    8fd2:	82 e2       	ldi	r24, 0x22	; 34
    8fd4:	90 e0       	ldi	r25, 0x00	; 0
    8fd6:	90 93 9d 04 	sts	0x049D, r25
    8fda:	80 93 9c 04 	sts	0x049C, r24
    8fde:	7e 2d       	mov	r23, r14
    8fe0:	9f 2d       	mov	r25, r15
    8fe2:	80 2f       	mov	r24, r16
    8fe4:	61 2f       	mov	r22, r17
    8fe6:	27 2f       	mov	r18, r23
    8fe8:	39 2f       	mov	r19, r25
    8fea:	48 2f       	mov	r20, r24
    8fec:	56 2f       	mov	r21, r22
    8fee:	b9 01       	movw	r22, r18
    8ff0:	ca 01       	movw	r24, r20
    8ff2:	df 91       	pop	r29
    8ff4:	cf 91       	pop	r28
    8ff6:	1f 91       	pop	r17
    8ff8:	0f 91       	pop	r16
    8ffa:	ff 90       	pop	r15
    8ffc:	ef 90       	pop	r14
    8ffe:	df 90       	pop	r13
    9000:	cf 90       	pop	r12
    9002:	bf 90       	pop	r11
    9004:	af 90       	pop	r10
    9006:	9f 90       	pop	r9
    9008:	8f 90       	pop	r8
    900a:	08 95       	ret

0000900c <__ctype_isfalse>:
    900c:	99 27       	eor	r25, r25
    900e:	88 27       	eor	r24, r24

00009010 <__ctype_istrue>:
    9010:	08 95       	ret

00009012 <strncasecmp_P>:
    9012:	fb 01       	movw	r30, r22
    9014:	dc 01       	movw	r26, r24
    9016:	41 50       	subi	r20, 0x01	; 1
    9018:	50 40       	sbci	r21, 0x00	; 0
    901a:	88 f0       	brcs	.+34     	; 0x903e <strncasecmp_P+0x2c>
    901c:	8d 91       	ld	r24, X+
    901e:	81 34       	cpi	r24, 0x41	; 65
    9020:	1c f0       	brlt	.+6      	; 0x9028 <strncasecmp_P+0x16>
    9022:	8b 35       	cpi	r24, 0x5B	; 91
    9024:	0c f4       	brge	.+2      	; 0x9028 <strncasecmp_P+0x16>
    9026:	80 5e       	subi	r24, 0xE0	; 224
    9028:	65 91       	lpm	r22, Z+
    902a:	61 34       	cpi	r22, 0x41	; 65
    902c:	1c f0       	brlt	.+6      	; 0x9034 <strncasecmp_P+0x22>
    902e:	6b 35       	cpi	r22, 0x5B	; 91
    9030:	0c f4       	brge	.+2      	; 0x9034 <strncasecmp_P+0x22>
    9032:	60 5e       	subi	r22, 0xE0	; 224
    9034:	86 1b       	sub	r24, r22
    9036:	61 11       	cpse	r22, r1
    9038:	71 f3       	breq	.-36     	; 0x9016 <strncasecmp_P+0x4>
    903a:	99 0b       	sbc	r25, r25
    903c:	08 95       	ret
    903e:	88 1b       	sub	r24, r24
    9040:	fc cf       	rjmp	.-8      	; 0x903a <strncasecmp_P+0x28>

00009042 <__mulsi3>:
    9042:	62 9f       	mul	r22, r18
    9044:	d0 01       	movw	r26, r0
    9046:	73 9f       	mul	r23, r19
    9048:	f0 01       	movw	r30, r0
    904a:	82 9f       	mul	r24, r18
    904c:	e0 0d       	add	r30, r0
    904e:	f1 1d       	adc	r31, r1
    9050:	64 9f       	mul	r22, r20
    9052:	e0 0d       	add	r30, r0
    9054:	f1 1d       	adc	r31, r1
    9056:	92 9f       	mul	r25, r18
    9058:	f0 0d       	add	r31, r0
    905a:	83 9f       	mul	r24, r19
    905c:	f0 0d       	add	r31, r0
    905e:	74 9f       	mul	r23, r20
    9060:	f0 0d       	add	r31, r0
    9062:	65 9f       	mul	r22, r21
    9064:	f0 0d       	add	r31, r0
    9066:	99 27       	eor	r25, r25
    9068:	72 9f       	mul	r23, r18
    906a:	b0 0d       	add	r27, r0
    906c:	e1 1d       	adc	r30, r1
    906e:	f9 1f       	adc	r31, r25
    9070:	63 9f       	mul	r22, r19
    9072:	b0 0d       	add	r27, r0
    9074:	e1 1d       	adc	r30, r1
    9076:	f9 1f       	adc	r31, r25
    9078:	bd 01       	movw	r22, r26
    907a:	cf 01       	movw	r24, r30
    907c:	11 24       	eor	r1, r1
    907e:	08 95       	ret

00009080 <__udivmodsi4>:
    9080:	a1 e2       	ldi	r26, 0x21	; 33
    9082:	1a 2e       	mov	r1, r26
    9084:	aa 1b       	sub	r26, r26
    9086:	bb 1b       	sub	r27, r27
    9088:	fd 01       	movw	r30, r26
    908a:	0d c0       	rjmp	.+26     	; 0x90a6 <__udivmodsi4_ep>

0000908c <__udivmodsi4_loop>:
    908c:	aa 1f       	adc	r26, r26
    908e:	bb 1f       	adc	r27, r27
    9090:	ee 1f       	adc	r30, r30
    9092:	ff 1f       	adc	r31, r31
    9094:	a2 17       	cp	r26, r18
    9096:	b3 07       	cpc	r27, r19
    9098:	e4 07       	cpc	r30, r20
    909a:	f5 07       	cpc	r31, r21
    909c:	20 f0       	brcs	.+8      	; 0x90a6 <__udivmodsi4_ep>
    909e:	a2 1b       	sub	r26, r18
    90a0:	b3 0b       	sbc	r27, r19
    90a2:	e4 0b       	sbc	r30, r20
    90a4:	f5 0b       	sbc	r31, r21

000090a6 <__udivmodsi4_ep>:
    90a6:	66 1f       	adc	r22, r22
    90a8:	77 1f       	adc	r23, r23
    90aa:	88 1f       	adc	r24, r24
    90ac:	99 1f       	adc	r25, r25
    90ae:	1a 94       	dec	r1
    90b0:	69 f7       	brne	.-38     	; 0x908c <__udivmodsi4_loop>
    90b2:	60 95       	com	r22
    90b4:	70 95       	com	r23
    90b6:	80 95       	com	r24
    90b8:	90 95       	com	r25
    90ba:	9b 01       	movw	r18, r22
    90bc:	ac 01       	movw	r20, r24
    90be:	bd 01       	movw	r22, r26
    90c0:	cf 01       	movw	r24, r30
    90c2:	08 95       	ret

000090c4 <_exit>:
    90c4:	f8 94       	cli

000090c6 <__stop_program>:
    90c6:	ff cf       	rjmp	.-2      	; 0x90c6 <__stop_program>
