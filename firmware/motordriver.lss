
motordriver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000204  00800100  00009856  0000990a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00009856  00000000  00000000  000000b4  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000001c8  00800304  00800304  00009b0e  2**0
                  ALLOC
  3 .eeprom       0000014b  00810000  00810000  00009b0e  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  4 .stab         0000798c  00000000  00000000  00009c5c  2**2
                  CONTENTS, READONLY, DEBUGGING
  5 .stabstr      00003122  00000000  00000000  000115e8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 5e 03 	jmp	0x6bc	; 0x6bc <__ctors_end>
       4:	0c 94 3d 2a 	jmp	0x547a	; 0x547a <__vector_1>
       8:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
       c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      10:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      14:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      18:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      1c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      20:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      24:	0c 94 87 0c 	jmp	0x190e	; 0x190e <__vector_9>
      28:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      2c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      30:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      34:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      38:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      3c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      40:	0c 94 8b 0a 	jmp	0x1516	; 0x1516 <__vector_16>
      44:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      48:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      4c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      50:	0c 94 3d 0a 	jmp	0x147a	; 0x147a <__vector_20>
      54:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      58:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      5c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      60:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      64:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      68:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      6c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      70:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      74:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      78:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      7c:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      80:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      84:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      88:	0c 94 7d 03 	jmp	0x6fa	; 0x6fa <__bad_interrupt>
      8c:	da 16       	cp	r13, r26
      8e:	17 17       	cp	r17, r23
      90:	9a 17       	cp	r25, r26
      92:	f4 17       	cp	r31, r20
      94:	b8 18       	sub	r11, r8
      96:	f4 1a       	sub	r15, r20
      98:	67 1a       	sub	r6, r23
      9a:	bf 1a       	sub	r11, r31
      9c:	18 16       	cp	r1, r24
      9e:	57 16       	cp	r5, r23
      a0:	5e 18       	sub	r5, r14
      a2:	56 1b       	sub	r21, r22
      a4:	b0 1b       	sub	r27, r16
      a6:	10 19       	sub	r17, r0
      a8:	6a 19       	sub	r22, r10
      aa:	d4 19       	sub	r29, r4
      ac:	2a 1a       	sub	r2, r26
      ae:	9d 16       	cp	r9, r29
      b0:	1d 3c       	cpi	r17, 0xCD	; 205
      b2:	0c 3c       	cpi	r16, 0xCC	; 204
      b4:	f4 3b       	cpi	r31, 0xB4	; 180
      b6:	e7 3b       	cpi	r30, 0xB7	; 183
      b8:	da 3b       	cpi	r29, 0xBA	; 186
      ba:	cf 3b       	cpi	r28, 0xBF	; 191
      bc:	c4 3b       	cpi	r28, 0xB4	; 180
      be:	b7 3b       	cpi	r27, 0xB7	; 183
      c0:	b4 3b       	cpi	r27, 0xB4	; 180
      c2:	af 3b       	cpi	r26, 0xBF	; 191
      c4:	a4 3b       	cpi	r26, 0xB4	; 180
      c6:	99 3b       	cpi	r25, 0xB9	; 185
      c8:	8e 3b       	cpi	r24, 0xBE	; 190
      ca:	83 3b       	cpi	r24, 0xB3	; 179
      cc:	78 3b       	cpi	r23, 0xB8	; 184
      ce:	6d 3b       	cpi	r22, 0xBD	; 189
      d0:	62 3b       	cpi	r22, 0xB2	; 178
      d2:	57 3b       	cpi	r21, 0xB7	; 183
      d4:	4c 3b       	cpi	r20, 0xBC	; 188
      d6:	41 3b       	cpi	r20, 0xB1	; 177
      d8:	36 3b       	cpi	r19, 0xB6	; 182
      da:	2b 3b       	cpi	r18, 0xBB	; 187
      dc:	1e 3b       	cpi	r17, 0xBE	; 190
      de:	18 3b       	cpi	r17, 0xB8	; 184
      e0:	d9 3a       	cpi	r29, 0xA9	; 169
      e2:	cc 3a       	cpi	r28, 0xAC	; 172
      e4:	c1 3a       	cpi	r28, 0xA1	; 161
      e6:	ae 3a       	cpi	r26, 0xAE	; 174
      e8:	a5 3a       	cpi	r26, 0xA5	; 165
      ea:	a2 3a       	cpi	r26, 0xA2	; 162
      ec:	95 3a       	cpi	r25, 0xA5	; 165
      ee:	8a 3a       	cpi	r24, 0xAA	; 170
      f0:	7f 3a       	cpi	r23, 0xAF	; 175
      f2:	74 3a       	cpi	r23, 0xA4	; 164
      f4:	69 3a       	cpi	r22, 0xA9	; 169
      f6:	21 3c       	cpi	r18, 0xC1	; 193

000000f8 <table>:
      f8:	00 00 00 00 ff ff 00 00 00 00 00 00 00 00 01 00     ................
     108:	01 00 00 00 00 00 00 00 00 00 ff ff 00 00 00 00     ................

00000118 <cmd_0_name>:
	...

0000011a <cmd_0_>:
     11a:	18 01 00 80                                         ....

0000011e <cmd_1_name>:
     11e:	2a 52 53 54 00 00                                   *RST..

00000124 <cmd_1_>:
     124:	1e 01 00 81                                         ....

00000128 <cmd_2_name>:
     128:	2a 49 44 4e 3f 00 00                                *IDN?..

0000012f <cmd_2_>:
     12f:	28 01 00 82                                         (...

00000133 <cmd_3_name>:
     133:	2a 49 44 4e 00 00                                   *IDN..

00000139 <cmd_3_>:
     139:	33 01 01 83                                         3...

0000013d <cmd_4_name>:
     13d:	4d 4f 56 45 41 42 53 00 00                          MOVEABS..

00000146 <cmd_4_>:
     146:	3d 01 03 84                                         =...

0000014a <cmd_5_name>:
     14a:	4d 4f 56 45 52 45 4c 00 00                          MOVEREL..

00000153 <cmd_5_>:
     153:	4a 01 03 85                                         J...

00000157 <cmd_6_name>:
     157:	5a 45 52 4f 52 55 4e 00 00                          ZERORUN..

00000160 <cmd_6_>:
     160:	57 01 01 86                                         W...

00000164 <cmd_7_name>:
     164:	45 4e 41 42 4c 45 00 00                             ENABLE..

0000016c <cmd_7_>:
     16c:	64 01 02 87                                         d...

00000170 <cmd_8_name>:
     170:	47 45 54 50 4f 53 00 00                             GETPOS..

00000178 <cmd_8_>:
     178:	70 01 02 88                                         p...

0000017c <cmd_9_name>:
     17c:	53 41 56 45 43 4f 4e 46 00 00                       SAVECONF..

00000186 <cmd_9_>:
     186:	7c 01 00 89                                         |...

0000018a <cmd_10_name>:
     18a:	4c 4f 41 44 43 4f 4e 46 00 00                       LOADCONF..

00000194 <cmd_10_>:
     194:	8a 01 00 8a                                         ....

00000198 <cmd_11_name>:
     198:	49 53 4d 4f 56 49 4e 47 00 00                       ISMOVING..

000001a2 <cmd_11_>:
     1a2:	98 01 01 8b                                         ....

000001a6 <cmd_12_name>:
     1a6:	47 45 54 41 4e 41 4c 4f 47 00 00                    GETANALOG..

000001b1 <cmd_12_>:
     1b1:	a6 01 01 8c                                         ....

000001b5 <cmd_13_name>:
     1b5:	47 45 54 5a 45 52 4f 50 4f 53 00 00                 GETZEROPOS..

000001c1 <cmd_13_>:
     1c1:	b5 01 01 8d                                         ....

000001c5 <cmd_14_name>:
     1c5:	53 45 54 5a 45 52 4f 50 4f 53 00 00                 SETZEROPOS..

000001d1 <cmd_14_>:
     1d1:	c5 01 02 8e                                         ....

000001d5 <cmd_15_name>:
     1d5:	47 45 54 47 45 41 52 52 41 54 49 4f 00 00           GETGEARRATIO..

000001e3 <cmd_15_>:
     1e3:	d5 01 01 8f                                         ....

000001e7 <cmd_16_name>:
     1e7:	53 45 54 47 45 41 52 52 41 54 49 4f 00 00           SETGEARRATIO..

000001f5 <cmd_16_>:
     1f5:	e7 01 02 90                                         ....

000001f9 <cmd_17_name>:
     1f9:	47 45 54 46 55 4c 4c 52 4f 54 00 00                 GETFULLROT..

00000205 <cmd_17_>:
     205:	f9 01 01 91                                         ....

00000209 <cmd_18_name>:
     209:	53 45 54 46 55 4c 4c 52 4f 54 00 00                 SETFULLROT..

00000215 <cmd_18_>:
     215:	09 02 02 92                                         ....

00000219 <cmd_19_name>:
     219:	47 45 54 53 55 42 53 54 45 50 53 00 00              GETSUBSTEPS..

00000226 <cmd_19_>:
     226:	19 02 01 93                                         ....

0000022a <cmd_20_name>:
     22a:	53 45 54 53 55 42 53 54 45 50 53 00 00              SETSUBSTEPS..

00000237 <cmd_20_>:
     237:	2a 02 02 94                                         *...

0000023b <cmd_21_name>:
     23b:	47 45 54 57 41 49 54 54 49 4d 45 00 00              GETWAITTIME..

00000248 <cmd_21_>:
     248:	3b 02 01 95                                         ;...

0000024c <cmd_22_name>:
     24c:	53 45 54 57 41 49 54 54 49 4d 45 00 00              SETWAITTIME..

00000259 <cmd_22_>:
     259:	4c 02 02 96                                         L...

0000025d <cmd_23_name>:
     25d:	53 45 54 43 4f 4e 53 54 53 50 45 45 44 00 00        SETCONSTSPEED..

0000026c <cmd_23_>:
     26c:	5d 02 03 97                                         ]...

00000270 <cmd_24_name>:
     270:	46 41 43 54 4f 52 59 52 45 53 45 54 00 00           FACTORYRESET..

0000027e <cmd_24_>:
     27e:	70 02 00 98                                         p...

00000282 <cmd_25_name>:
     282:	53 54 4f 50 41 4c 4c 00 00                          STOPALL..

0000028b <cmd_25_>:
     28b:	82 02 00 99                                         ....

0000028f <cmd_26_name>:
     28f:	53 45 54 46 4f 52 42 5a 4f 4e 45 00 00              SETFORBZONE..

0000029c <cmd_26_>:
     29c:	8f 02 03 9a                                         ....

000002a0 <cmd_27_name>:
     2a0:	45 4e 41 42 46 4f 52 42 5a 4f 4e 45 00 00           ENABFORBZONE..

000002ae <cmd_27_>:
     2ae:	a0 02 02 9b                                         ....

000002b2 <cmd_28_name>:
     2b2:	53 45 54 50 52 4f 47 53 54 45 50 00 00              SETPROGSTEP..

000002bf <cmd_28_>:
     2bf:	b2 02 06 9c                                         ....

000002c3 <cmd_29_name>:
     2c3:	47 45 54 4d 4f 54 53 54 41 54 45 00 00              GETMOTSTATE..

000002d0 <cmd_29_>:
     2d0:	c3 02 01 9d                                         ....

000002d4 <cmd_30_name>:
     2d4:	44 42 47 52 45 41 44 4f 55 54 00 00                 DBGREADOUT..

000002e0 <cmd_30_>:
     2e0:	d4 02 00 9e                                         ....

000002e4 <cmd_31_name>:
     2e4:	4c 45 44 00 00                                      LED..

000002e9 <cmd_31_>:
     2e9:	e4 02 03 9f                                         ....

000002ed <cmd_32_name>:
     2ed:	47 45 54 43 55 52 52 00 00                          GETCURR..

000002f6 <cmd_32_>:
     2f6:	ed 02 01 a0                                         ....

000002fa <cmd_33_name>:
     2fa:	53 45 54 43 55 52 52 00 00                          SETCURR..

00000303 <cmd_33_>:
     303:	fa 02 02 a1                                         ....

00000307 <cmd_34_name>:
     307:	47 45 54 44 45 43 41 59 00 00                       GETDECAY..

00000311 <cmd_34_>:
     311:	07 03 01 a2                                         ....

00000315 <cmd_35_name>:
     315:	53 45 54 44 45 43 41 59 00 00                       SETDECAY..

0000031f <cmd_35_>:
     31f:	15 03 02 a3                                         ....

00000323 <cmd_36_name>:
     323:	49 53 43 4f 4e 00 00                                ISCON..

0000032a <cmd_36_>:
     32a:	23 03 01 a4                                         #...

0000032e <commandList>:
     32e:	1a 01 24 01 2f 01 39 01 46 01 53 01 60 01 6c 01     ..$./.9.F.S.`.l.
     33e:	78 01 86 01 94 01 a2 01 b1 01 c1 01 d1 01 e3 01     x...............
     34e:	f5 01 05 02 15 02 26 02 37 02 48 02 59 02 6c 02     ......&.7.H.Y.l.
     35e:	7e 02 8b 02 9c 02 ae 02 bf 02 d0 02 e0 02 e9 02     ~...............
     36e:	f6 02 03 03 11 03 1f 03 2a 03                       ........*.

00000378 <disp_0_text>:
     378:	4c 4b 2d 49 6e 73 74 72 75 6d 65 6e 74 73 0a 53     LK-Instruments.S
     388:	4d 43 34 32 34 32 00 00                             MC4242..

00000390 <disp_0_>:
     390:	78 03 00                                            x..

00000393 <disp_1_text>:
     393:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 70 6f 73     Change motor.pos
     3a3:	69 74 69 6f 6e 00 00                                ition..

000003aa <disp_1_>:
     3aa:	93 03 01                                            ...

000003ad <disp_2_text>:
     3ad:	53 65 74 20 73 74 65 70 0a 6d 75 6c 74 69 70 6c     Set step.multipl
     3bd:	69 65 72 00 00                                      ier..

000003c2 <disp_2_>:
     3c2:	ad 03 02                                            ...

000003c5 <disp_3_text>:
     3c5:	43 68 61 6e 67 65 20 73 74 65 70 0a 75 6e 69 74     Change step.unit
	...

000003d7 <disp_3_>:
     3d7:	c5 03 03                                            ...

000003da <disp_4_text>:
     3da:	52 75 6e 20 69 6e 74 65 72 6e 61 6c 0a 70 72 6f     Run internal.pro
     3ea:	67 72 61 6d 00 00                                   gram..

000003f0 <disp_4_>:
     3f0:	da 03 04                                            ...

000003f3 <disp_5_text>:
     3f3:	52 75 6e 20 77 69 74 68 0a 63 6f 6e 73 74 61 6e     Run with.constan
     403:	74 20 73 70 65 65 64 00 00                          t speed..

0000040c <disp_5_>:
     40c:	f3 03 05                                            ...

0000040f <disp_6_text>:
     40f:	44 65 66 69 6e 65 20 7a 65 72 6f 0a 70 6f 73 69     Define zero.posi
     41f:	74 69 6f 6e 00 00                                   tion..

00000425 <disp_6_>:
     425:	0f 04 06                                            ...

00000428 <disp_7_text>:
     428:	52 75 6e 20 7a 65 72 6f 0a 63 61 6c 69 62 72 61     Run zero.calibra
     438:	74 69 6f 6e 00 00                                   tion..

0000043e <disp_7_>:
     43e:	28 04 07                                            (..

00000441 <disp_8_text>:
     441:	45 6e 74 65 72 0a 73 65 74 74 69 6e 67 73 20 6d     Enter.settings m
     451:	65 6e 75 00 00                                      enu..

00000456 <disp_8_>:
     456:	41 04 08                                            A..

00000459 <disp_9_text>:
     459:	20 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20                     
     469:	0a 20 20 20 20 20 20 20 20 20 20 20 20 20 20 20     .               
     479:	20 00 00                                             ..

0000047c <disp_9_>:
     47c:	59 04 09                                            Y..

0000047f <disp_10_text>:
     47f:	53 65 74 20 6d 6f 74 6f 72 0a 67 65 61 72 20 72     Set motor.gear r
     48f:	61 74 69 6f 00 00                                   atio..

00000495 <disp_10_>:
     495:	7f 04 0a                                            ...

00000498 <disp_11_text>:
     498:	53 65 74 20 73 74 65 70 73 20 70 65 72 0a 66 75     Set steps per.fu
     4a8:	6c 6c 20 72 6f 74 61 74 69 6f 6e 00 00              ll rotation..

000004b5 <disp_11_>:
     4b5:	98 04 0b                                            ...

000004b8 <disp_12_text>:
     4b8:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 73 75 62     Change motor.sub
     4c8:	73 74 65 70 00 00                                   step..

000004ce <disp_12_>:
     4ce:	b8 04 0c                                            ...

000004d1 <disp_13_text>:
     4d1:	43 68 61 6e 67 65 20 6d 6f 74 6f 72 0a 63 75 72     Change motor.cur
     4e1:	72 65 6e 74 00 00                                   rent..

000004e7 <disp_13_>:
     4e7:	d1 04 0d                                            ...

000004ea <disp_14_text>:
     4ea:	53 65 74 20 63 75 72 72 65 6e 74 0a 64 65 63 61     Set current.deca
     4fa:	79 20 6d 6f 64 65 00 00                             y mode..

00000502 <disp_14_>:
     502:	ea 04 0e                                            ...

00000505 <disp_15_text>:
     505:	43 68 61 6e 67 65 20 73 74 65 70 0a 77 61 69 74     Change step.wait
     515:	20 74 69 6d 65 00 00                                 time..

0000051c <disp_15_>:
     51c:	05 05 0f                                            ...

0000051f <disp_16_text>:
     51f:	53 61 76 65 20 63 75 72 72 65 6e 74 0a 63 6f 6e     Save current.con
     52f:	66 69 67 75 72 61 74 69 6f 6e 00 00                 figuration..

0000053b <disp_16_>:
     53b:	1f 05 10                                            ...

0000053e <disp_17_text>:
     53e:	4c 6f 61 64 20 6c 61 73 74 0a 63 6f 6e 66 69 67     Load last.config
     54e:	75 72 61 74 69 6f 6e 00 00                          uration..

00000557 <disp_17_>:
     557:	3e 05 11                                            >..

0000055a <menuList>:
     55a:	90 03 aa 03 c2 03 d7 03 f0 03 0c 04 25 04 3e 04     ............%.>.
     56a:	56 04 7c 04 95 04 b5 04 ce 04 e7 04 02 05 1c 05     V.|.............
     57a:	3b 05 57 05                                         ;.W.

0000057e <__c.1790>:
     57e:	6e 61 6e 00                                         nan.

00000582 <__c.1788>:
     582:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     592:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     5a2:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     5b2:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     5c2:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     5d2:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     5e2:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     5f2:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     602:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     612:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     622:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     632:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     642:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     652:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     662:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     672:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000680 <pstr_inf>:
     680:	49 4e 46                                            INF

00000683 <pstr_inity>:
     683:	49 4e 49 54 59                                      INITY

00000688 <pstr_nan>:
     688:	4e 41 4e                                            NAN

0000068b <pwr_m10>:
     68b:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     69b:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

000006a3 <pwr_p10>:
     6a3:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     6b3:	ca 1b 0e 5a ae c5 9d 74 00                          ...Z...t.

000006bc <__ctors_end>:
     6bc:	11 24       	eor	r1, r1
     6be:	1f be       	out	0x3f, r1	; 63
     6c0:	cf ef       	ldi	r28, 0xFF	; 255
     6c2:	d0 e4       	ldi	r29, 0x40	; 64
     6c4:	de bf       	out	0x3e, r29	; 62
     6c6:	cd bf       	out	0x3d, r28	; 61

000006c8 <__do_copy_data>:
     6c8:	13 e0       	ldi	r17, 0x03	; 3
     6ca:	a0 e0       	ldi	r26, 0x00	; 0
     6cc:	b1 e0       	ldi	r27, 0x01	; 1
     6ce:	e6 e5       	ldi	r30, 0x56	; 86
     6d0:	f8 e9       	ldi	r31, 0x98	; 152
     6d2:	00 e0       	ldi	r16, 0x00	; 0
     6d4:	0b bf       	out	0x3b, r16	; 59
     6d6:	02 c0       	rjmp	.+4      	; 0x6dc <__do_copy_data+0x14>
     6d8:	07 90       	elpm	r0, Z+
     6da:	0d 92       	st	X+, r0
     6dc:	a4 30       	cpi	r26, 0x04	; 4
     6de:	b1 07       	cpc	r27, r17
     6e0:	d9 f7       	brne	.-10     	; 0x6d8 <__do_copy_data+0x10>

000006e2 <__do_clear_bss>:
     6e2:	14 e0       	ldi	r17, 0x04	; 4
     6e4:	a4 e0       	ldi	r26, 0x04	; 4
     6e6:	b3 e0       	ldi	r27, 0x03	; 3
     6e8:	01 c0       	rjmp	.+2      	; 0x6ec <.do_clear_bss_start>

000006ea <.do_clear_bss_loop>:
     6ea:	1d 92       	st	X+, r1

000006ec <.do_clear_bss_start>:
     6ec:	ac 3c       	cpi	r26, 0xCC	; 204
     6ee:	b1 07       	cpc	r27, r17
     6f0:	e1 f7       	brne	.-8      	; 0x6ea <.do_clear_bss_loop>
     6f2:	0e 94 31 39 	call	0x7262	; 0x7262 <main>
     6f6:	0c 94 29 4c 	jmp	0x9852	; 0x9852 <_exit>

000006fa <__bad_interrupt>:
     6fa:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000006fe <initDataStructs>:
====================================================================== */

/* ---------------------------------------------------------------------
    initialize the internal data memory
 --------------------------------------------------------------------- */
void initDataStructs(void){
     6fe:	2f 92       	push	r2
     700:	3f 92       	push	r3
     702:	4f 92       	push	r4
     704:	5f 92       	push	r5
     706:	6f 92       	push	r6
     708:	7f 92       	push	r7
     70a:	8f 92       	push	r8
     70c:	9f 92       	push	r9
     70e:	af 92       	push	r10
     710:	bf 92       	push	r11
     712:	cf 92       	push	r12
     714:	df 92       	push	r13
     716:	ef 92       	push	r14
     718:	ff 92       	push	r15
     71a:	0f 93       	push	r16
     71c:	1f 93       	push	r17
     71e:	40 e0       	ldi	r20, 0x00	; 0
     720:	50 e0       	ldi	r21, 0x00	; 0

  for(i = 0; i <= MAX_MOTOR; i++){
    motor[i].actualPosition       = 0;
    motor[i].desiredPosition      = 0;
    motor[i].opticalZeroPosition  = 0;
    motor[i].stepError            = 0.0f;
     722:	0f 2e       	mov	r0, r31
     724:	f0 e0       	ldi	r31, 0x00	; 0
     726:	6f 2e       	mov	r6, r31
     728:	f0 e0       	ldi	r31, 0x00	; 0
     72a:	7f 2e       	mov	r7, r31
     72c:	f0 e0       	ldi	r31, 0x00	; 0
     72e:	8f 2e       	mov	r8, r31
     730:	f0 e0       	ldi	r31, 0x00	; 0
     732:	9f 2e       	mov	r9, r31
     734:	f0 2d       	mov	r31, r0
    motor[i].isMoving             = 0;
    motor[i].isTurnedOn           = 0;
    motor[i].isMovingInfinite     = MOTOR_MOVE_INFINITE_STOP;
    motor[i].gearRatio            = 60.0f/20.0f; /* TODO */
     736:	0f 2e       	mov	r0, r31
     738:	f0 e0       	ldi	r31, 0x00	; 0
     73a:	2f 2e       	mov	r2, r31
     73c:	f0 e0       	ldi	r31, 0x00	; 0
     73e:	3f 2e       	mov	r3, r31
     740:	f0 e4       	ldi	r31, 0x40	; 64
     742:	4f 2e       	mov	r4, r31
     744:	f0 e4       	ldi	r31, 0x40	; 64
     746:	5f 2e       	mov	r5, r31
     748:	f0 2d       	mov	r31, r0
    motor[i].stepsPerFullRotation = 400.0f;
    motor[i].subSteps             = 4.0f;
     74a:	0f 2e       	mov	r0, r31
     74c:	f0 e0       	ldi	r31, 0x00	; 0
     74e:	af 2e       	mov	r10, r31
     750:	f0 e0       	ldi	r31, 0x00	; 0
     752:	bf 2e       	mov	r11, r31
     754:	f0 e8       	ldi	r31, 0x80	; 128
     756:	cf 2e       	mov	r12, r31
     758:	f0 e4       	ldi	r31, 0x40	; 64
     75a:	df 2e       	mov	r13, r31
     75c:	f0 2d       	mov	r31, r0
    motor[i].stepMultiplier       = 1.0f;
     75e:	0f 2e       	mov	r0, r31
     760:	f0 e0       	ldi	r31, 0x00	; 0
     762:	ef 2e       	mov	r14, r31
     764:	f0 e0       	ldi	r31, 0x00	; 0
     766:	ff 2e       	mov	r15, r31
     768:	f0 e8       	ldi	r31, 0x80	; 128
     76a:	0f 2f       	mov	r16, r31
     76c:	ff e3       	ldi	r31, 0x3F	; 63
     76e:	1f 2f       	mov	r17, r31
     770:	f0 2d       	mov	r31, r0
    motor[i].stepUnit             = MOTOR_STEP_UNIT_DEGREE;
    motor[i].waitBetweenSteps     = 3;
     772:	63 e0       	ldi	r22, 0x03	; 3
     774:	70 e0       	ldi	r23, 0x00	; 0
void initDataStructs(void){

  uint8_t i, j;

  for(i = 0; i <= MAX_MOTOR; i++){
    motor[i].actualPosition       = 0;
     776:	fa 01       	movw	r30, r20
     778:	ee 0f       	add	r30, r30
     77a:	ff 1f       	adc	r31, r31
     77c:	ee 0f       	add	r30, r30
     77e:	ff 1f       	adc	r31, r31
     780:	ee 0f       	add	r30, r30
     782:	ff 1f       	adc	r31, r31
     784:	cf 01       	movw	r24, r30
     786:	88 0f       	add	r24, r24
     788:	99 1f       	adc	r25, r25
     78a:	88 0f       	add	r24, r24
     78c:	99 1f       	adc	r25, r25
     78e:	e8 0f       	add	r30, r24
     790:	f9 1f       	adc	r31, r25
     792:	e2 5e       	subi	r30, 0xE2	; 226
     794:	fb 4f       	sbci	r31, 0xFB	; 251
     796:	11 82       	std	Z+1, r1	; 0x01
     798:	10 82       	st	Z, r1
    motor[i].desiredPosition      = 0;
     79a:	fa 01       	movw	r30, r20
     79c:	ee 0f       	add	r30, r30
     79e:	ff 1f       	adc	r31, r31
     7a0:	ee 0f       	add	r30, r30
     7a2:	ff 1f       	adc	r31, r31
     7a4:	cf 01       	movw	r24, r30
     7a6:	88 0f       	add	r24, r24
     7a8:	99 1f       	adc	r25, r25
     7aa:	88 0f       	add	r24, r24
     7ac:	99 1f       	adc	r25, r25
     7ae:	e8 0f       	add	r30, r24
     7b0:	f9 1f       	adc	r31, r25
     7b2:	ee 0f       	add	r30, r30
     7b4:	ff 1f       	adc	r31, r31
     7b6:	e0 5e       	subi	r30, 0xE0	; 224
     7b8:	fb 4f       	sbci	r31, 0xFB	; 251
     7ba:	11 82       	std	Z+1, r1	; 0x01
     7bc:	10 82       	st	Z, r1
    motor[i].opticalZeroPosition  = 0;
     7be:	ca 01       	movw	r24, r20
     7c0:	fa 01       	movw	r30, r20
     7c2:	ee 0f       	add	r30, r30
     7c4:	ff 1f       	adc	r31, r31
     7c6:	ee 0f       	add	r30, r30
     7c8:	ff 1f       	adc	r31, r31
     7ca:	ee 0f       	add	r30, r30
     7cc:	ff 1f       	adc	r31, r31
     7ce:	88 0f       	add	r24, r24
     7d0:	99 1f       	adc	r25, r25
     7d2:	e8 0f       	add	r30, r24
     7d4:	f9 1f       	adc	r31, r25
     7d6:	ee 0f       	add	r30, r30
     7d8:	ff 1f       	adc	r31, r31
     7da:	ee 0f       	add	r30, r30
     7dc:	ff 1f       	adc	r31, r31
     7de:	ee 5d       	subi	r30, 0xDE	; 222
     7e0:	fb 4f       	sbci	r31, 0xFB	; 251
     7e2:	11 82       	std	Z+1, r1	; 0x01
     7e4:	10 82       	st	Z, r1
    motor[i].stepError            = 0.0f;
     7e6:	fa 01       	movw	r30, r20
     7e8:	ee 0f       	add	r30, r30
     7ea:	ff 1f       	adc	r31, r31
     7ec:	ee 0f       	add	r30, r30
     7ee:	ff 1f       	adc	r31, r31
     7f0:	ee 0f       	add	r30, r30
     7f2:	ff 1f       	adc	r31, r31
     7f4:	cf 01       	movw	r24, r30
     7f6:	88 0f       	add	r24, r24
     7f8:	99 1f       	adc	r25, r25
     7fa:	88 0f       	add	r24, r24
     7fc:	99 1f       	adc	r25, r25
     7fe:	e8 0f       	add	r30, r24
     800:	f9 1f       	adc	r31, r25
     802:	e2 5e       	subi	r30, 0xE2	; 226
     804:	fb 4f       	sbci	r31, 0xFB	; 251
     806:	66 82       	std	Z+6, r6	; 0x06
     808:	77 82       	std	Z+7, r7	; 0x07
     80a:	80 86       	std	Z+8, r8	; 0x08
     80c:	91 86       	std	Z+9, r9	; 0x09
    motor[i].isMoving             = 0;
     80e:	fa 01       	movw	r30, r20
     810:	ee 0f       	add	r30, r30
     812:	ff 1f       	adc	r31, r31
     814:	ee 0f       	add	r30, r30
     816:	ff 1f       	adc	r31, r31
     818:	ee 0f       	add	r30, r30
     81a:	ff 1f       	adc	r31, r31
     81c:	cf 01       	movw	r24, r30
     81e:	88 0f       	add	r24, r24
     820:	99 1f       	adc	r25, r25
     822:	88 0f       	add	r24, r24
     824:	99 1f       	adc	r25, r25
     826:	e8 0f       	add	r30, r24
     828:	f9 1f       	adc	r31, r25
     82a:	e2 5e       	subi	r30, 0xE2	; 226
     82c:	fb 4f       	sbci	r31, 0xFB	; 251
     82e:	12 86       	std	Z+10, r1	; 0x0a
    motor[i].isTurnedOn           = 0;
     830:	fa 01       	movw	r30, r20
     832:	ee 0f       	add	r30, r30
     834:	ff 1f       	adc	r31, r31
     836:	ee 0f       	add	r30, r30
     838:	ff 1f       	adc	r31, r31
     83a:	ee 0f       	add	r30, r30
     83c:	ff 1f       	adc	r31, r31
     83e:	cf 01       	movw	r24, r30
     840:	88 0f       	add	r24, r24
     842:	99 1f       	adc	r25, r25
     844:	88 0f       	add	r24, r24
     846:	99 1f       	adc	r25, r25
     848:	e8 0f       	add	r30, r24
     84a:	f9 1f       	adc	r31, r25
     84c:	e2 5e       	subi	r30, 0xE2	; 226
     84e:	fb 4f       	sbci	r31, 0xFB	; 251
     850:	13 86       	std	Z+11, r1	; 0x0b
    motor[i].isMovingInfinite     = MOTOR_MOVE_INFINITE_STOP;
     852:	fa 01       	movw	r30, r20
     854:	ee 0f       	add	r30, r30
     856:	ff 1f       	adc	r31, r31
     858:	ee 0f       	add	r30, r30
     85a:	ff 1f       	adc	r31, r31
     85c:	ee 0f       	add	r30, r30
     85e:	ff 1f       	adc	r31, r31
     860:	cf 01       	movw	r24, r30
     862:	88 0f       	add	r24, r24
     864:	99 1f       	adc	r25, r25
     866:	88 0f       	add	r24, r24
     868:	99 1f       	adc	r25, r25
     86a:	e8 0f       	add	r30, r24
     86c:	f9 1f       	adc	r31, r25
     86e:	e2 5e       	subi	r30, 0xE2	; 226
     870:	fb 4f       	sbci	r31, 0xFB	; 251
     872:	14 86       	std	Z+12, r1	; 0x0c
    motor[i].gearRatio            = 60.0f/20.0f; /* TODO */
     874:	fa 01       	movw	r30, r20
     876:	ee 0f       	add	r30, r30
     878:	ff 1f       	adc	r31, r31
     87a:	ee 0f       	add	r30, r30
     87c:	ff 1f       	adc	r31, r31
     87e:	ee 0f       	add	r30, r30
     880:	ff 1f       	adc	r31, r31
     882:	cf 01       	movw	r24, r30
     884:	88 0f       	add	r24, r24
     886:	99 1f       	adc	r25, r25
     888:	88 0f       	add	r24, r24
     88a:	99 1f       	adc	r25, r25
     88c:	e8 0f       	add	r30, r24
     88e:	f9 1f       	adc	r31, r25
     890:	e2 5e       	subi	r30, 0xE2	; 226
     892:	fb 4f       	sbci	r31, 0xFB	; 251
     894:	25 86       	std	Z+13, r2	; 0x0d
     896:	36 86       	std	Z+14, r3	; 0x0e
     898:	47 86       	std	Z+15, r4	; 0x0f
     89a:	50 8a       	std	Z+16, r5	; 0x10
    motor[i].stepsPerFullRotation = 400.0f;
     89c:	fa 01       	movw	r30, r20
     89e:	ee 0f       	add	r30, r30
     8a0:	ff 1f       	adc	r31, r31
     8a2:	ee 0f       	add	r30, r30
     8a4:	ff 1f       	adc	r31, r31
     8a6:	ee 0f       	add	r30, r30
     8a8:	ff 1f       	adc	r31, r31
     8aa:	cf 01       	movw	r24, r30
     8ac:	88 0f       	add	r24, r24
     8ae:	99 1f       	adc	r25, r25
     8b0:	88 0f       	add	r24, r24
     8b2:	99 1f       	adc	r25, r25
     8b4:	e8 0f       	add	r30, r24
     8b6:	f9 1f       	adc	r31, r25
     8b8:	e2 5e       	subi	r30, 0xE2	; 226
     8ba:	fb 4f       	sbci	r31, 0xFB	; 251
     8bc:	80 e0       	ldi	r24, 0x00	; 0
     8be:	90 e0       	ldi	r25, 0x00	; 0
     8c0:	a8 ec       	ldi	r26, 0xC8	; 200
     8c2:	b3 e4       	ldi	r27, 0x43	; 67
     8c4:	81 8b       	std	Z+17, r24	; 0x11
     8c6:	92 8b       	std	Z+18, r25	; 0x12
     8c8:	a3 8b       	std	Z+19, r26	; 0x13
     8ca:	b4 8b       	std	Z+20, r27	; 0x14
    motor[i].subSteps             = 4.0f;
     8cc:	fa 01       	movw	r30, r20
     8ce:	ee 0f       	add	r30, r30
     8d0:	ff 1f       	adc	r31, r31
     8d2:	ee 0f       	add	r30, r30
     8d4:	ff 1f       	adc	r31, r31
     8d6:	ee 0f       	add	r30, r30
     8d8:	ff 1f       	adc	r31, r31
     8da:	cf 01       	movw	r24, r30
     8dc:	88 0f       	add	r24, r24
     8de:	99 1f       	adc	r25, r25
     8e0:	88 0f       	add	r24, r24
     8e2:	99 1f       	adc	r25, r25
     8e4:	e8 0f       	add	r30, r24
     8e6:	f9 1f       	adc	r31, r25
     8e8:	e2 5e       	subi	r30, 0xE2	; 226
     8ea:	fb 4f       	sbci	r31, 0xFB	; 251
     8ec:	a5 8a       	std	Z+21, r10	; 0x15
     8ee:	b6 8a       	std	Z+22, r11	; 0x16
     8f0:	c7 8a       	std	Z+23, r12	; 0x17
     8f2:	d0 8e       	std	Z+24, r13	; 0x18
    motor[i].stepMultiplier       = 1.0f;
     8f4:	fa 01       	movw	r30, r20
     8f6:	ee 0f       	add	r30, r30
     8f8:	ff 1f       	adc	r31, r31
     8fa:	ee 0f       	add	r30, r30
     8fc:	ff 1f       	adc	r31, r31
     8fe:	ee 0f       	add	r30, r30
     900:	ff 1f       	adc	r31, r31
     902:	cf 01       	movw	r24, r30
     904:	88 0f       	add	r24, r24
     906:	99 1f       	adc	r25, r25
     908:	88 0f       	add	r24, r24
     90a:	99 1f       	adc	r25, r25
     90c:	e8 0f       	add	r30, r24
     90e:	f9 1f       	adc	r31, r25
     910:	e2 5e       	subi	r30, 0xE2	; 226
     912:	fb 4f       	sbci	r31, 0xFB	; 251
     914:	e2 8e       	std	Z+26, r14	; 0x1a
     916:	f3 8e       	std	Z+27, r15	; 0x1b
     918:	04 8f       	std	Z+28, r16	; 0x1c
     91a:	15 8f       	std	Z+29, r17	; 0x1d
    motor[i].stepUnit             = MOTOR_STEP_UNIT_DEGREE;
     91c:	fa 01       	movw	r30, r20
     91e:	ee 0f       	add	r30, r30
     920:	ff 1f       	adc	r31, r31
     922:	ee 0f       	add	r30, r30
     924:	ff 1f       	adc	r31, r31
     926:	ee 0f       	add	r30, r30
     928:	ff 1f       	adc	r31, r31
     92a:	cf 01       	movw	r24, r30
     92c:	88 0f       	add	r24, r24
     92e:	99 1f       	adc	r25, r25
     930:	88 0f       	add	r24, r24
     932:	99 1f       	adc	r25, r25
     934:	e8 0f       	add	r30, r24
     936:	f9 1f       	adc	r31, r25
     938:	e2 5e       	subi	r30, 0xE2	; 226
     93a:	fb 4f       	sbci	r31, 0xFB	; 251
     93c:	91 e0       	ldi	r25, 0x01	; 1
     93e:	91 8f       	std	Z+25, r25	; 0x19
    motor[i].waitBetweenSteps     = 3;
     940:	fa 01       	movw	r30, r20
     942:	ee 0f       	add	r30, r30
     944:	ff 1f       	adc	r31, r31
     946:	ee 0f       	add	r30, r30
     948:	ff 1f       	adc	r31, r31
     94a:	ee 0f       	add	r30, r30
     94c:	ff 1f       	adc	r31, r31
     94e:	cf 01       	movw	r24, r30
     950:	88 0f       	add	r24, r24
     952:	99 1f       	adc	r25, r25
     954:	88 0f       	add	r24, r24
     956:	99 1f       	adc	r25, r25
     958:	e8 0f       	add	r30, r24
     95a:	f9 1f       	adc	r31, r25
     95c:	e2 5e       	subi	r30, 0xE2	; 226
     95e:	fb 4f       	sbci	r31, 0xFB	; 251
     960:	77 8f       	std	Z+31, r23	; 0x1f
     962:	66 8f       	std	Z+30, r22	; 0x1e
    motor[i].delayCounter         = 2*motor[i].waitBetweenSteps-1;
     964:	fa 01       	movw	r30, r20
     966:	ee 0f       	add	r30, r30
     968:	ff 1f       	adc	r31, r31
     96a:	ee 0f       	add	r30, r30
     96c:	ff 1f       	adc	r31, r31
     96e:	ee 0f       	add	r30, r30
     970:	ff 1f       	adc	r31, r31
     972:	cf 01       	movw	r24, r30
     974:	88 0f       	add	r24, r24
     976:	99 1f       	adc	r25, r25
     978:	88 0f       	add	r24, r24
     97a:	99 1f       	adc	r25, r25
     97c:	e8 0f       	add	r30, r24
     97e:	f9 1f       	adc	r31, r25
     980:	e2 5e       	subi	r30, 0xE2	; 226
     982:	fb 4f       	sbci	r31, 0xFB	; 251
     984:	26 8d       	ldd	r18, Z+30	; 0x1e
     986:	37 8d       	ldd	r19, Z+31	; 0x1f
     988:	22 0f       	add	r18, r18
     98a:	33 1f       	adc	r19, r19
     98c:	21 50       	subi	r18, 0x01	; 1
     98e:	30 40       	sbci	r19, 0x00	; 0
     990:	fa 01       	movw	r30, r20
     992:	ee 0f       	add	r30, r30
     994:	ff 1f       	adc	r31, r31
     996:	ee 0f       	add	r30, r30
     998:	ff 1f       	adc	r31, r31
     99a:	ee 0f       	add	r30, r30
     99c:	ff 1f       	adc	r31, r31
     99e:	cf 01       	movw	r24, r30
     9a0:	88 0f       	add	r24, r24
     9a2:	99 1f       	adc	r25, r25
     9a4:	88 0f       	add	r24, r24
     9a6:	99 1f       	adc	r25, r25
     9a8:	e8 0f       	add	r30, r24
     9aa:	f9 1f       	adc	r31, r25
     9ac:	e2 5e       	subi	r30, 0xE2	; 226
     9ae:	fb 4f       	sbci	r31, 0xFB	; 251
     9b0:	31 a3       	std	Z+33, r19	; 0x21
     9b2:	20 a3       	std	Z+32, r18	; 0x20
    motor[i].angularVelocity      = OFF;
     9b4:	fa 01       	movw	r30, r20
     9b6:	ee 0f       	add	r30, r30
     9b8:	ff 1f       	adc	r31, r31
     9ba:	ee 0f       	add	r30, r30
     9bc:	ff 1f       	adc	r31, r31
     9be:	ee 0f       	add	r30, r30
     9c0:	ff 1f       	adc	r31, r31
     9c2:	cf 01       	movw	r24, r30
     9c4:	88 0f       	add	r24, r24
     9c6:	99 1f       	adc	r25, r25
     9c8:	88 0f       	add	r24, r24
     9ca:	99 1f       	adc	r25, r25
     9cc:	e8 0f       	add	r30, r24
     9ce:	f9 1f       	adc	r31, r25
     9d0:	e2 5e       	subi	r30, 0xE2	; 226
     9d2:	fb 4f       	sbci	r31, 0xFB	; 251
     9d4:	12 a2       	std	Z+34, r1	; 0x22
    motor[i].current              = 1.0;
     9d6:	fa 01       	movw	r30, r20
     9d8:	ee 0f       	add	r30, r30
     9da:	ff 1f       	adc	r31, r31
     9dc:	ee 0f       	add	r30, r30
     9de:	ff 1f       	adc	r31, r31
     9e0:	ee 0f       	add	r30, r30
     9e2:	ff 1f       	adc	r31, r31
     9e4:	cf 01       	movw	r24, r30
     9e6:	88 0f       	add	r24, r24
     9e8:	99 1f       	adc	r25, r25
     9ea:	88 0f       	add	r24, r24
     9ec:	99 1f       	adc	r25, r25
     9ee:	e8 0f       	add	r30, r24
     9f0:	f9 1f       	adc	r31, r25
     9f2:	e2 5e       	subi	r30, 0xE2	; 226
     9f4:	fb 4f       	sbci	r31, 0xFB	; 251
     9f6:	e3 a2       	std	Z+35, r14	; 0x23
     9f8:	f4 a2       	std	Z+36, r15	; 0x24
     9fa:	05 a3       	std	Z+37, r16	; 0x25
     9fc:	16 a3       	std	Z+38, r17	; 0x26
    motor[i].decay                = 0;
     9fe:	fa 01       	movw	r30, r20
     a00:	ee 0f       	add	r30, r30
     a02:	ff 1f       	adc	r31, r31
     a04:	ee 0f       	add	r30, r30
     a06:	ff 1f       	adc	r31, r31
     a08:	ee 0f       	add	r30, r30
     a0a:	ff 1f       	adc	r31, r31
     a0c:	cf 01       	movw	r24, r30
     a0e:	88 0f       	add	r24, r24
     a10:	99 1f       	adc	r25, r25
     a12:	88 0f       	add	r24, r24
     a14:	99 1f       	adc	r25, r25
     a16:	e8 0f       	add	r30, r24
     a18:	f9 1f       	adc	r31, r25
     a1a:	e2 5e       	subi	r30, 0xE2	; 226
     a1c:	fb 4f       	sbci	r31, 0xFB	; 251
     a1e:	17 a2       	std	Z+39, r1	; 0x27
     a20:	4f 5f       	subi	r20, 0xFF	; 255
     a22:	5f 4f       	sbci	r21, 0xFF	; 255
 --------------------------------------------------------------------- */
void initDataStructs(void){

  uint8_t i, j;

  for(i = 0; i <= MAX_MOTOR; i++){
     a24:	44 30       	cpi	r20, 0x04	; 4
     a26:	51 05       	cpc	r21, r1
     a28:	09 f0       	breq	.+2      	; 0xa2c <initDataStructs+0x32e>
     a2a:	a5 ce       	rjmp	.-694    	; 0x776 <initDataStructs+0x78>
    motor[i].angularVelocity      = OFF;
    motor[i].current              = 1.0;
    motor[i].decay                = 0;
  }

  rxString.charCount = 0;
     a2c:	10 92 1f 03 	sts	0x031F, r1
  rxString.readyToProcess = 0;
     a30:	10 92 1e 03 	sts	0x031E, r1

  txString.charCount = 0;
     a34:	10 92 18 04 	sts	0x0418, r1
  txString.readyToProcess = 0;
     a38:	10 92 17 04 	sts	0x0417, r1

  status.status = 0;
     a3c:	10 92 c3 04 	sts	0x04C3, r1
  status.inRemoteMode = 0;
     a40:	10 92 c4 04 	sts	0x04C4, r1

  adc.ADCvalue = 0;
     a44:	10 92 fa 03 	sts	0x03FA, r1
     a48:	10 92 f9 03 	sts	0x03F9, r1
  adc.numberOfMeasurements = 8;
     a4c:	88 e0       	ldi	r24, 0x08	; 8
     a4e:	80 93 fb 03 	sts	0x03FB, r24

  menu.newDisplayedMenu = MENU_MAIN;
     a52:	10 92 0d 03 	sts	0x030D, r1
  menu.currentDisplayedMenu = 42;
     a56:	9a e2       	ldi	r25, 0x2A	; 42
     a58:	90 93 0e 03 	sts	0x030E, r25
  menu.newMenuMode = MENU_SCROLL_MODE;
     a5c:	82 e0       	ldi	r24, 0x02	; 2
     a5e:	80 93 0f 03 	sts	0x030F, r24
  menu.fastMovingMode = OFF;
     a62:	10 92 10 03 	sts	0x0310, r1
  menu.currentProgramStep = 0;
     a66:	10 92 11 03 	sts	0x0311, r1
  menu.currentMenuMode = 42;
     a6a:	90 93 12 03 	sts	0x0312, r25
  menu.selectedMotor = NO_MOTOR|(1<<DUMMY_MOTOR);  /* DUMMY_MOTOR stays always selected */
     a6e:	80 e1       	ldi	r24, 0x10	; 16
     a70:	80 93 13 03 	sts	0x0313, r24
  /* strings are initialized in main */

  buttonState.inputRegister = 0;
     a74:	10 92 0a 03 	sts	0x030A, r1
  buttonState.inDebouncingMode = 0;
     a78:	10 92 0b 03 	sts	0x030B, r1
  buttonState.readyToProcess = 0;
     a7c:	10 92 0c 03 	sts	0x030C, r1

  rotEnc.direction = NO_MOVE;
     a80:	10 92 fc 03 	sts	0x03FC, r1
  rotEnc.steps = 0;
     a84:	10 92 fd 03 	sts	0x03FD, r1
  rotEnc.readyToProcess = 0;
     a88:	10 92 fe 03 	sts	0x03FE, r1
  rotEnc.buttonPressed = 0;
     a8c:	10 92 ff 03 	sts	0x03FF, r1
  rotEnc.buttonDebounce = 0;
     a90:	10 92 00 04 	sts	0x0400, r1

  IIC.operationInProgress = 0;
     a94:	10 92 1d 04 	sts	0x041D, r1

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     a98:	10 92 05 04 	sts	0x0405, r1
    forbiddenZone[i].start  = 0;
     a9c:	10 92 02 04 	sts	0x0402, r1
     aa0:	10 92 01 04 	sts	0x0401, r1
    forbiddenZone[i].stop   = 0;
     aa4:	10 92 04 04 	sts	0x0404, r1
     aa8:	10 92 03 04 	sts	0x0403, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     aac:	10 92 0a 04 	sts	0x040A, r1
    forbiddenZone[i].start  = 0;
     ab0:	10 92 07 04 	sts	0x0407, r1
     ab4:	10 92 06 04 	sts	0x0406, r1
    forbiddenZone[i].stop   = 0;
     ab8:	10 92 09 04 	sts	0x0409, r1
     abc:	10 92 08 04 	sts	0x0408, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     ac0:	10 92 0f 04 	sts	0x040F, r1
    forbiddenZone[i].start  = 0;
     ac4:	10 92 0c 04 	sts	0x040C, r1
     ac8:	10 92 0b 04 	sts	0x040B, r1
    forbiddenZone[i].stop   = 0;
     acc:	10 92 0e 04 	sts	0x040E, r1
     ad0:	10 92 0d 04 	sts	0x040D, r1
  rotEnc.buttonDebounce = 0;

  IIC.operationInProgress = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    forbiddenZone[i].active = 0;
     ad4:	10 92 14 04 	sts	0x0414, r1
    forbiddenZone[i].start  = 0;
     ad8:	10 92 11 04 	sts	0x0411, r1
     adc:	10 92 10 04 	sts	0x0410, r1
    forbiddenZone[i].stop   = 0;
     ae0:	10 92 13 04 	sts	0x0413, r1
     ae4:	10 92 12 04 	sts	0x0412, r1
     ae8:	20 e0       	ldi	r18, 0x00	; 0
     aea:	30 e0       	ldi	r19, 0x00	; 0
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    programList[i].isActive = 0;
    programList[i].absRel = PROG_RELATIVE_MOVEMENT;
     aec:	41 e0       	ldi	r20, 0x01	; 1
    forbiddenZone[i].stop   = 0;
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    programList[i].isActive = 0;
     aee:	c9 01       	movw	r24, r18
     af0:	f9 01       	movw	r30, r18
     af2:	ee 0f       	add	r30, r30
     af4:	ff 1f       	adc	r31, r31
     af6:	ee 0f       	add	r30, r30
     af8:	ff 1f       	adc	r31, r31
     afa:	ee 0f       	add	r30, r30
     afc:	ff 1f       	adc	r31, r31
     afe:	88 0f       	add	r24, r24
     b00:	99 1f       	adc	r25, r25
     b02:	e8 0f       	add	r30, r24
     b04:	f9 1f       	adc	r31, r25
     b06:	ef 5d       	subi	r30, 0xDF	; 223
     b08:	fc 4f       	sbci	r31, 0xFC	; 252
     b0a:	10 82       	st	Z, r1
    programList[i].absRel = PROG_RELATIVE_MOVEMENT;
     b0c:	c9 01       	movw	r24, r18
     b0e:	f9 01       	movw	r30, r18
     b10:	ee 0f       	add	r30, r30
     b12:	ff 1f       	adc	r31, r31
     b14:	ee 0f       	add	r30, r30
     b16:	ff 1f       	adc	r31, r31
     b18:	ee 0f       	add	r30, r30
     b1a:	ff 1f       	adc	r31, r31
     b1c:	88 0f       	add	r24, r24
     b1e:	99 1f       	adc	r25, r25
     b20:	e8 0f       	add	r30, r24
     b22:	f9 1f       	adc	r31, r25
     b24:	ef 5d       	subi	r30, 0xDF	; 223
     b26:	fc 4f       	sbci	r31, 0xFC	; 252
     b28:	41 87       	std	Z+9, r20	; 0x09
    for(j = 0; j <= MAX_MOTOR; j++){
      programList[i].position[j] = 0;
     b2a:	c9 01       	movw	r24, r18
     b2c:	f9 01       	movw	r30, r18
     b2e:	ee 0f       	add	r30, r30
     b30:	ff 1f       	adc	r31, r31
     b32:	ee 0f       	add	r30, r30
     b34:	ff 1f       	adc	r31, r31
     b36:	ee 0f       	add	r30, r30
     b38:	ff 1f       	adc	r31, r31
     b3a:	88 0f       	add	r24, r24
     b3c:	99 1f       	adc	r25, r25
     b3e:	e8 0f       	add	r30, r24
     b40:	f9 1f       	adc	r31, r25
     b42:	ef 5d       	subi	r30, 0xDF	; 223
     b44:	fc 4f       	sbci	r31, 0xFC	; 252
     b46:	12 82       	std	Z+2, r1	; 0x02
     b48:	11 82       	std	Z+1, r1	; 0x01
     b4a:	c9 01       	movw	r24, r18
     b4c:	f9 01       	movw	r30, r18
     b4e:	ee 0f       	add	r30, r30
     b50:	ff 1f       	adc	r31, r31
     b52:	ee 0f       	add	r30, r30
     b54:	ff 1f       	adc	r31, r31
     b56:	ee 0f       	add	r30, r30
     b58:	ff 1f       	adc	r31, r31
     b5a:	88 0f       	add	r24, r24
     b5c:	99 1f       	adc	r25, r25
     b5e:	e8 0f       	add	r30, r24
     b60:	f9 1f       	adc	r31, r25
     b62:	ef 5d       	subi	r30, 0xDF	; 223
     b64:	fc 4f       	sbci	r31, 0xFC	; 252
     b66:	14 82       	std	Z+4, r1	; 0x04
     b68:	13 82       	std	Z+3, r1	; 0x03
     b6a:	c9 01       	movw	r24, r18
     b6c:	f9 01       	movw	r30, r18
     b6e:	ee 0f       	add	r30, r30
     b70:	ff 1f       	adc	r31, r31
     b72:	ee 0f       	add	r30, r30
     b74:	ff 1f       	adc	r31, r31
     b76:	ee 0f       	add	r30, r30
     b78:	ff 1f       	adc	r31, r31
     b7a:	88 0f       	add	r24, r24
     b7c:	99 1f       	adc	r25, r25
     b7e:	e8 0f       	add	r30, r24
     b80:	f9 1f       	adc	r31, r25
     b82:	ef 5d       	subi	r30, 0xDF	; 223
     b84:	fc 4f       	sbci	r31, 0xFC	; 252
     b86:	16 82       	std	Z+6, r1	; 0x06
     b88:	15 82       	std	Z+5, r1	; 0x05
     b8a:	c9 01       	movw	r24, r18
     b8c:	f9 01       	movw	r30, r18
     b8e:	ee 0f       	add	r30, r30
     b90:	ff 1f       	adc	r31, r31
     b92:	ee 0f       	add	r30, r30
     b94:	ff 1f       	adc	r31, r31
     b96:	ee 0f       	add	r30, r30
     b98:	ff 1f       	adc	r31, r31
     b9a:	88 0f       	add	r24, r24
     b9c:	99 1f       	adc	r25, r25
     b9e:	e8 0f       	add	r30, r24
     ba0:	f9 1f       	adc	r31, r25
     ba2:	ef 5d       	subi	r30, 0xDF	; 223
     ba4:	fc 4f       	sbci	r31, 0xFC	; 252
     ba6:	10 86       	std	Z+8, r1	; 0x08
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	2f 5f       	subi	r18, 0xFF	; 255
     bac:	3f 4f       	sbci	r19, 0xFF	; 255
    forbiddenZone[i].start  = 0;
    forbiddenZone[i].stop   = 0;
  }

  /* initialize program list */
  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
     bae:	20 31       	cpi	r18, 0x10	; 16
     bb0:	31 05       	cpc	r19, r1
     bb2:	09 f0       	breq	.+2      	; 0xbb6 <initDataStructs+0x4b8>
     bb4:	9c cf       	rjmp	.-200    	; 0xaee <initDataStructs+0x3f0>
    for(j = 0; j <= MAX_MOTOR; j++){
      programList[i].position[j] = 0;
    }
  }
  /* define home position on program step 0 */
  programList[0].isActive = 1;
     bb6:	81 e0       	ldi	r24, 0x01	; 1
     bb8:	80 93 21 03 	sts	0x0321, r24

  return;
}
     bbc:	1f 91       	pop	r17
     bbe:	0f 91       	pop	r16
     bc0:	ff 90       	pop	r15
     bc2:	ef 90       	pop	r14
     bc4:	df 90       	pop	r13
     bc6:	cf 90       	pop	r12
     bc8:	bf 90       	pop	r11
     bca:	af 90       	pop	r10
     bcc:	9f 90       	pop	r9
     bce:	8f 90       	pop	r8
     bd0:	7f 90       	pop	r7
     bd2:	6f 90       	pop	r6
     bd4:	5f 90       	pop	r5
     bd6:	4f 90       	pop	r4
     bd8:	3f 90       	pop	r3
     bda:	2f 90       	pop	r2
     bdc:	08 95       	ret

00000bde <initUSART>:
   - 8 bit character size
   - no flow control
  */

  /* set baud rate registers */
  UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
     bde:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = (uint8_t)(UBRR_VALUE & 0xFF);
     be2:	85 e1       	ldi	r24, 0x15	; 21
     be4:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B |= (1<<TXEN0) | (1<<RXEN0)        /* enable RX and TX */
     be8:	e1 ec       	ldi	r30, 0xC1	; 193
     bea:	f0 e0       	ldi	r31, 0x00	; 0
     bec:	80 81       	ld	r24, Z
     bee:	88 69       	ori	r24, 0x98	; 152
     bf0:	80 83       	st	Z, r24
           |(1<<RXCIE0);                   /* enable RX interrupt */

  return;
}
     bf2:	08 95       	ret

00000bf4 <sendChar>:
====================================================================== */

/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){
     bf4:	98 2f       	mov	r25, r24

  while(!(UCSR0A & (1<<UDRE0))){
     bf6:	80 91 c0 00 	lds	r24, 0x00C0
     bfa:	85 ff       	sbrs	r24, 5
     bfc:	fc cf       	rjmp	.-8      	; 0xbf6 <sendChar+0x2>
    ;
  }

  UDR0 = c;
     bfe:	90 93 c6 00 	sts	0x00C6, r25

  return;
}
     c02:	08 95       	ret

00000c04 <initMotorDelayTimer>:

  /*
   * the 8-bit Timer/Counter2 is used for that
   */

  TCCR2A |= (1<<WGM21);   /* enable CTC */
     c04:	e0 eb       	ldi	r30, 0xB0	; 176
     c06:	f0 e0       	ldi	r31, 0x00	; 0
     c08:	80 81       	ld	r24, Z
     c0a:	82 60       	ori	r24, 0x02	; 2
     c0c:	80 83       	st	Z, r24
  OCR2A   = 77;
     c0e:	8d e4       	ldi	r24, 0x4D	; 77
     c10:	80 93 b3 00 	sts	0x00B3, r24
  TIMSK2 |= (1<<OCIE2A);  /* enable interrupt */
     c14:	e0 e7       	ldi	r30, 0x70	; 112
     c16:	f0 e0       	ldi	r31, 0x00	; 0
     c18:	80 81       	ld	r24, Z
     c1a:	82 60       	ori	r24, 0x02	; 2
     c1c:	80 83       	st	Z, r24
  TCNT2   = 0;
     c1e:	10 92 b2 00 	sts	0x00B2, r1

  /* start the timer/counter */
  TCCR2B |= (1<<CS22)|(1<<CS20);  /* prescaler = 1024 --> 51.2 us per clock */
     c22:	e1 eb       	ldi	r30, 0xB1	; 177
     c24:	f0 e0       	ldi	r31, 0x00	; 0
     c26:	80 81       	ld	r24, Z
     c28:	85 60       	ori	r24, 0x05	; 5
     c2a:	80 83       	st	Z, r24

  return;
}
     c2c:	08 95       	ret

00000c2e <moveMotorRelative>:
/* ---------------------------------------------------------------------
    moveMotorBySteps: move motor <steps> steps forward or backward
    This is a relative movement to the actual position.
    NOTE: this function is only used by motorZeroRun()
 --------------------------------------------------------------------- */
void moveMotorRelative(uint8_t mot, int16_t steps){
     c2e:	ff 92       	push	r15
     c30:	0f 93       	push	r16
     c32:	1f 93       	push	r17

  int16_t  i;
  uint16_t j;

  /* set direction */
  if(steps == 0){
     c34:	61 15       	cp	r22, r1
     c36:	71 05       	cpc	r23, r1
     c38:	09 f4       	brne	.+2      	; 0xc3c <moveMotorRelative+0xe>
     c3a:	58 c0       	rjmp	.+176    	; 0xcec <moveMotorRelative+0xbe>
    /* no move */
    return;
  }
  else if(steps < 0){
     c3c:	77 fd       	sbrc	r23, 7
     c3e:	5a c0       	rjmp	.+180    	; 0xcf4 <moveMotorRelative+0xc6>
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
  }
  else{
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
     c40:	42 b1       	in	r20, 0x02	; 2
     c42:	e8 2f       	mov	r30, r24
     c44:	f0 e0       	ldi	r31, 0x00	; 0
     c46:	9f 01       	movw	r18, r30
     c48:	22 0f       	add	r18, r18
     c4a:	33 1f       	adc	r19, r19
     c4c:	2f 5f       	subi	r18, 0xFF	; 255
     c4e:	3f 4f       	sbci	r19, 0xFF	; 255
     c50:	81 e0       	ldi	r24, 0x01	; 1
     c52:	90 e0       	ldi	r25, 0x00	; 0
     c54:	02 c0       	rjmp	.+4      	; 0xc5a <moveMotorRelative+0x2c>
     c56:	88 0f       	add	r24, r24
     c58:	99 1f       	adc	r25, r25
     c5a:	2a 95       	dec	r18
     c5c:	e2 f7       	brpl	.-8      	; 0xc56 <moveMotorRelative+0x28>
     c5e:	80 95       	com	r24
     c60:	84 23       	and	r24, r20
     c62:	82 b9       	out	0x02, r24	; 2
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     c64:	77 fd       	sbrc	r23, 7
     c66:	59 c0       	rjmp	.+178    	; 0xd1a <moveMotorRelative+0xec>
     c68:	16 16       	cp	r1, r22
     c6a:	17 06       	cpc	r1, r23
     c6c:	0c f0       	brlt	.+2      	; 0xc70 <moveMotorRelative+0x42>
     c6e:	3e c0       	rjmp	.+124    	; 0xcec <moveMotorRelative+0xbe>
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
  }
  else{
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
     c70:	ee 0f       	add	r30, r30
     c72:	ff 1f       	adc	r31, r31
     c74:	81 e0       	ldi	r24, 0x01	; 1
     c76:	90 e0       	ldi	r25, 0x00	; 0
     c78:	0e 2e       	mov	r0, r30
     c7a:	02 c0       	rjmp	.+4      	; 0xc80 <moveMotorRelative+0x52>
     c7c:	88 0f       	add	r24, r24
     c7e:	99 1f       	adc	r25, r25
     c80:	0a 94       	dec	r0
     c82:	e2 f7       	brpl	.-8      	; 0xc7c <moveMotorRelative+0x4e>
     c84:	18 2f       	mov	r17, r24
     c86:	08 2f       	mov	r16, r24
     c88:	00 95       	com	r16
     c8a:	a0 e0       	ldi	r26, 0x00	; 0
     c8c:	b0 e0       	ldi	r27, 0x00	; 0
     c8e:	cf 01       	movw	r24, r30
     c90:	88 0f       	add	r24, r24
     c92:	99 1f       	adc	r25, r25
     c94:	88 0f       	add	r24, r24
     c96:	99 1f       	adc	r25, r25
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     c98:	5d e0       	ldi	r21, 0x0D	; 13
     c9a:	f5 2e       	mov	r15, r21
  for (i = 0; i < abs(steps); i++){
    PORTA |= (1 << (2*mot));
    _delay_us(2); /* as specified in datasheet */
    PORTA &= ~(1 << (2*mot));

    for(j = 0; j < motor[mot].waitBetweenSteps; j++){
     c9c:	fc 01       	movw	r30, r24
     c9e:	ee 0f       	add	r30, r30
     ca0:	ff 1f       	adc	r31, r31
     ca2:	ee 0f       	add	r30, r30
     ca4:	ff 1f       	adc	r31, r31
     ca6:	e8 0f       	add	r30, r24
     ca8:	f9 1f       	adc	r31, r25
     caa:	e4 5c       	subi	r30, 0xC4	; 196
     cac:	fb 4f       	sbci	r31, 0xFB	; 251
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     cae:	48 e8       	ldi	r20, 0x88	; 136
     cb0:	53 e1       	ldi	r21, 0x13	; 19
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
    PORTA |= (1 << (2*mot));
     cb2:	82 b1       	in	r24, 0x02	; 2
     cb4:	81 2b       	or	r24, r17
     cb6:	82 b9       	out	0x02, r24	; 2
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     cb8:	8f 2d       	mov	r24, r15
     cba:	8a 95       	dec	r24
     cbc:	f1 f7       	brne	.-4      	; 0xcba <moveMotorRelative+0x8c>
    _delay_us(2); /* as specified in datasheet */
    PORTA &= ~(1 << (2*mot));
     cbe:	82 b1       	in	r24, 0x02	; 2
     cc0:	80 23       	and	r24, r16
     cc2:	82 b9       	out	0x02, r24	; 2

    for(j = 0; j < motor[mot].waitBetweenSteps; j++){
     cc4:	80 81       	ld	r24, Z
     cc6:	91 81       	ldd	r25, Z+1	; 0x01
     cc8:	89 2b       	or	r24, r25
     cca:	61 f0       	breq	.+24     	; 0xce4 <moveMotorRelative+0xb6>
     ccc:	20 e0       	ldi	r18, 0x00	; 0
     cce:	30 e0       	ldi	r19, 0x00	; 0
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
     cd0:	ca 01       	movw	r24, r20
     cd2:	01 97       	sbiw	r24, 0x01	; 1
     cd4:	f1 f7       	brne	.-4      	; 0xcd2 <moveMotorRelative+0xa4>
     cd6:	2f 5f       	subi	r18, 0xFF	; 255
     cd8:	3f 4f       	sbci	r19, 0xFF	; 255
     cda:	80 81       	ld	r24, Z
     cdc:	91 81       	ldd	r25, Z+1	; 0x01
     cde:	28 17       	cp	r18, r24
     ce0:	39 07       	cpc	r19, r25
     ce2:	b0 f3       	brcs	.-20     	; 0xcd0 <moveMotorRelative+0xa2>
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     ce4:	11 96       	adiw	r26, 0x01	; 1
     ce6:	a6 17       	cp	r26, r22
     ce8:	b7 07       	cpc	r27, r23
     cea:	1c f3       	brlt	.-58     	; 0xcb2 <moveMotorRelative+0x84>
      _delay_ms(1);
    }
  }

  return;
}
     cec:	1f 91       	pop	r17
     cee:	0f 91       	pop	r16
     cf0:	ff 90       	pop	r15
     cf2:	08 95       	ret
    /* no move */
    return;
  }
  else if(steps < 0){
    /* move CCW */
    PORTA |= (1 << (2*mot + 1));
     cf4:	42 b1       	in	r20, 0x02	; 2
     cf6:	e8 2f       	mov	r30, r24
     cf8:	f0 e0       	ldi	r31, 0x00	; 0
     cfa:	9f 01       	movw	r18, r30
     cfc:	22 0f       	add	r18, r18
     cfe:	33 1f       	adc	r19, r19
     d00:	2f 5f       	subi	r18, 0xFF	; 255
     d02:	3f 4f       	sbci	r19, 0xFF	; 255
     d04:	81 e0       	ldi	r24, 0x01	; 1
     d06:	90 e0       	ldi	r25, 0x00	; 0
     d08:	02 c0       	rjmp	.+4      	; 0xd0e <moveMotorRelative+0xe0>
     d0a:	88 0f       	add	r24, r24
     d0c:	99 1f       	adc	r25, r25
     d0e:	2a 95       	dec	r18
     d10:	e2 f7       	brpl	.-8      	; 0xd0a <moveMotorRelative+0xdc>
     d12:	48 2b       	or	r20, r24
     d14:	42 b9       	out	0x02, r20	; 2
    /* move CW */
    PORTA &= ~(1 << (2*mot + 1));
  }

  /* now move the motor */
  for (i = 0; i < abs(steps); i++){
     d16:	77 ff       	sbrs	r23, 7
     d18:	a7 cf       	rjmp	.-178    	; 0xc68 <moveMotorRelative+0x3a>
     d1a:	70 95       	com	r23
     d1c:	61 95       	neg	r22
     d1e:	7f 4f       	sbci	r23, 0xFF	; 255
     d20:	a3 cf       	rjmp	.-186    	; 0xc68 <moveMotorRelative+0x3a>

00000d22 <defineOpticalZeroPosition>:
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
     d22:	ae e1       	ldi	r26, 0x1E	; 30
     d24:	b4 e0       	ldi	r27, 0x04	; 4
     d26:	e8 2f       	mov	r30, r24
     d28:	f0 e0       	ldi	r31, 0x00	; 0
     d2a:	ee 0f       	add	r30, r30
     d2c:	ff 1f       	adc	r31, r31
     d2e:	ee 0f       	add	r30, r30
     d30:	ff 1f       	adc	r31, r31
     d32:	ee 0f       	add	r30, r30
     d34:	ff 1f       	adc	r31, r31
     d36:	9f 01       	movw	r18, r30
     d38:	22 0f       	add	r18, r18
     d3a:	33 1f       	adc	r19, r19
     d3c:	22 0f       	add	r18, r18
     d3e:	33 1f       	adc	r19, r19
     d40:	e2 0f       	add	r30, r18
     d42:	f3 1f       	adc	r31, r19
     d44:	ea 0f       	add	r30, r26
     d46:	fb 1f       	adc	r31, r27
     d48:	40 81       	ld	r20, Z
     d4a:	51 81       	ldd	r21, Z+1	; 0x01
     d4c:	46 0f       	add	r20, r22
     d4e:	57 1f       	adc	r21, r23
     d50:	e8 2f       	mov	r30, r24
     d52:	f0 e0       	ldi	r31, 0x00	; 0
     d54:	ee 0f       	add	r30, r30
     d56:	ff 1f       	adc	r31, r31
     d58:	ee 0f       	add	r30, r30
     d5a:	ff 1f       	adc	r31, r31
     d5c:	9f 01       	movw	r18, r30
     d5e:	22 0f       	add	r18, r18
     d60:	33 1f       	adc	r19, r19
     d62:	22 0f       	add	r18, r18
     d64:	33 1f       	adc	r19, r19
     d66:	e2 0f       	add	r30, r18
     d68:	f3 1f       	adc	r31, r19
     d6a:	31 96       	adiw	r30, 0x01	; 1
     d6c:	ee 0f       	add	r30, r30
     d6e:	ff 1f       	adc	r31, r31
     d70:	ea 0f       	add	r30, r26
     d72:	fb 1f       	adc	r31, r27
     d74:	51 83       	std	Z+1, r21	; 0x01
     d76:	40 83       	st	Z, r20
  motor[i].opticalZeroPosition = motor[i].desiredPosition;
     d78:	e8 2f       	mov	r30, r24
     d7a:	f0 e0       	ldi	r31, 0x00	; 0
     d7c:	ee 0f       	add	r30, r30
     d7e:	ff 1f       	adc	r31, r31
     d80:	ee 0f       	add	r30, r30
     d82:	ff 1f       	adc	r31, r31
     d84:	9f 01       	movw	r18, r30
     d86:	22 0f       	add	r18, r18
     d88:	33 1f       	adc	r19, r19
     d8a:	22 0f       	add	r18, r18
     d8c:	33 1f       	adc	r19, r19
     d8e:	e2 0f       	add	r30, r18
     d90:	f3 1f       	adc	r31, r19
     d92:	31 96       	adiw	r30, 0x01	; 1
     d94:	ee 0f       	add	r30, r30
     d96:	ff 1f       	adc	r31, r31
     d98:	ea 0f       	add	r30, r26
     d9a:	fb 1f       	adc	r31, r27
     d9c:	40 81       	ld	r20, Z
     d9e:	51 81       	ldd	r21, Z+1	; 0x01
     da0:	28 2f       	mov	r18, r24
     da2:	30 e0       	ldi	r19, 0x00	; 0
     da4:	c9 01       	movw	r24, r18
     da6:	88 0f       	add	r24, r24
     da8:	99 1f       	adc	r25, r25
     daa:	88 0f       	add	r24, r24
     dac:	99 1f       	adc	r25, r25
     dae:	88 0f       	add	r24, r24
     db0:	99 1f       	adc	r25, r25
     db2:	22 0f       	add	r18, r18
     db4:	33 1f       	adc	r19, r19
     db6:	82 0f       	add	r24, r18
     db8:	93 1f       	adc	r25, r19
     dba:	01 96       	adiw	r24, 0x01	; 1
     dbc:	88 0f       	add	r24, r24
     dbe:	99 1f       	adc	r25, r25
     dc0:	88 0f       	add	r24, r24
     dc2:	99 1f       	adc	r25, r25
     dc4:	a8 0f       	add	r26, r24
     dc6:	b9 1f       	adc	r27, r25
     dc8:	11 96       	adiw	r26, 0x01	; 1
     dca:	5c 93       	st	X, r21
     dcc:	4e 93       	st	-X, r20

  return;
}
     dce:	08 95       	ret

00000dd0 <getADCvalue>:

  uint8_t i = 0;
  uint8_t lowByte, highByte;

  // select channel
  ADMUX = (ADMUX & ~(0x1F)) | (sensPin & 0x1F);
     dd0:	90 91 7c 00 	lds	r25, 0x007C
     dd4:	8f 71       	andi	r24, 0x1F	; 31
     dd6:	90 7e       	andi	r25, 0xE0	; 224
     dd8:	89 2b       	or	r24, r25
     dda:	80 93 7c 00 	sts	0x007C, r24

  // reset all values and counters before starting new conversion
  adc.ADCvalue = 0;
     dde:	10 92 fa 03 	sts	0x03FA, r1
     de2:	10 92 f9 03 	sts	0x03F9, r1

  // start the conversion
  for(i = 0; i < adc.numberOfMeasurements; i++){
     de6:	80 91 fb 03 	lds	r24, 0x03FB
     dea:	88 23       	and	r24, r24
     dec:	11 f1       	breq	.+68     	; 0xe32 <getADCvalue+0x62>
     dee:	60 e0       	ldi	r22, 0x00	; 0
    ADCSRA |= (1<<ADSC);
     df0:	80 91 7a 00 	lds	r24, 0x007A
     df4:	80 64       	ori	r24, 0x40	; 64
     df6:	80 93 7a 00 	sts	0x007A, r24
    while(ADCSRA & (1<<ADSC)){
     dfa:	80 91 7a 00 	lds	r24, 0x007A
     dfe:	86 fd       	sbrc	r24, 6
     e00:	fc cf       	rjmp	.-8      	; 0xdfa <getADCvalue+0x2a>
      ;
    }
    lowByte = ADCL;
     e02:	80 91 78 00 	lds	r24, 0x0078
    highByte = ADCH;
     e06:	20 91 79 00 	lds	r18, 0x0079
    adc.ADCvalue += (highByte<<8) | lowByte;
     e0a:	40 91 f9 03 	lds	r20, 0x03F9
     e0e:	50 91 fa 03 	lds	r21, 0x03FA
     e12:	32 2f       	mov	r19, r18
     e14:	20 e0       	ldi	r18, 0x00	; 0
     e16:	90 e0       	ldi	r25, 0x00	; 0
     e18:	82 2b       	or	r24, r18
     e1a:	93 2b       	or	r25, r19
     e1c:	84 0f       	add	r24, r20
     e1e:	95 1f       	adc	r25, r21
     e20:	90 93 fa 03 	sts	0x03FA, r25
     e24:	80 93 f9 03 	sts	0x03F9, r24

  // reset all values and counters before starting new conversion
  adc.ADCvalue = 0;

  // start the conversion
  for(i = 0; i < adc.numberOfMeasurements; i++){
     e28:	6f 5f       	subi	r22, 0xFF	; 255
     e2a:	80 91 fb 03 	lds	r24, 0x03FB
     e2e:	68 17       	cp	r22, r24
     e30:	f8 f2       	brcs	.-66     	; 0xdf0 <getADCvalue+0x20>
    lowByte = ADCL;
    highByte = ADCH;
    adc.ADCvalue += (highByte<<8) | lowByte;
  }

  return (adc.ADCvalue / adc.numberOfMeasurements);
     e32:	80 91 f9 03 	lds	r24, 0x03F9
     e36:	90 91 fa 03 	lds	r25, 0x03FA
     e3a:	60 91 fb 03 	lds	r22, 0x03FB
     e3e:	70 e0       	ldi	r23, 0x00	; 0
     e40:	0e 94 b4 45 	call	0x8b68	; 0x8b68 <__udivmodhi4>
     e44:	cb 01       	movw	r24, r22
}
     e46:	08 95       	ret

00000e48 <changeButtonLED>:
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     e48:	82 30       	cpi	r24, 0x02	; 2
     e4a:	11 f1       	breq	.+68     	; 0xe90 <changeButtonLED+0x48>
     e4c:	83 30       	cpi	r24, 0x03	; 3
     e4e:	78 f0       	brcs	.+30     	; 0xe6e <changeButtonLED+0x26>
     e50:	83 30       	cpi	r24, 0x03	; 3
     e52:	a9 f1       	breq	.+106    	; 0xebe <changeButtonLED+0x76>
     e54:	84 30       	cpi	r24, 0x04	; 4
     e56:	d9 f0       	breq	.+54     	; 0xe8e <changeButtonLED+0x46>
     e58:	a0 e0       	ldi	r26, 0x00	; 0
     e5a:	b0 e0       	ldi	r27, 0x00	; 0
     e5c:	e3 e0       	ldi	r30, 0x03	; 3
     e5e:	f0 e0       	ldi	r31, 0x00	; 0
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e60:	ad 53       	subi	r26, 0x3D	; 61
     e62:	bc 4f       	sbci	r27, 0xFC	; 252
     e64:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e66:	ed 53       	subi	r30, 0x3D	; 61
     e68:	fc 4f       	sbci	r31, 0xFC	; 252
     e6a:	40 83       	st	Z, r20

  return;
}
     e6c:	08 95       	ret
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     e6e:	88 23       	and	r24, r24
     e70:	d1 f0       	breq	.+52     	; 0xea6 <changeButtonLED+0x5e>
     e72:	81 30       	cpi	r24, 0x01	; 1
     e74:	89 f7       	brne	.-30     	; 0xe58 <changeButtonLED+0x10>
	case 0: chan = 6*2+color; break;
     e76:	6a 5f       	subi	r22, 0xFA	; 250
     e78:	a6 2f       	mov	r26, r22
     e7a:	b0 e0       	ldi	r27, 0x00	; 0
     e7c:	fd 01       	movw	r30, r26
     e7e:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e80:	ad 53       	subi	r26, 0x3D	; 61
     e82:	bc 4f       	sbci	r27, 0xFC	; 252
     e84:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e86:	ed 53       	subi	r30, 0x3D	; 61
     e88:	fc 4f       	sbci	r31, 0xFC	; 252
     e8a:	40 83       	st	Z, r20

  return;
}
     e8c:	08 95       	ret
  
  switch(butt) {
	case 0: chan = 6*2+color; break;
	case 1: chan = 6*1+color; break;
	case 2: chan = 6*0+color; break;
	case 3: chan = 6*5+color; break;
     e8e:	68 5e       	subi	r22, 0xE8	; 232
     e90:	a6 2f       	mov	r26, r22
     e92:	b0 e0       	ldi	r27, 0x00	; 0
     e94:	fd 01       	movw	r30, r26
     e96:	33 96       	adiw	r30, 0x03	; 3
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     e98:	ad 53       	subi	r26, 0x3D	; 61
     e9a:	bc 4f       	sbci	r27, 0xFC	; 252
     e9c:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     e9e:	ed 53       	subi	r30, 0x3D	; 61
     ea0:	fc 4f       	sbci	r31, 0xFC	; 252
     ea2:	40 83       	st	Z, r20

  return;
}
     ea4:	08 95       	ret
 --------------------------------------------------------------------- */
void changeButtonLED(uint8_t butt, uint8_t color, uint8_t intensity){
  
  uint8_t chan = 0;
  
  switch(butt) {
     ea6:	64 5f       	subi	r22, 0xF4	; 244
     ea8:	a6 2f       	mov	r26, r22
     eaa:	b0 e0       	ldi	r27, 0x00	; 0
     eac:	fd 01       	movw	r30, r26
     eae:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     eb0:	ad 53       	subi	r26, 0x3D	; 61
     eb2:	bc 4f       	sbci	r27, 0xFC	; 252
     eb4:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     eb6:	ed 53       	subi	r30, 0x3D	; 61
     eb8:	fc 4f       	sbci	r31, 0xFC	; 252
     eba:	40 83       	st	Z, r20

  return;
}
     ebc:	08 95       	ret
  
  uint8_t chan = 0;
  
  switch(butt) {
	case 0: chan = 6*2+color; break;
	case 1: chan = 6*1+color; break;
     ebe:	62 5e       	subi	r22, 0xE2	; 226
     ec0:	a6 2f       	mov	r26, r22
     ec2:	b0 e0       	ldi	r27, 0x00	; 0
     ec4:	fd 01       	movw	r30, r26
     ec6:	33 96       	adiw	r30, 0x03	; 3
	case 3: chan = 6*5+color; break;
	case 4: chan = 6*4+color; break;
	default: chan = 0; break;
  }

  buttLedData[chan]   = intensity;
     ec8:	ad 53       	subi	r26, 0x3D	; 61
     eca:	bc 4f       	sbci	r27, 0xFC	; 252
     ecc:	4c 93       	st	X, r20
  buttLedData[chan+3] = intensity;
     ece:	ed 53       	subi	r30, 0x3D	; 61
     ed0:	fc 4f       	sbci	r31, 0xFC	; 252
     ed2:	40 83       	st	Z, r20

  return;
}
     ed4:	08 95       	ret

00000ed6 <updateLEDs>:

/* ---------------------------------------------------------------------
   update LEDs
 --------------------------------------------------------------------- */
void updateLEDs(void){
     ed6:	6f e2       	ldi	r22, 0x2F	; 47
     ed8:	70 e0       	ldi	r23, 0x00	; 0
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
     eda:	32 e4       	ldi	r19, 0x42	; 66
  //uint8_t  j = 0;
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
	data = buttLedData[i];
     edc:	fb 01       	movw	r30, r22
     ede:	ed 53       	subi	r30, 0x3D	; 61
     ee0:	fc 4f       	sbci	r31, 0xFC	; 252
     ee2:	80 81       	ld	r24, Z
     ee4:	48 2f       	mov	r20, r24
     ee6:	50 e0       	ldi	r21, 0x00	; 0
     ee8:	27 e0       	ldi	r18, 0x07	; 7
     eea:	0f c0       	rjmp	.+30     	; 0xf0a <updateLEDs+0x34>
    {
        outbyte = (data>>i) & 0x01;
        // Set the data pin to given value, and clk pin to 0
        if(outbyte)
        {
            PORTC |= (outbyte << WS2803_SDI);
     eec:	46 9a       	sbi	0x08, 6	; 8
        }
        else
        {
            PORTC &= ~(outbyte << WS2803_SDI);
        }
        PORTC &= ~(1 << WS2803_CKI);
     eee:	47 98       	cbi	0x08, 7	; 8
     ef0:	83 2f       	mov	r24, r19
     ef2:	8a 95       	dec	r24
     ef4:	f1 f7       	brne	.-4      	; 0xef2 <updateLEDs+0x1c>
        _delay_us(10);

        // Keep the data pin, and set clk pin to 1 (strobe)
        PORTC |= 1 << WS2803_CKI;
     ef6:	47 9a       	sbi	0x08, 7	; 8
     ef8:	83 2f       	mov	r24, r19
     efa:	8a 95       	dec	r24
     efc:	f1 f7       	brne	.-4      	; 0xefa <updateLEDs+0x24>
        _delay_us(10);

        // Zero both clk and data pins
        PORTC &= ~((1 << WS2803_SDI) | (1 << WS2803_CKI));
     efe:	88 b1       	in	r24, 0x08	; 8
     f00:	8f 73       	andi	r24, 0x3F	; 63
     f02:	88 b9       	out	0x08, r24	; 8
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
	data = buttLedData[i];
	for(uint8_t i=7; i<255; i--)
     f04:	21 50       	subi	r18, 0x01	; 1
     f06:	2f 3f       	cpi	r18, 0xFF	; 255
     f08:	61 f0       	breq	.+24     	; 0xf22 <updateLEDs+0x4c>
    {
        outbyte = (data>>i) & 0x01;
        // Set the data pin to given value, and clk pin to 0
        if(outbyte)
     f0a:	ca 01       	movw	r24, r20
     f0c:	02 2e       	mov	r0, r18
     f0e:	02 c0       	rjmp	.+4      	; 0xf14 <updateLEDs+0x3e>
     f10:	95 95       	asr	r25
     f12:	87 95       	ror	r24
     f14:	0a 94       	dec	r0
     f16:	e2 f7       	brpl	.-8      	; 0xf10 <updateLEDs+0x3a>
     f18:	80 fd       	sbrc	r24, 0
     f1a:	e8 cf       	rjmp	.-48     	; 0xeec <updateLEDs+0x16>
        {
            PORTC |= (outbyte << WS2803_SDI);
        }
        else
        {
            PORTC &= ~(outbyte << WS2803_SDI);
     f1c:	88 b1       	in	r24, 0x08	; 8
     f1e:	88 b9       	out	0x08, r24	; 8
     f20:	e6 cf       	rjmp	.-52     	; 0xeee <updateLEDs+0x18>
  uint16_t i = 0;
  //uint8_t  j = 0;
  uint8_t data = 0;
  uint8_t outbyte = 0;

  for(i = BUTT_LED_CHANNELS - 1; i < 255; i--){
     f22:	61 50       	subi	r22, 0x01	; 1
     f24:	70 40       	sbci	r23, 0x00	; 0
     f26:	8f ef       	ldi	r24, 0xFF	; 255
     f28:	6f 3f       	cpi	r22, 0xFF	; 255
     f2a:	78 07       	cpc	r23, r24
     f2c:	b9 f6       	brne	.-82     	; 0xedc <updateLEDs+0x6>
        PORTC &= ~((1 << WS2803_SDI) | (1 << WS2803_CKI));
    }
  }

  return;
}
     f2e:	08 95       	ret

00000f30 <changeMotorButtonLED>:

/* ---------------------------------------------------------------------
   change motor button LED color/intensity
 --------------------------------------------------------------------- */
void changeMotorButtonLED(uint8_t motor, uint8_t enable){
     f30:	1f 93       	push	r17
     f32:	18 2f       	mov	r17, r24
    
  if(enable){ //button lights white
     f34:	66 23       	and	r22, r22
     f36:	81 f4       	brne	.+32     	; 0xf58 <changeMotorButtonLED+0x28>
    changeButtonLED(motor, BLUE, 0x0F);
    changeButtonLED(motor, GREEN, 0x0F);
    changeButtonLED(motor, RED, 0x08);
  }
  else{ //button lights green
    changeButtonLED(motor, BLUE, 0x00);
     f38:	60 e0       	ldi	r22, 0x00	; 0
     f3a:	40 e0       	ldi	r20, 0x00	; 0
     f3c:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
    changeButtonLED(motor, GREEN, 0x0F);
     f40:	81 2f       	mov	r24, r17
     f42:	61 e0       	ldi	r22, 0x01	; 1
     f44:	4f e0       	ldi	r20, 0x0F	; 15
     f46:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
    changeButtonLED(motor, RED, 0x00);
     f4a:	81 2f       	mov	r24, r17
     f4c:	62 e0       	ldi	r22, 0x02	; 2
     f4e:	40 e0       	ldi	r20, 0x00	; 0
     f50:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
  }
  //updateLEDs();

  return;
}
     f54:	1f 91       	pop	r17
     f56:	08 95       	ret
   change motor button LED color/intensity
 --------------------------------------------------------------------- */
void changeMotorButtonLED(uint8_t motor, uint8_t enable){
    
  if(enable){ //button lights white
    changeButtonLED(motor, BLUE, 0x0F);
     f58:	60 e0       	ldi	r22, 0x00	; 0
     f5a:	4f e0       	ldi	r20, 0x0F	; 15
     f5c:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
    changeButtonLED(motor, GREEN, 0x0F);
     f60:	81 2f       	mov	r24, r17
     f62:	61 e0       	ldi	r22, 0x01	; 1
     f64:	4f e0       	ldi	r20, 0x0F	; 15
     f66:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
    changeButtonLED(motor, RED, 0x08);
     f6a:	81 2f       	mov	r24, r17
     f6c:	62 e0       	ldi	r22, 0x02	; 2
     f6e:	48 e0       	ldi	r20, 0x08	; 8
     f70:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
    changeButtonLED(motor, RED, 0x00);
  }
  //updateLEDs();

  return;
}
     f74:	1f 91       	pop	r17
     f76:	08 95       	ret

00000f78 <updateMotorButtonLEDs>:

/* ---------------------------------------------------------------------
   update motor button LEDs
 --------------------------------------------------------------------- */
void updateMotorButtonLEDs(void){
     f78:	cf 93       	push	r28
     f7a:	df 93       	push	r29
     f7c:	c0 e0       	ldi	r28, 0x00	; 0
     f7e:	d0 e0       	ldi	r29, 0x00	; 0
  
  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    if(menu.selectedMotor & (1 << i)){
     f80:	80 91 13 03 	lds	r24, 0x0313
     f84:	90 e0       	ldi	r25, 0x00	; 0
     f86:	0c 2e       	mov	r0, r28
     f88:	02 c0       	rjmp	.+4      	; 0xf8e <updateMotorButtonLEDs+0x16>
     f8a:	95 95       	asr	r25
     f8c:	87 95       	ror	r24
     f8e:	0a 94       	dec	r0
     f90:	e2 f7       	brpl	.-8      	; 0xf8a <updateMotorButtonLEDs+0x12>
     f92:	80 ff       	sbrs	r24, 0
     f94:	0d c0       	rjmp	.+26     	; 0xfb0 <updateMotorButtonLEDs+0x38>
      changeMotorButtonLED(i, 1);
     f96:	8c 2f       	mov	r24, r28
     f98:	61 e0       	ldi	r22, 0x01	; 1
     f9a:	0e 94 98 07 	call	0xf30	; 0xf30 <changeMotorButtonLED>
    }
    else{
      changeMotorButtonLED(i, 0);
     f9e:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void updateMotorButtonLEDs(void){
  
  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
     fa0:	c4 30       	cpi	r28, 0x04	; 4
     fa2:	d1 05       	cpc	r29, r1
     fa4:	69 f7       	brne	.-38     	; 0xf80 <updateMotorButtonLEDs+0x8>
    }
    else{
      changeMotorButtonLED(i, 0);
    }
  }
  updateLEDs();
     fa6:	0e 94 6b 07 	call	0xed6	; 0xed6 <updateLEDs>
  
  return;
}
     faa:	df 91       	pop	r29
     fac:	cf 91       	pop	r28
     fae:	08 95       	ret
  for(i = 0; i <= MAX_MOTOR; i++){
    if(menu.selectedMotor & (1 << i)){
      changeMotorButtonLED(i, 1);
    }
    else{
      changeMotorButtonLED(i, 0);
     fb0:	8c 2f       	mov	r24, r28
     fb2:	60 e0       	ldi	r22, 0x00	; 0
     fb4:	0e 94 98 07 	call	0xf30	; 0xf30 <changeMotorButtonLED>
     fb8:	f2 cf       	rjmp	.-28     	; 0xf9e <updateMotorButtonLEDs+0x26>

00000fba <stepsToDegree>:
}

/* ---------------------------------------------------------------------
   calculate degree from steps
 --------------------------------------------------------------------- */
double stepsToDegree(uint8_t mot, int16_t steps){
     fba:	2f 92       	push	r2
     fbc:	3f 92       	push	r3
     fbe:	4f 92       	push	r4
     fc0:	5f 92       	push	r5
     fc2:	6f 92       	push	r6
     fc4:	7f 92       	push	r7
     fc6:	8f 92       	push	r8
     fc8:	9f 92       	push	r9
     fca:	af 92       	push	r10
     fcc:	bf 92       	push	r11
     fce:	cf 92       	push	r12
     fd0:	df 92       	push	r13
     fd2:	ef 92       	push	r14
     fd4:	ff 92       	push	r15
     fd6:	0f 93       	push	r16
     fd8:	1f 93       	push	r17
     fda:	48 2f       	mov	r20, r24

  double radian = 0.0f;

  radian = (steps) * ( (360.0f)/(motor[mot].gearRatio
     fdc:	ae e1       	ldi	r26, 0x1E	; 30
     fde:	b4 e0       	ldi	r27, 0x04	; 4
     fe0:	e8 2f       	mov	r30, r24
     fe2:	f0 e0       	ldi	r31, 0x00	; 0
     fe4:	ee 0f       	add	r30, r30
     fe6:	ff 1f       	adc	r31, r31
     fe8:	ee 0f       	add	r30, r30
     fea:	ff 1f       	adc	r31, r31
     fec:	ee 0f       	add	r30, r30
     fee:	ff 1f       	adc	r31, r31
     ff0:	9f 01       	movw	r18, r30
     ff2:	22 0f       	add	r18, r18
     ff4:	33 1f       	adc	r19, r19
     ff6:	22 0f       	add	r18, r18
     ff8:	33 1f       	adc	r19, r19
     ffa:	e2 0f       	add	r30, r18
     ffc:	f3 1f       	adc	r31, r19
     ffe:	ea 0f       	add	r30, r26
    1000:	fb 1f       	adc	r31, r27
    1002:	25 84       	ldd	r2, Z+13	; 0x0d
    1004:	36 84       	ldd	r3, Z+14	; 0x0e
    1006:	47 84       	ldd	r4, Z+15	; 0x0f
    1008:	50 88       	ldd	r5, Z+16	; 0x10
    100a:	e4 2f       	mov	r30, r20
    100c:	f0 e0       	ldi	r31, 0x00	; 0
    100e:	ee 0f       	add	r30, r30
    1010:	ff 1f       	adc	r31, r31
    1012:	ee 0f       	add	r30, r30
    1014:	ff 1f       	adc	r31, r31
    1016:	ee 0f       	add	r30, r30
    1018:	ff 1f       	adc	r31, r31
    101a:	9f 01       	movw	r18, r30
    101c:	22 0f       	add	r18, r18
    101e:	33 1f       	adc	r19, r19
    1020:	22 0f       	add	r18, r18
    1022:	33 1f       	adc	r19, r19
    1024:	e2 0f       	add	r30, r18
    1026:	f3 1f       	adc	r31, r19
    1028:	ea 0f       	add	r30, r26
    102a:	fb 1f       	adc	r31, r27
    102c:	65 88       	ldd	r6, Z+21	; 0x15
    102e:	76 88       	ldd	r7, Z+22	; 0x16
    1030:	87 88       	ldd	r8, Z+23	; 0x17
    1032:	90 8c       	ldd	r9, Z+24	; 0x18
    1034:	24 2f       	mov	r18, r20
    1036:	30 e0       	ldi	r19, 0x00	; 0
    1038:	22 0f       	add	r18, r18
    103a:	33 1f       	adc	r19, r19
    103c:	22 0f       	add	r18, r18
    103e:	33 1f       	adc	r19, r19
    1040:	22 0f       	add	r18, r18
    1042:	33 1f       	adc	r19, r19
    1044:	a9 01       	movw	r20, r18
    1046:	44 0f       	add	r20, r20
    1048:	55 1f       	adc	r21, r21
    104a:	44 0f       	add	r20, r20
    104c:	55 1f       	adc	r21, r21
    104e:	24 0f       	add	r18, r20
    1050:	35 1f       	adc	r19, r21
    1052:	a2 0f       	add	r26, r18
    1054:	b3 1f       	adc	r27, r19
    1056:	51 96       	adiw	r26, 0x11	; 17
    1058:	ed 90       	ld	r14, X+
    105a:	fd 90       	ld	r15, X+
    105c:	0d 91       	ld	r16, X+
    105e:	1c 91       	ld	r17, X
    1060:	54 97       	sbiw	r26, 0x14	; 20
    1062:	88 27       	eor	r24, r24
    1064:	77 fd       	sbrc	r23, 7
    1066:	80 95       	com	r24
    1068:	98 2f       	mov	r25, r24
    106a:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    106e:	5b 01       	movw	r10, r22
    1070:	6c 01       	movw	r12, r24
    1072:	c2 01       	movw	r24, r4
    1074:	b1 01       	movw	r22, r2
    1076:	a4 01       	movw	r20, r8
    1078:	93 01       	movw	r18, r6
    107a:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    107e:	a8 01       	movw	r20, r16
    1080:	97 01       	movw	r18, r14
    1082:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    1086:	9b 01       	movw	r18, r22
    1088:	ac 01       	movw	r20, r24
    108a:	60 e0       	ldi	r22, 0x00	; 0
    108c:	70 e0       	ldi	r23, 0x00	; 0
    108e:	84 eb       	ldi	r24, 0xB4	; 180
    1090:	93 e4       	ldi	r25, 0x43	; 67
    1092:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    1096:	9b 01       	movw	r18, r22
    1098:	ac 01       	movw	r20, r24
    109a:	c6 01       	movw	r24, r12
    109c:	b5 01       	movw	r22, r10
    109e:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
                                *motor[mot].subSteps
                                *motor[mot].stepsPerFullRotation) );

  return radian;
}
    10a2:	1f 91       	pop	r17
    10a4:	0f 91       	pop	r16
    10a6:	ff 90       	pop	r15
    10a8:	ef 90       	pop	r14
    10aa:	df 90       	pop	r13
    10ac:	cf 90       	pop	r12
    10ae:	bf 90       	pop	r11
    10b0:	af 90       	pop	r10
    10b2:	9f 90       	pop	r9
    10b4:	8f 90       	pop	r8
    10b6:	7f 90       	pop	r7
    10b8:	6f 90       	pop	r6
    10ba:	5f 90       	pop	r5
    10bc:	4f 90       	pop	r4
    10be:	3f 90       	pop	r3
    10c0:	2f 90       	pop	r2
    10c2:	08 95       	ret

000010c4 <stepsToRadian>:
}

/* ---------------------------------------------------------------------
   calculate radians from steps
 --------------------------------------------------------------------- */
double stepsToRadian(uint8_t mot, int16_t steps){
    10c4:	2f 92       	push	r2
    10c6:	3f 92       	push	r3
    10c8:	4f 92       	push	r4
    10ca:	5f 92       	push	r5
    10cc:	6f 92       	push	r6
    10ce:	7f 92       	push	r7
    10d0:	8f 92       	push	r8
    10d2:	9f 92       	push	r9
    10d4:	af 92       	push	r10
    10d6:	bf 92       	push	r11
    10d8:	cf 92       	push	r12
    10da:	df 92       	push	r13
    10dc:	ef 92       	push	r14
    10de:	ff 92       	push	r15
    10e0:	0f 93       	push	r16
    10e2:	1f 93       	push	r17
    10e4:	48 2f       	mov	r20, r24

  double radian = 0.0f;

  radian = (steps) * ( (2.0f)/(motor[mot].gearRatio
    10e6:	ae e1       	ldi	r26, 0x1E	; 30
    10e8:	b4 e0       	ldi	r27, 0x04	; 4
    10ea:	e8 2f       	mov	r30, r24
    10ec:	f0 e0       	ldi	r31, 0x00	; 0
    10ee:	ee 0f       	add	r30, r30
    10f0:	ff 1f       	adc	r31, r31
    10f2:	ee 0f       	add	r30, r30
    10f4:	ff 1f       	adc	r31, r31
    10f6:	ee 0f       	add	r30, r30
    10f8:	ff 1f       	adc	r31, r31
    10fa:	9f 01       	movw	r18, r30
    10fc:	22 0f       	add	r18, r18
    10fe:	33 1f       	adc	r19, r19
    1100:	22 0f       	add	r18, r18
    1102:	33 1f       	adc	r19, r19
    1104:	e2 0f       	add	r30, r18
    1106:	f3 1f       	adc	r31, r19
    1108:	ea 0f       	add	r30, r26
    110a:	fb 1f       	adc	r31, r27
    110c:	25 84       	ldd	r2, Z+13	; 0x0d
    110e:	36 84       	ldd	r3, Z+14	; 0x0e
    1110:	47 84       	ldd	r4, Z+15	; 0x0f
    1112:	50 88       	ldd	r5, Z+16	; 0x10
    1114:	e4 2f       	mov	r30, r20
    1116:	f0 e0       	ldi	r31, 0x00	; 0
    1118:	ee 0f       	add	r30, r30
    111a:	ff 1f       	adc	r31, r31
    111c:	ee 0f       	add	r30, r30
    111e:	ff 1f       	adc	r31, r31
    1120:	ee 0f       	add	r30, r30
    1122:	ff 1f       	adc	r31, r31
    1124:	9f 01       	movw	r18, r30
    1126:	22 0f       	add	r18, r18
    1128:	33 1f       	adc	r19, r19
    112a:	22 0f       	add	r18, r18
    112c:	33 1f       	adc	r19, r19
    112e:	e2 0f       	add	r30, r18
    1130:	f3 1f       	adc	r31, r19
    1132:	ea 0f       	add	r30, r26
    1134:	fb 1f       	adc	r31, r27
    1136:	65 88       	ldd	r6, Z+21	; 0x15
    1138:	76 88       	ldd	r7, Z+22	; 0x16
    113a:	87 88       	ldd	r8, Z+23	; 0x17
    113c:	90 8c       	ldd	r9, Z+24	; 0x18
    113e:	24 2f       	mov	r18, r20
    1140:	30 e0       	ldi	r19, 0x00	; 0
    1142:	22 0f       	add	r18, r18
    1144:	33 1f       	adc	r19, r19
    1146:	22 0f       	add	r18, r18
    1148:	33 1f       	adc	r19, r19
    114a:	22 0f       	add	r18, r18
    114c:	33 1f       	adc	r19, r19
    114e:	a9 01       	movw	r20, r18
    1150:	44 0f       	add	r20, r20
    1152:	55 1f       	adc	r21, r21
    1154:	44 0f       	add	r20, r20
    1156:	55 1f       	adc	r21, r21
    1158:	24 0f       	add	r18, r20
    115a:	35 1f       	adc	r19, r21
    115c:	a2 0f       	add	r26, r18
    115e:	b3 1f       	adc	r27, r19
    1160:	51 96       	adiw	r26, 0x11	; 17
    1162:	ed 90       	ld	r14, X+
    1164:	fd 90       	ld	r15, X+
    1166:	0d 91       	ld	r16, X+
    1168:	1c 91       	ld	r17, X
    116a:	54 97       	sbiw	r26, 0x14	; 20
    116c:	88 27       	eor	r24, r24
    116e:	77 fd       	sbrc	r23, 7
    1170:	80 95       	com	r24
    1172:	98 2f       	mov	r25, r24
    1174:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    1178:	5b 01       	movw	r10, r22
    117a:	6c 01       	movw	r12, r24
    117c:	c2 01       	movw	r24, r4
    117e:	b1 01       	movw	r22, r2
    1180:	a4 01       	movw	r20, r8
    1182:	93 01       	movw	r18, r6
    1184:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    1188:	a8 01       	movw	r20, r16
    118a:	97 01       	movw	r18, r14
    118c:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    1190:	9b 01       	movw	r18, r22
    1192:	ac 01       	movw	r20, r24
    1194:	60 e0       	ldi	r22, 0x00	; 0
    1196:	70 e0       	ldi	r23, 0x00	; 0
    1198:	80 e0       	ldi	r24, 0x00	; 0
    119a:	90 e4       	ldi	r25, 0x40	; 64
    119c:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    11a0:	9b 01       	movw	r18, r22
    11a2:	ac 01       	movw	r20, r24
    11a4:	c6 01       	movw	r24, r12
    11a6:	b5 01       	movw	r22, r10
    11a8:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
                              *motor[mot].subSteps
                              *motor[mot].stepsPerFullRotation) );

  return radian;
}
    11ac:	1f 91       	pop	r17
    11ae:	0f 91       	pop	r16
    11b0:	ff 90       	pop	r15
    11b2:	ef 90       	pop	r14
    11b4:	df 90       	pop	r13
    11b6:	cf 90       	pop	r12
    11b8:	bf 90       	pop	r11
    11ba:	af 90       	pop	r10
    11bc:	9f 90       	pop	r9
    11be:	8f 90       	pop	r8
    11c0:	7f 90       	pop	r7
    11c2:	6f 90       	pop	r6
    11c4:	5f 90       	pop	r5
    11c6:	4f 90       	pop	r4
    11c8:	3f 90       	pop	r3
    11ca:	2f 90       	pop	r2
    11cc:	08 95       	ret

000011ce <setConstSpeed>:

/* ---------------------------------------------------------------------
   set constant angular velocity
 --------------------------------------------------------------------- */
void setConstSpeed(uint8_t i, uint8_t state){
    11ce:	48 2f       	mov	r20, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    11d0:	f8 94       	cli

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    switch(state){
    11d2:	61 30       	cpi	r22, 0x01	; 1
    11d4:	09 f4       	brne	.+2      	; 0x11d8 <setConstSpeed+0xa>
    11d6:	3d c0       	rjmp	.+122    	; 0x1252 <setConstSpeed+0x84>
    11d8:	61 30       	cpi	r22, 0x01	; 1
    11da:	08 f0       	brcs	.+2      	; 0x11de <setConstSpeed+0x10>
    11dc:	88 c0       	rjmp	.+272    	; 0x12ee <setConstSpeed+0x120>
      case MOTOR_MOVE_INFINITE_STOP:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    11de:	e8 2f       	mov	r30, r24
    11e0:	f0 e0       	ldi	r31, 0x00	; 0
    11e2:	ee 0f       	add	r30, r30
    11e4:	ff 1f       	adc	r31, r31
    11e6:	ee 0f       	add	r30, r30
    11e8:	ff 1f       	adc	r31, r31
    11ea:	ee 0f       	add	r30, r30
    11ec:	ff 1f       	adc	r31, r31
    11ee:	cf 01       	movw	r24, r30
    11f0:	88 0f       	add	r24, r24
    11f2:	99 1f       	adc	r25, r25
    11f4:	88 0f       	add	r24, r24
    11f6:	99 1f       	adc	r25, r25
    11f8:	e8 0f       	add	r30, r24
    11fa:	f9 1f       	adc	r31, r25
    11fc:	e2 5e       	subi	r30, 0xE2	; 226
    11fe:	fb 4f       	sbci	r31, 0xFB	; 251
    1200:	14 86       	std	Z+12, r1	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    1202:	e4 2f       	mov	r30, r20
    1204:	f0 e0       	ldi	r31, 0x00	; 0
    1206:	ee 0f       	add	r30, r30
    1208:	ff 1f       	adc	r31, r31
    120a:	ee 0f       	add	r30, r30
    120c:	ff 1f       	adc	r31, r31
    120e:	ee 0f       	add	r30, r30
    1210:	ff 1f       	adc	r31, r31
    1212:	cf 01       	movw	r24, r30
    1214:	88 0f       	add	r24, r24
    1216:	99 1f       	adc	r25, r25
    1218:	88 0f       	add	r24, r24
    121a:	99 1f       	adc	r25, r25
    121c:	e8 0f       	add	r30, r24
    121e:	f9 1f       	adc	r31, r25
    1220:	e2 5e       	subi	r30, 0xE2	; 226
    1222:	fb 4f       	sbci	r31, 0xFB	; 251
    1224:	20 81       	ld	r18, Z
    1226:	31 81       	ldd	r19, Z+1	; 0x01
        break;

      case MOTOR_MOVE_INFINITE_CCW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
        motor[i].desiredPosition  = motor[i].actualPosition;
        motor[i].desiredPosition += -1;
    1228:	e4 2f       	mov	r30, r20
    122a:	f0 e0       	ldi	r31, 0x00	; 0
    122c:	ee 0f       	add	r30, r30
    122e:	ff 1f       	adc	r31, r31
    1230:	ee 0f       	add	r30, r30
    1232:	ff 1f       	adc	r31, r31
    1234:	cf 01       	movw	r24, r30
    1236:	88 0f       	add	r24, r24
    1238:	99 1f       	adc	r25, r25
    123a:	88 0f       	add	r24, r24
    123c:	99 1f       	adc	r25, r25
    123e:	e8 0f       	add	r30, r24
    1240:	f9 1f       	adc	r31, r25
    1242:	ee 0f       	add	r30, r30
    1244:	ff 1f       	adc	r31, r31
    1246:	e0 5e       	subi	r30, 0xE0	; 224
    1248:	fb 4f       	sbci	r31, 0xFB	; 251
    124a:	31 83       	std	Z+1, r19	; 0x01
    124c:	20 83       	st	Z, r18
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    124e:	78 94       	sei
        break;
    }
  }

  return;
}
    1250:	08 95       	ret
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
        motor[i].desiredPosition  = motor[i].actualPosition;
        break;

      case MOTOR_MOVE_INFINITE_CW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CW;
    1252:	e8 2f       	mov	r30, r24
    1254:	f0 e0       	ldi	r31, 0x00	; 0
    1256:	ee 0f       	add	r30, r30
    1258:	ff 1f       	adc	r31, r31
    125a:	ee 0f       	add	r30, r30
    125c:	ff 1f       	adc	r31, r31
    125e:	ee 0f       	add	r30, r30
    1260:	ff 1f       	adc	r31, r31
    1262:	cf 01       	movw	r24, r30
    1264:	88 0f       	add	r24, r24
    1266:	99 1f       	adc	r25, r25
    1268:	88 0f       	add	r24, r24
    126a:	99 1f       	adc	r25, r25
    126c:	e8 0f       	add	r30, r24
    126e:	f9 1f       	adc	r31, r25
    1270:	e2 5e       	subi	r30, 0xE2	; 226
    1272:	fb 4f       	sbci	r31, 0xFB	; 251
    1274:	64 87       	std	Z+12, r22	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    1276:	e4 2f       	mov	r30, r20
    1278:	f0 e0       	ldi	r31, 0x00	; 0
    127a:	ee 0f       	add	r30, r30
    127c:	ff 1f       	adc	r31, r31
    127e:	ee 0f       	add	r30, r30
    1280:	ff 1f       	adc	r31, r31
    1282:	ee 0f       	add	r30, r30
    1284:	ff 1f       	adc	r31, r31
    1286:	cf 01       	movw	r24, r30
    1288:	88 0f       	add	r24, r24
    128a:	99 1f       	adc	r25, r25
    128c:	88 0f       	add	r24, r24
    128e:	99 1f       	adc	r25, r25
    1290:	e8 0f       	add	r30, r24
    1292:	f9 1f       	adc	r31, r25
    1294:	e2 5e       	subi	r30, 0xE2	; 226
    1296:	fb 4f       	sbci	r31, 0xFB	; 251
    1298:	20 81       	ld	r18, Z
    129a:	31 81       	ldd	r19, Z+1	; 0x01
    129c:	e4 2f       	mov	r30, r20
    129e:	f0 e0       	ldi	r31, 0x00	; 0
    12a0:	ee 0f       	add	r30, r30
    12a2:	ff 1f       	adc	r31, r31
    12a4:	ee 0f       	add	r30, r30
    12a6:	ff 1f       	adc	r31, r31
    12a8:	cf 01       	movw	r24, r30
    12aa:	88 0f       	add	r24, r24
    12ac:	99 1f       	adc	r25, r25
    12ae:	88 0f       	add	r24, r24
    12b0:	99 1f       	adc	r25, r25
    12b2:	e8 0f       	add	r30, r24
    12b4:	f9 1f       	adc	r31, r25
    12b6:	ee 0f       	add	r30, r30
    12b8:	ff 1f       	adc	r31, r31
    12ba:	e0 5e       	subi	r30, 0xE0	; 224
    12bc:	fb 4f       	sbci	r31, 0xFB	; 251
    12be:	31 83       	std	Z+1, r19	; 0x01
    12c0:	20 83       	st	Z, r18
        motor[i].desiredPosition += 1;
    12c2:	e4 2f       	mov	r30, r20
    12c4:	f0 e0       	ldi	r31, 0x00	; 0
    12c6:	ee 0f       	add	r30, r30
    12c8:	ff 1f       	adc	r31, r31
    12ca:	ee 0f       	add	r30, r30
    12cc:	ff 1f       	adc	r31, r31
    12ce:	cf 01       	movw	r24, r30
    12d0:	88 0f       	add	r24, r24
    12d2:	99 1f       	adc	r25, r25
    12d4:	88 0f       	add	r24, r24
    12d6:	99 1f       	adc	r25, r25
    12d8:	e8 0f       	add	r30, r24
    12da:	f9 1f       	adc	r31, r25
    12dc:	ee 0f       	add	r30, r30
    12de:	ff 1f       	adc	r31, r31
    12e0:	e0 5e       	subi	r30, 0xE0	; 224
    12e2:	fb 4f       	sbci	r31, 0xFB	; 251
    12e4:	20 81       	ld	r18, Z
    12e6:	31 81       	ldd	r19, Z+1	; 0x01
    12e8:	2f 5f       	subi	r18, 0xFF	; 255
    12ea:	3f 4f       	sbci	r19, 0xFF	; 255
    12ec:	9d cf       	rjmp	.-198    	; 0x1228 <setConstSpeed+0x5a>
   set constant angular velocity
 --------------------------------------------------------------------- */
void setConstSpeed(uint8_t i, uint8_t state){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    switch(state){
    12ee:	62 30       	cpi	r22, 0x02	; 2
    12f0:	09 f0       	breq	.+2      	; 0x12f4 <setConstSpeed+0x126>
    12f2:	ad cf       	rjmp	.-166    	; 0x124e <setConstSpeed+0x80>
        motor[i].desiredPosition  = motor[i].actualPosition;
        motor[i].desiredPosition += 1;
        break;

      case MOTOR_MOVE_INFINITE_CCW:
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
    12f4:	e8 2f       	mov	r30, r24
    12f6:	f0 e0       	ldi	r31, 0x00	; 0
    12f8:	ee 0f       	add	r30, r30
    12fa:	ff 1f       	adc	r31, r31
    12fc:	ee 0f       	add	r30, r30
    12fe:	ff 1f       	adc	r31, r31
    1300:	ee 0f       	add	r30, r30
    1302:	ff 1f       	adc	r31, r31
    1304:	cf 01       	movw	r24, r30
    1306:	88 0f       	add	r24, r24
    1308:	99 1f       	adc	r25, r25
    130a:	88 0f       	add	r24, r24
    130c:	99 1f       	adc	r25, r25
    130e:	e8 0f       	add	r30, r24
    1310:	f9 1f       	adc	r31, r25
    1312:	e2 5e       	subi	r30, 0xE2	; 226
    1314:	fb 4f       	sbci	r31, 0xFB	; 251
    1316:	64 87       	std	Z+12, r22	; 0x0c
        motor[i].desiredPosition  = motor[i].actualPosition;
    1318:	e4 2f       	mov	r30, r20
    131a:	f0 e0       	ldi	r31, 0x00	; 0
    131c:	ee 0f       	add	r30, r30
    131e:	ff 1f       	adc	r31, r31
    1320:	ee 0f       	add	r30, r30
    1322:	ff 1f       	adc	r31, r31
    1324:	ee 0f       	add	r30, r30
    1326:	ff 1f       	adc	r31, r31
    1328:	cf 01       	movw	r24, r30
    132a:	88 0f       	add	r24, r24
    132c:	99 1f       	adc	r25, r25
    132e:	88 0f       	add	r24, r24
    1330:	99 1f       	adc	r25, r25
    1332:	e8 0f       	add	r30, r24
    1334:	f9 1f       	adc	r31, r25
    1336:	e2 5e       	subi	r30, 0xE2	; 226
    1338:	fb 4f       	sbci	r31, 0xFB	; 251
    133a:	20 81       	ld	r18, Z
    133c:	31 81       	ldd	r19, Z+1	; 0x01
    133e:	e4 2f       	mov	r30, r20
    1340:	f0 e0       	ldi	r31, 0x00	; 0
    1342:	ee 0f       	add	r30, r30
    1344:	ff 1f       	adc	r31, r31
    1346:	ee 0f       	add	r30, r30
    1348:	ff 1f       	adc	r31, r31
    134a:	cf 01       	movw	r24, r30
    134c:	88 0f       	add	r24, r24
    134e:	99 1f       	adc	r25, r25
    1350:	88 0f       	add	r24, r24
    1352:	99 1f       	adc	r25, r25
    1354:	e8 0f       	add	r30, r24
    1356:	f9 1f       	adc	r31, r25
    1358:	ee 0f       	add	r30, r30
    135a:	ff 1f       	adc	r31, r31
    135c:	e0 5e       	subi	r30, 0xE0	; 224
    135e:	fb 4f       	sbci	r31, 0xFB	; 251
    1360:	31 83       	std	Z+1, r19	; 0x01
    1362:	20 83       	st	Z, r18
        motor[i].desiredPosition += -1;
    1364:	e4 2f       	mov	r30, r20
    1366:	f0 e0       	ldi	r31, 0x00	; 0
    1368:	ee 0f       	add	r30, r30
    136a:	ff 1f       	adc	r31, r31
    136c:	ee 0f       	add	r30, r30
    136e:	ff 1f       	adc	r31, r31
    1370:	cf 01       	movw	r24, r30
    1372:	88 0f       	add	r24, r24
    1374:	99 1f       	adc	r25, r25
    1376:	88 0f       	add	r24, r24
    1378:	99 1f       	adc	r25, r25
    137a:	e8 0f       	add	r30, r24
    137c:	f9 1f       	adc	r31, r25
    137e:	ee 0f       	add	r30, r30
    1380:	ff 1f       	adc	r31, r31
    1382:	e0 5e       	subi	r30, 0xE0	; 224
    1384:	fb 4f       	sbci	r31, 0xFB	; 251
    1386:	20 81       	ld	r18, Z
    1388:	31 81       	ldd	r19, Z+1	; 0x01
    138a:	21 50       	subi	r18, 0x01	; 1
    138c:	30 40       	sbci	r19, 0x00	; 0
    138e:	4c cf       	rjmp	.-360    	; 0x1228 <setConstSpeed+0x5a>

00001390 <getPortExpanderAddress>:
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    1390:	81 30       	cpi	r24, 0x01	; 1
    1392:	61 f0       	breq	.+24     	; 0x13ac <getPortExpanderAddress+0x1c>
    1394:	81 30       	cpi	r24, 0x01	; 1
    1396:	30 f0       	brcs	.+12     	; 0x13a4 <getPortExpanderAddress+0x14>
    1398:	82 30       	cpi	r24, 0x02	; 2
    139a:	51 f0       	breq	.+20     	; 0x13b0 <getPortExpanderAddress+0x20>
    139c:	83 30       	cpi	r24, 0x03	; 3
    139e:	21 f0       	breq	.+8      	; 0x13a8 <getPortExpanderAddress+0x18>
      addr = IIC_MOTOR2_PORTEXP_ADDR;
      break;

    case MOTOR3:
      addr = IIC_MOTOR3_PORTEXP_ADDR;
      break;
    13a0:	80 e0       	ldi	r24, 0x00	; 0
    default:
      addr = 0;
  }

  return addr;
}
    13a2:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    13a4:	82 e4       	ldi	r24, 0x42	; 66
    13a6:	08 95       	ret
      addr = IIC_MOTOR1_PORTEXP_ADDR;
      break;

    case MOTOR2:
      addr = IIC_MOTOR2_PORTEXP_ADDR;
      break;
    13a8:	88 e4       	ldi	r24, 0x48	; 72
    13aa:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getPortExpanderAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    13ac:	84 e4       	ldi	r24, 0x44	; 68
    13ae:	08 95       	ret
    13b0:	86 e4       	ldi	r24, 0x46	; 70
    13b2:	08 95       	ret

000013b4 <getDACAddress>:
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    13b4:	81 30       	cpi	r24, 0x01	; 1
    13b6:	61 f0       	breq	.+24     	; 0x13d0 <getDACAddress+0x1c>
    13b8:	81 30       	cpi	r24, 0x01	; 1
    13ba:	30 f0       	brcs	.+12     	; 0x13c8 <getDACAddress+0x14>
    13bc:	82 30       	cpi	r24, 0x02	; 2
    13be:	51 f0       	breq	.+20     	; 0x13d4 <getDACAddress+0x20>
    13c0:	83 30       	cpi	r24, 0x03	; 3
    13c2:	21 f0       	breq	.+8      	; 0x13cc <getDACAddress+0x18>
      addr = IIC_MOTOR2_DAC_ADDR;
      break;

    case MOTOR3:
      addr = IIC_MOTOR3_DAC_ADDR;
      break;
    13c4:	80 e0       	ldi	r24, 0x00	; 0
    default:
      addr = 0;
  }

  return addr;
}
    13c6:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    13c8:	82 e1       	ldi	r24, 0x12	; 18
    13ca:	08 95       	ret
      addr = IIC_MOTOR1_DAC_ADDR;
      break;

    case MOTOR2:
      addr = IIC_MOTOR2_DAC_ADDR;
      break;
    13cc:	8c e9       	ldi	r24, 0x9C	; 156
    13ce:	08 95       	ret
 --------------------------------------------------------------------- */
uint8_t getDACAddress(uint8_t mot){

  uint8_t addr = 0;

  switch(mot){
    13d0:	84 e1       	ldi	r24, 0x14	; 20
    13d2:	08 95       	ret
    13d4:	8a e9       	ldi	r24, 0x9A	; 154
    13d6:	08 95       	ret

000013d8 <reverseBitOrder>:
   because of reversed bit order :'-(
   ... shit happens
 --------------------------------------------------------------------- */
uint8_t reverseBitOrder(uint8_t b){

  b = (b & 0xF0) >> 4 | (b & 0x0F) << 4;
    13d8:	28 2f       	mov	r18, r24
    13da:	22 95       	swap	r18
    13dc:	2f 70       	andi	r18, 0x0F	; 15
    13de:	82 95       	swap	r24
    13e0:	80 7f       	andi	r24, 0xF0	; 240
    13e2:	28 2b       	or	r18, r24
  b = (b & 0xCC) >> 2 | (b & 0x33) << 2;
    13e4:	30 e0       	ldi	r19, 0x00	; 0
    13e6:	c9 01       	movw	r24, r18
    13e8:	83 73       	andi	r24, 0x33	; 51
    13ea:	90 70       	andi	r25, 0x00	; 0
    13ec:	88 0f       	add	r24, r24
    13ee:	99 1f       	adc	r25, r25
    13f0:	88 0f       	add	r24, r24
    13f2:	99 1f       	adc	r25, r25
    13f4:	2c 7c       	andi	r18, 0xCC	; 204
    13f6:	30 70       	andi	r19, 0x00	; 0
    13f8:	35 95       	asr	r19
    13fa:	27 95       	ror	r18
    13fc:	35 95       	asr	r19
    13fe:	27 95       	ror	r18
    1400:	82 2b       	or	r24, r18
  b = (b & 0xAA) >> 1 | (b & 0x55) << 1;
    1402:	28 2f       	mov	r18, r24
    1404:	30 e0       	ldi	r19, 0x00	; 0
    1406:	c9 01       	movw	r24, r18
    1408:	85 75       	andi	r24, 0x55	; 85
    140a:	90 70       	andi	r25, 0x00	; 0
    140c:	88 0f       	add	r24, r24
    140e:	99 1f       	adc	r25, r25
    1410:	2a 7a       	andi	r18, 0xAA	; 170
    1412:	30 70       	andi	r19, 0x00	; 0
    1414:	35 95       	asr	r19
    1416:	27 95       	ror	r18

  return b;
}
    1418:	82 2b       	or	r24, r18
    141a:	08 95       	ret

0000141c <getSubSteps>:
uint8_t getSubSteps(uint8_t mot){

  uint8_t steps = 0;

  return steps;
}
    141c:	80 e0       	ldi	r24, 0x00	; 0
    141e:	08 95       	ret

00001420 <getButtonEvent>:
uint8_t getButtonEvent(void){

  uint8_t state = 0;
  uint8_t button = NO_BUTTON;

  if(buttonState.readyToProcess){
    1420:	80 91 0c 03 	lds	r24, 0x030C
    1424:	88 23       	and	r24, r24
    1426:	a1 f0       	breq	.+40     	; 0x1450 <getButtonEvent+0x30>
    /* a button has been pressed */
    state = buttonState.inputRegister;
    1428:	90 91 0a 03 	lds	r25, 0x030A
	
	if(rotEnc.buttonPressed){
    142c:	80 91 ff 03 	lds	r24, 0x03FF
    1430:	88 23       	and	r24, r24
    1432:	61 f4       	brne	.+24     	; 0x144c <getButtonEvent+0x2c>
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
    1434:	97 fd       	sbrc	r25, 7
    1436:	10 c0       	rjmp	.+32     	; 0x1458 <getButtonEvent+0x38>
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
    1438:	96 fd       	sbrc	r25, 6
    143a:	0c c0       	rjmp	.+24     	; 0x1454 <getButtonEvent+0x34>
      button = BUTTON_MOTOR1;
    }
    else if(state & (1<<BUTTON_MOTOR2)){
    143c:	95 fd       	sbrc	r25, 5
    143e:	0e c0       	rjmp	.+28     	; 0x145c <getButtonEvent+0x3c>
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
    1440:	94 fd       	sbrc	r25, 4
    1442:	0e c0       	rjmp	.+28     	; 0x1460 <getButtonEvent+0x40>
      button = BUTTON_MOTOR3;
    }
    else if(state & (1<<BUTTON_MENUESCAPE)){
    1444:	93 ff       	sbrs	r25, 3
    1446:	04 c0       	rjmp	.+8      	; 0x1450 <getButtonEvent+0x30>
    1448:	83 e0       	ldi	r24, 0x03	; 3
    144a:	08 95       	ret

  if(buttonState.readyToProcess){
    /* a button has been pressed */
    state = buttonState.inputRegister;
	
	if(rotEnc.buttonPressed){
    144c:	88 e0       	ldi	r24, 0x08	; 8
    144e:	08 95       	ret
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
      button = BUTTON_MOTOR3;
    }
    else if(state & (1<<BUTTON_MENUESCAPE)){
    1450:	8a e2       	ldi	r24, 0x2A	; 42
      button = NO_BUTTON;
    }
  }

  return button;
}
    1452:	08 95       	ret
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
    1454:	86 e0       	ldi	r24, 0x06	; 6
    1456:	08 95       	ret
    state = buttonState.inputRegister;
	
	if(rotEnc.buttonPressed){
      button = BUTTON_ROT_ENC_PRESS;
	}
	else if(state & (1<<BUTTON_MOTOR0)){
    1458:	87 e0       	ldi	r24, 0x07	; 7
    145a:	08 95       	ret
      button = BUTTON_MOTOR0;
    }
    else if(state & (1<<BUTTON_MOTOR1)){
      button = BUTTON_MOTOR1;
    }
    else if(state & (1<<BUTTON_MOTOR2)){
    145c:	85 e0       	ldi	r24, 0x05	; 5
    145e:	08 95       	ret
      button = BUTTON_MOTOR2;
    }
    else if(state & (1<<BUTTON_MOTOR3)){
    1460:	84 e0       	ldi	r24, 0x04	; 4
    1462:	08 95       	ret

00001464 <getRotaryEncoderEvent>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1464:	f8 94       	cli
   */

  int8_t steps = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(rotEnc.readyToProcess){
    1466:	80 91 fe 03 	lds	r24, 0x03FE
    146a:	88 23       	and	r24, r24
    146c:	21 f0       	breq	.+8      	; 0x1476 <getRotaryEncoderEvent+0x12>
      steps = rotEnc.steps;
    146e:	80 91 fd 03 	lds	r24, 0x03FD
      rotEnc.steps = 0;
    1472:	10 92 fd 03 	sts	0x03FD, r1
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1476:	78 94       	sei
    }
  }
  return steps;
}
    1478:	08 95       	ret

0000147a <__vector_20>:
    A character in the USART receive buffer is ready for fetch.
    Build up the command string for parsing here. If the
    rxSerial.readyToProcess is NOT zero, the actual command
    in the buffer is not parsed yet. In this case refuse the new char.
 --------------------------------------------------------------------- */
ISR(USART0_RX_vect){
    147a:	1f 92       	push	r1
    147c:	0f 92       	push	r0
    147e:	0f b6       	in	r0, 0x3f	; 63
    1480:	0f 92       	push	r0
    1482:	0b b6       	in	r0, 0x3b	; 59
    1484:	0f 92       	push	r0
    1486:	11 24       	eor	r1, r1
    1488:	8f 93       	push	r24
    148a:	9f 93       	push	r25
    148c:	ef 93       	push	r30
    148e:	ff 93       	push	r31

  uint8_t c;

  c = UDR0;
    1490:	90 91 c6 00 	lds	r25, 0x00C6

  if(rxString.readyToProcess == 0){ /* actual rxString in buffer not parsed yet */
    1494:	80 91 1e 03 	lds	r24, 0x031E
    1498:	88 23       	and	r24, r24
    149a:	e1 f4       	brne	.+56     	; 0x14d4 <__vector_20+0x5a>
    if(c == '\r'){
    149c:	9d 30       	cpi	r25, 0x0D	; 13
    149e:	09 f1       	breq	.+66     	; 0x14e2 <__vector_20+0x68>
      /* get rid of windoze line ending overhead bullshit */
      return;
    }
    if((c != '\n') && (rxString.charCount < SERIAL_BUFFERSIZE)){
    14a0:	9a 30       	cpi	r25, 0x0A	; 10
    14a2:	21 f0       	breq	.+8      	; 0x14ac <__vector_20+0x32>
    14a4:	80 91 1f 03 	lds	r24, 0x031F
    14a8:	80 34       	cpi	r24, 0x40	; 64
    14aa:	30 f1       	brcs	.+76     	; 0x14f8 <__vector_20+0x7e>
      rxString.buffer[rxString.charCount] = c;
      rxString.charCount++;
    }
    else{
      /* end of command */
      rxString.buffer[rxString.charCount] = '\0';
    14ac:	e0 91 1c 03 	lds	r30, 0x031C
    14b0:	f0 91 1d 03 	lds	r31, 0x031D
    14b4:	80 91 1f 03 	lds	r24, 0x031F
    14b8:	e8 0f       	add	r30, r24
    14ba:	f1 1d       	adc	r31, r1
    14bc:	10 82       	st	Z, r1
      rxString.readyToProcess = 1;
    14be:	81 e0       	ldi	r24, 0x01	; 1
    14c0:	80 93 1e 03 	sts	0x031E, r24
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    14c4:	80 91 c0 00 	lds	r24, 0x00C0
    14c8:	85 ff       	sbrs	r24, 5
    14ca:	fc cf       	rjmp	.-8      	; 0x14c4 <__vector_20+0x4a>
    ;
  }

  UDR0 = c;
    14cc:	86 e0       	ldi	r24, 0x06	; 6
    14ce:	80 93 c6 00 	sts	0x00C6, r24
    14d2:	07 c0       	rjmp	.+14     	; 0x14e2 <__vector_20+0x68>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    14d4:	80 91 c0 00 	lds	r24, 0x00C0
    14d8:	85 ff       	sbrs	r24, 5
    14da:	fc cf       	rjmp	.-8      	; 0x14d4 <__vector_20+0x5a>
    ;
  }

  UDR0 = c;
    14dc:	85 e1       	ldi	r24, 0x15	; 21
    14de:	80 93 c6 00 	sts	0x00C6, r24
  else{ /* actual command in buffer is not processed yet */
    sendChar(0x15);   /* send a NAK */
  }

  return;
}
    14e2:	ff 91       	pop	r31
    14e4:	ef 91       	pop	r30
    14e6:	9f 91       	pop	r25
    14e8:	8f 91       	pop	r24
    14ea:	0f 90       	pop	r0
    14ec:	0b be       	out	0x3b, r0	; 59
    14ee:	0f 90       	pop	r0
    14f0:	0f be       	out	0x3f, r0	; 63
    14f2:	0f 90       	pop	r0
    14f4:	1f 90       	pop	r1
    14f6:	18 95       	reti
    if(c == '\r'){
      /* get rid of windoze line ending overhead bullshit */
      return;
    }
    if((c != '\n') && (rxString.charCount < SERIAL_BUFFERSIZE)){
      rxString.buffer[rxString.charCount] = c;
    14f8:	e0 91 1c 03 	lds	r30, 0x031C
    14fc:	f0 91 1d 03 	lds	r31, 0x031D
    1500:	80 91 1f 03 	lds	r24, 0x031F
    1504:	e8 0f       	add	r30, r24
    1506:	f1 1d       	adc	r31, r1
    1508:	90 83       	st	Z, r25
      rxString.charCount++;
    150a:	80 91 1f 03 	lds	r24, 0x031F
    150e:	8f 5f       	subi	r24, 0xFF	; 255
    1510:	80 93 1f 03 	sts	0x031F, r24
    1514:	e6 cf       	rjmp	.-52     	; 0x14e2 <__vector_20+0x68>

00001516 <__vector_16>:

/* ---------------------------------------------------------------------
    if any button is pressed or turned, this interrupt will
    handle the reaction
 --------------------------------------------------------------------- */
ISR(TIMER0_COMPA_vect){
    1516:	1f 92       	push	r1
    1518:	0f 92       	push	r0
    151a:	0f b6       	in	r0, 0x3f	; 63
    151c:	0f 92       	push	r0
    151e:	0b b6       	in	r0, 0x3b	; 59
    1520:	0f 92       	push	r0
    1522:	11 24       	eor	r1, r1
    1524:	8f 93       	push	r24
    1526:	ef 93       	push	r30
    1528:	ff 93       	push	r31

  uint8_t inputReg = 0;
  static int16_t last = 0;  /* save old rotEnc value */

  inputReg = PINC;  /* rotEnc is connected to PORTC */
    152a:	86 b1       	in	r24, 0x06	; 6

  /* handle rotEnc's button */
  if((inputReg^0xFF) & (1<<BUTTON_ROT_ENC)){
    152c:	80 95       	com	r24
    152e:	83 ff       	sbrs	r24, 3
    1530:	3a c0       	rjmp	.+116    	; 0x15a6 <__vector_16+0x90>
    /* button was pressed */
    if(rotEnc.buttonDebounce == 0){
    1532:	80 91 00 04 	lds	r24, 0x0400
    1536:	88 23       	and	r24, r24
    1538:	09 f4       	brne	.+2      	; 0x153c <__vector_16+0x26>
    153a:	40 c0       	rjmp	.+128    	; 0x15bc <__vector_16+0xa6>
  /* now care about the rotary encoder rotations
   *
   * code from:
   * http://www.mikrocontroller.net/articles/Drehgeber
   */
  last = (last << 2) & 0x0F;
    153c:	e0 91 06 03 	lds	r30, 0x0306
    1540:	f0 91 07 03 	lds	r31, 0x0307
    1544:	ee 0f       	add	r30, r30
    1546:	ff 1f       	adc	r31, r31
    1548:	ee 0f       	add	r30, r30
    154a:	ff 1f       	adc	r31, r31
    154c:	ef 70       	andi	r30, 0x0F	; 15
    154e:	f0 70       	andi	r31, 0x00	; 0
    1550:	f0 93 07 03 	sts	0x0307, r31
    1554:	e0 93 06 03 	sts	0x0306, r30
  if(PHASE_A){
    1558:	35 9b       	sbis	0x06, 5	; 6
    155a:	05 c0       	rjmp	.+10     	; 0x1566 <__vector_16+0x50>
    last |= 2;
    155c:	e2 60       	ori	r30, 0x02	; 2
    155e:	f0 93 07 03 	sts	0x0307, r31
    1562:	e0 93 06 03 	sts	0x0306, r30
  }
  if(PHASE_B){
    1566:	34 9b       	sbis	0x06, 4	; 6
    1568:	05 c0       	rjmp	.+10     	; 0x1574 <__vector_16+0x5e>
    last |= 1;
    156a:	e1 60       	ori	r30, 0x01	; 1
    156c:	f0 93 07 03 	sts	0x0307, r31
    1570:	e0 93 06 03 	sts	0x0306, r30
  }
  if(pgm_read_byte(&table[last])){
    1574:	ee 0f       	add	r30, r30
    1576:	ff 1f       	adc	r31, r31
    1578:	e8 50       	subi	r30, 0x08	; 8
    157a:	ff 4f       	sbci	r31, 0xFF	; 255
    157c:	e4 91       	lpm	r30, Z+
    157e:	ee 23       	and	r30, r30
    1580:	41 f0       	breq	.+16     	; 0x1592 <__vector_16+0x7c>
    rotEnc.steps += pgm_read_byte(&table[last]);
    1582:	80 91 fd 03 	lds	r24, 0x03FD
    1586:	e8 0f       	add	r30, r24
    1588:	e0 93 fd 03 	sts	0x03FD, r30
    rotEnc.readyToProcess = 1;
    158c:	81 e0       	ldi	r24, 0x01	; 1
    158e:	80 93 fe 03 	sts	0x03FE, r24
  }
}
    1592:	ff 91       	pop	r31
    1594:	ef 91       	pop	r30
    1596:	8f 91       	pop	r24
    1598:	0f 90       	pop	r0
    159a:	0b be       	out	0x3b, r0	; 59
    159c:	0f 90       	pop	r0
    159e:	0f be       	out	0x3f, r0	; 63
    15a0:	0f 90       	pop	r0
    15a2:	1f 90       	pop	r1
    15a4:	18 95       	reti
	  rotEnc.buttonDebounce = 1;
    }
  }
  else{
      /* button is no longer pressed ...*/
      if(rotEnc.buttonDebounce == 1){
    15a6:	80 91 00 04 	lds	r24, 0x0400
    15aa:	81 30       	cpi	r24, 0x01	; 1
    15ac:	39 f6       	brne	.-114    	; 0x153c <__vector_16+0x26>
        /* ... and we are already in debouncing mode -> generate event */
        rotEnc.buttonPressed = 1;
    15ae:	80 93 ff 03 	sts	0x03FF, r24
        rotEnc.buttonDebounce = 0;
    15b2:	10 92 00 04 	sts	0x0400, r1
        buttonState.readyToProcess = 1;
    15b6:	80 93 0c 03 	sts	0x030C, r24
    15ba:	c0 cf       	rjmp	.-128    	; 0x153c <__vector_16+0x26>
  /* handle rotEnc's button */
  if((inputReg^0xFF) & (1<<BUTTON_ROT_ENC)){
    /* button was pressed */
    if(rotEnc.buttonDebounce == 0){
      // enter debouncing mode
	  rotEnc.buttonDebounce = 1;
    15bc:	81 e0       	ldi	r24, 0x01	; 1
    15be:	80 93 00 04 	sts	0x0400, r24
    15c2:	bc cf       	rjmp	.-136    	; 0x153c <__vector_16+0x26>

000015c4 <loadConfigFromEEPROM>:
}

/* ---------------------------------------------------------------------
    load last stored motor configuration from EEPROM
 --------------------------------------------------------------------- */
void loadConfigFromEEPROM(void){
    15c4:	7f 92       	push	r7
    15c6:	8f 92       	push	r8
    15c8:	9f 92       	push	r9
    15ca:	af 92       	push	r10
    15cc:	bf 92       	push	r11
    15ce:	cf 92       	push	r12
    15d0:	df 92       	push	r13
    15d2:	ef 92       	push	r14
    15d4:	ff 92       	push	r15
    15d6:	0f 93       	push	r16
    15d8:	1f 93       	push	r17
    15da:	cf 93       	push	r28
    15dc:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    15de:	f8 94       	cli
    15e0:	cc 24       	eor	r12, r12
    15e2:	dd 24       	eor	r13, r13
    15e4:	88 24       	eor	r8, r8
    15e6:	99 24       	eor	r9, r9
    15e8:	aa 24       	eor	r10, r10
    15ea:	bb 24       	eor	r11, r11
      eeprom_read_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
      eeprom_read_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));

      /* activate forbidden zone if necessary */
      if(forbiddenZone[i].start != forbiddenZone[i].stop){
        forbiddenZone[i].active = 1;
    15ec:	77 24       	eor	r7, r7
    15ee:	73 94       	inc	r7

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
      eeprom_read_block(&(motor[i].opticalZeroPosition), &(opticalZeroPositionEE[i]), sizeof(int16_t));
    15f0:	c6 01       	movw	r24, r12
    15f2:	88 0f       	add	r24, r24
    15f4:	99 1f       	adc	r25, r25
    15f6:	86 01       	movw	r16, r12
    15f8:	00 0f       	add	r16, r16
    15fa:	11 1f       	adc	r17, r17
    15fc:	00 0f       	add	r16, r16
    15fe:	11 1f       	adc	r17, r17
    1600:	00 0f       	add	r16, r16
    1602:	11 1f       	adc	r17, r17
    1604:	80 0f       	add	r24, r16
    1606:	91 1f       	adc	r25, r17
    1608:	88 0f       	add	r24, r24
    160a:	99 1f       	adc	r25, r25
    160c:	88 0f       	add	r24, r24
    160e:	99 1f       	adc	r25, r25
    1610:	b4 01       	movw	r22, r8
    1612:	6d 5c       	subi	r22, 0xCD	; 205
    1614:	7f 4f       	sbci	r23, 0xFF	; 255
    1616:	8e 5d       	subi	r24, 0xDE	; 222
    1618:	9b 4f       	sbci	r25, 0xFB	; 251
    161a:	42 e0       	ldi	r20, 0x02	; 2
    161c:	50 e0       	ldi	r21, 0x00	; 0
    161e:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].gearRatio), &(gearRatioEE[i]), sizeof(double));
    1622:	78 01       	movw	r14, r16
    1624:	ee 0c       	add	r14, r14
    1626:	ff 1c       	adc	r15, r15
    1628:	ee 0c       	add	r14, r14
    162a:	ff 1c       	adc	r15, r15
    162c:	e0 0e       	add	r14, r16
    162e:	f1 1e       	adc	r15, r17
    1630:	b5 01       	movw	r22, r10
    1632:	65 5c       	subi	r22, 0xC5	; 197
    1634:	7f 4f       	sbci	r23, 0xFF	; 255
    1636:	c7 01       	movw	r24, r14
    1638:	85 5d       	subi	r24, 0xD5	; 213
    163a:	9b 4f       	sbci	r25, 0xFB	; 251
    163c:	44 e0       	ldi	r20, 0x04	; 4
    163e:	50 e0       	ldi	r21, 0x00	; 0
    1640:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepsPerFullRotation), &(stepsPerFullRotationEE[i]), sizeof(double));
    1644:	b5 01       	movw	r22, r10
    1646:	65 5b       	subi	r22, 0xB5	; 181
    1648:	7f 4f       	sbci	r23, 0xFF	; 255
    164a:	c7 01       	movw	r24, r14
    164c:	81 5d       	subi	r24, 0xD1	; 209
    164e:	9b 4f       	sbci	r25, 0xFB	; 251
    1650:	44 e0       	ldi	r20, 0x04	; 4
    1652:	50 e0       	ldi	r21, 0x00	; 0
    1654:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].subSteps), &(subStepsEE[i]), sizeof(double));
    1658:	b5 01       	movw	r22, r10
    165a:	65 5a       	subi	r22, 0xA5	; 165
    165c:	7f 4f       	sbci	r23, 0xFF	; 255
    165e:	c7 01       	movw	r24, r14
    1660:	8d 5c       	subi	r24, 0xCD	; 205
    1662:	9b 4f       	sbci	r25, 0xFB	; 251
    1664:	44 e0       	ldi	r20, 0x04	; 4
    1666:	50 e0       	ldi	r21, 0x00	; 0
    1668:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepMultiplier), &(stepMultiplierEE[i]), sizeof(double));
    166c:	b5 01       	movw	r22, r10
    166e:	65 59       	subi	r22, 0x95	; 149
    1670:	7f 4f       	sbci	r23, 0xFF	; 255
    1672:	c7 01       	movw	r24, r14
    1674:	88 5c       	subi	r24, 0xC8	; 200
    1676:	9b 4f       	sbci	r25, 0xFB	; 251
    1678:	44 e0       	ldi	r20, 0x04	; 4
    167a:	50 e0       	ldi	r21, 0x00	; 0
    167c:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
	    eeprom_read_block(&(motor[i].current), &(currentEE[i]), sizeof(double));
    1680:	b5 01       	movw	r22, r10
    1682:	65 58       	subi	r22, 0x85	; 133
    1684:	7f 4f       	sbci	r23, 0xFF	; 255
    1686:	c7 01       	movw	r24, r14
    1688:	8f 5b       	subi	r24, 0xBF	; 191
    168a:	9b 4f       	sbci	r25, 0xFB	; 251
    168c:	44 e0       	ldi	r20, 0x04	; 4
    168e:	50 e0       	ldi	r21, 0x00	; 0
    1690:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].decay), &(decayEE[i]), sizeof(int8_t));
    1694:	b6 01       	movw	r22, r12
    1696:	65 57       	subi	r22, 0x75	; 117
    1698:	7f 4f       	sbci	r23, 0xFF	; 255
    169a:	c7 01       	movw	r24, r14
    169c:	8b 5b       	subi	r24, 0xBB	; 187
    169e:	9b 4f       	sbci	r25, 0xFB	; 251
    16a0:	41 e0       	ldi	r20, 0x01	; 1
    16a2:	50 e0       	ldi	r21, 0x00	; 0
    16a4:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].stepUnit), &(stepUnitEE[i]), sizeof(int8_t));
    16a8:	b6 01       	movw	r22, r12
    16aa:	61 57       	subi	r22, 0x71	; 113
    16ac:	7f 4f       	sbci	r23, 0xFF	; 255
    16ae:	c7 01       	movw	r24, r14
    16b0:	89 5c       	subi	r24, 0xC9	; 201
    16b2:	9b 4f       	sbci	r25, 0xFB	; 251
    16b4:	41 e0       	ldi	r20, 0x01	; 1
    16b6:	50 e0       	ldi	r21, 0x00	; 0
    16b8:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(motor[i].waitBetweenSteps), &(waitBetweenStepsEE[i]), sizeof(int16_t));
    16bc:	b4 01       	movw	r22, r8
    16be:	6d 56       	subi	r22, 0x6D	; 109
    16c0:	7f 4f       	sbci	r23, 0xFF	; 255
    16c2:	c7 01       	movw	r24, r14
    16c4:	84 5c       	subi	r24, 0xC4	; 196
    16c6:	9b 4f       	sbci	r25, 0xFB	; 251
    16c8:	42 e0       	ldi	r20, 0x02	; 2
    16ca:	50 e0       	ldi	r21, 0x00	; 0
    16cc:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>

      eeprom_read_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
    16d0:	86 01       	movw	r16, r12
    16d2:	00 0f       	add	r16, r16
    16d4:	11 1f       	adc	r17, r17
    16d6:	00 0f       	add	r16, r16
    16d8:	11 1f       	adc	r17, r17
    16da:	0c 0d       	add	r16, r12
    16dc:	1d 1d       	adc	r17, r13
    16de:	e8 01       	movw	r28, r16
    16e0:	cf 5f       	subi	r28, 0xFF	; 255
    16e2:	db 4f       	sbci	r29, 0xFB	; 251
    16e4:	b4 01       	movw	r22, r8
    16e6:	65 56       	subi	r22, 0x65	; 101
    16e8:	7f 4f       	sbci	r23, 0xFF	; 255
    16ea:	ce 01       	movw	r24, r28
    16ec:	42 e0       	ldi	r20, 0x02	; 2
    16ee:	50 e0       	ldi	r21, 0x00	; 0
    16f0:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
      eeprom_read_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    16f4:	b4 01       	movw	r22, r8
    16f6:	6d 55       	subi	r22, 0x5D	; 93
    16f8:	7f 4f       	sbci	r23, 0xFF	; 255
    16fa:	c8 01       	movw	r24, r16
    16fc:	8d 5f       	subi	r24, 0xFD	; 253
    16fe:	9b 4f       	sbci	r25, 0xFB	; 251
    1700:	42 e0       	ldi	r20, 0x02	; 2
    1702:	50 e0       	ldi	r21, 0x00	; 0
    1704:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>

      /* activate forbidden zone if necessary */
      if(forbiddenZone[i].start != forbiddenZone[i].stop){
    1708:	28 81       	ld	r18, Y
    170a:	39 81       	ldd	r19, Y+1	; 0x01
    170c:	8a 81       	ldd	r24, Y+2	; 0x02
    170e:	9b 81       	ldd	r25, Y+3	; 0x03
    1710:	28 17       	cp	r18, r24
    1712:	39 07       	cpc	r19, r25
    1714:	09 f0       	breq	.+2      	; 0x1718 <loadConfigFromEEPROM+0x154>
        forbiddenZone[i].active = 1;
    1716:	7c 82       	std	Y+4, r7	; 0x04
    1718:	08 94       	sec
    171a:	c1 1c       	adc	r12, r1
    171c:	d1 1c       	adc	r13, r1
    171e:	82 e0       	ldi	r24, 0x02	; 2
    1720:	90 e0       	ldi	r25, 0x00	; 0
    1722:	88 0e       	add	r8, r24
    1724:	99 1e       	adc	r9, r25
    1726:	84 e0       	ldi	r24, 0x04	; 4
    1728:	90 e0       	ldi	r25, 0x00	; 0
    172a:	a8 0e       	add	r10, r24
    172c:	b9 1e       	adc	r11, r25
void loadConfigFromEEPROM(void){

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
    172e:	94 e0       	ldi	r25, 0x04	; 4
    1730:	c9 16       	cp	r12, r25
    1732:	d1 04       	cpc	r13, r1
    1734:	09 f0       	breq	.+2      	; 0x1738 <loadConfigFromEEPROM+0x174>
    1736:	5c cf       	rjmp	.-328    	; 0x15f0 <loadConfigFromEEPROM+0x2c>
    1738:	c0 e0       	ldi	r28, 0x00	; 0
    173a:	d0 e0       	ldi	r29, 0x00	; 0
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* load internal stores programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
      eeprom_read_block(&(programList[i]), &(programListEE[i]), sizeof(progStep));
    173c:	be 01       	movw	r22, r28
    173e:	65 55       	subi	r22, 0x55	; 85
    1740:	7f 4f       	sbci	r23, 0xFF	; 255
    1742:	ce 01       	movw	r24, r28
    1744:	8f 5d       	subi	r24, 0xDF	; 223
    1746:	9c 4f       	sbci	r25, 0xFC	; 252
    1748:	4a e0       	ldi	r20, 0x0A	; 10
    174a:	50 e0       	ldi	r21, 0x00	; 0
    174c:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
    1750:	2a 96       	adiw	r28, 0x0a	; 10
      }
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* load internal stores programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    1752:	c0 3a       	cpi	r28, 0xA0	; 160
    1754:	d1 05       	cpc	r29, r1
    1756:	91 f7       	brne	.-28     	; 0x173c <loadConfigFromEEPROM+0x178>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1758:	78 94       	sei
#endif

  }

  return;
}
    175a:	df 91       	pop	r29
    175c:	cf 91       	pop	r28
    175e:	1f 91       	pop	r17
    1760:	0f 91       	pop	r16
    1762:	ff 90       	pop	r15
    1764:	ef 90       	pop	r14
    1766:	df 90       	pop	r13
    1768:	cf 90       	pop	r12
    176a:	bf 90       	pop	r11
    176c:	af 90       	pop	r10
    176e:	9f 90       	pop	r9
    1770:	8f 90       	pop	r8
    1772:	7f 90       	pop	r7
    1774:	08 95       	ret

00001776 <saveConfigToEEPROM>:
}

/* ---------------------------------------------------------------------
    save current motor configuration to EEPROM
 --------------------------------------------------------------------- */
void saveConfigToEEPROM(void){
    1776:	af 92       	push	r10
    1778:	bf 92       	push	r11
    177a:	cf 92       	push	r12
    177c:	df 92       	push	r13
    177e:	ef 92       	push	r14
    1780:	ff 92       	push	r15
    1782:	0f 93       	push	r16
    1784:	1f 93       	push	r17
    1786:	cf 93       	push	r28
    1788:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    178a:	f8 94       	cli
    178c:	c0 e0       	ldi	r28, 0x00	; 0
    178e:	d0 e0       	ldi	r29, 0x00	; 0
    1790:	aa 24       	eor	r10, r10
    1792:	bb 24       	eor	r11, r11
    1794:	cc 24       	eor	r12, r12
    1796:	dd 24       	eor	r13, r13

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
      eeprom_update_block(&(motor[i].opticalZeroPosition), &(opticalZeroPositionEE[i]), sizeof(int16_t));
    1798:	ce 01       	movw	r24, r28
    179a:	88 0f       	add	r24, r24
    179c:	99 1f       	adc	r25, r25
    179e:	8e 01       	movw	r16, r28
    17a0:	00 0f       	add	r16, r16
    17a2:	11 1f       	adc	r17, r17
    17a4:	00 0f       	add	r16, r16
    17a6:	11 1f       	adc	r17, r17
    17a8:	00 0f       	add	r16, r16
    17aa:	11 1f       	adc	r17, r17
    17ac:	80 0f       	add	r24, r16
    17ae:	91 1f       	adc	r25, r17
    17b0:	88 0f       	add	r24, r24
    17b2:	99 1f       	adc	r25, r25
    17b4:	88 0f       	add	r24, r24
    17b6:	99 1f       	adc	r25, r25
    17b8:	b5 01       	movw	r22, r10
    17ba:	6d 5c       	subi	r22, 0xCD	; 205
    17bc:	7f 4f       	sbci	r23, 0xFF	; 255
    17be:	8e 5d       	subi	r24, 0xDE	; 222
    17c0:	9b 4f       	sbci	r25, 0xFB	; 251
    17c2:	42 e0       	ldi	r20, 0x02	; 2
    17c4:	50 e0       	ldi	r21, 0x00	; 0
    17c6:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].gearRatio), &(gearRatioEE[i]), sizeof(double));
    17ca:	78 01       	movw	r14, r16
    17cc:	ee 0c       	add	r14, r14
    17ce:	ff 1c       	adc	r15, r15
    17d0:	ee 0c       	add	r14, r14
    17d2:	ff 1c       	adc	r15, r15
    17d4:	e0 0e       	add	r14, r16
    17d6:	f1 1e       	adc	r15, r17
    17d8:	b6 01       	movw	r22, r12
    17da:	65 5c       	subi	r22, 0xC5	; 197
    17dc:	7f 4f       	sbci	r23, 0xFF	; 255
    17de:	c7 01       	movw	r24, r14
    17e0:	85 5d       	subi	r24, 0xD5	; 213
    17e2:	9b 4f       	sbci	r25, 0xFB	; 251
    17e4:	44 e0       	ldi	r20, 0x04	; 4
    17e6:	50 e0       	ldi	r21, 0x00	; 0
    17e8:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepsPerFullRotation), &(stepsPerFullRotationEE[i]), sizeof(double));
    17ec:	b6 01       	movw	r22, r12
    17ee:	65 5b       	subi	r22, 0xB5	; 181
    17f0:	7f 4f       	sbci	r23, 0xFF	; 255
    17f2:	c7 01       	movw	r24, r14
    17f4:	81 5d       	subi	r24, 0xD1	; 209
    17f6:	9b 4f       	sbci	r25, 0xFB	; 251
    17f8:	44 e0       	ldi	r20, 0x04	; 4
    17fa:	50 e0       	ldi	r21, 0x00	; 0
    17fc:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].subSteps), &(subStepsEE[i]), sizeof(double));
    1800:	b6 01       	movw	r22, r12
    1802:	65 5a       	subi	r22, 0xA5	; 165
    1804:	7f 4f       	sbci	r23, 0xFF	; 255
    1806:	c7 01       	movw	r24, r14
    1808:	8d 5c       	subi	r24, 0xCD	; 205
    180a:	9b 4f       	sbci	r25, 0xFB	; 251
    180c:	44 e0       	ldi	r20, 0x04	; 4
    180e:	50 e0       	ldi	r21, 0x00	; 0
    1810:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepMultiplier), &(stepMultiplierEE[i]), sizeof(double));
    1814:	b6 01       	movw	r22, r12
    1816:	65 59       	subi	r22, 0x95	; 149
    1818:	7f 4f       	sbci	r23, 0xFF	; 255
    181a:	c7 01       	movw	r24, r14
    181c:	88 5c       	subi	r24, 0xC8	; 200
    181e:	9b 4f       	sbci	r25, 0xFB	; 251
    1820:	44 e0       	ldi	r20, 0x04	; 4
    1822:	50 e0       	ldi	r21, 0x00	; 0
    1824:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
	    eeprom_update_block(&(motor[i].current), &(currentEE[i]), sizeof(double));
    1828:	b6 01       	movw	r22, r12
    182a:	65 58       	subi	r22, 0x85	; 133
    182c:	7f 4f       	sbci	r23, 0xFF	; 255
    182e:	c7 01       	movw	r24, r14
    1830:	8f 5b       	subi	r24, 0xBF	; 191
    1832:	9b 4f       	sbci	r25, 0xFB	; 251
    1834:	44 e0       	ldi	r20, 0x04	; 4
    1836:	50 e0       	ldi	r21, 0x00	; 0
    1838:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].decay), &(decayEE[i]), sizeof(int8_t));
    183c:	be 01       	movw	r22, r28
    183e:	65 57       	subi	r22, 0x75	; 117
    1840:	7f 4f       	sbci	r23, 0xFF	; 255
    1842:	c7 01       	movw	r24, r14
    1844:	8b 5b       	subi	r24, 0xBB	; 187
    1846:	9b 4f       	sbci	r25, 0xFB	; 251
    1848:	41 e0       	ldi	r20, 0x01	; 1
    184a:	50 e0       	ldi	r21, 0x00	; 0
    184c:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].stepUnit), &(stepUnitEE[i]), sizeof(int8_t));
    1850:	be 01       	movw	r22, r28
    1852:	61 57       	subi	r22, 0x71	; 113
    1854:	7f 4f       	sbci	r23, 0xFF	; 255
    1856:	c7 01       	movw	r24, r14
    1858:	89 5c       	subi	r24, 0xC9	; 201
    185a:	9b 4f       	sbci	r25, 0xFB	; 251
    185c:	41 e0       	ldi	r20, 0x01	; 1
    185e:	50 e0       	ldi	r21, 0x00	; 0
    1860:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(motor[i].waitBetweenSteps), &(waitBetweenStepsEE[i]), sizeof(int16_t));
    1864:	b5 01       	movw	r22, r10
    1866:	6d 56       	subi	r22, 0x6D	; 109
    1868:	7f 4f       	sbci	r23, 0xFF	; 255
    186a:	c7 01       	movw	r24, r14
    186c:	84 5c       	subi	r24, 0xC4	; 196
    186e:	9b 4f       	sbci	r25, 0xFB	; 251
    1870:	42 e0       	ldi	r20, 0x02	; 2
    1872:	50 e0       	ldi	r21, 0x00	; 0
    1874:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>

      eeprom_update_block(&(forbiddenZone[i].start), &(forbiddenZoneStartEE[i]), sizeof(int16_t));
    1878:	8e 01       	movw	r16, r28
    187a:	00 0f       	add	r16, r16
    187c:	11 1f       	adc	r17, r17
    187e:	00 0f       	add	r16, r16
    1880:	11 1f       	adc	r17, r17
    1882:	0c 0f       	add	r16, r28
    1884:	1d 1f       	adc	r17, r29
    1886:	b5 01       	movw	r22, r10
    1888:	65 56       	subi	r22, 0x65	; 101
    188a:	7f 4f       	sbci	r23, 0xFF	; 255
    188c:	c8 01       	movw	r24, r16
    188e:	8f 5f       	subi	r24, 0xFF	; 255
    1890:	9b 4f       	sbci	r25, 0xFB	; 251
    1892:	42 e0       	ldi	r20, 0x02	; 2
    1894:	50 e0       	ldi	r21, 0x00	; 0
    1896:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
      eeprom_update_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    189a:	b5 01       	movw	r22, r10
    189c:	6d 55       	subi	r22, 0x5D	; 93
    189e:	7f 4f       	sbci	r23, 0xFF	; 255
    18a0:	c8 01       	movw	r24, r16
    18a2:	8d 5f       	subi	r24, 0xFD	; 253
    18a4:	9b 4f       	sbci	r25, 0xFB	; 251
    18a6:	42 e0       	ldi	r20, 0x02	; 2
    18a8:	50 e0       	ldi	r21, 0x00	; 0
    18aa:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
    18ae:	21 96       	adiw	r28, 0x01	; 1
    18b0:	82 e0       	ldi	r24, 0x02	; 2
    18b2:	90 e0       	ldi	r25, 0x00	; 0
    18b4:	a8 0e       	add	r10, r24
    18b6:	b9 1e       	adc	r11, r25
    18b8:	84 e0       	ldi	r24, 0x04	; 4
    18ba:	90 e0       	ldi	r25, 0x00	; 0
    18bc:	c8 0e       	add	r12, r24
    18be:	d9 1e       	adc	r13, r25
void saveConfigToEEPROM(void){

  uint8_t i = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    for(i = 0; i <= MAX_MOTOR; i++){
    18c0:	c4 30       	cpi	r28, 0x04	; 4
    18c2:	d1 05       	cpc	r29, r1
    18c4:	09 f0       	breq	.+2      	; 0x18c8 <saveConfigToEEPROM+0x152>
    18c6:	68 cf       	rjmp	.-304    	; 0x1798 <saveConfigToEEPROM+0x22>
    18c8:	c0 e0       	ldi	r28, 0x00	; 0
    18ca:	d0 e0       	ldi	r29, 0x00	; 0
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* save internal stored programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
      eeprom_update_block(&(programList[i]), &(programListEE[i]), sizeof(progStep));
    18cc:	be 01       	movw	r22, r28
    18ce:	65 55       	subi	r22, 0x55	; 85
    18d0:	7f 4f       	sbci	r23, 0xFF	; 255
    18d2:	ce 01       	movw	r24, r28
    18d4:	8f 5d       	subi	r24, 0xDF	; 223
    18d6:	9c 4f       	sbci	r25, 0xFC	; 252
    18d8:	4a e0       	ldi	r20, 0x0A	; 10
    18da:	50 e0       	ldi	r21, 0x00	; 0
    18dc:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
    18e0:	2a 96       	adiw	r28, 0x0a	; 10
      eeprom_update_block(&(forbiddenZone[i].stop), &(forbiddenZoneStopEE[i]), sizeof(int16_t));
    }

#if SAVE_INTERNAL_PROGRAM_TO_EEPROM
    /* save internal stored programs */
    for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    18e2:	c0 3a       	cpi	r28, 0xA0	; 160
    18e4:	d1 05       	cpc	r29, r1
    18e6:	91 f7       	brne	.-28     	; 0x18cc <saveConfigToEEPROM+0x156>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    18e8:	78 94       	sei
#endif

  }

  return;
}
    18ea:	df 91       	pop	r29
    18ec:	cf 91       	pop	r28
    18ee:	1f 91       	pop	r17
    18f0:	0f 91       	pop	r16
    18f2:	ff 90       	pop	r15
    18f4:	ef 90       	pop	r14
    18f6:	df 90       	pop	r13
    18f8:	cf 90       	pop	r12
    18fa:	bf 90       	pop	r11
    18fc:	af 90       	pop	r10
    18fe:	08 95       	ret

00001900 <commandFactoryReset>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1900:	f8 94       	cli
    sets the whole system back to factory reset
 --------------------------------------------------------------------- */
void commandFactoryReset(void){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    initDataStructs();
    1902:	0e 94 7f 03 	call	0x6fe	; 0x6fe <initDataStructs>
    saveConfigToEEPROM();
    1906:	0e 94 bb 0b 	call	0x1776	; 0x1776 <saveConfigToEEPROM>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    190a:	78 94       	sei
  }

  return;
}
    190c:	08 95       	ret

0000190e <__vector_9>:
}

/* ---------------------------------------------------------------------
    handles all motor movement
 --------------------------------------------------------------------- */
ISR(TIMER2_COMPA_vect){
    190e:	1f 92       	push	r1
    1910:	0f 92       	push	r0
    1912:	0f b6       	in	r0, 0x3f	; 63
    1914:	0f 92       	push	r0
    1916:	0b b6       	in	r0, 0x3b	; 59
    1918:	0f 92       	push	r0
    191a:	11 24       	eor	r1, r1
    191c:	2f 92       	push	r2
    191e:	3f 92       	push	r3
    1920:	4f 92       	push	r4
    1922:	5f 92       	push	r5
    1924:	6f 92       	push	r6
    1926:	7f 92       	push	r7
    1928:	8f 92       	push	r8
    192a:	9f 92       	push	r9
    192c:	af 92       	push	r10
    192e:	bf 92       	push	r11
    1930:	cf 92       	push	r12
    1932:	df 92       	push	r13
    1934:	ef 92       	push	r14
    1936:	ff 92       	push	r15
    1938:	0f 93       	push	r16
    193a:	1f 93       	push	r17
    193c:	2f 93       	push	r18
    193e:	3f 93       	push	r19
    1940:	4f 93       	push	r20
    1942:	5f 93       	push	r21
    1944:	6f 93       	push	r22
    1946:	7f 93       	push	r23
    1948:	8f 93       	push	r24
    194a:	9f 93       	push	r25
    194c:	af 93       	push	r26
    194e:	bf 93       	push	r27
    1950:	ef 93       	push	r30
    1952:	ff 93       	push	r31
    1954:	df 93       	push	r29
    1956:	cf 93       	push	r28
    1958:	cd b7       	in	r28, 0x3d	; 61
    195a:	de b7       	in	r29, 0x3e	; 62
    195c:	a0 97       	sbiw	r28, 0x20	; 32
    195e:	de bf       	out	0x3e, r29	; 62
    1960:	cd bf       	out	0x3d, r28	; 61
    1962:	9e 01       	movw	r18, r28
    1964:	27 5f       	subi	r18, 0xF7	; 247
    1966:	3f 4f       	sbci	r19, 0xFF	; 255
    1968:	3c 8f       	std	Y+28, r19	; 0x1c
    196a:	2b 8f       	std	Y+27, r18	; 0x1b
    196c:	3a 8f       	std	Y+26, r19	; 0x1a
    196e:	29 8f       	std	Y+25, r18	; 0x19
    1970:	18 a2       	std	Y+32, r1	; 0x20
    1972:	1f 8e       	std	Y+31, r1	; 0x1f
    1974:	66 24       	eor	r6, r6
    1976:	77 24       	eor	r7, r7
    1978:	1e 8e       	std	Y+30, r1	; 0x1e
    197a:	1d 8e       	std	Y+29, r1	; 0x1d
  uint8_t outputStep = 0;

  double stepsPerFullRotation[MAX_MOTOR + 1];

  for(i = 0; i <= MAX_MOTOR; i++){
    stepDiff[i] = motor[i].desiredPosition - motor[i].actualPosition;
    197c:	23 01       	movw	r4, r6
    197e:	44 0c       	add	r4, r4
    1980:	55 1c       	adc	r5, r5
    1982:	44 0c       	add	r4, r4
    1984:	55 1c       	adc	r5, r5
    1986:	42 01       	movw	r8, r4
    1988:	88 0c       	add	r8, r8
    198a:	99 1c       	adc	r9, r9
    198c:	88 0c       	add	r8, r8
    198e:	99 1c       	adc	r9, r9
    1990:	84 0c       	add	r8, r4
    1992:	95 1c       	adc	r9, r5
    1994:	88 0c       	add	r8, r8
    1996:	99 1c       	adc	r9, r9
    1998:	80 e2       	ldi	r24, 0x20	; 32
    199a:	94 e0       	ldi	r25, 0x04	; 4
    199c:	88 0e       	add	r8, r24
    199e:	99 1e       	adc	r9, r25
    19a0:	d4 01       	movw	r26, r8
    19a2:	ad 90       	ld	r10, X+
    19a4:	bc 90       	ld	r11, X
    19a6:	13 01       	movw	r2, r6
    19a8:	22 0c       	add	r2, r2
    19aa:	33 1c       	adc	r3, r3
    19ac:	22 0c       	add	r2, r2
    19ae:	33 1c       	adc	r3, r3
    19b0:	22 0c       	add	r2, r2
    19b2:	33 1c       	adc	r3, r3
    19b4:	61 01       	movw	r12, r2
    19b6:	cc 0c       	add	r12, r12
    19b8:	dd 1c       	adc	r13, r13
    19ba:	cc 0c       	add	r12, r12
    19bc:	dd 1c       	adc	r13, r13
    19be:	c2 0c       	add	r12, r2
    19c0:	d3 1c       	adc	r13, r3
    19c2:	ee e1       	ldi	r30, 0x1E	; 30
    19c4:	f4 e0       	ldi	r31, 0x04	; 4
    19c6:	ce 0e       	add	r12, r30
    19c8:	df 1e       	adc	r13, r31
    19ca:	d6 01       	movw	r26, r12
    19cc:	8d 91       	ld	r24, X+
    19ce:	9c 91       	ld	r25, X
    19d0:	11 97       	sbiw	r26, 0x01	; 1
    19d2:	a8 1a       	sub	r10, r24
    19d4:	b9 0a       	sbc	r11, r25
    19d6:	e1 e0       	ldi	r30, 0x01	; 1
    19d8:	f0 e0       	ldi	r31, 0x00	; 0
    19da:	ec 0f       	add	r30, r28
    19dc:	fd 1f       	adc	r31, r29
    19de:	2d 8d       	ldd	r18, Y+29	; 0x1d
    19e0:	3e 8d       	ldd	r19, Y+30	; 0x1e
    19e2:	e2 0f       	add	r30, r18
    19e4:	f3 1f       	adc	r31, r19
    19e6:	b1 82       	std	Z+1, r11	; 0x01
    19e8:	a0 82       	st	Z, r10

    stepsPerFullRotation[i] =  motor[i].gearRatio
    19ea:	1d 96       	adiw	r26, 0x0d	; 13
    19ec:	6d 91       	ld	r22, X+
    19ee:	7d 91       	ld	r23, X+
    19f0:	8d 91       	ld	r24, X+
    19f2:	9c 91       	ld	r25, X
    19f4:	50 97       	sbiw	r26, 0x10	; 16
    19f6:	51 96       	adiw	r26, 0x11	; 17
    19f8:	2d 91       	ld	r18, X+
    19fa:	3d 91       	ld	r19, X+
    19fc:	4d 91       	ld	r20, X+
    19fe:	5c 91       	ld	r21, X
    1a00:	54 97       	sbiw	r26, 0x14	; 20
    1a02:	55 96       	adiw	r26, 0x15	; 21
    1a04:	ed 90       	ld	r14, X+
    1a06:	fd 90       	ld	r15, X+
    1a08:	0d 91       	ld	r16, X+
    1a0a:	1c 91       	ld	r17, X
    1a0c:	58 97       	sbiw	r26, 0x18	; 24
    1a0e:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    1a12:	a8 01       	movw	r20, r16
    1a14:	97 01       	movw	r18, r14
    1a16:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    1a1a:	a9 8d       	ldd	r26, Y+25	; 0x19
    1a1c:	ba 8d       	ldd	r27, Y+26	; 0x1a
    1a1e:	6d 93       	st	X+, r22
    1a20:	7d 93       	st	X+, r23
    1a22:	8d 93       	st	X+, r24
    1a24:	9c 93       	st	X, r25
    1a26:	13 97       	sbiw	r26, 0x03	; 3
                              *motor[i].stepsPerFullRotation
                              *motor[i].subSteps;

    if(stepDiff[i] == 0){
    1a28:	a1 14       	cp	r10, r1
    1a2a:	b1 04       	cpc	r11, r1
    1a2c:	09 f4       	brne	.+2      	; 0x1a30 <__vector_9+0x122>
    1a2e:	4c c0       	rjmp	.+152    	; 0x1ac8 <__vector_9+0x1ba>
      /* no motor movement required */
      continue;
    }
    else{
      /* check if the wait-time between two steps is over */
      if(motor[i].delayCounter){
    1a30:	f6 01       	movw	r30, r12
    1a32:	80 a1       	ldd	r24, Z+32	; 0x20
    1a34:	91 a1       	ldd	r25, Z+33	; 0x21
    1a36:	89 2b       	or	r24, r25
    1a38:	09 f4       	brne	.+2      	; 0x1a3c <__vector_9+0x12e>
    1a3a:	69 c1       	rjmp	.+722    	; 0x1d0e <__vector_9+0x400>
        /* seems not to be, so decrement */
        motor[i].delayCounter--;
    1a3c:	80 a1       	ldd	r24, Z+32	; 0x20
    1a3e:	91 a1       	ldd	r25, Z+33	; 0x21
    1a40:	01 97       	sbiw	r24, 0x01	; 1
    1a42:	91 a3       	std	Z+33, r25	; 0x21
    1a44:	80 a3       	std	Z+32, r24	; 0x20

        /* and we also got time here to correct motor step error */
        if(motor[i].stepError > 1.0f){
    1a46:	66 81       	ldd	r22, Z+6	; 0x06
    1a48:	77 81       	ldd	r23, Z+7	; 0x07
    1a4a:	80 85       	ldd	r24, Z+8	; 0x08
    1a4c:	91 85       	ldd	r25, Z+9	; 0x09
    1a4e:	20 e0       	ldi	r18, 0x00	; 0
    1a50:	30 e0       	ldi	r19, 0x00	; 0
    1a52:	40 e8       	ldi	r20, 0x80	; 128
    1a54:	5f e3       	ldi	r21, 0x3F	; 63
    1a56:	0e 94 2d 45 	call	0x8a5a	; 0x8a5a <__gesf2>
    1a5a:	18 16       	cp	r1, r24
    1a5c:	d4 f4       	brge	.+52     	; 0x1a92 <__vector_9+0x184>
          motor[i].desiredPosition += 1;
    1a5e:	d4 01       	movw	r26, r8
    1a60:	8d 91       	ld	r24, X+
    1a62:	9c 91       	ld	r25, X
    1a64:	11 97       	sbiw	r26, 0x01	; 1
    1a66:	01 96       	adiw	r24, 0x01	; 1
    1a68:	11 96       	adiw	r26, 0x01	; 1
    1a6a:	9c 93       	st	X, r25
    1a6c:	8e 93       	st	-X, r24
          motor[i].stepError -= 1.0f;
    1a6e:	f6 01       	movw	r30, r12
    1a70:	66 81       	ldd	r22, Z+6	; 0x06
    1a72:	77 81       	ldd	r23, Z+7	; 0x07
    1a74:	80 85       	ldd	r24, Z+8	; 0x08
    1a76:	91 85       	ldd	r25, Z+9	; 0x09
    1a78:	20 e0       	ldi	r18, 0x00	; 0
    1a7a:	30 e0       	ldi	r19, 0x00	; 0
    1a7c:	40 e8       	ldi	r20, 0x80	; 128
    1a7e:	5f e3       	ldi	r21, 0x3F	; 63
    1a80:	0e 94 26 43 	call	0x864c	; 0x864c <__subsf3>
    1a84:	d6 01       	movw	r26, r12
    1a86:	16 96       	adiw	r26, 0x06	; 6
    1a88:	6d 93       	st	X+, r22
    1a8a:	7d 93       	st	X+, r23
    1a8c:	8d 93       	st	X+, r24
    1a8e:	9c 93       	st	X, r25
    1a90:	19 97       	sbiw	r26, 0x09	; 9
        }
        if(motor[i].stepError < -1.0f){
    1a92:	61 01       	movw	r12, r2
    1a94:	cc 0c       	add	r12, r12
    1a96:	dd 1c       	adc	r13, r13
    1a98:	cc 0c       	add	r12, r12
    1a9a:	dd 1c       	adc	r13, r13
    1a9c:	c2 0c       	add	r12, r2
    1a9e:	d3 1c       	adc	r13, r3
    1aa0:	ee e1       	ldi	r30, 0x1E	; 30
    1aa2:	f4 e0       	ldi	r31, 0x04	; 4
    1aa4:	ce 0e       	add	r12, r30
    1aa6:	df 1e       	adc	r13, r31
    1aa8:	d6 01       	movw	r26, r12
    1aaa:	16 96       	adiw	r26, 0x06	; 6
    1aac:	6d 91       	ld	r22, X+
    1aae:	7d 91       	ld	r23, X+
    1ab0:	8d 91       	ld	r24, X+
    1ab2:	9c 91       	ld	r25, X
    1ab4:	19 97       	sbiw	r26, 0x09	; 9
    1ab6:	20 e0       	ldi	r18, 0x00	; 0
    1ab8:	30 e0       	ldi	r19, 0x00	; 0
    1aba:	40 e8       	ldi	r20, 0x80	; 128
    1abc:	5f eb       	ldi	r21, 0xBF	; 191
    1abe:	0e 94 8b 43 	call	0x8716	; 0x8716 <__cmpsf2>
    1ac2:	88 23       	and	r24, r24
    1ac4:	0c f4       	brge	.+2      	; 0x1ac8 <__vector_9+0x1ba>
    1ac6:	0c c2       	rjmp	.+1048   	; 0x1ee0 <__vector_9+0x5d2>
          else{
            outputStep |= (1 << (2*i));
          }
        }
        /* so we will move and therefore set back the delay counter */
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    1ac8:	08 94       	sec
    1aca:	61 1c       	adc	r6, r1
    1acc:	71 1c       	adc	r7, r1
    1ace:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1ad0:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1ad2:	2e 5f       	subi	r18, 0xFE	; 254
    1ad4:	3f 4f       	sbci	r19, 0xFF	; 255
    1ad6:	3e 8f       	std	Y+30, r19	; 0x1e
    1ad8:	2d 8f       	std	Y+29, r18	; 0x1d
    1ada:	89 8d       	ldd	r24, Y+25	; 0x19
    1adc:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ade:	04 96       	adiw	r24, 0x04	; 4
    1ae0:	9a 8f       	std	Y+26, r25	; 0x1a
    1ae2:	89 8f       	std	Y+25, r24	; 0x19
  uint8_t outputDir  = 0;
  uint8_t outputStep = 0;

  double stepsPerFullRotation[MAX_MOTOR + 1];

  for(i = 0; i <= MAX_MOTOR; i++){
    1ae4:	94 e0       	ldi	r25, 0x04	; 4
    1ae6:	69 16       	cp	r6, r25
    1ae8:	71 04       	cpc	r7, r1
    1aea:	09 f0       	breq	.+2      	; 0x1aee <__vector_9+0x1e0>
    1aec:	47 cf       	rjmp	.-370    	; 0x197c <__vector_9+0x6e>
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
      }
    }
  }

  PORTA |= outputDir;     /* set direction */
    1aee:	82 b1       	in	r24, 0x02	; 2
    1af0:	a8 a1       	ldd	r26, Y+32	; 0x20
    1af2:	a8 2b       	or	r26, r24
    1af4:	a2 b9       	out	0x02, r26	; 2
    1af6:	96 e0       	ldi	r25, 0x06	; 6
    1af8:	89 2f       	mov	r24, r25
    1afa:	8a 95       	dec	r24
    1afc:	f1 f7       	brne	.-4      	; 0x1afa <__vector_9+0x1ec>
  _delay_us(1.0);         /* sync */
  PORTA |= outputStep;    /* make exactly one step */
    1afe:	82 b1       	in	r24, 0x02	; 2
    1b00:	bf 8d       	ldd	r27, Y+31	; 0x1f
    1b02:	8b 2b       	or	r24, r27
    1b04:	82 b9       	out	0x02, r24	; 2
    1b06:	8d e0       	ldi	r24, 0x0D	; 13
    1b08:	8a 95       	dec	r24
    1b0a:	f1 f7       	brne	.-4      	; 0x1b08 <__vector_9+0x1fa>
  _delay_us(2.0);         /* sync */
  PORTA &= ~outputStep;
    1b0c:	82 b1       	in	r24, 0x02	; 2
    1b0e:	b0 95       	com	r27
    1b10:	b8 23       	and	r27, r24
    1b12:	b2 b9       	out	0x02, r27	; 2
    1b14:	9a 95       	dec	r25
    1b16:	f1 f7       	brne	.-4      	; 0x1b14 <__vector_9+0x206>
  _delay_us(1.0);
  PORTA = 0;
    1b18:	12 b8       	out	0x02, r1	; 2
    1b1a:	3e 01       	movw	r6, r28
    1b1c:	08 94       	sec
    1b1e:	61 1c       	adc	r6, r1
    1b20:	71 1c       	adc	r7, r1
    1b22:	cc 24       	eor	r12, r12
    1b24:	dd 24       	eor	r13, r13
    1b26:	ec 2c       	mov	r14, r12
    1b28:	5d 2c       	mov	r5, r13

  /* update motor positions */
  for(i = 0; i <= MAX_MOTOR; i++){
    if(motor[i].isMoving){
    1b2a:	f6 01       	movw	r30, r12
    1b2c:	ee 0f       	add	r30, r30
    1b2e:	ff 1f       	adc	r31, r31
    1b30:	ee 0f       	add	r30, r30
    1b32:	ff 1f       	adc	r31, r31
    1b34:	ee 0f       	add	r30, r30
    1b36:	ff 1f       	adc	r31, r31
    1b38:	cf 01       	movw	r24, r30
    1b3a:	88 0f       	add	r24, r24
    1b3c:	99 1f       	adc	r25, r25
    1b3e:	88 0f       	add	r24, r24
    1b40:	99 1f       	adc	r25, r25
    1b42:	e8 0f       	add	r30, r24
    1b44:	f9 1f       	adc	r31, r25
    1b46:	e2 5e       	subi	r30, 0xE2	; 226
    1b48:	fb 4f       	sbci	r31, 0xFB	; 251
    1b4a:	82 85       	ldd	r24, Z+10	; 0x0a
    1b4c:	88 23       	and	r24, r24
    1b4e:	09 f4       	brne	.+2      	; 0x1b52 <__vector_9+0x244>
    1b50:	a4 c0       	rjmp	.+328    	; 0x1c9a <__vector_9+0x38c>
      if(stepDiff[i] > 0){
    1b52:	f3 01       	movw	r30, r6
    1b54:	80 81       	ld	r24, Z
    1b56:	91 81       	ldd	r25, Z+1	; 0x01
    1b58:	18 16       	cp	r1, r24
    1b5a:	19 06       	cpc	r1, r25
    1b5c:	0c f0       	brlt	.+2      	; 0x1b60 <__vector_9+0x252>
    1b5e:	01 c1       	rjmp	.+514    	; 0x1d62 <__vector_9+0x454>
        /* check if we got one full rotation */
        if(((motor[i].actualPosition) + 1) > stepsPerFullRotation[i]){
    1b60:	f6 01       	movw	r30, r12
    1b62:	ee 0f       	add	r30, r30
    1b64:	ff 1f       	adc	r31, r31
    1b66:	ee 0f       	add	r30, r30
    1b68:	ff 1f       	adc	r31, r31
    1b6a:	ee 0f       	add	r30, r30
    1b6c:	ff 1f       	adc	r31, r31
    1b6e:	cf 01       	movw	r24, r30
    1b70:	88 0f       	add	r24, r24
    1b72:	99 1f       	adc	r25, r25
    1b74:	88 0f       	add	r24, r24
    1b76:	99 1f       	adc	r25, r25
    1b78:	e8 0f       	add	r30, r24
    1b7a:	f9 1f       	adc	r31, r25
    1b7c:	e2 5e       	subi	r30, 0xE2	; 226
    1b7e:	fb 4f       	sbci	r31, 0xFB	; 251
    1b80:	60 81       	ld	r22, Z
    1b82:	71 81       	ldd	r23, Z+1	; 0x01
    1b84:	ab 8d       	ldd	r26, Y+27	; 0x1b
    1b86:	bc 8d       	ldd	r27, Y+28	; 0x1c
    1b88:	8d 90       	ld	r8, X+
    1b8a:	9d 90       	ld	r9, X+
    1b8c:	ad 90       	ld	r10, X+
    1b8e:	bc 90       	ld	r11, X
    1b90:	6f 5f       	subi	r22, 0xFF	; 255
    1b92:	7f 4f       	sbci	r23, 0xFF	; 255
    1b94:	88 27       	eor	r24, r24
    1b96:	77 fd       	sbrc	r23, 7
    1b98:	80 95       	com	r24
    1b9a:	98 2f       	mov	r25, r24
    1b9c:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    1ba0:	a5 01       	movw	r20, r10
    1ba2:	94 01       	movw	r18, r8
    1ba4:	0e 94 2d 45 	call	0x8a5a	; 0x8a5a <__gesf2>
    1ba8:	18 16       	cp	r1, r24
    1baa:	0c f4       	brge	.+2      	; 0x1bae <__vector_9+0x2a0>
    1bac:	5a c1       	rjmp	.+692    	; 0x1e62 <__vector_9+0x554>
          /* so set back to 0 */
          motor[i].actualPosition = 0;
          /* correct desired motor position */
          motor[i].desiredPosition -= (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition++;
    1bae:	ee 2d       	mov	r30, r14
    1bb0:	f5 2d       	mov	r31, r5
    1bb2:	ee 0f       	add	r30, r30
    1bb4:	ff 1f       	adc	r31, r31
    1bb6:	ee 0f       	add	r30, r30
    1bb8:	ff 1f       	adc	r31, r31
    1bba:	ee 0f       	add	r30, r30
    1bbc:	ff 1f       	adc	r31, r31
    1bbe:	cf 01       	movw	r24, r30
    1bc0:	88 0f       	add	r24, r24
    1bc2:	99 1f       	adc	r25, r25
    1bc4:	88 0f       	add	r24, r24
    1bc6:	99 1f       	adc	r25, r25
    1bc8:	e8 0f       	add	r30, r24
    1bca:	f9 1f       	adc	r31, r25
    1bcc:	e2 5e       	subi	r30, 0xE2	; 226
    1bce:	fb 4f       	sbci	r31, 0xFB	; 251
    1bd0:	20 81       	ld	r18, Z
    1bd2:	31 81       	ldd	r19, Z+1	; 0x01
    1bd4:	2f 5f       	subi	r18, 0xFF	; 255
    1bd6:	3f 4f       	sbci	r19, 0xFF	; 255
    1bd8:	ee 2d       	mov	r30, r14
    1bda:	f5 2d       	mov	r31, r5
    1bdc:	ee 0f       	add	r30, r30
    1bde:	ff 1f       	adc	r31, r31
    1be0:	ee 0f       	add	r30, r30
    1be2:	ff 1f       	adc	r31, r31
    1be4:	ee 0f       	add	r30, r30
    1be6:	ff 1f       	adc	r31, r31
    1be8:	cf 01       	movw	r24, r30
    1bea:	88 0f       	add	r24, r24
    1bec:	99 1f       	adc	r25, r25
    1bee:	88 0f       	add	r24, r24
    1bf0:	99 1f       	adc	r25, r25
    1bf2:	e8 0f       	add	r30, r24
    1bf4:	f9 1f       	adc	r31, r25
    1bf6:	e2 5e       	subi	r30, 0xE2	; 226
    1bf8:	fb 4f       	sbci	r31, 0xFB	; 251
    1bfa:	31 83       	std	Z+1, r19	; 0x01
    1bfc:	20 83       	st	Z, r18
        if(motor[i].isMovingInfinite){
    1bfe:	ee 2d       	mov	r30, r14
    1c00:	f5 2d       	mov	r31, r5
    1c02:	ee 0f       	add	r30, r30
    1c04:	ff 1f       	adc	r31, r31
    1c06:	ee 0f       	add	r30, r30
    1c08:	ff 1f       	adc	r31, r31
    1c0a:	ee 0f       	add	r30, r30
    1c0c:	ff 1f       	adc	r31, r31
    1c0e:	cf 01       	movw	r24, r30
    1c10:	88 0f       	add	r24, r24
    1c12:	99 1f       	adc	r25, r25
    1c14:	88 0f       	add	r24, r24
    1c16:	99 1f       	adc	r25, r25
    1c18:	e8 0f       	add	r30, r24
    1c1a:	f9 1f       	adc	r31, r25
    1c1c:	e2 5e       	subi	r30, 0xE2	; 226
    1c1e:	fb 4f       	sbci	r31, 0xFB	; 251
    1c20:	84 85       	ldd	r24, Z+12	; 0x0c
    1c22:	88 23       	and	r24, r24
    1c24:	41 f1       	breq	.+80     	; 0x1c76 <__vector_9+0x368>
          motor[i].desiredPosition += 1;
    1c26:	ee 2d       	mov	r30, r14
    1c28:	f5 2d       	mov	r31, r5
    1c2a:	ee 0f       	add	r30, r30
    1c2c:	ff 1f       	adc	r31, r31
    1c2e:	ee 0f       	add	r30, r30
    1c30:	ff 1f       	adc	r31, r31
    1c32:	cf 01       	movw	r24, r30
    1c34:	88 0f       	add	r24, r24
    1c36:	99 1f       	adc	r25, r25
    1c38:	88 0f       	add	r24, r24
    1c3a:	99 1f       	adc	r25, r25
    1c3c:	e8 0f       	add	r30, r24
    1c3e:	f9 1f       	adc	r31, r25
    1c40:	ee 0f       	add	r30, r30
    1c42:	ff 1f       	adc	r31, r31
    1c44:	e0 5e       	subi	r30, 0xE0	; 224
    1c46:	fb 4f       	sbci	r31, 0xFB	; 251
    1c48:	20 81       	ld	r18, Z
    1c4a:	31 81       	ldd	r19, Z+1	; 0x01
    1c4c:	2f 5f       	subi	r18, 0xFF	; 255
    1c4e:	3f 4f       	sbci	r19, 0xFF	; 255
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition--;
        if(motor[i].isMovingInfinite){
          motor[i].desiredPosition += -1;
    1c50:	ee 2d       	mov	r30, r14
    1c52:	f5 2d       	mov	r31, r5
    1c54:	ee 0f       	add	r30, r30
    1c56:	ff 1f       	adc	r31, r31
    1c58:	ee 0f       	add	r30, r30
    1c5a:	ff 1f       	adc	r31, r31
    1c5c:	cf 01       	movw	r24, r30
    1c5e:	88 0f       	add	r24, r24
    1c60:	99 1f       	adc	r25, r25
    1c62:	88 0f       	add	r24, r24
    1c64:	99 1f       	adc	r25, r25
    1c66:	e8 0f       	add	r30, r24
    1c68:	f9 1f       	adc	r31, r25
    1c6a:	ee 0f       	add	r30, r30
    1c6c:	ff 1f       	adc	r31, r31
    1c6e:	e0 5e       	subi	r30, 0xE0	; 224
    1c70:	fb 4f       	sbci	r31, 0xFB	; 251
    1c72:	31 83       	std	Z+1, r19	; 0x01
    1c74:	20 83       	st	Z, r18
        }
      }
      motor[i].isMoving = 0;
    1c76:	ee 2d       	mov	r30, r14
    1c78:	f5 2d       	mov	r31, r5
    1c7a:	ee 0f       	add	r30, r30
    1c7c:	ff 1f       	adc	r31, r31
    1c7e:	ee 0f       	add	r30, r30
    1c80:	ff 1f       	adc	r31, r31
    1c82:	ee 0f       	add	r30, r30
    1c84:	ff 1f       	adc	r31, r31
    1c86:	cf 01       	movw	r24, r30
    1c88:	88 0f       	add	r24, r24
    1c8a:	99 1f       	adc	r25, r25
    1c8c:	88 0f       	add	r24, r24
    1c8e:	99 1f       	adc	r25, r25
    1c90:	e8 0f       	add	r30, r24
    1c92:	f9 1f       	adc	r31, r25
    1c94:	e2 5e       	subi	r30, 0xE2	; 226
    1c96:	fb 4f       	sbci	r31, 0xFB	; 251
    1c98:	12 86       	std	Z+10, r1	; 0x0a
    1c9a:	08 94       	sec
    1c9c:	c1 1c       	adc	r12, r1
    1c9e:	d1 1c       	adc	r13, r1
    1ca0:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1ca2:	3c 8d       	ldd	r19, Y+28	; 0x1c
    1ca4:	2c 5f       	subi	r18, 0xFC	; 252
    1ca6:	3f 4f       	sbci	r19, 0xFF	; 255
    1ca8:	3c 8f       	std	Y+28, r19	; 0x1c
    1caa:	2b 8f       	std	Y+27, r18	; 0x1b
    1cac:	82 e0       	ldi	r24, 0x02	; 2
    1cae:	90 e0       	ldi	r25, 0x00	; 0
    1cb0:	68 0e       	add	r6, r24
    1cb2:	79 1e       	adc	r7, r25
  PORTA &= ~outputStep;
  _delay_us(1.0);
  PORTA = 0;

  /* update motor positions */
  for(i = 0; i <= MAX_MOTOR; i++){
    1cb4:	94 e0       	ldi	r25, 0x04	; 4
    1cb6:	c9 16       	cp	r12, r25
    1cb8:	d1 04       	cpc	r13, r1
    1cba:	09 f0       	breq	.+2      	; 0x1cbe <__vector_9+0x3b0>
    1cbc:	34 cf       	rjmp	.-408    	; 0x1b26 <__vector_9+0x218>
        }
      }
      motor[i].isMoving = 0;
    }
  }
}
    1cbe:	a0 96       	adiw	r28, 0x20	; 32
    1cc0:	de bf       	out	0x3e, r29	; 62
    1cc2:	cd bf       	out	0x3d, r28	; 61
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	ff 91       	pop	r31
    1cca:	ef 91       	pop	r30
    1ccc:	bf 91       	pop	r27
    1cce:	af 91       	pop	r26
    1cd0:	9f 91       	pop	r25
    1cd2:	8f 91       	pop	r24
    1cd4:	7f 91       	pop	r23
    1cd6:	6f 91       	pop	r22
    1cd8:	5f 91       	pop	r21
    1cda:	4f 91       	pop	r20
    1cdc:	3f 91       	pop	r19
    1cde:	2f 91       	pop	r18
    1ce0:	1f 91       	pop	r17
    1ce2:	0f 91       	pop	r16
    1ce4:	ff 90       	pop	r15
    1ce6:	ef 90       	pop	r14
    1ce8:	df 90       	pop	r13
    1cea:	cf 90       	pop	r12
    1cec:	bf 90       	pop	r11
    1cee:	af 90       	pop	r10
    1cf0:	9f 90       	pop	r9
    1cf2:	8f 90       	pop	r8
    1cf4:	7f 90       	pop	r7
    1cf6:	6f 90       	pop	r6
    1cf8:	5f 90       	pop	r5
    1cfa:	4f 90       	pop	r4
    1cfc:	3f 90       	pop	r3
    1cfe:	2f 90       	pop	r2
    1d00:	0f 90       	pop	r0
    1d02:	0b be       	out	0x3b, r0	; 59
    1d04:	0f 90       	pop	r0
    1d06:	0f be       	out	0x3f, r0	; 63
    1d08:	0f 90       	pop	r0
    1d0a:	1f 90       	pop	r1
    1d0c:	18 95       	reti
          motor[i].stepError += 1.0f;
        }
      }
      else{
        /* here we just waited the specified time between two steps */
        motor[i].isMoving = 1;
    1d0e:	21 e0       	ldi	r18, 0x01	; 1
    1d10:	f6 01       	movw	r30, r12
    1d12:	22 87       	std	Z+10, r18	; 0x0a

        if(stepDiff[i] < 0){
    1d14:	b7 fc       	sbrc	r11, 7
    1d16:	07 c1       	rjmp	.+526    	; 0x1f26 <__vector_9+0x618>
          }
        }
        else{
          /* moving CW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1d18:	f2 01       	movw	r30, r4
    1d1a:	e6 0d       	add	r30, r6
    1d1c:	f7 1d       	adc	r31, r7
    1d1e:	ef 5f       	subi	r30, 0xFF	; 255
    1d20:	fb 4f       	sbci	r31, 0xFB	; 251
    1d22:	84 81       	ldd	r24, Z+4	; 0x04
    1d24:	88 23       	and	r24, r24
    1d26:	09 f0       	breq	.+2      	; 0x1d2a <__vector_9+0x41c>
    1d28:	88 c0       	rjmp	.+272    	; 0x1e3a <__vector_9+0x52c>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].start)){
            motor[i].desiredPosition = motor[i].actualPosition;
            motor[i].isMoving = 0;
          }
          else{
            outputStep |= (1 << (2*i));
    1d2a:	81 e0       	ldi	r24, 0x01	; 1
    1d2c:	90 e0       	ldi	r25, 0x00	; 0
    1d2e:	0d 8c       	ldd	r0, Y+29	; 0x1d
    1d30:	02 c0       	rjmp	.+4      	; 0x1d36 <__vector_9+0x428>
    1d32:	88 0f       	add	r24, r24
    1d34:	99 1f       	adc	r25, r25
    1d36:	0a 94       	dec	r0
    1d38:	e2 f7       	brpl	.-8      	; 0x1d32 <__vector_9+0x424>
    1d3a:	ff 8d       	ldd	r31, Y+31	; 0x1f
    1d3c:	f8 2b       	or	r31, r24
    1d3e:	ff 8f       	std	Y+31, r31	; 0x1f
          }
        }
        /* so we will move and therefore set back the delay counter */
        motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    1d40:	f1 01       	movw	r30, r2
    1d42:	ee 0f       	add	r30, r30
    1d44:	ff 1f       	adc	r31, r31
    1d46:	ee 0f       	add	r30, r30
    1d48:	ff 1f       	adc	r31, r31
    1d4a:	e2 0d       	add	r30, r2
    1d4c:	f3 1d       	adc	r31, r3
    1d4e:	e2 5e       	subi	r30, 0xE2	; 226
    1d50:	fb 4f       	sbci	r31, 0xFB	; 251
    1d52:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d54:	97 8d       	ldd	r25, Z+31	; 0x1f
    1d56:	88 0f       	add	r24, r24
    1d58:	99 1f       	adc	r25, r25
    1d5a:	01 97       	sbiw	r24, 0x01	; 1
    1d5c:	91 a3       	std	Z+33, r25	; 0x21
    1d5e:	80 a3       	std	Z+32, r24	; 0x20
    1d60:	b3 ce       	rjmp	.-666    	; 0x1ac8 <__vector_9+0x1ba>
        motor[i].actualPosition++;
        if(motor[i].isMovingInfinite){
          motor[i].desiredPosition += 1;
        }
      }
      else if(stepDiff[i] < 0){
    1d62:	89 2b       	or	r24, r25
    1d64:	09 f4       	brne	.+2      	; 0x1d68 <__vector_9+0x45a>
    1d66:	87 cf       	rjmp	.-242    	; 0x1c76 <__vector_9+0x368>
      /* check if we got one full rotation */
        if(((motor[i].actualPosition) - 1) < 0){
    1d68:	f6 01       	movw	r30, r12
    1d6a:	ee 0f       	add	r30, r30
    1d6c:	ff 1f       	adc	r31, r31
    1d6e:	ee 0f       	add	r30, r30
    1d70:	ff 1f       	adc	r31, r31
    1d72:	ee 0f       	add	r30, r30
    1d74:	ff 1f       	adc	r31, r31
    1d76:	cf 01       	movw	r24, r30
    1d78:	88 0f       	add	r24, r24
    1d7a:	99 1f       	adc	r25, r25
    1d7c:	88 0f       	add	r24, r24
    1d7e:	99 1f       	adc	r25, r25
    1d80:	e8 0f       	add	r30, r24
    1d82:	f9 1f       	adc	r31, r25
    1d84:	e2 5e       	subi	r30, 0xE2	; 226
    1d86:	fb 4f       	sbci	r31, 0xFB	; 251
    1d88:	80 81       	ld	r24, Z
    1d8a:	91 81       	ldd	r25, Z+1	; 0x01
    1d8c:	18 16       	cp	r1, r24
    1d8e:	19 06       	cpc	r1, r25
    1d90:	0c f0       	brlt	.+2      	; 0x1d94 <__vector_9+0x486>
    1d92:	fd c0       	rjmp	.+506    	; 0x1f8e <__vector_9+0x680>
          /* so set back to max steps per round */
          motor[i].actualPosition = (int16_t)round(stepsPerFullRotation[i]);
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
        }
        motor[i].actualPosition--;
    1d94:	ee 2d       	mov	r30, r14
    1d96:	f5 2d       	mov	r31, r5
    1d98:	ee 0f       	add	r30, r30
    1d9a:	ff 1f       	adc	r31, r31
    1d9c:	ee 0f       	add	r30, r30
    1d9e:	ff 1f       	adc	r31, r31
    1da0:	ee 0f       	add	r30, r30
    1da2:	ff 1f       	adc	r31, r31
    1da4:	cf 01       	movw	r24, r30
    1da6:	88 0f       	add	r24, r24
    1da8:	99 1f       	adc	r25, r25
    1daa:	88 0f       	add	r24, r24
    1dac:	99 1f       	adc	r25, r25
    1dae:	e8 0f       	add	r30, r24
    1db0:	f9 1f       	adc	r31, r25
    1db2:	e2 5e       	subi	r30, 0xE2	; 226
    1db4:	fb 4f       	sbci	r31, 0xFB	; 251
    1db6:	20 81       	ld	r18, Z
    1db8:	31 81       	ldd	r19, Z+1	; 0x01
    1dba:	21 50       	subi	r18, 0x01	; 1
    1dbc:	30 40       	sbci	r19, 0x00	; 0
    1dbe:	ee 2d       	mov	r30, r14
    1dc0:	f5 2d       	mov	r31, r5
    1dc2:	ee 0f       	add	r30, r30
    1dc4:	ff 1f       	adc	r31, r31
    1dc6:	ee 0f       	add	r30, r30
    1dc8:	ff 1f       	adc	r31, r31
    1dca:	ee 0f       	add	r30, r30
    1dcc:	ff 1f       	adc	r31, r31
    1dce:	cf 01       	movw	r24, r30
    1dd0:	88 0f       	add	r24, r24
    1dd2:	99 1f       	adc	r25, r25
    1dd4:	88 0f       	add	r24, r24
    1dd6:	99 1f       	adc	r25, r25
    1dd8:	e8 0f       	add	r30, r24
    1dda:	f9 1f       	adc	r31, r25
    1ddc:	e2 5e       	subi	r30, 0xE2	; 226
    1dde:	fb 4f       	sbci	r31, 0xFB	; 251
    1de0:	31 83       	std	Z+1, r19	; 0x01
    1de2:	20 83       	st	Z, r18
        if(motor[i].isMovingInfinite){
    1de4:	ee 2d       	mov	r30, r14
    1de6:	f5 2d       	mov	r31, r5
    1de8:	ee 0f       	add	r30, r30
    1dea:	ff 1f       	adc	r31, r31
    1dec:	ee 0f       	add	r30, r30
    1dee:	ff 1f       	adc	r31, r31
    1df0:	ee 0f       	add	r30, r30
    1df2:	ff 1f       	adc	r31, r31
    1df4:	cf 01       	movw	r24, r30
    1df6:	88 0f       	add	r24, r24
    1df8:	99 1f       	adc	r25, r25
    1dfa:	88 0f       	add	r24, r24
    1dfc:	99 1f       	adc	r25, r25
    1dfe:	e8 0f       	add	r30, r24
    1e00:	f9 1f       	adc	r31, r25
    1e02:	e2 5e       	subi	r30, 0xE2	; 226
    1e04:	fb 4f       	sbci	r31, 0xFB	; 251
    1e06:	84 85       	ldd	r24, Z+12	; 0x0c
    1e08:	88 23       	and	r24, r24
    1e0a:	09 f4       	brne	.+2      	; 0x1e0e <__vector_9+0x500>
    1e0c:	34 cf       	rjmp	.-408    	; 0x1c76 <__vector_9+0x368>
          motor[i].desiredPosition += -1;
    1e0e:	ee 2d       	mov	r30, r14
    1e10:	f5 2d       	mov	r31, r5
    1e12:	ee 0f       	add	r30, r30
    1e14:	ff 1f       	adc	r31, r31
    1e16:	ee 0f       	add	r30, r30
    1e18:	ff 1f       	adc	r31, r31
    1e1a:	cf 01       	movw	r24, r30
    1e1c:	88 0f       	add	r24, r24
    1e1e:	99 1f       	adc	r25, r25
    1e20:	88 0f       	add	r24, r24
    1e22:	99 1f       	adc	r25, r25
    1e24:	e8 0f       	add	r30, r24
    1e26:	f9 1f       	adc	r31, r25
    1e28:	ee 0f       	add	r30, r30
    1e2a:	ff 1f       	adc	r31, r31
    1e2c:	e0 5e       	subi	r30, 0xE0	; 224
    1e2e:	fb 4f       	sbci	r31, 0xFB	; 251
    1e30:	20 81       	ld	r18, Z
    1e32:	31 81       	ldd	r19, Z+1	; 0x01
    1e34:	21 50       	subi	r18, 0x01	; 1
    1e36:	30 40       	sbci	r19, 0x00	; 0
    1e38:	0b cf       	rjmp	.-490    	; 0x1c50 <__vector_9+0x342>
          }
        }
        else{
          /* moving CW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1e3a:	d6 01       	movw	r26, r12
    1e3c:	8d 91       	ld	r24, X+
    1e3e:	9c 91       	ld	r25, X
    1e40:	11 97       	sbiw	r26, 0x01	; 1
    1e42:	20 81       	ld	r18, Z
    1e44:	31 81       	ldd	r19, Z+1	; 0x01
    1e46:	01 96       	adiw	r24, 0x01	; 1
    1e48:	82 17       	cp	r24, r18
    1e4a:	93 07       	cpc	r25, r19
    1e4c:	09 f0       	breq	.+2      	; 0x1e50 <__vector_9+0x542>
    1e4e:	6d cf       	rjmp	.-294    	; 0x1d2a <__vector_9+0x41c>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].start)){
            motor[i].desiredPosition = motor[i].actualPosition;
    1e50:	8d 91       	ld	r24, X+
    1e52:	9c 91       	ld	r25, X
    1e54:	11 97       	sbiw	r26, 0x01	; 1
    1e56:	f4 01       	movw	r30, r8
    1e58:	91 83       	std	Z+1, r25	; 0x01
    1e5a:	80 83       	st	Z, r24
            motor[i].isMoving = 0;
    1e5c:	1a 96       	adiw	r26, 0x0a	; 10
    1e5e:	1c 92       	st	X, r1
    1e60:	6f cf       	rjmp	.-290    	; 0x1d40 <__vector_9+0x432>
    if(motor[i].isMoving){
      if(stepDiff[i] > 0){
        /* check if we got one full rotation */
        if(((motor[i].actualPosition) + 1) > stepsPerFullRotation[i]){
          /* so set back to 0 */
          motor[i].actualPosition = 0;
    1e62:	f6 01       	movw	r30, r12
    1e64:	ee 0f       	add	r30, r30
    1e66:	ff 1f       	adc	r31, r31
    1e68:	ee 0f       	add	r30, r30
    1e6a:	ff 1f       	adc	r31, r31
    1e6c:	ee 0f       	add	r30, r30
    1e6e:	ff 1f       	adc	r31, r31
    1e70:	cf 01       	movw	r24, r30
    1e72:	88 0f       	add	r24, r24
    1e74:	99 1f       	adc	r25, r25
    1e76:	88 0f       	add	r24, r24
    1e78:	99 1f       	adc	r25, r25
    1e7a:	e8 0f       	add	r30, r24
    1e7c:	f9 1f       	adc	r31, r25
    1e7e:	e2 5e       	subi	r30, 0xE2	; 226
    1e80:	fb 4f       	sbci	r31, 0xFB	; 251
    1e82:	11 82       	std	Z+1, r1	; 0x01
    1e84:	10 82       	st	Z, r1
          /* correct desired motor position */
          motor[i].desiredPosition -= (int16_t)round(stepsPerFullRotation[i]);
    1e86:	f6 01       	movw	r30, r12
    1e88:	ee 0f       	add	r30, r30
    1e8a:	ff 1f       	adc	r31, r31
    1e8c:	ee 0f       	add	r30, r30
    1e8e:	ff 1f       	adc	r31, r31
    1e90:	cf 01       	movw	r24, r30
    1e92:	88 0f       	add	r24, r24
    1e94:	99 1f       	adc	r25, r25
    1e96:	88 0f       	add	r24, r24
    1e98:	99 1f       	adc	r25, r25
    1e9a:	e8 0f       	add	r30, r24
    1e9c:	f9 1f       	adc	r31, r25
    1e9e:	ee 0f       	add	r30, r30
    1ea0:	ff 1f       	adc	r31, r31
    1ea2:	e0 5e       	subi	r30, 0xE0	; 224
    1ea4:	fb 4f       	sbci	r31, 0xFB	; 251
    1ea6:	00 81       	ld	r16, Z
    1ea8:	11 81       	ldd	r17, Z+1	; 0x01
    1eaa:	c5 01       	movw	r24, r10
    1eac:	b4 01       	movw	r22, r8
    1eae:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    1eb2:	0e 94 f7 43 	call	0x87ee	; 0x87ee <__fixsfsi>
    1eb6:	06 1b       	sub	r16, r22
    1eb8:	17 0b       	sbc	r17, r23
    1eba:	f6 01       	movw	r30, r12
    1ebc:	ee 0f       	add	r30, r30
    1ebe:	ff 1f       	adc	r31, r31
    1ec0:	ee 0f       	add	r30, r30
    1ec2:	ff 1f       	adc	r31, r31
    1ec4:	cf 01       	movw	r24, r30
    1ec6:	88 0f       	add	r24, r24
    1ec8:	99 1f       	adc	r25, r25
    1eca:	88 0f       	add	r24, r24
    1ecc:	99 1f       	adc	r25, r25
    1ece:	e8 0f       	add	r30, r24
    1ed0:	f9 1f       	adc	r31, r25
    1ed2:	ee 0f       	add	r30, r30
    1ed4:	ff 1f       	adc	r31, r31
    1ed6:	e0 5e       	subi	r30, 0xE0	; 224
    1ed8:	fb 4f       	sbci	r31, 0xFB	; 251
    1eda:	11 83       	std	Z+1, r17	; 0x01
    1edc:	00 83       	st	Z, r16
    1ede:	67 ce       	rjmp	.-818    	; 0x1bae <__vector_9+0x2a0>
        if(motor[i].stepError > 1.0f){
          motor[i].desiredPosition += 1;
          motor[i].stepError -= 1.0f;
        }
        if(motor[i].stepError < -1.0f){
          motor[i].desiredPosition += -1;
    1ee0:	f2 01       	movw	r30, r4
    1ee2:	ee 0f       	add	r30, r30
    1ee4:	ff 1f       	adc	r31, r31
    1ee6:	ee 0f       	add	r30, r30
    1ee8:	ff 1f       	adc	r31, r31
    1eea:	e4 0d       	add	r30, r4
    1eec:	f5 1d       	adc	r31, r5
    1eee:	ee 0f       	add	r30, r30
    1ef0:	ff 1f       	adc	r31, r31
    1ef2:	e0 5e       	subi	r30, 0xE0	; 224
    1ef4:	fb 4f       	sbci	r31, 0xFB	; 251
    1ef6:	80 81       	ld	r24, Z
    1ef8:	91 81       	ldd	r25, Z+1	; 0x01
    1efa:	01 97       	sbiw	r24, 0x01	; 1
    1efc:	91 83       	std	Z+1, r25	; 0x01
    1efe:	80 83       	st	Z, r24
          motor[i].stepError += 1.0f;
    1f00:	f6 01       	movw	r30, r12
    1f02:	66 81       	ldd	r22, Z+6	; 0x06
    1f04:	77 81       	ldd	r23, Z+7	; 0x07
    1f06:	80 85       	ldd	r24, Z+8	; 0x08
    1f08:	91 85       	ldd	r25, Z+9	; 0x09
    1f0a:	20 e0       	ldi	r18, 0x00	; 0
    1f0c:	30 e0       	ldi	r19, 0x00	; 0
    1f0e:	40 e8       	ldi	r20, 0x80	; 128
    1f10:	5f e3       	ldi	r21, 0x3F	; 63
    1f12:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    1f16:	d6 01       	movw	r26, r12
    1f18:	16 96       	adiw	r26, 0x06	; 6
    1f1a:	6d 93       	st	X+, r22
    1f1c:	7d 93       	st	X+, r23
    1f1e:	8d 93       	st	X+, r24
    1f20:	9c 93       	st	X, r25
    1f22:	19 97       	sbiw	r26, 0x09	; 9
    1f24:	d1 cd       	rjmp	.-1118   	; 0x1ac8 <__vector_9+0x1ba>
        motor[i].isMoving = 1;

        if(stepDiff[i] < 0){
          /* moving CCW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1f26:	f2 01       	movw	r30, r4
    1f28:	e6 0d       	add	r30, r6
    1f2a:	f7 1d       	adc	r31, r7
    1f2c:	ef 5f       	subi	r30, 0xFF	; 255
    1f2e:	fb 4f       	sbci	r31, 0xFB	; 251
    1f30:	84 81       	ldd	r24, Z+4	; 0x04
    1f32:	88 23       	and	r24, r24
    1f34:	09 f5       	brne	.+66     	; 0x1f78 <__vector_9+0x66a>
             && ((motor[i].actualPosition + 1) == forbiddenZone[i].stop)){
            motor[i].desiredPosition = motor[i].actualPosition;
            motor[i].isMoving = 0;
          }
          else{
            outputDir  |= (1 << (2*i + 1)); /* 1 = CCW, 0 = CW */
    1f36:	2d 8d       	ldd	r18, Y+29	; 0x1d
    1f38:	3e 8d       	ldd	r19, Y+30	; 0x1e
    1f3a:	2f 5f       	subi	r18, 0xFF	; 255
    1f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f3e:	3e 8f       	std	Y+30, r19	; 0x1e
    1f40:	2d 8f       	std	Y+29, r18	; 0x1d
    1f42:	81 e0       	ldi	r24, 0x01	; 1
    1f44:	90 e0       	ldi	r25, 0x00	; 0
    1f46:	0d 8c       	ldd	r0, Y+29	; 0x1d
    1f48:	02 c0       	rjmp	.+4      	; 0x1f4e <__vector_9+0x640>
    1f4a:	88 0f       	add	r24, r24
    1f4c:	99 1f       	adc	r25, r25
    1f4e:	0a 94       	dec	r0
    1f50:	e2 f7       	brpl	.-8      	; 0x1f4a <__vector_9+0x63c>
    1f52:	21 50       	subi	r18, 0x01	; 1
    1f54:	30 40       	sbci	r19, 0x00	; 0
    1f56:	3e 8f       	std	Y+30, r19	; 0x1e
    1f58:	2d 8f       	std	Y+29, r18	; 0x1d
    1f5a:	38 a1       	ldd	r19, Y+32	; 0x20
    1f5c:	38 2b       	or	r19, r24
    1f5e:	38 a3       	std	Y+32, r19	; 0x20
            outputStep |= (1 << (2*i));
    1f60:	81 e0       	ldi	r24, 0x01	; 1
    1f62:	90 e0       	ldi	r25, 0x00	; 0
    1f64:	0d 8c       	ldd	r0, Y+29	; 0x1d
    1f66:	02 c0       	rjmp	.+4      	; 0x1f6c <__vector_9+0x65e>
    1f68:	88 0f       	add	r24, r24
    1f6a:	99 1f       	adc	r25, r25
    1f6c:	0a 94       	dec	r0
    1f6e:	e2 f7       	brpl	.-8      	; 0x1f68 <__vector_9+0x65a>
    1f70:	af 8d       	ldd	r26, Y+31	; 0x1f
    1f72:	a8 2b       	or	r26, r24
    1f74:	af 8f       	std	Y+31, r26	; 0x1f
    1f76:	e4 ce       	rjmp	.-568    	; 0x1d40 <__vector_9+0x432>
        motor[i].isMoving = 1;

        if(stepDiff[i] < 0){
          /* moving CCW */
          /* check for forbidden zone */
          if(forbiddenZone[i].active
    1f78:	d6 01       	movw	r26, r12
    1f7a:	8d 91       	ld	r24, X+
    1f7c:	9c 91       	ld	r25, X
    1f7e:	11 97       	sbiw	r26, 0x01	; 1
    1f80:	22 81       	ldd	r18, Z+2	; 0x02
    1f82:	33 81       	ldd	r19, Z+3	; 0x03
    1f84:	01 96       	adiw	r24, 0x01	; 1
    1f86:	82 17       	cp	r24, r18
    1f88:	93 07       	cpc	r25, r19
    1f8a:	a9 f6       	brne	.-86     	; 0x1f36 <__vector_9+0x628>
    1f8c:	61 cf       	rjmp	.-318    	; 0x1e50 <__vector_9+0x542>
      }
      else if(stepDiff[i] < 0){
      /* check if we got one full rotation */
        if(((motor[i].actualPosition) - 1) < 0){
          /* so set back to max steps per round */
          motor[i].actualPosition = (int16_t)round(stepsPerFullRotation[i]);
    1f8e:	eb 8d       	ldd	r30, Y+27	; 0x1b
    1f90:	fc 8d       	ldd	r31, Y+28	; 0x1c
    1f92:	60 81       	ld	r22, Z
    1f94:	71 81       	ldd	r23, Z+1	; 0x01
    1f96:	82 81       	ldd	r24, Z+2	; 0x02
    1f98:	93 81       	ldd	r25, Z+3	; 0x03
    1f9a:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    1f9e:	0e 94 f7 43 	call	0x87ee	; 0x87ee <__fixsfsi>
    1fa2:	ab 01       	movw	r20, r22
    1fa4:	f6 01       	movw	r30, r12
    1fa6:	ee 0f       	add	r30, r30
    1fa8:	ff 1f       	adc	r31, r31
    1faa:	ee 0f       	add	r30, r30
    1fac:	ff 1f       	adc	r31, r31
    1fae:	ee 0f       	add	r30, r30
    1fb0:	ff 1f       	adc	r31, r31
    1fb2:	9f 01       	movw	r18, r30
    1fb4:	22 0f       	add	r18, r18
    1fb6:	33 1f       	adc	r19, r19
    1fb8:	22 0f       	add	r18, r18
    1fba:	33 1f       	adc	r19, r19
    1fbc:	e2 0f       	add	r30, r18
    1fbe:	f3 1f       	adc	r31, r19
    1fc0:	e2 5e       	subi	r30, 0xE2	; 226
    1fc2:	fb 4f       	sbci	r31, 0xFB	; 251
    1fc4:	71 83       	std	Z+1, r23	; 0x01
    1fc6:	60 83       	st	Z, r22
          /* correct desired motor position */
          motor[i].desiredPosition += (int16_t)round(stepsPerFullRotation[i]);
    1fc8:	f6 01       	movw	r30, r12
    1fca:	ee 0f       	add	r30, r30
    1fcc:	ff 1f       	adc	r31, r31
    1fce:	ee 0f       	add	r30, r30
    1fd0:	ff 1f       	adc	r31, r31
    1fd2:	cf 01       	movw	r24, r30
    1fd4:	88 0f       	add	r24, r24
    1fd6:	99 1f       	adc	r25, r25
    1fd8:	88 0f       	add	r24, r24
    1fda:	99 1f       	adc	r25, r25
    1fdc:	e8 0f       	add	r30, r24
    1fde:	f9 1f       	adc	r31, r25
    1fe0:	ee 0f       	add	r30, r30
    1fe2:	ff 1f       	adc	r31, r31
    1fe4:	e0 5e       	subi	r30, 0xE0	; 224
    1fe6:	fb 4f       	sbci	r31, 0xFB	; 251
    1fe8:	80 81       	ld	r24, Z
    1fea:	91 81       	ldd	r25, Z+1	; 0x01
    1fec:	48 0f       	add	r20, r24
    1fee:	59 1f       	adc	r21, r25
    1ff0:	f6 01       	movw	r30, r12
    1ff2:	ee 0f       	add	r30, r30
    1ff4:	ff 1f       	adc	r31, r31
    1ff6:	ee 0f       	add	r30, r30
    1ff8:	ff 1f       	adc	r31, r31
    1ffa:	cf 01       	movw	r24, r30
    1ffc:	88 0f       	add	r24, r24
    1ffe:	99 1f       	adc	r25, r25
    2000:	88 0f       	add	r24, r24
    2002:	99 1f       	adc	r25, r25
    2004:	e8 0f       	add	r30, r24
    2006:	f9 1f       	adc	r31, r25
    2008:	ee 0f       	add	r30, r30
    200a:	ff 1f       	adc	r31, r31
    200c:	e0 5e       	subi	r30, 0xE0	; 224
    200e:	fb 4f       	sbci	r31, 0xFB	; 251
    2010:	51 83       	std	Z+1, r21	; 0x01
    2012:	40 83       	st	Z, r20
    2014:	bf ce       	rjmp	.-642    	; 0x1d94 <__vector_9+0x486>

00002016 <radiansToSteps>:
}

/* ---------------------------------------------------------------------
   set desired motor position if unit is radian
 --------------------------------------------------------------------- */
void radiansToSteps(uint8_t mot, double rad, double multiply){
    2016:	2f 92       	push	r2
    2018:	3f 92       	push	r3
    201a:	4f 92       	push	r4
    201c:	5f 92       	push	r5
    201e:	6f 92       	push	r6
    2020:	7f 92       	push	r7
    2022:	8f 92       	push	r8
    2024:	9f 92       	push	r9
    2026:	bf 92       	push	r11
    2028:	cf 92       	push	r12
    202a:	df 92       	push	r13
    202c:	ef 92       	push	r14
    202e:	ff 92       	push	r15
    2030:	0f 93       	push	r16
    2032:	1f 93       	push	r17
    2034:	df 93       	push	r29
    2036:	cf 93       	push	r28
    2038:	00 d0       	rcall	.+0      	; 0x203a <radiansToSteps+0x24>
    203a:	00 d0       	rcall	.+0      	; 0x203c <radiansToSteps+0x26>
    203c:	cd b7       	in	r28, 0x3d	; 61
    203e:	de b7       	in	r29, 0x3e	; 62
    2040:	b8 2e       	mov	r11, r24

  double roundedSteps = 0.0f;

  roundedSteps = round(rad * multiply *
    2042:	cb 01       	movw	r24, r22
    2044:	ba 01       	movw	r22, r20
    2046:	a9 01       	movw	r20, r18
    2048:	98 01       	movw	r18, r16
    204a:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    204e:	69 83       	std	Y+1, r22	; 0x01
    2050:	7a 83       	std	Y+2, r23	; 0x02
    2052:	8b 83       	std	Y+3, r24	; 0x03
    2054:	9c 83       	std	Y+4, r25	; 0x04
    2056:	ee e1       	ldi	r30, 0x1E	; 30
    2058:	ce 2e       	mov	r12, r30
    205a:	e4 e0       	ldi	r30, 0x04	; 4
    205c:	de 2e       	mov	r13, r30
    205e:	eb 2d       	mov	r30, r11
    2060:	f0 e0       	ldi	r31, 0x00	; 0
    2062:	ee 0f       	add	r30, r30
    2064:	ff 1f       	adc	r31, r31
    2066:	ee 0f       	add	r30, r30
    2068:	ff 1f       	adc	r31, r31
    206a:	ee 0f       	add	r30, r30
    206c:	ff 1f       	adc	r31, r31
    206e:	cf 01       	movw	r24, r30
    2070:	88 0f       	add	r24, r24
    2072:	99 1f       	adc	r25, r25
    2074:	88 0f       	add	r24, r24
    2076:	99 1f       	adc	r25, r25
    2078:	e8 0f       	add	r30, r24
    207a:	f9 1f       	adc	r31, r25
    207c:	ec 0d       	add	r30, r12
    207e:	fd 1d       	adc	r31, r13
    2080:	61 89       	ldd	r22, Z+17	; 0x11
    2082:	72 89       	ldd	r23, Z+18	; 0x12
    2084:	83 89       	ldd	r24, Z+19	; 0x13
    2086:	94 89       	ldd	r25, Z+20	; 0x14
    2088:	eb 2d       	mov	r30, r11
    208a:	f0 e0       	ldi	r31, 0x00	; 0
    208c:	ee 0f       	add	r30, r30
    208e:	ff 1f       	adc	r31, r31
    2090:	ee 0f       	add	r30, r30
    2092:	ff 1f       	adc	r31, r31
    2094:	ee 0f       	add	r30, r30
    2096:	ff 1f       	adc	r31, r31
    2098:	9f 01       	movw	r18, r30
    209a:	22 0f       	add	r18, r18
    209c:	33 1f       	adc	r19, r19
    209e:	22 0f       	add	r18, r18
    20a0:	33 1f       	adc	r19, r19
    20a2:	e2 0f       	add	r30, r18
    20a4:	f3 1f       	adc	r31, r19
    20a6:	ec 0d       	add	r30, r12
    20a8:	fd 1d       	adc	r31, r13
    20aa:	25 85       	ldd	r18, Z+13	; 0x0d
    20ac:	36 85       	ldd	r19, Z+14	; 0x0e
    20ae:	47 85       	ldd	r20, Z+15	; 0x0f
    20b0:	50 89       	ldd	r21, Z+16	; 0x10
    20b2:	eb 2d       	mov	r30, r11
    20b4:	f0 e0       	ldi	r31, 0x00	; 0
    20b6:	ee 0f       	add	r30, r30
    20b8:	ff 1f       	adc	r31, r31
    20ba:	ee 0f       	add	r30, r30
    20bc:	ff 1f       	adc	r31, r31
    20be:	ee 0f       	add	r30, r30
    20c0:	ff 1f       	adc	r31, r31
    20c2:	df 01       	movw	r26, r30
    20c4:	aa 0f       	add	r26, r26
    20c6:	bb 1f       	adc	r27, r27
    20c8:	aa 0f       	add	r26, r26
    20ca:	bb 1f       	adc	r27, r27
    20cc:	ea 0f       	add	r30, r26
    20ce:	fb 1f       	adc	r31, r27
    20d0:	ec 0d       	add	r30, r12
    20d2:	fd 1d       	adc	r31, r13
    20d4:	e5 88       	ldd	r14, Z+21	; 0x15
    20d6:	f6 88       	ldd	r15, Z+22	; 0x16
    20d8:	07 89       	ldd	r16, Z+23	; 0x17
    20da:	10 8d       	ldd	r17, Z+24	; 0x18
    20dc:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    20e0:	a8 01       	movw	r20, r16
    20e2:	97 01       	movw	r18, r14
    20e4:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    20e8:	20 e0       	ldi	r18, 0x00	; 0
    20ea:	30 e0       	ldi	r19, 0x00	; 0
    20ec:	40 e0       	ldi	r20, 0x00	; 0
    20ee:	5f e3       	ldi	r21, 0x3F	; 63
    20f0:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    20f4:	9b 01       	movw	r18, r22
    20f6:	ac 01       	movw	r20, r24
    20f8:	69 81       	ldd	r22, Y+1	; 0x01
    20fa:	7a 81       	ldd	r23, Y+2	; 0x02
    20fc:	8b 81       	ldd	r24, Y+3	; 0x03
    20fe:	9c 81       	ldd	r25, Y+4	; 0x04
    2100:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    2104:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    2108:	1b 01       	movw	r2, r22
    210a:	2c 01       	movw	r4, r24
          ((motor[mot].stepsPerFullRotation
           *motor[mot].gearRatio
           *motor[mot].subSteps)/(2.0f)));

  motor[mot].desiredPosition += (int16_t)roundedSteps;
    210c:	eb 2d       	mov	r30, r11
    210e:	f0 e0       	ldi	r31, 0x00	; 0
    2110:	ee 0f       	add	r30, r30
    2112:	ff 1f       	adc	r31, r31
    2114:	ee 0f       	add	r30, r30
    2116:	ff 1f       	adc	r31, r31
    2118:	cf 01       	movw	r24, r30
    211a:	88 0f       	add	r24, r24
    211c:	99 1f       	adc	r25, r25
    211e:	88 0f       	add	r24, r24
    2120:	99 1f       	adc	r25, r25
    2122:	e8 0f       	add	r30, r24
    2124:	f9 1f       	adc	r31, r25
    2126:	31 96       	adiw	r30, 0x01	; 1
    2128:	ee 0f       	add	r30, r30
    212a:	ff 1f       	adc	r31, r31
    212c:	ec 0d       	add	r30, r12
    212e:	fd 1d       	adc	r31, r13
    2130:	00 81       	ld	r16, Z
    2132:	11 81       	ldd	r17, Z+1	; 0x01
    2134:	c2 01       	movw	r24, r4
    2136:	b1 01       	movw	r22, r2
    2138:	0e 94 f7 43 	call	0x87ee	; 0x87ee <__fixsfsi>
    213c:	60 0f       	add	r22, r16
    213e:	71 1f       	adc	r23, r17
    2140:	eb 2d       	mov	r30, r11
    2142:	f0 e0       	ldi	r31, 0x00	; 0
    2144:	ee 0f       	add	r30, r30
    2146:	ff 1f       	adc	r31, r31
    2148:	ee 0f       	add	r30, r30
    214a:	ff 1f       	adc	r31, r31
    214c:	9f 01       	movw	r18, r30
    214e:	22 0f       	add	r18, r18
    2150:	33 1f       	adc	r19, r19
    2152:	22 0f       	add	r18, r18
    2154:	33 1f       	adc	r19, r19
    2156:	e2 0f       	add	r30, r18
    2158:	f3 1f       	adc	r31, r19
    215a:	31 96       	adiw	r30, 0x01	; 1
    215c:	ee 0f       	add	r30, r30
    215e:	ff 1f       	adc	r31, r31
    2160:	ec 0d       	add	r30, r12
    2162:	fd 1d       	adc	r31, r13
    2164:	71 83       	std	Z+1, r23	; 0x01
    2166:	60 83       	st	Z, r22

  /* calculate rounding-error */
  motor[mot].stepError +=
    2168:	eb 2d       	mov	r30, r11
    216a:	f0 e0       	ldi	r31, 0x00	; 0
    216c:	ee 0f       	add	r30, r30
    216e:	ff 1f       	adc	r31, r31
    2170:	ee 0f       	add	r30, r30
    2172:	ff 1f       	adc	r31, r31
    2174:	ee 0f       	add	r30, r30
    2176:	ff 1f       	adc	r31, r31
    2178:	cf 01       	movw	r24, r30
    217a:	88 0f       	add	r24, r24
    217c:	99 1f       	adc	r25, r25
    217e:	88 0f       	add	r24, r24
    2180:	99 1f       	adc	r25, r25
    2182:	e8 0f       	add	r30, r24
    2184:	f9 1f       	adc	r31, r25
    2186:	ec 0d       	add	r30, r12
    2188:	fd 1d       	adc	r31, r13
    218a:	66 80       	ldd	r6, Z+6	; 0x06
    218c:	77 80       	ldd	r7, Z+7	; 0x07
    218e:	80 84       	ldd	r8, Z+8	; 0x08
    2190:	91 84       	ldd	r9, Z+9	; 0x09
    2192:	eb 2d       	mov	r30, r11
    2194:	f0 e0       	ldi	r31, 0x00	; 0
    2196:	ee 0f       	add	r30, r30
    2198:	ff 1f       	adc	r31, r31
    219a:	ee 0f       	add	r30, r30
    219c:	ff 1f       	adc	r31, r31
    219e:	ee 0f       	add	r30, r30
    21a0:	ff 1f       	adc	r31, r31
    21a2:	cf 01       	movw	r24, r30
    21a4:	88 0f       	add	r24, r24
    21a6:	99 1f       	adc	r25, r25
    21a8:	88 0f       	add	r24, r24
    21aa:	99 1f       	adc	r25, r25
    21ac:	e8 0f       	add	r30, r24
    21ae:	f9 1f       	adc	r31, r25
    21b0:	ec 0d       	add	r30, r12
    21b2:	fd 1d       	adc	r31, r13
    21b4:	61 89       	ldd	r22, Z+17	; 0x11
    21b6:	72 89       	ldd	r23, Z+18	; 0x12
    21b8:	83 89       	ldd	r24, Z+19	; 0x13
    21ba:	94 89       	ldd	r25, Z+20	; 0x14
    21bc:	eb 2d       	mov	r30, r11
    21be:	f0 e0       	ldi	r31, 0x00	; 0
    21c0:	ee 0f       	add	r30, r30
    21c2:	ff 1f       	adc	r31, r31
    21c4:	ee 0f       	add	r30, r30
    21c6:	ff 1f       	adc	r31, r31
    21c8:	ee 0f       	add	r30, r30
    21ca:	ff 1f       	adc	r31, r31
    21cc:	9f 01       	movw	r18, r30
    21ce:	22 0f       	add	r18, r18
    21d0:	33 1f       	adc	r19, r19
    21d2:	22 0f       	add	r18, r18
    21d4:	33 1f       	adc	r19, r19
    21d6:	e2 0f       	add	r30, r18
    21d8:	f3 1f       	adc	r31, r19
    21da:	ec 0d       	add	r30, r12
    21dc:	fd 1d       	adc	r31, r13
    21de:	25 85       	ldd	r18, Z+13	; 0x0d
    21e0:	36 85       	ldd	r19, Z+14	; 0x0e
    21e2:	47 85       	ldd	r20, Z+15	; 0x0f
    21e4:	50 89       	ldd	r21, Z+16	; 0x10
    21e6:	eb 2d       	mov	r30, r11
    21e8:	f0 e0       	ldi	r31, 0x00	; 0
    21ea:	ee 0f       	add	r30, r30
    21ec:	ff 1f       	adc	r31, r31
    21ee:	ee 0f       	add	r30, r30
    21f0:	ff 1f       	adc	r31, r31
    21f2:	ee 0f       	add	r30, r30
    21f4:	ff 1f       	adc	r31, r31
    21f6:	df 01       	movw	r26, r30
    21f8:	aa 0f       	add	r26, r26
    21fa:	bb 1f       	adc	r27, r27
    21fc:	aa 0f       	add	r26, r26
    21fe:	bb 1f       	adc	r27, r27
    2200:	ea 0f       	add	r30, r26
    2202:	fb 1f       	adc	r31, r27
    2204:	ec 0d       	add	r30, r12
    2206:	fd 1d       	adc	r31, r13
    2208:	e5 88       	ldd	r14, Z+21	; 0x15
    220a:	f6 88       	ldd	r15, Z+22	; 0x16
    220c:	07 89       	ldd	r16, Z+23	; 0x17
    220e:	10 8d       	ldd	r17, Z+24	; 0x18
    2210:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    2214:	a8 01       	movw	r20, r16
    2216:	97 01       	movw	r18, r14
    2218:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    221c:	20 e0       	ldi	r18, 0x00	; 0
    221e:	30 e0       	ldi	r19, 0x00	; 0
    2220:	40 e0       	ldi	r20, 0x00	; 0
    2222:	5f e3       	ldi	r21, 0x3F	; 63
    2224:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    2228:	9b 01       	movw	r18, r22
    222a:	ac 01       	movw	r20, r24
    222c:	69 81       	ldd	r22, Y+1	; 0x01
    222e:	7a 81       	ldd	r23, Y+2	; 0x02
    2230:	8b 81       	ldd	r24, Y+3	; 0x03
    2232:	9c 81       	ldd	r25, Y+4	; 0x04
    2234:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    2238:	a2 01       	movw	r20, r4
    223a:	91 01       	movw	r18, r2
    223c:	0e 94 26 43 	call	0x864c	; 0x864c <__subsf3>
    2240:	9b 01       	movw	r18, r22
    2242:	ac 01       	movw	r20, r24
    2244:	c4 01       	movw	r24, r8
    2246:	b3 01       	movw	r22, r6
    2248:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    224c:	2b 2d       	mov	r18, r11
    224e:	30 e0       	ldi	r19, 0x00	; 0
    2250:	22 0f       	add	r18, r18
    2252:	33 1f       	adc	r19, r19
    2254:	22 0f       	add	r18, r18
    2256:	33 1f       	adc	r19, r19
    2258:	22 0f       	add	r18, r18
    225a:	33 1f       	adc	r19, r19
    225c:	a9 01       	movw	r20, r18
    225e:	44 0f       	add	r20, r20
    2260:	55 1f       	adc	r21, r21
    2262:	44 0f       	add	r20, r20
    2264:	55 1f       	adc	r21, r21
    2266:	24 0f       	add	r18, r20
    2268:	35 1f       	adc	r19, r21
    226a:	c2 0e       	add	r12, r18
    226c:	d3 1e       	adc	r13, r19
    226e:	f6 01       	movw	r30, r12
    2270:	66 83       	std	Z+6, r22	; 0x06
    2272:	77 83       	std	Z+7, r23	; 0x07
    2274:	80 87       	std	Z+8, r24	; 0x08
    2276:	91 87       	std	Z+9, r25	; 0x09
       *motor[mot].gearRatio
       *motor[mot].subSteps)/(2.0f))
       - roundedSteps;

  return;
}
    2278:	0f 90       	pop	r0
    227a:	0f 90       	pop	r0
    227c:	0f 90       	pop	r0
    227e:	0f 90       	pop	r0
    2280:	cf 91       	pop	r28
    2282:	df 91       	pop	r29
    2284:	1f 91       	pop	r17
    2286:	0f 91       	pop	r16
    2288:	ff 90       	pop	r15
    228a:	ef 90       	pop	r14
    228c:	df 90       	pop	r13
    228e:	cf 90       	pop	r12
    2290:	bf 90       	pop	r11
    2292:	9f 90       	pop	r9
    2294:	8f 90       	pop	r8
    2296:	7f 90       	pop	r7
    2298:	6f 90       	pop	r6
    229a:	5f 90       	pop	r5
    229c:	4f 90       	pop	r4
    229e:	3f 90       	pop	r3
    22a0:	2f 90       	pop	r2
    22a2:	08 95       	ret

000022a4 <degreeToSteps>:
}

/* ---------------------------------------------------------------------
   set desired motor position if unit is degree
 --------------------------------------------------------------------- */
void degreeToSteps(uint8_t mot, double degree, double multiply){
    22a4:	2f 92       	push	r2
    22a6:	3f 92       	push	r3
    22a8:	4f 92       	push	r4
    22aa:	5f 92       	push	r5
    22ac:	6f 92       	push	r6
    22ae:	7f 92       	push	r7
    22b0:	8f 92       	push	r8
    22b2:	9f 92       	push	r9
    22b4:	bf 92       	push	r11
    22b6:	cf 92       	push	r12
    22b8:	df 92       	push	r13
    22ba:	ef 92       	push	r14
    22bc:	ff 92       	push	r15
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	df 93       	push	r29
    22c4:	cf 93       	push	r28
    22c6:	00 d0       	rcall	.+0      	; 0x22c8 <degreeToSteps+0x24>
    22c8:	00 d0       	rcall	.+0      	; 0x22ca <degreeToSteps+0x26>
    22ca:	cd b7       	in	r28, 0x3d	; 61
    22cc:	de b7       	in	r29, 0x3e	; 62
    22ce:	b8 2e       	mov	r11, r24

  double roundedSteps = 0.0;

  roundedSteps = round(degree * multiply *
    22d0:	cb 01       	movw	r24, r22
    22d2:	ba 01       	movw	r22, r20
    22d4:	a9 01       	movw	r20, r18
    22d6:	98 01       	movw	r18, r16
    22d8:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    22dc:	69 83       	std	Y+1, r22	; 0x01
    22de:	7a 83       	std	Y+2, r23	; 0x02
    22e0:	8b 83       	std	Y+3, r24	; 0x03
    22e2:	9c 83       	std	Y+4, r25	; 0x04
    22e4:	ee e1       	ldi	r30, 0x1E	; 30
    22e6:	ce 2e       	mov	r12, r30
    22e8:	e4 e0       	ldi	r30, 0x04	; 4
    22ea:	de 2e       	mov	r13, r30
    22ec:	eb 2d       	mov	r30, r11
    22ee:	f0 e0       	ldi	r31, 0x00	; 0
    22f0:	ee 0f       	add	r30, r30
    22f2:	ff 1f       	adc	r31, r31
    22f4:	ee 0f       	add	r30, r30
    22f6:	ff 1f       	adc	r31, r31
    22f8:	ee 0f       	add	r30, r30
    22fa:	ff 1f       	adc	r31, r31
    22fc:	cf 01       	movw	r24, r30
    22fe:	88 0f       	add	r24, r24
    2300:	99 1f       	adc	r25, r25
    2302:	88 0f       	add	r24, r24
    2304:	99 1f       	adc	r25, r25
    2306:	e8 0f       	add	r30, r24
    2308:	f9 1f       	adc	r31, r25
    230a:	ec 0d       	add	r30, r12
    230c:	fd 1d       	adc	r31, r13
    230e:	61 89       	ldd	r22, Z+17	; 0x11
    2310:	72 89       	ldd	r23, Z+18	; 0x12
    2312:	83 89       	ldd	r24, Z+19	; 0x13
    2314:	94 89       	ldd	r25, Z+20	; 0x14
    2316:	eb 2d       	mov	r30, r11
    2318:	f0 e0       	ldi	r31, 0x00	; 0
    231a:	ee 0f       	add	r30, r30
    231c:	ff 1f       	adc	r31, r31
    231e:	ee 0f       	add	r30, r30
    2320:	ff 1f       	adc	r31, r31
    2322:	ee 0f       	add	r30, r30
    2324:	ff 1f       	adc	r31, r31
    2326:	9f 01       	movw	r18, r30
    2328:	22 0f       	add	r18, r18
    232a:	33 1f       	adc	r19, r19
    232c:	22 0f       	add	r18, r18
    232e:	33 1f       	adc	r19, r19
    2330:	e2 0f       	add	r30, r18
    2332:	f3 1f       	adc	r31, r19
    2334:	ec 0d       	add	r30, r12
    2336:	fd 1d       	adc	r31, r13
    2338:	25 85       	ldd	r18, Z+13	; 0x0d
    233a:	36 85       	ldd	r19, Z+14	; 0x0e
    233c:	47 85       	ldd	r20, Z+15	; 0x0f
    233e:	50 89       	ldd	r21, Z+16	; 0x10
    2340:	eb 2d       	mov	r30, r11
    2342:	f0 e0       	ldi	r31, 0x00	; 0
    2344:	ee 0f       	add	r30, r30
    2346:	ff 1f       	adc	r31, r31
    2348:	ee 0f       	add	r30, r30
    234a:	ff 1f       	adc	r31, r31
    234c:	ee 0f       	add	r30, r30
    234e:	ff 1f       	adc	r31, r31
    2350:	df 01       	movw	r26, r30
    2352:	aa 0f       	add	r26, r26
    2354:	bb 1f       	adc	r27, r27
    2356:	aa 0f       	add	r26, r26
    2358:	bb 1f       	adc	r27, r27
    235a:	ea 0f       	add	r30, r26
    235c:	fb 1f       	adc	r31, r27
    235e:	ec 0d       	add	r30, r12
    2360:	fd 1d       	adc	r31, r13
    2362:	e5 88       	ldd	r14, Z+21	; 0x15
    2364:	f6 88       	ldd	r15, Z+22	; 0x16
    2366:	07 89       	ldd	r16, Z+23	; 0x17
    2368:	10 8d       	ldd	r17, Z+24	; 0x18
    236a:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    236e:	a8 01       	movw	r20, r16
    2370:	97 01       	movw	r18, r14
    2372:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    2376:	20 e0       	ldi	r18, 0x00	; 0
    2378:	30 e0       	ldi	r19, 0x00	; 0
    237a:	44 eb       	ldi	r20, 0xB4	; 180
    237c:	53 e4       	ldi	r21, 0x43	; 67
    237e:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    2382:	9b 01       	movw	r18, r22
    2384:	ac 01       	movw	r20, r24
    2386:	69 81       	ldd	r22, Y+1	; 0x01
    2388:	7a 81       	ldd	r23, Y+2	; 0x02
    238a:	8b 81       	ldd	r24, Y+3	; 0x03
    238c:	9c 81       	ldd	r25, Y+4	; 0x04
    238e:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    2392:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    2396:	1b 01       	movw	r2, r22
    2398:	2c 01       	movw	r4, r24
          ((motor[mot].stepsPerFullRotation
           *motor[mot].gearRatio
           *motor[mot].subSteps)/(360.0f)));

  motor[mot].desiredPosition += (int16_t)roundedSteps;
    239a:	eb 2d       	mov	r30, r11
    239c:	f0 e0       	ldi	r31, 0x00	; 0
    239e:	ee 0f       	add	r30, r30
    23a0:	ff 1f       	adc	r31, r31
    23a2:	ee 0f       	add	r30, r30
    23a4:	ff 1f       	adc	r31, r31
    23a6:	cf 01       	movw	r24, r30
    23a8:	88 0f       	add	r24, r24
    23aa:	99 1f       	adc	r25, r25
    23ac:	88 0f       	add	r24, r24
    23ae:	99 1f       	adc	r25, r25
    23b0:	e8 0f       	add	r30, r24
    23b2:	f9 1f       	adc	r31, r25
    23b4:	31 96       	adiw	r30, 0x01	; 1
    23b6:	ee 0f       	add	r30, r30
    23b8:	ff 1f       	adc	r31, r31
    23ba:	ec 0d       	add	r30, r12
    23bc:	fd 1d       	adc	r31, r13
    23be:	00 81       	ld	r16, Z
    23c0:	11 81       	ldd	r17, Z+1	; 0x01
    23c2:	c2 01       	movw	r24, r4
    23c4:	b1 01       	movw	r22, r2
    23c6:	0e 94 f7 43 	call	0x87ee	; 0x87ee <__fixsfsi>
    23ca:	60 0f       	add	r22, r16
    23cc:	71 1f       	adc	r23, r17
    23ce:	eb 2d       	mov	r30, r11
    23d0:	f0 e0       	ldi	r31, 0x00	; 0
    23d2:	ee 0f       	add	r30, r30
    23d4:	ff 1f       	adc	r31, r31
    23d6:	ee 0f       	add	r30, r30
    23d8:	ff 1f       	adc	r31, r31
    23da:	9f 01       	movw	r18, r30
    23dc:	22 0f       	add	r18, r18
    23de:	33 1f       	adc	r19, r19
    23e0:	22 0f       	add	r18, r18
    23e2:	33 1f       	adc	r19, r19
    23e4:	e2 0f       	add	r30, r18
    23e6:	f3 1f       	adc	r31, r19
    23e8:	31 96       	adiw	r30, 0x01	; 1
    23ea:	ee 0f       	add	r30, r30
    23ec:	ff 1f       	adc	r31, r31
    23ee:	ec 0d       	add	r30, r12
    23f0:	fd 1d       	adc	r31, r13
    23f2:	71 83       	std	Z+1, r23	; 0x01
    23f4:	60 83       	st	Z, r22

  /* calculate rounding-error */
  motor[mot].stepError +=
    23f6:	eb 2d       	mov	r30, r11
    23f8:	f0 e0       	ldi	r31, 0x00	; 0
    23fa:	ee 0f       	add	r30, r30
    23fc:	ff 1f       	adc	r31, r31
    23fe:	ee 0f       	add	r30, r30
    2400:	ff 1f       	adc	r31, r31
    2402:	ee 0f       	add	r30, r30
    2404:	ff 1f       	adc	r31, r31
    2406:	cf 01       	movw	r24, r30
    2408:	88 0f       	add	r24, r24
    240a:	99 1f       	adc	r25, r25
    240c:	88 0f       	add	r24, r24
    240e:	99 1f       	adc	r25, r25
    2410:	e8 0f       	add	r30, r24
    2412:	f9 1f       	adc	r31, r25
    2414:	ec 0d       	add	r30, r12
    2416:	fd 1d       	adc	r31, r13
    2418:	66 80       	ldd	r6, Z+6	; 0x06
    241a:	77 80       	ldd	r7, Z+7	; 0x07
    241c:	80 84       	ldd	r8, Z+8	; 0x08
    241e:	91 84       	ldd	r9, Z+9	; 0x09
    2420:	eb 2d       	mov	r30, r11
    2422:	f0 e0       	ldi	r31, 0x00	; 0
    2424:	ee 0f       	add	r30, r30
    2426:	ff 1f       	adc	r31, r31
    2428:	ee 0f       	add	r30, r30
    242a:	ff 1f       	adc	r31, r31
    242c:	ee 0f       	add	r30, r30
    242e:	ff 1f       	adc	r31, r31
    2430:	cf 01       	movw	r24, r30
    2432:	88 0f       	add	r24, r24
    2434:	99 1f       	adc	r25, r25
    2436:	88 0f       	add	r24, r24
    2438:	99 1f       	adc	r25, r25
    243a:	e8 0f       	add	r30, r24
    243c:	f9 1f       	adc	r31, r25
    243e:	ec 0d       	add	r30, r12
    2440:	fd 1d       	adc	r31, r13
    2442:	61 89       	ldd	r22, Z+17	; 0x11
    2444:	72 89       	ldd	r23, Z+18	; 0x12
    2446:	83 89       	ldd	r24, Z+19	; 0x13
    2448:	94 89       	ldd	r25, Z+20	; 0x14
    244a:	eb 2d       	mov	r30, r11
    244c:	f0 e0       	ldi	r31, 0x00	; 0
    244e:	ee 0f       	add	r30, r30
    2450:	ff 1f       	adc	r31, r31
    2452:	ee 0f       	add	r30, r30
    2454:	ff 1f       	adc	r31, r31
    2456:	ee 0f       	add	r30, r30
    2458:	ff 1f       	adc	r31, r31
    245a:	9f 01       	movw	r18, r30
    245c:	22 0f       	add	r18, r18
    245e:	33 1f       	adc	r19, r19
    2460:	22 0f       	add	r18, r18
    2462:	33 1f       	adc	r19, r19
    2464:	e2 0f       	add	r30, r18
    2466:	f3 1f       	adc	r31, r19
    2468:	ec 0d       	add	r30, r12
    246a:	fd 1d       	adc	r31, r13
    246c:	25 85       	ldd	r18, Z+13	; 0x0d
    246e:	36 85       	ldd	r19, Z+14	; 0x0e
    2470:	47 85       	ldd	r20, Z+15	; 0x0f
    2472:	50 89       	ldd	r21, Z+16	; 0x10
    2474:	eb 2d       	mov	r30, r11
    2476:	f0 e0       	ldi	r31, 0x00	; 0
    2478:	ee 0f       	add	r30, r30
    247a:	ff 1f       	adc	r31, r31
    247c:	ee 0f       	add	r30, r30
    247e:	ff 1f       	adc	r31, r31
    2480:	ee 0f       	add	r30, r30
    2482:	ff 1f       	adc	r31, r31
    2484:	df 01       	movw	r26, r30
    2486:	aa 0f       	add	r26, r26
    2488:	bb 1f       	adc	r27, r27
    248a:	aa 0f       	add	r26, r26
    248c:	bb 1f       	adc	r27, r27
    248e:	ea 0f       	add	r30, r26
    2490:	fb 1f       	adc	r31, r27
    2492:	ec 0d       	add	r30, r12
    2494:	fd 1d       	adc	r31, r13
    2496:	e5 88       	ldd	r14, Z+21	; 0x15
    2498:	f6 88       	ldd	r15, Z+22	; 0x16
    249a:	07 89       	ldd	r16, Z+23	; 0x17
    249c:	10 8d       	ldd	r17, Z+24	; 0x18
    249e:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    24a2:	a8 01       	movw	r20, r16
    24a4:	97 01       	movw	r18, r14
    24a6:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    24aa:	20 e0       	ldi	r18, 0x00	; 0
    24ac:	30 e0       	ldi	r19, 0x00	; 0
    24ae:	44 eb       	ldi	r20, 0xB4	; 180
    24b0:	53 e4       	ldi	r21, 0x43	; 67
    24b2:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    24b6:	9b 01       	movw	r18, r22
    24b8:	ac 01       	movw	r20, r24
    24ba:	69 81       	ldd	r22, Y+1	; 0x01
    24bc:	7a 81       	ldd	r23, Y+2	; 0x02
    24be:	8b 81       	ldd	r24, Y+3	; 0x03
    24c0:	9c 81       	ldd	r25, Y+4	; 0x04
    24c2:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    24c6:	a2 01       	movw	r20, r4
    24c8:	91 01       	movw	r18, r2
    24ca:	0e 94 26 43 	call	0x864c	; 0x864c <__subsf3>
    24ce:	9b 01       	movw	r18, r22
    24d0:	ac 01       	movw	r20, r24
    24d2:	c4 01       	movw	r24, r8
    24d4:	b3 01       	movw	r22, r6
    24d6:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    24da:	2b 2d       	mov	r18, r11
    24dc:	30 e0       	ldi	r19, 0x00	; 0
    24de:	22 0f       	add	r18, r18
    24e0:	33 1f       	adc	r19, r19
    24e2:	22 0f       	add	r18, r18
    24e4:	33 1f       	adc	r19, r19
    24e6:	22 0f       	add	r18, r18
    24e8:	33 1f       	adc	r19, r19
    24ea:	a9 01       	movw	r20, r18
    24ec:	44 0f       	add	r20, r20
    24ee:	55 1f       	adc	r21, r21
    24f0:	44 0f       	add	r20, r20
    24f2:	55 1f       	adc	r21, r21
    24f4:	24 0f       	add	r18, r20
    24f6:	35 1f       	adc	r19, r21
    24f8:	c2 0e       	add	r12, r18
    24fa:	d3 1e       	adc	r13, r19
    24fc:	f6 01       	movw	r30, r12
    24fe:	66 83       	std	Z+6, r22	; 0x06
    2500:	77 83       	std	Z+7, r23	; 0x07
    2502:	80 87       	std	Z+8, r24	; 0x08
    2504:	91 87       	std	Z+9, r25	; 0x09
       *motor[mot].gearRatio
       *motor[mot].subSteps)/(360.0f))
       - roundedSteps;

  return;
}
    2506:	0f 90       	pop	r0
    2508:	0f 90       	pop	r0
    250a:	0f 90       	pop	r0
    250c:	0f 90       	pop	r0
    250e:	cf 91       	pop	r28
    2510:	df 91       	pop	r29
    2512:	1f 91       	pop	r17
    2514:	0f 91       	pop	r16
    2516:	ff 90       	pop	r15
    2518:	ef 90       	pop	r14
    251a:	df 90       	pop	r13
    251c:	cf 90       	pop	r12
    251e:	bf 90       	pop	r11
    2520:	9f 90       	pop	r9
    2522:	8f 90       	pop	r8
    2524:	7f 90       	pop	r7
    2526:	6f 90       	pop	r6
    2528:	5f 90       	pop	r5
    252a:	4f 90       	pop	r4
    252c:	3f 90       	pop	r3
    252e:	2f 90       	pop	r2
    2530:	08 95       	ret

00002532 <commandGetMotorDecay>:
 --------------------------------------------------------------------- */
char* commandGetMotorDecay(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2532:	60 e0       	ldi	r22, 0x00	; 0
    2534:	70 e0       	ldi	r23, 0x00	; 0
    2536:	4a e0       	ldi	r20, 0x0A	; 10
    2538:	50 e0       	ldi	r21, 0x00	; 0
    253a:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    253e:	64 30       	cpi	r22, 0x04	; 4
    2540:	d8 f5       	brcc	.+118    	; 0x25b8 <commandGetMotorDecay+0x86>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].decay);
    2542:	40 91 15 04 	lds	r20, 0x0415
    2546:	50 91 16 04 	lds	r21, 0x0416
    254a:	e6 2f       	mov	r30, r22
    254c:	f0 e0       	ldi	r31, 0x00	; 0
    254e:	ee 0f       	add	r30, r30
    2550:	ff 1f       	adc	r31, r31
    2552:	ee 0f       	add	r30, r30
    2554:	ff 1f       	adc	r31, r31
    2556:	ee 0f       	add	r30, r30
    2558:	ff 1f       	adc	r31, r31
    255a:	cf 01       	movw	r24, r30
    255c:	88 0f       	add	r24, r24
    255e:	99 1f       	adc	r25, r25
    2560:	88 0f       	add	r24, r24
    2562:	99 1f       	adc	r25, r25
    2564:	e8 0f       	add	r30, r24
    2566:	f9 1f       	adc	r31, r25
    2568:	e2 5e       	subi	r30, 0xE2	; 226
    256a:	fb 4f       	sbci	r31, 0xFB	; 251
    256c:	27 a1       	ldd	r18, Z+39	; 0x27
    256e:	00 d0       	rcall	.+0      	; 0x2570 <commandGetMotorDecay+0x3e>
    2570:	00 d0       	rcall	.+0      	; 0x2572 <commandGetMotorDecay+0x40>
    2572:	00 d0       	rcall	.+0      	; 0x2574 <commandGetMotorDecay+0x42>
    2574:	ed b7       	in	r30, 0x3d	; 61
    2576:	fe b7       	in	r31, 0x3e	; 62
    2578:	31 96       	adiw	r30, 0x01	; 1
    257a:	ad b7       	in	r26, 0x3d	; 61
    257c:	be b7       	in	r27, 0x3e	; 62
    257e:	12 96       	adiw	r26, 0x02	; 2
    2580:	5c 93       	st	X, r21
    2582:	4e 93       	st	-X, r20
    2584:	11 97       	sbiw	r26, 0x01	; 1
    2586:	87 e1       	ldi	r24, 0x17	; 23
    2588:	91 e0       	ldi	r25, 0x01	; 1
    258a:	93 83       	std	Z+3, r25	; 0x03
    258c:	82 83       	std	Z+2, r24	; 0x02
    258e:	33 27       	eor	r19, r19
    2590:	27 fd       	sbrc	r18, 7
    2592:	30 95       	com	r19
    2594:	35 83       	std	Z+5, r19	; 0x05
    2596:	24 83       	std	Z+4, r18	; 0x04
    2598:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    259c:	8d b7       	in	r24, 0x3d	; 61
    259e:	9e b7       	in	r25, 0x3e	; 62
    25a0:	06 96       	adiw	r24, 0x06	; 6
    25a2:	0f b6       	in	r0, 0x3f	; 63
    25a4:	f8 94       	cli
    25a6:	9e bf       	out	0x3e, r25	; 62
    25a8:	0f be       	out	0x3f, r0	; 63
    25aa:	8d bf       	out	0x3d, r24	; 61
  }
  
  return txString.buffer;
    25ac:	20 91 15 04 	lds	r18, 0x0415
    25b0:	30 91 16 04 	lds	r19, 0x0416
}
    25b4:	c9 01       	movw	r24, r18
    25b6:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    25b8:	80 91 15 04 	lds	r24, 0x0415
    25bc:	90 91 16 04 	lds	r25, 0x0416
    25c0:	00 d0       	rcall	.+0      	; 0x25c2 <commandGetMotorDecay+0x90>
    25c2:	00 d0       	rcall	.+0      	; 0x25c4 <commandGetMotorDecay+0x92>
    25c4:	00 d0       	rcall	.+0      	; 0x25c6 <commandGetMotorDecay+0x94>
    25c6:	ed b7       	in	r30, 0x3d	; 61
    25c8:	fe b7       	in	r31, 0x3e	; 62
    25ca:	31 96       	adiw	r30, 0x01	; 1
    25cc:	ad b7       	in	r26, 0x3d	; 61
    25ce:	be b7       	in	r27, 0x3e	; 62
    25d0:	12 96       	adiw	r26, 0x02	; 2
    25d2:	9c 93       	st	X, r25
    25d4:	8e 93       	st	-X, r24
    25d6:	11 97       	sbiw	r26, 0x01	; 1
    25d8:	80 e0       	ldi	r24, 0x00	; 0
    25da:	91 e0       	ldi	r25, 0x01	; 1
    25dc:	93 83       	std	Z+3, r25	; 0x03
    25de:	82 83       	std	Z+2, r24	; 0x02
    25e0:	64 83       	std	Z+4, r22	; 0x04
    25e2:	15 82       	std	Z+5, r1	; 0x05
    25e4:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    25e8:	8d b7       	in	r24, 0x3d	; 61
    25ea:	9e b7       	in	r25, 0x3e	; 62
    25ec:	06 96       	adiw	r24, 0x06	; 6
    25ee:	0f b6       	in	r0, 0x3f	; 63
    25f0:	f8 94       	cli
    25f2:	9e bf       	out	0x3e, r25	; 62
    25f4:	0f be       	out	0x3f, r0	; 63
    25f6:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].decay);
  }
  
  return txString.buffer;
    25f8:	20 91 15 04 	lds	r18, 0x0415
    25fc:	30 91 16 04 	lds	r19, 0x0416
}
    2600:	c9 01       	movw	r24, r18
    2602:	08 95       	ret

00002604 <commandGetWaitTime>:
 --------------------------------------------------------------------- */
char* commandGetWaitTime(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2604:	60 e0       	ldi	r22, 0x00	; 0
    2606:	70 e0       	ldi	r23, 0x00	; 0
    2608:	4a e0       	ldi	r20, 0x0A	; 10
    260a:	50 e0       	ldi	r21, 0x00	; 0
    260c:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    2610:	64 30       	cpi	r22, 0x04	; 4
    2612:	c8 f5       	brcc	.+114    	; 0x2686 <commandGetWaitTime+0x82>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].waitBetweenSteps);
    2614:	40 91 15 04 	lds	r20, 0x0415
    2618:	50 91 16 04 	lds	r21, 0x0416
    261c:	e6 2f       	mov	r30, r22
    261e:	f0 e0       	ldi	r31, 0x00	; 0
    2620:	ee 0f       	add	r30, r30
    2622:	ff 1f       	adc	r31, r31
    2624:	ee 0f       	add	r30, r30
    2626:	ff 1f       	adc	r31, r31
    2628:	ee 0f       	add	r30, r30
    262a:	ff 1f       	adc	r31, r31
    262c:	cf 01       	movw	r24, r30
    262e:	88 0f       	add	r24, r24
    2630:	99 1f       	adc	r25, r25
    2632:	88 0f       	add	r24, r24
    2634:	99 1f       	adc	r25, r25
    2636:	e8 0f       	add	r30, r24
    2638:	f9 1f       	adc	r31, r25
    263a:	e2 5e       	subi	r30, 0xE2	; 226
    263c:	fb 4f       	sbci	r31, 0xFB	; 251
    263e:	26 8d       	ldd	r18, Z+30	; 0x1e
    2640:	37 8d       	ldd	r19, Z+31	; 0x1f
    2642:	00 d0       	rcall	.+0      	; 0x2644 <commandGetWaitTime+0x40>
    2644:	00 d0       	rcall	.+0      	; 0x2646 <commandGetWaitTime+0x42>
    2646:	00 d0       	rcall	.+0      	; 0x2648 <commandGetWaitTime+0x44>
    2648:	ed b7       	in	r30, 0x3d	; 61
    264a:	fe b7       	in	r31, 0x3e	; 62
    264c:	31 96       	adiw	r30, 0x01	; 1
    264e:	ad b7       	in	r26, 0x3d	; 61
    2650:	be b7       	in	r27, 0x3e	; 62
    2652:	12 96       	adiw	r26, 0x02	; 2
    2654:	5c 93       	st	X, r21
    2656:	4e 93       	st	-X, r20
    2658:	11 97       	sbiw	r26, 0x01	; 1
    265a:	87 e1       	ldi	r24, 0x17	; 23
    265c:	91 e0       	ldi	r25, 0x01	; 1
    265e:	93 83       	std	Z+3, r25	; 0x03
    2660:	82 83       	std	Z+2, r24	; 0x02
    2662:	35 83       	std	Z+5, r19	; 0x05
    2664:	24 83       	std	Z+4, r18	; 0x04
    2666:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    266a:	8d b7       	in	r24, 0x3d	; 61
    266c:	9e b7       	in	r25, 0x3e	; 62
    266e:	06 96       	adiw	r24, 0x06	; 6
    2670:	0f b6       	in	r0, 0x3f	; 63
    2672:	f8 94       	cli
    2674:	9e bf       	out	0x3e, r25	; 62
    2676:	0f be       	out	0x3f, r0	; 63
    2678:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    267a:	20 91 15 04 	lds	r18, 0x0415
    267e:	30 91 16 04 	lds	r19, 0x0416
}
    2682:	c9 01       	movw	r24, r18
    2684:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2686:	80 91 15 04 	lds	r24, 0x0415
    268a:	90 91 16 04 	lds	r25, 0x0416
    268e:	00 d0       	rcall	.+0      	; 0x2690 <commandGetWaitTime+0x8c>
    2690:	00 d0       	rcall	.+0      	; 0x2692 <commandGetWaitTime+0x8e>
    2692:	00 d0       	rcall	.+0      	; 0x2694 <commandGetWaitTime+0x90>
    2694:	ed b7       	in	r30, 0x3d	; 61
    2696:	fe b7       	in	r31, 0x3e	; 62
    2698:	31 96       	adiw	r30, 0x01	; 1
    269a:	ad b7       	in	r26, 0x3d	; 61
    269c:	be b7       	in	r27, 0x3e	; 62
    269e:	12 96       	adiw	r26, 0x02	; 2
    26a0:	9c 93       	st	X, r25
    26a2:	8e 93       	st	-X, r24
    26a4:	11 97       	sbiw	r26, 0x01	; 1
    26a6:	80 e0       	ldi	r24, 0x00	; 0
    26a8:	91 e0       	ldi	r25, 0x01	; 1
    26aa:	93 83       	std	Z+3, r25	; 0x03
    26ac:	82 83       	std	Z+2, r24	; 0x02
    26ae:	64 83       	std	Z+4, r22	; 0x04
    26b0:	15 82       	std	Z+5, r1	; 0x05
    26b2:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    26b6:	8d b7       	in	r24, 0x3d	; 61
    26b8:	9e b7       	in	r25, 0x3e	; 62
    26ba:	06 96       	adiw	r24, 0x06	; 6
    26bc:	0f b6       	in	r0, 0x3f	; 63
    26be:	f8 94       	cli
    26c0:	9e bf       	out	0x3e, r25	; 62
    26c2:	0f be       	out	0x3f, r0	; 63
    26c4:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].waitBetweenSteps);
  }

  return txString.buffer;
    26c6:	20 91 15 04 	lds	r18, 0x0415
    26ca:	30 91 16 04 	lds	r19, 0x0416
}
    26ce:	c9 01       	movw	r24, r18
    26d0:	08 95       	ret

000026d2 <commandGetSubSteps>:
 --------------------------------------------------------------------- */
char* commandGetSubSteps(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    26d2:	60 e0       	ldi	r22, 0x00	; 0
    26d4:	70 e0       	ldi	r23, 0x00	; 0
    26d6:	4a e0       	ldi	r20, 0x0A	; 10
    26d8:	50 e0       	ldi	r21, 0x00	; 0
    26da:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    26de:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    26e0:	64 30       	cpi	r22, 0x04	; 4
    26e2:	08 f0       	brcs	.+2      	; 0x26e6 <commandGetSubSteps+0x14>
    26e4:	40 c0       	rjmp	.+128    	; 0x2766 <commandGetSubSteps+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].subSteps);
    26e6:	60 91 15 04 	lds	r22, 0x0415
    26ea:	70 91 16 04 	lds	r23, 0x0416
    26ee:	e2 2f       	mov	r30, r18
    26f0:	f0 e0       	ldi	r31, 0x00	; 0
    26f2:	ee 0f       	add	r30, r30
    26f4:	ff 1f       	adc	r31, r31
    26f6:	ee 0f       	add	r30, r30
    26f8:	ff 1f       	adc	r31, r31
    26fa:	ee 0f       	add	r30, r30
    26fc:	ff 1f       	adc	r31, r31
    26fe:	cf 01       	movw	r24, r30
    2700:	88 0f       	add	r24, r24
    2702:	99 1f       	adc	r25, r25
    2704:	88 0f       	add	r24, r24
    2706:	99 1f       	adc	r25, r25
    2708:	e8 0f       	add	r30, r24
    270a:	f9 1f       	adc	r31, r25
    270c:	e2 5e       	subi	r30, 0xE2	; 226
    270e:	fb 4f       	sbci	r31, 0xFB	; 251
    2710:	25 89       	ldd	r18, Z+21	; 0x15
    2712:	36 89       	ldd	r19, Z+22	; 0x16
    2714:	47 89       	ldd	r20, Z+23	; 0x17
    2716:	50 8d       	ldd	r21, Z+24	; 0x18
    2718:	ad b7       	in	r26, 0x3d	; 61
    271a:	be b7       	in	r27, 0x3e	; 62
    271c:	18 97       	sbiw	r26, 0x08	; 8
    271e:	0f b6       	in	r0, 0x3f	; 63
    2720:	f8 94       	cli
    2722:	be bf       	out	0x3e, r27	; 62
    2724:	0f be       	out	0x3f, r0	; 63
    2726:	ad bf       	out	0x3d, r26	; 61
    2728:	ed b7       	in	r30, 0x3d	; 61
    272a:	fe b7       	in	r31, 0x3e	; 62
    272c:	31 96       	adiw	r30, 0x01	; 1
    272e:	12 96       	adiw	r26, 0x02	; 2
    2730:	7c 93       	st	X, r23
    2732:	6e 93       	st	-X, r22
    2734:	11 97       	sbiw	r26, 0x01	; 1
    2736:	8a e1       	ldi	r24, 0x1A	; 26
    2738:	91 e0       	ldi	r25, 0x01	; 1
    273a:	93 83       	std	Z+3, r25	; 0x03
    273c:	82 83       	std	Z+2, r24	; 0x02
    273e:	24 83       	std	Z+4, r18	; 0x04
    2740:	35 83       	std	Z+5, r19	; 0x05
    2742:	46 83       	std	Z+6, r20	; 0x06
    2744:	57 83       	std	Z+7, r21	; 0x07
    2746:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    274a:	8d b7       	in	r24, 0x3d	; 61
    274c:	9e b7       	in	r25, 0x3e	; 62
    274e:	08 96       	adiw	r24, 0x08	; 8
    2750:	0f b6       	in	r0, 0x3f	; 63
    2752:	f8 94       	cli
    2754:	9e bf       	out	0x3e, r25	; 62
    2756:	0f be       	out	0x3f, r0	; 63
    2758:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    275a:	20 91 15 04 	lds	r18, 0x0415
    275e:	30 91 16 04 	lds	r19, 0x0416
}
    2762:	c9 01       	movw	r24, r18
    2764:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2766:	80 91 15 04 	lds	r24, 0x0415
    276a:	90 91 16 04 	lds	r25, 0x0416
    276e:	00 d0       	rcall	.+0      	; 0x2770 <commandGetSubSteps+0x9e>
    2770:	00 d0       	rcall	.+0      	; 0x2772 <commandGetSubSteps+0xa0>
    2772:	00 d0       	rcall	.+0      	; 0x2774 <commandGetSubSteps+0xa2>
    2774:	ed b7       	in	r30, 0x3d	; 61
    2776:	fe b7       	in	r31, 0x3e	; 62
    2778:	31 96       	adiw	r30, 0x01	; 1
    277a:	ad b7       	in	r26, 0x3d	; 61
    277c:	be b7       	in	r27, 0x3e	; 62
    277e:	12 96       	adiw	r26, 0x02	; 2
    2780:	9c 93       	st	X, r25
    2782:	8e 93       	st	-X, r24
    2784:	11 97       	sbiw	r26, 0x01	; 1
    2786:	80 e0       	ldi	r24, 0x00	; 0
    2788:	91 e0       	ldi	r25, 0x01	; 1
    278a:	93 83       	std	Z+3, r25	; 0x03
    278c:	82 83       	std	Z+2, r24	; 0x02
    278e:	24 83       	std	Z+4, r18	; 0x04
    2790:	15 82       	std	Z+5, r1	; 0x05
    2792:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2796:	8d b7       	in	r24, 0x3d	; 61
    2798:	9e b7       	in	r25, 0x3e	; 62
    279a:	06 96       	adiw	r24, 0x06	; 6
    279c:	0f b6       	in	r0, 0x3f	; 63
    279e:	f8 94       	cli
    27a0:	9e bf       	out	0x3e, r25	; 62
    27a2:	0f be       	out	0x3f, r0	; 63
    27a4:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].subSteps);
  }

  return txString.buffer;
    27a6:	20 91 15 04 	lds	r18, 0x0415
    27aa:	30 91 16 04 	lds	r19, 0x0416
}
    27ae:	c9 01       	movw	r24, r18
    27b0:	08 95       	ret

000027b2 <commandGetFullRotation>:
 --------------------------------------------------------------------- */
char* commandGetFullRotation(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    27b2:	60 e0       	ldi	r22, 0x00	; 0
    27b4:	70 e0       	ldi	r23, 0x00	; 0
    27b6:	4a e0       	ldi	r20, 0x0A	; 10
    27b8:	50 e0       	ldi	r21, 0x00	; 0
    27ba:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    27be:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    27c0:	64 30       	cpi	r22, 0x04	; 4
    27c2:	08 f0       	brcs	.+2      	; 0x27c6 <commandGetFullRotation+0x14>
    27c4:	40 c0       	rjmp	.+128    	; 0x2846 <commandGetFullRotation+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].stepsPerFullRotation);
    27c6:	60 91 15 04 	lds	r22, 0x0415
    27ca:	70 91 16 04 	lds	r23, 0x0416
    27ce:	e2 2f       	mov	r30, r18
    27d0:	f0 e0       	ldi	r31, 0x00	; 0
    27d2:	ee 0f       	add	r30, r30
    27d4:	ff 1f       	adc	r31, r31
    27d6:	ee 0f       	add	r30, r30
    27d8:	ff 1f       	adc	r31, r31
    27da:	ee 0f       	add	r30, r30
    27dc:	ff 1f       	adc	r31, r31
    27de:	cf 01       	movw	r24, r30
    27e0:	88 0f       	add	r24, r24
    27e2:	99 1f       	adc	r25, r25
    27e4:	88 0f       	add	r24, r24
    27e6:	99 1f       	adc	r25, r25
    27e8:	e8 0f       	add	r30, r24
    27ea:	f9 1f       	adc	r31, r25
    27ec:	e2 5e       	subi	r30, 0xE2	; 226
    27ee:	fb 4f       	sbci	r31, 0xFB	; 251
    27f0:	21 89       	ldd	r18, Z+17	; 0x11
    27f2:	32 89       	ldd	r19, Z+18	; 0x12
    27f4:	43 89       	ldd	r20, Z+19	; 0x13
    27f6:	54 89       	ldd	r21, Z+20	; 0x14
    27f8:	ad b7       	in	r26, 0x3d	; 61
    27fa:	be b7       	in	r27, 0x3e	; 62
    27fc:	18 97       	sbiw	r26, 0x08	; 8
    27fe:	0f b6       	in	r0, 0x3f	; 63
    2800:	f8 94       	cli
    2802:	be bf       	out	0x3e, r27	; 62
    2804:	0f be       	out	0x3f, r0	; 63
    2806:	ad bf       	out	0x3d, r26	; 61
    2808:	ed b7       	in	r30, 0x3d	; 61
    280a:	fe b7       	in	r31, 0x3e	; 62
    280c:	31 96       	adiw	r30, 0x01	; 1
    280e:	12 96       	adiw	r26, 0x02	; 2
    2810:	7c 93       	st	X, r23
    2812:	6e 93       	st	-X, r22
    2814:	11 97       	sbiw	r26, 0x01	; 1
    2816:	8a e1       	ldi	r24, 0x1A	; 26
    2818:	91 e0       	ldi	r25, 0x01	; 1
    281a:	93 83       	std	Z+3, r25	; 0x03
    281c:	82 83       	std	Z+2, r24	; 0x02
    281e:	24 83       	std	Z+4, r18	; 0x04
    2820:	35 83       	std	Z+5, r19	; 0x05
    2822:	46 83       	std	Z+6, r20	; 0x06
    2824:	57 83       	std	Z+7, r21	; 0x07
    2826:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    282a:	8d b7       	in	r24, 0x3d	; 61
    282c:	9e b7       	in	r25, 0x3e	; 62
    282e:	08 96       	adiw	r24, 0x08	; 8
    2830:	0f b6       	in	r0, 0x3f	; 63
    2832:	f8 94       	cli
    2834:	9e bf       	out	0x3e, r25	; 62
    2836:	0f be       	out	0x3f, r0	; 63
    2838:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    283a:	20 91 15 04 	lds	r18, 0x0415
    283e:	30 91 16 04 	lds	r19, 0x0416
}
    2842:	c9 01       	movw	r24, r18
    2844:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2846:	80 91 15 04 	lds	r24, 0x0415
    284a:	90 91 16 04 	lds	r25, 0x0416
    284e:	00 d0       	rcall	.+0      	; 0x2850 <commandGetFullRotation+0x9e>
    2850:	00 d0       	rcall	.+0      	; 0x2852 <commandGetFullRotation+0xa0>
    2852:	00 d0       	rcall	.+0      	; 0x2854 <commandGetFullRotation+0xa2>
    2854:	ed b7       	in	r30, 0x3d	; 61
    2856:	fe b7       	in	r31, 0x3e	; 62
    2858:	31 96       	adiw	r30, 0x01	; 1
    285a:	ad b7       	in	r26, 0x3d	; 61
    285c:	be b7       	in	r27, 0x3e	; 62
    285e:	12 96       	adiw	r26, 0x02	; 2
    2860:	9c 93       	st	X, r25
    2862:	8e 93       	st	-X, r24
    2864:	11 97       	sbiw	r26, 0x01	; 1
    2866:	80 e0       	ldi	r24, 0x00	; 0
    2868:	91 e0       	ldi	r25, 0x01	; 1
    286a:	93 83       	std	Z+3, r25	; 0x03
    286c:	82 83       	std	Z+2, r24	; 0x02
    286e:	24 83       	std	Z+4, r18	; 0x04
    2870:	15 82       	std	Z+5, r1	; 0x05
    2872:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2876:	8d b7       	in	r24, 0x3d	; 61
    2878:	9e b7       	in	r25, 0x3e	; 62
    287a:	06 96       	adiw	r24, 0x06	; 6
    287c:	0f b6       	in	r0, 0x3f	; 63
    287e:	f8 94       	cli
    2880:	9e bf       	out	0x3e, r25	; 62
    2882:	0f be       	out	0x3f, r0	; 63
    2884:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%.0f", motor[i].stepsPerFullRotation);
  }

  return txString.buffer;
    2886:	20 91 15 04 	lds	r18, 0x0415
    288a:	30 91 16 04 	lds	r19, 0x0416
}
    288e:	c9 01       	movw	r24, r18
    2890:	08 95       	ret

00002892 <commandGetGearRatio>:
 --------------------------------------------------------------------- */
char* commandGetGearRatio(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2892:	60 e0       	ldi	r22, 0x00	; 0
    2894:	70 e0       	ldi	r23, 0x00	; 0
    2896:	4a e0       	ldi	r20, 0x0A	; 10
    2898:	50 e0       	ldi	r21, 0x00	; 0
    289a:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    289e:	26 2f       	mov	r18, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    28a0:	64 30       	cpi	r22, 0x04	; 4
    28a2:	08 f0       	brcs	.+2      	; 0x28a6 <commandGetGearRatio+0x14>
    28a4:	40 c0       	rjmp	.+128    	; 0x2926 <commandGetGearRatio+0x94>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%f", motor[i].gearRatio);
    28a6:	60 91 15 04 	lds	r22, 0x0415
    28aa:	70 91 16 04 	lds	r23, 0x0416
    28ae:	e2 2f       	mov	r30, r18
    28b0:	f0 e0       	ldi	r31, 0x00	; 0
    28b2:	ee 0f       	add	r30, r30
    28b4:	ff 1f       	adc	r31, r31
    28b6:	ee 0f       	add	r30, r30
    28b8:	ff 1f       	adc	r31, r31
    28ba:	ee 0f       	add	r30, r30
    28bc:	ff 1f       	adc	r31, r31
    28be:	cf 01       	movw	r24, r30
    28c0:	88 0f       	add	r24, r24
    28c2:	99 1f       	adc	r25, r25
    28c4:	88 0f       	add	r24, r24
    28c6:	99 1f       	adc	r25, r25
    28c8:	e8 0f       	add	r30, r24
    28ca:	f9 1f       	adc	r31, r25
    28cc:	e2 5e       	subi	r30, 0xE2	; 226
    28ce:	fb 4f       	sbci	r31, 0xFB	; 251
    28d0:	25 85       	ldd	r18, Z+13	; 0x0d
    28d2:	36 85       	ldd	r19, Z+14	; 0x0e
    28d4:	47 85       	ldd	r20, Z+15	; 0x0f
    28d6:	50 89       	ldd	r21, Z+16	; 0x10
    28d8:	ad b7       	in	r26, 0x3d	; 61
    28da:	be b7       	in	r27, 0x3e	; 62
    28dc:	18 97       	sbiw	r26, 0x08	; 8
    28de:	0f b6       	in	r0, 0x3f	; 63
    28e0:	f8 94       	cli
    28e2:	be bf       	out	0x3e, r27	; 62
    28e4:	0f be       	out	0x3f, r0	; 63
    28e6:	ad bf       	out	0x3d, r26	; 61
    28e8:	ed b7       	in	r30, 0x3d	; 61
    28ea:	fe b7       	in	r31, 0x3e	; 62
    28ec:	31 96       	adiw	r30, 0x01	; 1
    28ee:	12 96       	adiw	r26, 0x02	; 2
    28f0:	7c 93       	st	X, r23
    28f2:	6e 93       	st	-X, r22
    28f4:	11 97       	sbiw	r26, 0x01	; 1
    28f6:	8f e1       	ldi	r24, 0x1F	; 31
    28f8:	91 e0       	ldi	r25, 0x01	; 1
    28fa:	93 83       	std	Z+3, r25	; 0x03
    28fc:	82 83       	std	Z+2, r24	; 0x02
    28fe:	24 83       	std	Z+4, r18	; 0x04
    2900:	35 83       	std	Z+5, r19	; 0x05
    2902:	46 83       	std	Z+6, r20	; 0x06
    2904:	57 83       	std	Z+7, r21	; 0x07
    2906:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    290a:	8d b7       	in	r24, 0x3d	; 61
    290c:	9e b7       	in	r25, 0x3e	; 62
    290e:	08 96       	adiw	r24, 0x08	; 8
    2910:	0f b6       	in	r0, 0x3f	; 63
    2912:	f8 94       	cli
    2914:	9e bf       	out	0x3e, r25	; 62
    2916:	0f be       	out	0x3f, r0	; 63
    2918:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    291a:	20 91 15 04 	lds	r18, 0x0415
    291e:	30 91 16 04 	lds	r19, 0x0416
}
    2922:	c9 01       	movw	r24, r18
    2924:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2926:	80 91 15 04 	lds	r24, 0x0415
    292a:	90 91 16 04 	lds	r25, 0x0416
    292e:	00 d0       	rcall	.+0      	; 0x2930 <commandGetGearRatio+0x9e>
    2930:	00 d0       	rcall	.+0      	; 0x2932 <commandGetGearRatio+0xa0>
    2932:	00 d0       	rcall	.+0      	; 0x2934 <commandGetGearRatio+0xa2>
    2934:	ed b7       	in	r30, 0x3d	; 61
    2936:	fe b7       	in	r31, 0x3e	; 62
    2938:	31 96       	adiw	r30, 0x01	; 1
    293a:	ad b7       	in	r26, 0x3d	; 61
    293c:	be b7       	in	r27, 0x3e	; 62
    293e:	12 96       	adiw	r26, 0x02	; 2
    2940:	9c 93       	st	X, r25
    2942:	8e 93       	st	-X, r24
    2944:	11 97       	sbiw	r26, 0x01	; 1
    2946:	80 e0       	ldi	r24, 0x00	; 0
    2948:	91 e0       	ldi	r25, 0x01	; 1
    294a:	93 83       	std	Z+3, r25	; 0x03
    294c:	82 83       	std	Z+2, r24	; 0x02
    294e:	24 83       	std	Z+4, r18	; 0x04
    2950:	15 82       	std	Z+5, r1	; 0x05
    2952:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2956:	8d b7       	in	r24, 0x3d	; 61
    2958:	9e b7       	in	r25, 0x3e	; 62
    295a:	06 96       	adiw	r24, 0x06	; 6
    295c:	0f b6       	in	r0, 0x3f	; 63
    295e:	f8 94       	cli
    2960:	9e bf       	out	0x3e, r25	; 62
    2962:	0f be       	out	0x3f, r0	; 63
    2964:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%f", motor[i].gearRatio);
  }

  return txString.buffer;
    2966:	20 91 15 04 	lds	r18, 0x0415
    296a:	30 91 16 04 	lds	r19, 0x0416
}
    296e:	c9 01       	movw	r24, r18
    2970:	08 95       	ret

00002972 <commandGetOptZeroPos>:
 --------------------------------------------------------------------- */
char* commandGetOptZeroPos(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2972:	60 e0       	ldi	r22, 0x00	; 0
    2974:	70 e0       	ldi	r23, 0x00	; 0
    2976:	4a e0       	ldi	r20, 0x0A	; 10
    2978:	50 e0       	ldi	r21, 0x00	; 0
    297a:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    297e:	64 30       	cpi	r22, 0x04	; 4
    2980:	d8 f5       	brcc	.+118    	; 0x29f8 <commandGetOptZeroPos+0x86>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].opticalZeroPosition);
    2982:	40 91 15 04 	lds	r20, 0x0415
    2986:	50 91 16 04 	lds	r21, 0x0416
    298a:	86 2f       	mov	r24, r22
    298c:	90 e0       	ldi	r25, 0x00	; 0
    298e:	fc 01       	movw	r30, r24
    2990:	ee 0f       	add	r30, r30
    2992:	ff 1f       	adc	r31, r31
    2994:	ee 0f       	add	r30, r30
    2996:	ff 1f       	adc	r31, r31
    2998:	ee 0f       	add	r30, r30
    299a:	ff 1f       	adc	r31, r31
    299c:	88 0f       	add	r24, r24
    299e:	99 1f       	adc	r25, r25
    29a0:	e8 0f       	add	r30, r24
    29a2:	f9 1f       	adc	r31, r25
    29a4:	ee 0f       	add	r30, r30
    29a6:	ff 1f       	adc	r31, r31
    29a8:	ee 0f       	add	r30, r30
    29aa:	ff 1f       	adc	r31, r31
    29ac:	ee 5d       	subi	r30, 0xDE	; 222
    29ae:	fb 4f       	sbci	r31, 0xFB	; 251
    29b0:	20 81       	ld	r18, Z
    29b2:	31 81       	ldd	r19, Z+1	; 0x01
    29b4:	00 d0       	rcall	.+0      	; 0x29b6 <commandGetOptZeroPos+0x44>
    29b6:	00 d0       	rcall	.+0      	; 0x29b8 <commandGetOptZeroPos+0x46>
    29b8:	00 d0       	rcall	.+0      	; 0x29ba <commandGetOptZeroPos+0x48>
    29ba:	ed b7       	in	r30, 0x3d	; 61
    29bc:	fe b7       	in	r31, 0x3e	; 62
    29be:	31 96       	adiw	r30, 0x01	; 1
    29c0:	ad b7       	in	r26, 0x3d	; 61
    29c2:	be b7       	in	r27, 0x3e	; 62
    29c4:	12 96       	adiw	r26, 0x02	; 2
    29c6:	5c 93       	st	X, r21
    29c8:	4e 93       	st	-X, r20
    29ca:	11 97       	sbiw	r26, 0x01	; 1
    29cc:	87 e1       	ldi	r24, 0x17	; 23
    29ce:	91 e0       	ldi	r25, 0x01	; 1
    29d0:	93 83       	std	Z+3, r25	; 0x03
    29d2:	82 83       	std	Z+2, r24	; 0x02
    29d4:	35 83       	std	Z+5, r19	; 0x05
    29d6:	24 83       	std	Z+4, r18	; 0x04
    29d8:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    29dc:	8d b7       	in	r24, 0x3d	; 61
    29de:	9e b7       	in	r25, 0x3e	; 62
    29e0:	06 96       	adiw	r24, 0x06	; 6
    29e2:	0f b6       	in	r0, 0x3f	; 63
    29e4:	f8 94       	cli
    29e6:	9e bf       	out	0x3e, r25	; 62
    29e8:	0f be       	out	0x3f, r0	; 63
    29ea:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    29ec:	20 91 15 04 	lds	r18, 0x0415
    29f0:	30 91 16 04 	lds	r19, 0x0416
}
    29f4:	c9 01       	movw	r24, r18
    29f6:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    29f8:	80 91 15 04 	lds	r24, 0x0415
    29fc:	90 91 16 04 	lds	r25, 0x0416
    2a00:	00 d0       	rcall	.+0      	; 0x2a02 <commandGetOptZeroPos+0x90>
    2a02:	00 d0       	rcall	.+0      	; 0x2a04 <commandGetOptZeroPos+0x92>
    2a04:	00 d0       	rcall	.+0      	; 0x2a06 <commandGetOptZeroPos+0x94>
    2a06:	ed b7       	in	r30, 0x3d	; 61
    2a08:	fe b7       	in	r31, 0x3e	; 62
    2a0a:	31 96       	adiw	r30, 0x01	; 1
    2a0c:	ad b7       	in	r26, 0x3d	; 61
    2a0e:	be b7       	in	r27, 0x3e	; 62
    2a10:	12 96       	adiw	r26, 0x02	; 2
    2a12:	9c 93       	st	X, r25
    2a14:	8e 93       	st	-X, r24
    2a16:	11 97       	sbiw	r26, 0x01	; 1
    2a18:	80 e0       	ldi	r24, 0x00	; 0
    2a1a:	91 e0       	ldi	r25, 0x01	; 1
    2a1c:	93 83       	std	Z+3, r25	; 0x03
    2a1e:	82 83       	std	Z+2, r24	; 0x02
    2a20:	64 83       	std	Z+4, r22	; 0x04
    2a22:	15 82       	std	Z+5, r1	; 0x05
    2a24:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2a28:	8d b7       	in	r24, 0x3d	; 61
    2a2a:	9e b7       	in	r25, 0x3e	; 62
    2a2c:	06 96       	adiw	r24, 0x06	; 6
    2a2e:	0f b6       	in	r0, 0x3f	; 63
    2a30:	f8 94       	cli
    2a32:	9e bf       	out	0x3e, r25	; 62
    2a34:	0f be       	out	0x3f, r0	; 63
    2a36:	8d bf       	out	0x3d, r24	; 61
  }
  else{
    sprintf(txString.buffer, "%d", motor[i].opticalZeroPosition);
  }

  return txString.buffer;
    2a38:	20 91 15 04 	lds	r18, 0x0415
    2a3c:	30 91 16 04 	lds	r19, 0x0416
}
    2a40:	c9 01       	movw	r24, r18
    2a42:	08 95       	ret

00002a44 <commandGetAnalog>:
char* commandGetAnalog(char* param0){

  uint8_t i = 0;
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2a44:	60 e0       	ldi	r22, 0x00	; 0
    2a46:	70 e0       	ldi	r23, 0x00	; 0
    2a48:	4a e0       	ldi	r20, 0x0A	; 10
    2a4a:	50 e0       	ldi	r21, 0x00	; 0
    2a4c:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if((i < MOTOR_SENS0) || (i > MOTOR_SENS_MAX)){
    2a50:	64 30       	cpi	r22, 0x04	; 4
    2a52:	48 f5       	brcc	.+82     	; 0x2aa6 <commandGetAnalog+0x62>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    val = getADCvalue(i);
    2a54:	86 2f       	mov	r24, r22
    2a56:	0e 94 e8 06 	call	0xdd0	; 0xdd0 <getADCvalue>
    sprintf(txString.buffer, "%d", val);
    2a5a:	20 91 15 04 	lds	r18, 0x0415
    2a5e:	30 91 16 04 	lds	r19, 0x0416
    2a62:	00 d0       	rcall	.+0      	; 0x2a64 <commandGetAnalog+0x20>
    2a64:	00 d0       	rcall	.+0      	; 0x2a66 <commandGetAnalog+0x22>
    2a66:	00 d0       	rcall	.+0      	; 0x2a68 <commandGetAnalog+0x24>
    2a68:	ed b7       	in	r30, 0x3d	; 61
    2a6a:	fe b7       	in	r31, 0x3e	; 62
    2a6c:	31 96       	adiw	r30, 0x01	; 1
    2a6e:	ad b7       	in	r26, 0x3d	; 61
    2a70:	be b7       	in	r27, 0x3e	; 62
    2a72:	12 96       	adiw	r26, 0x02	; 2
    2a74:	3c 93       	st	X, r19
    2a76:	2e 93       	st	-X, r18
    2a78:	11 97       	sbiw	r26, 0x01	; 1
    2a7a:	27 e1       	ldi	r18, 0x17	; 23
    2a7c:	31 e0       	ldi	r19, 0x01	; 1
    2a7e:	33 83       	std	Z+3, r19	; 0x03
    2a80:	22 83       	std	Z+2, r18	; 0x02
    2a82:	95 83       	std	Z+5, r25	; 0x05
    2a84:	84 83       	std	Z+4, r24	; 0x04
    2a86:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2a8a:	8d b7       	in	r24, 0x3d	; 61
    2a8c:	9e b7       	in	r25, 0x3e	; 62
    2a8e:	06 96       	adiw	r24, 0x06	; 6
    2a90:	0f b6       	in	r0, 0x3f	; 63
    2a92:	f8 94       	cli
    2a94:	9e bf       	out	0x3e, r25	; 62
    2a96:	0f be       	out	0x3f, r0	; 63
    2a98:	8d bf       	out	0x3d, r24	; 61
  }

  return txString.buffer;
    2a9a:	20 91 15 04 	lds	r18, 0x0415
    2a9e:	30 91 16 04 	lds	r19, 0x0416
}
    2aa2:	c9 01       	movw	r24, r18
    2aa4:	08 95       	ret
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if((i < MOTOR_SENS0) || (i > MOTOR_SENS_MAX)){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2aa6:	80 91 15 04 	lds	r24, 0x0415
    2aaa:	90 91 16 04 	lds	r25, 0x0416
    2aae:	00 d0       	rcall	.+0      	; 0x2ab0 <commandGetAnalog+0x6c>
    2ab0:	00 d0       	rcall	.+0      	; 0x2ab2 <commandGetAnalog+0x6e>
    2ab2:	00 d0       	rcall	.+0      	; 0x2ab4 <commandGetAnalog+0x70>
    2ab4:	ed b7       	in	r30, 0x3d	; 61
    2ab6:	fe b7       	in	r31, 0x3e	; 62
    2ab8:	31 96       	adiw	r30, 0x01	; 1
    2aba:	ad b7       	in	r26, 0x3d	; 61
    2abc:	be b7       	in	r27, 0x3e	; 62
    2abe:	12 96       	adiw	r26, 0x02	; 2
    2ac0:	9c 93       	st	X, r25
    2ac2:	8e 93       	st	-X, r24
    2ac4:	11 97       	sbiw	r26, 0x01	; 1
    2ac6:	80 e0       	ldi	r24, 0x00	; 0
    2ac8:	91 e0       	ldi	r25, 0x01	; 1
    2aca:	93 83       	std	Z+3, r25	; 0x03
    2acc:	82 83       	std	Z+2, r24	; 0x02
    2ace:	64 83       	std	Z+4, r22	; 0x04
    2ad0:	15 82       	std	Z+5, r1	; 0x05
    2ad2:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2ad6:	8d b7       	in	r24, 0x3d	; 61
    2ad8:	9e b7       	in	r25, 0x3e	; 62
    2ada:	06 96       	adiw	r24, 0x06	; 6
    2adc:	0f b6       	in	r0, 0x3f	; 63
    2ade:	f8 94       	cli
    2ae0:	9e bf       	out	0x3e, r25	; 62
    2ae2:	0f be       	out	0x3f, r0	; 63
    2ae4:	8d bf       	out	0x3d, r24	; 61
  else{
    val = getADCvalue(i);
    sprintf(txString.buffer, "%d", val);
  }

  return txString.buffer;
    2ae6:	20 91 15 04 	lds	r18, 0x0415
    2aea:	30 91 16 04 	lds	r19, 0x0416
}
    2aee:	c9 01       	movw	r24, r18
    2af0:	08 95       	ret

00002af2 <commandIsMoving>:
 --------------------------------------------------------------------- */
char* commandIsMoving(char* param0){

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    2af2:	60 e0       	ldi	r22, 0x00	; 0
    2af4:	70 e0       	ldi	r23, 0x00	; 0
    2af6:	4a e0       	ldi	r20, 0x0A	; 10
    2af8:	50 e0       	ldi	r21, 0x00	; 0
    2afa:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if(i > MAX_MOTOR){
    2afe:	64 30       	cpi	r22, 0x04	; 4
    2b00:	08 f0       	brcs	.+2      	; 0x2b04 <commandIsMoving+0x12>
    2b02:	45 c0       	rjmp	.+138    	; 0x2b8e <commandIsMoving+0x9c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(motor[i].desiredPosition - motor[i].actualPosition){
    2b04:	e6 2f       	mov	r30, r22
    2b06:	f0 e0       	ldi	r31, 0x00	; 0
    2b08:	ee 0f       	add	r30, r30
    2b0a:	ff 1f       	adc	r31, r31
    2b0c:	ee 0f       	add	r30, r30
    2b0e:	ff 1f       	adc	r31, r31
    2b10:	cf 01       	movw	r24, r30
    2b12:	88 0f       	add	r24, r24
    2b14:	99 1f       	adc	r25, r25
    2b16:	88 0f       	add	r24, r24
    2b18:	99 1f       	adc	r25, r25
    2b1a:	e8 0f       	add	r30, r24
    2b1c:	f9 1f       	adc	r31, r25
    2b1e:	ee 0f       	add	r30, r30
    2b20:	ff 1f       	adc	r31, r31
    2b22:	e0 5e       	subi	r30, 0xE0	; 224
    2b24:	fb 4f       	sbci	r31, 0xFB	; 251
    2b26:	20 81       	ld	r18, Z
    2b28:	31 81       	ldd	r19, Z+1	; 0x01
    2b2a:	e6 2f       	mov	r30, r22
    2b2c:	f0 e0       	ldi	r31, 0x00	; 0
    2b2e:	ee 0f       	add	r30, r30
    2b30:	ff 1f       	adc	r31, r31
    2b32:	ee 0f       	add	r30, r30
    2b34:	ff 1f       	adc	r31, r31
    2b36:	ee 0f       	add	r30, r30
    2b38:	ff 1f       	adc	r31, r31
    2b3a:	cf 01       	movw	r24, r30
    2b3c:	88 0f       	add	r24, r24
    2b3e:	99 1f       	adc	r25, r25
    2b40:	88 0f       	add	r24, r24
    2b42:	99 1f       	adc	r25, r25
    2b44:	e8 0f       	add	r30, r24
    2b46:	f9 1f       	adc	r31, r25
    2b48:	e2 5e       	subi	r30, 0xE2	; 226
    2b4a:	fb 4f       	sbci	r31, 0xFB	; 251
    2b4c:	80 81       	ld	r24, Z
    2b4e:	91 81       	ldd	r25, Z+1	; 0x01
    2b50:	28 17       	cp	r18, r24
    2b52:	39 07       	cpc	r19, r25
    2b54:	71 f0       	breq	.+28     	; 0x2b72 <commandIsMoving+0x80>
      sprintf(txString.buffer, "1");
    2b56:	e0 91 15 04 	lds	r30, 0x0415
    2b5a:	f0 91 16 04 	lds	r31, 0x0416
    2b5e:	81 e3       	ldi	r24, 0x31	; 49
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	91 83       	std	Z+1, r25	; 0x01
    2b64:	80 83       	st	Z, r24
    else{
      sprintf(txString.buffer, "0");
    }
  }

  return txString.buffer;
    2b66:	20 91 15 04 	lds	r18, 0x0415
    2b6a:	30 91 16 04 	lds	r19, 0x0416
}
    2b6e:	c9 01       	movw	r24, r18
    2b70:	08 95       	ret
  else{
    if(motor[i].desiredPosition - motor[i].actualPosition){
      sprintf(txString.buffer, "1");
    }
    else{
      sprintf(txString.buffer, "0");
    2b72:	e0 91 15 04 	lds	r30, 0x0415
    2b76:	f0 91 16 04 	lds	r31, 0x0416
    2b7a:	80 e3       	ldi	r24, 0x30	; 48
    2b7c:	90 e0       	ldi	r25, 0x00	; 0
    2b7e:	91 83       	std	Z+1, r25	; 0x01
    2b80:	80 83       	st	Z, r24
    }
  }

  return txString.buffer;
    2b82:	20 91 15 04 	lds	r18, 0x0415
    2b86:	30 91 16 04 	lds	r19, 0x0416
}
    2b8a:	c9 01       	movw	r24, r18
    2b8c:	08 95       	ret
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    2b8e:	80 91 15 04 	lds	r24, 0x0415
    2b92:	90 91 16 04 	lds	r25, 0x0416
    2b96:	00 d0       	rcall	.+0      	; 0x2b98 <commandIsMoving+0xa6>
    2b98:	00 d0       	rcall	.+0      	; 0x2b9a <commandIsMoving+0xa8>
    2b9a:	00 d0       	rcall	.+0      	; 0x2b9c <commandIsMoving+0xaa>
    2b9c:	ed b7       	in	r30, 0x3d	; 61
    2b9e:	fe b7       	in	r31, 0x3e	; 62
    2ba0:	31 96       	adiw	r30, 0x01	; 1
    2ba2:	ad b7       	in	r26, 0x3d	; 61
    2ba4:	be b7       	in	r27, 0x3e	; 62
    2ba6:	12 96       	adiw	r26, 0x02	; 2
    2ba8:	9c 93       	st	X, r25
    2baa:	8e 93       	st	-X, r24
    2bac:	11 97       	sbiw	r26, 0x01	; 1
    2bae:	80 e0       	ldi	r24, 0x00	; 0
    2bb0:	91 e0       	ldi	r25, 0x01	; 1
    2bb2:	93 83       	std	Z+3, r25	; 0x03
    2bb4:	82 83       	std	Z+2, r24	; 0x02
    2bb6:	64 83       	std	Z+4, r22	; 0x04
    2bb8:	15 82       	std	Z+5, r1	; 0x05
    2bba:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2bbe:	8d b7       	in	r24, 0x3d	; 61
    2bc0:	9e b7       	in	r25, 0x3e	; 62
    2bc2:	06 96       	adiw	r24, 0x06	; 6
    2bc4:	0f b6       	in	r0, 0x3f	; 63
    2bc6:	f8 94       	cli
    2bc8:	9e bf       	out	0x3e, r25	; 62
    2bca:	0f be       	out	0x3f, r0	; 63
    2bcc:	8d bf       	out	0x3d, r24	; 61
    else{
      sprintf(txString.buffer, "0");
    }
  }

  return txString.buffer;
    2bce:	20 91 15 04 	lds	r18, 0x0415
    2bd2:	30 91 16 04 	lds	r19, 0x0416
}
    2bd6:	c9 01       	movw	r24, r18
    2bd8:	08 95       	ret

00002bda <updateDisplayChangeValues>:

/* ---------------------------------------------------------------------
   update the display after switching to value-changing-mode
   or update changed values for a motor on the display
 --------------------------------------------------------------------- */
void updateDisplayChangeValues(uint8_t thisMenu){
    2bda:	2f 92       	push	r2
    2bdc:	3f 92       	push	r3
    2bde:	4f 92       	push	r4
    2be0:	5f 92       	push	r5
    2be2:	6f 92       	push	r6
    2be4:	7f 92       	push	r7
    2be6:	8f 92       	push	r8
    2be8:	9f 92       	push	r9
    2bea:	af 92       	push	r10
    2bec:	bf 92       	push	r11
    2bee:	df 92       	push	r13
    2bf0:	ef 92       	push	r14
    2bf2:	ff 92       	push	r15
    2bf4:	0f 93       	push	r16
    2bf6:	1f 93       	push	r17
    2bf8:	cf 93       	push	r28
    2bfa:	df 93       	push	r29

  uint8_t sLen;
  uint8_t c = 0;

  /* determine which values shall be changed */
  menuPtr = (menuItem*)pgm_read_word(&menuList[thisMenu]);
    2bfc:	90 e0       	ldi	r25, 0x00	; 0
    2bfe:	88 0f       	add	r24, r24
    2c00:	99 1f       	adc	r25, r25
    2c02:	86 5a       	subi	r24, 0xA6	; 166
    2c04:	9a 4f       	sbci	r25, 0xFA	; 250
    2c06:	fc 01       	movw	r30, r24
    2c08:	25 91       	lpm	r18, Z+
    2c0a:	34 91       	lpm	r19, Z+
  state = (uint8_t)pgm_read_byte(&menuPtr->state);
    2c0c:	2e 5f       	subi	r18, 0xFE	; 254
    2c0e:	3f 4f       	sbci	r19, 0xFF	; 255
    2c10:	f9 01       	movw	r30, r18
    2c12:	84 91       	lpm	r24, Z+

  /* load the values of all 4 motors */
  switch(state){
    2c14:	e8 2f       	mov	r30, r24
    2c16:	f0 e0       	ldi	r31, 0x00	; 0
    2c18:	e2 31       	cpi	r30, 0x12	; 18
    2c1a:	f1 05       	cpc	r31, r1
    2c1c:	08 f0       	brcs	.+2      	; 0x2c20 <updateDisplayChangeValues+0x46>
    2c1e:	47 c0       	rjmp	.+142    	; 0x2cae <updateDisplayChangeValues+0xd4>
    2c20:	ea 5b       	subi	r30, 0xBA	; 186
    2c22:	ff 4f       	sbci	r31, 0xFF	; 255
    2c24:	ee 0f       	add	r30, r30
    2c26:	ff 1f       	adc	r31, r31
    2c28:	05 90       	lpm	r0, Z+
    2c2a:	f4 91       	lpm	r31, Z+
    2c2c:	e0 2d       	mov	r30, r0
    2c2e:	09 94       	ijmp
        }
      }
      break;
      
    case MENU_SETTINGS:
      sprintf(menu.newDisplayValue[0], "test    ");
    2c30:	e0 91 16 03 	lds	r30, 0x0316
    2c34:	f0 91 17 03 	lds	r31, 0x0317
    2c38:	20 81       	ld	r18, Z
    2c3a:	31 81       	ldd	r19, Z+1	; 0x01
    2c3c:	c9 01       	movw	r24, r18
    2c3e:	dc 01       	movw	r26, r24
    2c40:	e0 e2       	ldi	r30, 0x20	; 32
    2c42:	f2 e0       	ldi	r31, 0x02	; 2
    2c44:	89 e0       	ldi	r24, 0x09	; 9
    2c46:	01 90       	ld	r0, Z+
    2c48:	0d 92       	st	X+, r0
    2c4a:	81 50       	subi	r24, 0x01	; 1
    2c4c:	e1 f7       	brne	.-8      	; 0x2c46 <updateDisplayChangeValues+0x6c>
      sprintf(menu.newDisplayValue[1], "test    ");
    2c4e:	e0 91 16 03 	lds	r30, 0x0316
    2c52:	f0 91 17 03 	lds	r31, 0x0317
    2c56:	22 81       	ldd	r18, Z+2	; 0x02
    2c58:	33 81       	ldd	r19, Z+3	; 0x03
    2c5a:	c9 01       	movw	r24, r18
    2c5c:	dc 01       	movw	r26, r24
    2c5e:	e0 e2       	ldi	r30, 0x20	; 32
    2c60:	f2 e0       	ldi	r31, 0x02	; 2
    2c62:	89 e0       	ldi	r24, 0x09	; 9
    2c64:	01 90       	ld	r0, Z+
    2c66:	0d 92       	st	X+, r0
    2c68:	81 50       	subi	r24, 0x01	; 1
    2c6a:	e1 f7       	brne	.-8      	; 0x2c64 <updateDisplayChangeValues+0x8a>
      sprintf(menu.newDisplayValue[2], "test    ");
    2c6c:	e0 91 16 03 	lds	r30, 0x0316
    2c70:	f0 91 17 03 	lds	r31, 0x0317
    2c74:	24 81       	ldd	r18, Z+4	; 0x04
    2c76:	35 81       	ldd	r19, Z+5	; 0x05
    2c78:	c9 01       	movw	r24, r18
    2c7a:	dc 01       	movw	r26, r24
    2c7c:	e0 e2       	ldi	r30, 0x20	; 32
    2c7e:	f2 e0       	ldi	r31, 0x02	; 2
    2c80:	89 e0       	ldi	r24, 0x09	; 9
    2c82:	01 90       	ld	r0, Z+
    2c84:	0d 92       	st	X+, r0
    2c86:	81 50       	subi	r24, 0x01	; 1
    2c88:	e1 f7       	brne	.-8      	; 0x2c82 <updateDisplayChangeValues+0xa8>
      sprintf(menu.newDisplayValue[3], "test    ");
    2c8a:	e0 91 16 03 	lds	r30, 0x0316
    2c8e:	f0 91 17 03 	lds	r31, 0x0317
    2c92:	26 81       	ldd	r18, Z+6	; 0x06
    2c94:	37 81       	ldd	r19, Z+7	; 0x07
    2c96:	c9 01       	movw	r24, r18
    2c98:	dc 01       	movw	r26, r24
    2c9a:	e0 e2       	ldi	r30, 0x20	; 32
    2c9c:	f2 e0       	ldi	r31, 0x02	; 2
    2c9e:	89 e0       	ldi	r24, 0x09	; 9
    2ca0:	01 90       	ld	r0, Z+
    2ca2:	0d 92       	st	X+, r0
    2ca4:	81 50       	subi	r24, 0x01	; 1
    2ca6:	e1 f7       	brne	.-8      	; 0x2ca0 <updateDisplayChangeValues+0xc6>
      menu.currentMenuMode = MENU_SETTINGS_MODE;
    2ca8:	85 e0       	ldi	r24, 0x05	; 5
    2caa:	80 93 12 03 	sts	0x0312, r24
    2cae:	20 e0       	ldi	r18, 0x00	; 0
    2cb0:	30 e0       	ldi	r19, 0x00	; 0

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
      menu.newDisplayValue[i][j] = ' ';
    2cb2:	90 e2       	ldi	r25, 0x20	; 32
      break;
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    2cb4:	a0 91 16 03 	lds	r26, 0x0316
    2cb8:	b0 91 17 03 	lds	r27, 0x0317
    2cbc:	a2 0f       	add	r26, r18
    2cbe:	b3 1f       	adc	r27, r19
    2cc0:	ec 91       	ld	r30, X
    2cc2:	11 96       	adiw	r26, 0x01	; 1
    2cc4:	fc 91       	ld	r31, X
    2cc6:	df 01       	movw	r26, r30
    2cc8:	0d 90       	ld	r0, X+
    2cca:	00 20       	and	r0, r0
    2ccc:	e9 f7       	brne	.-6      	; 0x2cc8 <updateDisplayChangeValues+0xee>
    2cce:	11 97       	sbiw	r26, 0x01	; 1
    2cd0:	ae 1b       	sub	r26, r30
    2cd2:	bf 0b       	sbc	r27, r31
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
    2cd4:	a8 30       	cpi	r26, 0x08	; 8
    2cd6:	80 f4       	brcc	.+32     	; 0x2cf8 <updateDisplayChangeValues+0x11e>
    2cd8:	8a 2f       	mov	r24, r26
      menu.newDisplayValue[i][j] = ' ';
    2cda:	e0 91 16 03 	lds	r30, 0x0316
    2cde:	f0 91 17 03 	lds	r31, 0x0317
    2ce2:	e2 0f       	add	r30, r18
    2ce4:	f3 1f       	adc	r31, r19
    2ce6:	01 90       	ld	r0, Z+
    2ce8:	f0 81       	ld	r31, Z
    2cea:	e0 2d       	mov	r30, r0
    2cec:	e8 0f       	add	r30, r24
    2cee:	f1 1d       	adc	r31, r1
    2cf0:	90 83       	st	Z, r25
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    sLen = strlen(menu.newDisplayValue[i]);
    for(j = sLen; j < DISPLAY_VALUE_STRING_LENGTH-1; j++){
    2cf2:	8f 5f       	subi	r24, 0xFF	; 255
    2cf4:	88 30       	cpi	r24, 0x08	; 8
    2cf6:	88 f3       	brcs	.-30     	; 0x2cda <updateDisplayChangeValues+0x100>
      menu.newDisplayValue[i][j] = ' ';
    }
    menu.newDisplayValue[i][DISPLAY_VALUE_STRING_LENGTH-1] = '\0';
    2cf8:	e0 91 16 03 	lds	r30, 0x0316
    2cfc:	f0 91 17 03 	lds	r31, 0x0317
    2d00:	e2 0f       	add	r30, r18
    2d02:	f3 1f       	adc	r31, r19
    2d04:	01 90       	ld	r0, Z+
    2d06:	f0 81       	ld	r31, Z
    2d08:	e0 2d       	mov	r30, r0
    2d0a:	10 86       	std	Z+8, r1	; 0x08
    2d0c:	2e 5f       	subi	r18, 0xFE	; 254
    2d0e:	3f 4f       	sbci	r19, 0xFF	; 255
    default:  /* in case of fire ;-) */
      break;
  }

  /* fill the new ascii values up with spaces */
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    2d10:	28 30       	cpi	r18, 0x08	; 8
    2d12:	31 05       	cpc	r19, r1
    2d14:	79 f6       	brne	.-98     	; 0x2cb4 <updateDisplayChangeValues+0xda>
    }
    menu.newDisplayValue[i][DISPLAY_VALUE_STRING_LENGTH-1] = '\0';
  }

  return;
}
    2d16:	df 91       	pop	r29
    2d18:	cf 91       	pop	r28
    2d1a:	1f 91       	pop	r17
    2d1c:	0f 91       	pop	r16
    2d1e:	ff 90       	pop	r15
    2d20:	ef 90       	pop	r14
    2d22:	df 90       	pop	r13
    2d24:	bf 90       	pop	r11
    2d26:	af 90       	pop	r10
    2d28:	9f 90       	pop	r9
    2d2a:	8f 90       	pop	r8
    2d2c:	7f 90       	pop	r7
    2d2e:	6f 90       	pop	r6
    2d30:	5f 90       	pop	r5
    2d32:	4f 90       	pop	r4
    2d34:	3f 90       	pop	r3
    2d36:	2f 90       	pop	r2
    2d38:	08 95       	ret
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_LOAD_CONFIG:
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Load all");
    2d3a:	e0 91 16 03 	lds	r30, 0x0316
    2d3e:	f0 91 17 03 	lds	r31, 0x0317
    2d42:	20 81       	ld	r18, Z
    2d44:	31 81       	ldd	r19, Z+1	; 0x01
    2d46:	c9 01       	movw	r24, r18
    2d48:	dc 01       	movw	r26, r24
    2d4a:	e2 ec       	ldi	r30, 0xC2	; 194
    2d4c:	f1 e0       	ldi	r31, 0x01	; 1
    2d4e:	89 e0       	ldi	r24, 0x09	; 9
    2d50:	01 90       	ld	r0, Z+
    2d52:	0d 92       	st	X+, r0
    2d54:	81 50       	subi	r24, 0x01	; 1
    2d56:	e1 f7       	brne	.-8      	; 0x2d50 <updateDisplayChangeValues+0x176>
      sprintf(menu.newDisplayValue[1], " saved  ");
    2d58:	e0 91 16 03 	lds	r30, 0x0316
    2d5c:	f0 91 17 03 	lds	r31, 0x0317
    2d60:	22 81       	ldd	r18, Z+2	; 0x02
    2d62:	33 81       	ldd	r19, Z+3	; 0x03
    2d64:	c9 01       	movw	r24, r18
    2d66:	dc 01       	movw	r26, r24
    2d68:	eb ec       	ldi	r30, 0xCB	; 203
    2d6a:	f1 e0       	ldi	r31, 0x01	; 1
    2d6c:	89 e0       	ldi	r24, 0x09	; 9
    2d6e:	01 90       	ld	r0, Z+
    2d70:	0d 92       	st	X+, r0
    2d72:	81 50       	subi	r24, 0x01	; 1
    2d74:	e1 f7       	brne	.-8      	; 0x2d6e <updateDisplayChangeValues+0x194>
      sprintf(menu.newDisplayValue[2], "configur");
    2d76:	e0 91 16 03 	lds	r30, 0x0316
    2d7a:	f0 91 17 03 	lds	r31, 0x0317
    2d7e:	24 81       	ldd	r18, Z+4	; 0x04
    2d80:	35 81       	ldd	r19, Z+5	; 0x05
    2d82:	c9 01       	movw	r24, r18
    2d84:	dc 01       	movw	r26, r24
    2d86:	e0 eb       	ldi	r30, 0xB0	; 176
    2d88:	f1 e0       	ldi	r31, 0x01	; 1
    2d8a:	89 e0       	ldi	r24, 0x09	; 9
    2d8c:	01 90       	ld	r0, Z+
    2d8e:	0d 92       	st	X+, r0
    2d90:	81 50       	subi	r24, 0x01	; 1
    2d92:	e1 f7       	brne	.-8      	; 0x2d8c <updateDisplayChangeValues+0x1b2>
      sprintf(menu.newDisplayValue[3], "ations  ");
    2d94:	e0 91 16 03 	lds	r30, 0x0316
    2d98:	f0 91 17 03 	lds	r31, 0x0317
    2d9c:	26 81       	ldd	r18, Z+6	; 0x06
    2d9e:	37 81       	ldd	r19, Z+7	; 0x07
    2da0:	c9 01       	movw	r24, r18
    2da2:	dc 01       	movw	r26, r24
    2da4:	e9 eb       	ldi	r30, 0xB9	; 185
    2da6:	f1 e0       	ldi	r31, 0x01	; 1
    2da8:	89 e0       	ldi	r24, 0x09	; 9
    2daa:	01 90       	ld	r0, Z+
    2dac:	0d 92       	st	X+, r0
    2dae:	81 50       	subi	r24, 0x01	; 1
    2db0:	e1 f7       	brne	.-8      	; 0x2daa <updateDisplayChangeValues+0x1d0>
    2db2:	7d cf       	rjmp	.-262    	; 0x2cae <updateDisplayChangeValues+0xd4>
  state = (uint8_t)pgm_read_byte(&menuPtr->state);

  /* load the values of all 4 motors */
  switch(state){
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
    2db4:	e0 91 16 03 	lds	r30, 0x0316
    2db8:	f0 91 17 03 	lds	r31, 0x0317
    2dbc:	20 81       	ld	r18, Z
    2dbe:	31 81       	ldd	r19, Z+1	; 0x01
    2dc0:	c9 01       	movw	r24, r18
    2dc2:	dc 01       	movw	r26, r24
    2dc4:	e2 e2       	ldi	r30, 0x22	; 34
    2dc6:	f1 e0       	ldi	r31, 0x01	; 1
    2dc8:	89 e0       	ldi	r24, 0x09	; 9
    2dca:	01 90       	ld	r0, Z+
    2dcc:	0d 92       	st	X+, r0
    2dce:	81 50       	subi	r24, 0x01	; 1
    2dd0:	e1 f7       	brne	.-8      	; 0x2dca <updateDisplayChangeValues+0x1f0>
      sprintf(menu.newDisplayValue[1], "        ");
    2dd2:	e0 91 16 03 	lds	r30, 0x0316
    2dd6:	f0 91 17 03 	lds	r31, 0x0317
    2dda:	22 81       	ldd	r18, Z+2	; 0x02
    2ddc:	33 81       	ldd	r19, Z+3	; 0x03
    2dde:	c9 01       	movw	r24, r18
    2de0:	dc 01       	movw	r26, r24
    2de2:	eb e2       	ldi	r30, 0x2B	; 43
    2de4:	f1 e0       	ldi	r31, 0x01	; 1
    2de6:	89 e0       	ldi	r24, 0x09	; 9
    2de8:	01 90       	ld	r0, Z+
    2dea:	0d 92       	st	X+, r0
    2dec:	81 50       	subi	r24, 0x01	; 1
    2dee:	e1 f7       	brne	.-8      	; 0x2de8 <updateDisplayChangeValues+0x20e>
      sprintf(menu.newDisplayValue[2], "Firmware");
    2df0:	e0 91 16 03 	lds	r30, 0x0316
    2df4:	f0 91 17 03 	lds	r31, 0x0317
    2df8:	24 81       	ldd	r18, Z+4	; 0x04
    2dfa:	35 81       	ldd	r19, Z+5	; 0x05
    2dfc:	c9 01       	movw	r24, r18
    2dfe:	dc 01       	movw	r26, r24
    2e00:	e4 e3       	ldi	r30, 0x34	; 52
    2e02:	f1 e0       	ldi	r31, 0x01	; 1
    2e04:	89 e0       	ldi	r24, 0x09	; 9
    2e06:	01 90       	ld	r0, Z+
    2e08:	0d 92       	st	X+, r0
    2e0a:	81 50       	subi	r24, 0x01	; 1
    2e0c:	e1 f7       	brne	.-8      	; 0x2e06 <updateDisplayChangeValues+0x22c>
      sprintf(menu.newDisplayValue[3], FW_VERSION);
    2e0e:	e0 91 16 03 	lds	r30, 0x0316
    2e12:	f0 91 17 03 	lds	r31, 0x0317
    2e16:	26 81       	ldd	r18, Z+6	; 0x06
    2e18:	37 81       	ldd	r19, Z+7	; 0x07
    2e1a:	c9 01       	movw	r24, r18
    2e1c:	dc 01       	movw	r26, r24
    2e1e:	ed e3       	ldi	r30, 0x3D	; 61
    2e20:	f1 e0       	ldi	r31, 0x01	; 1
    2e22:	87 e0       	ldi	r24, 0x07	; 7
    2e24:	01 90       	ld	r0, Z+
    2e26:	0d 92       	st	X+, r0
    2e28:	81 50       	subi	r24, 0x01	; 1
    2e2a:	e1 f7       	brne	.-8      	; 0x2e24 <updateDisplayChangeValues+0x24a>
    2e2c:	40 cf       	rjmp	.-384    	; 0x2cae <updateDisplayChangeValues+0xd4>
      break;
    2e2e:	c0 e0       	ldi	r28, 0x00	; 0
    2e30:	d0 e0       	ldi	r29, 0x00	; 0
    2e32:	ee 24       	eor	r14, r14
    2e34:	ff 24       	eor	r15, r15
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
            break;

          case MOTOR_STEP_UNIT_DEGREE:
            /* 0xDF is the display code for the degree-circle */
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
    2e36:	bb e4       	ldi	r27, 0x4B	; 75
    2e38:	ab 2e       	mov	r10, r27
    2e3a:	b1 e0       	ldi	r27, 0x01	; 1
    2e3c:	bb 2e       	mov	r11, r27
    2e3e:	af ed       	ldi	r26, 0xDF	; 223
    2e40:	8a 2e       	mov	r8, r26
    2e42:	91 2c       	mov	r9, r1
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    2e44:	f4 e5       	ldi	r31, 0x54	; 84
    2e46:	6f 2e       	mov	r6, r31
    2e48:	f1 e0       	ldi	r31, 0x01	; 1
    2e4a:	7f 2e       	mov	r7, r31
    2e4c:	e7 ef       	ldi	r30, 0xF7	; 247
    2e4e:	4e 2e       	mov	r4, r30
    2e50:	51 2c       	mov	r5, r1
            c = 0x3E;
          }
        }
        switch(motor[i].stepUnit){
          case MOTOR_STEP_UNIT_STEP:
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
    2e52:	74 e4       	ldi	r23, 0x44	; 68
    2e54:	27 2e       	mov	r2, r23
    2e56:	71 e0       	ldi	r23, 0x01	; 1
    2e58:	37 2e       	mov	r3, r23
    case MENU_MAIN:   /* main menu point, no values here to change */
      sprintf(menu.newDisplayValue[0], "SMCx242 ");
      sprintf(menu.newDisplayValue[1], "        ");
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;
    2e5a:	4c 2f       	mov	r20, r28

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    2e5c:	80 91 13 03 	lds	r24, 0x0313
    2e60:	9e 01       	movw	r18, r28
    2e62:	90 e0       	ldi	r25, 0x00	; 0
    2e64:	0c 2e       	mov	r0, r28
    2e66:	02 c0       	rjmp	.+4      	; 0x2e6c <updateDisplayChangeValues+0x292>
    2e68:	95 95       	asr	r25
    2e6a:	87 95       	ror	r24
    2e6c:	0a 94       	dec	r0
    2e6e:	e2 f7       	brpl	.-8      	; 0x2e68 <updateDisplayChangeValues+0x28e>
    2e70:	80 fd       	sbrc	r24, 0
    2e72:	e9 c4       	rjmp	.+2514   	; 0x3846 <updateDisplayChangeValues+0xc6c>
    2e74:	60 e2       	ldi	r22, 0x20	; 32
    2e76:	d6 2e       	mov	r13, r22
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        switch(motor[i].stepUnit){
    2e78:	f9 01       	movw	r30, r18
    2e7a:	ee 0f       	add	r30, r30
    2e7c:	ff 1f       	adc	r31, r31
    2e7e:	ee 0f       	add	r30, r30
    2e80:	ff 1f       	adc	r31, r31
    2e82:	ee 0f       	add	r30, r30
    2e84:	ff 1f       	adc	r31, r31
    2e86:	cf 01       	movw	r24, r30
    2e88:	88 0f       	add	r24, r24
    2e8a:	99 1f       	adc	r25, r25
    2e8c:	88 0f       	add	r24, r24
    2e8e:	99 1f       	adc	r25, r25
    2e90:	e8 0f       	add	r30, r24
    2e92:	f9 1f       	adc	r31, r25
    2e94:	e2 5e       	subi	r30, 0xE2	; 226
    2e96:	fb 4f       	sbci	r31, 0xFB	; 251
    2e98:	81 8d       	ldd	r24, Z+25	; 0x19
    2e9a:	81 30       	cpi	r24, 0x01	; 1
    2e9c:	09 f4       	brne	.+2      	; 0x2ea0 <updateDisplayChangeValues+0x2c6>
    2e9e:	ea c5       	rjmp	.+3028   	; 0x3a74 <updateDisplayChangeValues+0xe9a>
    2ea0:	82 30       	cpi	r24, 0x02	; 2
    2ea2:	09 f4       	brne	.+2      	; 0x2ea6 <updateDisplayChangeValues+0x2cc>
    2ea4:	a0 c5       	rjmp	.+2880   	; 0x39e6 <updateDisplayChangeValues+0xe0c>
    2ea6:	88 23       	and	r24, r24
    2ea8:	d9 f5       	brne	.+118    	; 0x2f20 <updateDisplayChangeValues+0x346>
          case MOTOR_STEP_UNIT_STEP:
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
    2eaa:	a0 91 16 03 	lds	r26, 0x0316
    2eae:	b0 91 17 03 	lds	r27, 0x0317
    2eb2:	f9 01       	movw	r30, r18
    2eb4:	ee 0f       	add	r30, r30
    2eb6:	ff 1f       	adc	r31, r31
    2eb8:	ee 0f       	add	r30, r30
    2eba:	ff 1f       	adc	r31, r31
    2ebc:	ee 0f       	add	r30, r30
    2ebe:	ff 1f       	adc	r31, r31
    2ec0:	cf 01       	movw	r24, r30
    2ec2:	88 0f       	add	r24, r24
    2ec4:	99 1f       	adc	r25, r25
    2ec6:	88 0f       	add	r24, r24
    2ec8:	99 1f       	adc	r25, r25
    2eca:	e8 0f       	add	r30, r24
    2ecc:	f9 1f       	adc	r31, r25
    2ece:	e2 5e       	subi	r30, 0xE2	; 226
    2ed0:	fb 4f       	sbci	r31, 0xFB	; 251
    2ed2:	20 81       	ld	r18, Z
    2ed4:	31 81       	ldd	r19, Z+1	; 0x01
    2ed6:	8d b7       	in	r24, 0x3d	; 61
    2ed8:	9e b7       	in	r25, 0x3e	; 62
    2eda:	08 97       	sbiw	r24, 0x08	; 8
    2edc:	0f b6       	in	r0, 0x3f	; 63
    2ede:	f8 94       	cli
    2ee0:	9e bf       	out	0x3e, r25	; 62
    2ee2:	0f be       	out	0x3f, r0	; 63
    2ee4:	8d bf       	out	0x3d, r24	; 61
    2ee6:	ed b7       	in	r30, 0x3d	; 61
    2ee8:	fe b7       	in	r31, 0x3e	; 62
    2eea:	31 96       	adiw	r30, 0x01	; 1
    2eec:	ae 0d       	add	r26, r14
    2eee:	bf 1d       	adc	r27, r15
    2ef0:	8d 91       	ld	r24, X+
    2ef2:	9c 91       	ld	r25, X
    2ef4:	ad b7       	in	r26, 0x3d	; 61
    2ef6:	be b7       	in	r27, 0x3e	; 62
    2ef8:	12 96       	adiw	r26, 0x02	; 2
    2efa:	9c 93       	st	X, r25
    2efc:	8e 93       	st	-X, r24
    2efe:	11 97       	sbiw	r26, 0x01	; 1
    2f00:	33 82       	std	Z+3, r3	; 0x03
    2f02:	22 82       	std	Z+2, r2	; 0x02
    2f04:	d4 82       	std	Z+4, r13	; 0x04
    2f06:	15 82       	std	Z+5, r1	; 0x05
    2f08:	37 83       	std	Z+7, r19	; 0x07
    2f0a:	26 83       	std	Z+6, r18	; 0x06
    2f0c:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2f10:	ed b7       	in	r30, 0x3d	; 61
    2f12:	fe b7       	in	r31, 0x3e	; 62
    2f14:	38 96       	adiw	r30, 0x08	; 8
    2f16:	0f b6       	in	r0, 0x3f	; 63
    2f18:	f8 94       	cli
    2f1a:	fe bf       	out	0x3e, r31	; 62
    2f1c:	0f be       	out	0x3f, r0	; 63
    2f1e:	ed bf       	out	0x3d, r30	; 61
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    2f20:	21 96       	adiw	r28, 0x01	; 1
    2f22:	22 e0       	ldi	r18, 0x02	; 2
    2f24:	30 e0       	ldi	r19, 0x00	; 0
    2f26:	e2 0e       	add	r14, r18
    2f28:	f3 1e       	adc	r15, r19
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
    2f2a:	c4 30       	cpi	r28, 0x04	; 4
    2f2c:	d1 05       	cpc	r29, r1
    2f2e:	09 f0       	breq	.+2      	; 0x2f32 <updateDisplayChangeValues+0x358>
    2f30:	94 cf       	rjmp	.-216    	; 0x2e5a <updateDisplayChangeValues+0x280>
    2f32:	bd ce       	rjmp	.-646    	; 0x2cae <updateDisplayChangeValues+0xd4>
        }
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
    2f34:	c0 e0       	ldi	r28, 0x00	; 0
    2f36:	d0 e0       	ldi	r29, 0x00	; 0
    2f38:	0d e7       	ldi	r16, 0x7D	; 125
    2f3a:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    2f3c:	80 91 13 03 	lds	r24, 0x0313
    2f40:	9e 01       	movw	r18, r28
    2f42:	90 e0       	ldi	r25, 0x00	; 0
    2f44:	0c 2e       	mov	r0, r28
    2f46:	02 c0       	rjmp	.+4      	; 0x2f4c <updateDisplayChangeValues+0x372>
    2f48:	95 95       	asr	r25
    2f4a:	87 95       	ror	r24
    2f4c:	0a 94       	dec	r0
    2f4e:	e2 f7       	brpl	.-8      	; 0x2f48 <updateDisplayChangeValues+0x36e>
    2f50:	80 fd       	sbrc	r24, 0
    2f52:	81 c4       	rjmp	.+2306   	; 0x3856 <updateDisplayChangeValues+0xc7c>
    2f54:	60 e2       	ldi	r22, 0x20	; 32
    2f56:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
    2f58:	a0 91 16 03 	lds	r26, 0x0316
    2f5c:	b0 91 17 03 	lds	r27, 0x0317
    2f60:	f9 01       	movw	r30, r18
    2f62:	ee 0f       	add	r30, r30
    2f64:	ff 1f       	adc	r31, r31
    2f66:	ee 0f       	add	r30, r30
    2f68:	ff 1f       	adc	r31, r31
    2f6a:	ee 0f       	add	r30, r30
    2f6c:	ff 1f       	adc	r31, r31
    2f6e:	cf 01       	movw	r24, r30
    2f70:	88 0f       	add	r24, r24
    2f72:	99 1f       	adc	r25, r25
    2f74:	88 0f       	add	r24, r24
    2f76:	99 1f       	adc	r25, r25
    2f78:	e8 0f       	add	r30, r24
    2f7a:	f9 1f       	adc	r31, r25
    2f7c:	e2 5e       	subi	r30, 0xE2	; 226
    2f7e:	fb 4f       	sbci	r31, 0xFB	; 251
    2f80:	22 8d       	ldd	r18, Z+26	; 0x1a
    2f82:	33 8d       	ldd	r19, Z+27	; 0x1b
    2f84:	44 8d       	ldd	r20, Z+28	; 0x1c
    2f86:	55 8d       	ldd	r21, Z+29	; 0x1d
    2f88:	8d b7       	in	r24, 0x3d	; 61
    2f8a:	9e b7       	in	r25, 0x3e	; 62
    2f8c:	0a 97       	sbiw	r24, 0x0a	; 10
    2f8e:	0f b6       	in	r0, 0x3f	; 63
    2f90:	f8 94       	cli
    2f92:	9e bf       	out	0x3e, r25	; 62
    2f94:	0f be       	out	0x3f, r0	; 63
    2f96:	8d bf       	out	0x3d, r24	; 61
    2f98:	ed b7       	in	r30, 0x3d	; 61
    2f9a:	fe b7       	in	r31, 0x3e	; 62
    2f9c:	31 96       	adiw	r30, 0x01	; 1
    2f9e:	ce 01       	movw	r24, r28
    2fa0:	88 0f       	add	r24, r24
    2fa2:	99 1f       	adc	r25, r25
    2fa4:	a8 0f       	add	r26, r24
    2fa6:	b9 1f       	adc	r27, r25
    2fa8:	8d 91       	ld	r24, X+
    2faa:	9c 91       	ld	r25, X
    2fac:	ad b7       	in	r26, 0x3d	; 61
    2fae:	be b7       	in	r27, 0x3e	; 62
    2fb0:	12 96       	adiw	r26, 0x02	; 2
    2fb2:	9c 93       	st	X, r25
    2fb4:	8e 93       	st	-X, r24
    2fb6:	11 97       	sbiw	r26, 0x01	; 1
    2fb8:	13 83       	std	Z+3, r17	; 0x03
    2fba:	02 83       	std	Z+2, r16	; 0x02
    2fbc:	75 83       	std	Z+5, r23	; 0x05
    2fbe:	64 83       	std	Z+4, r22	; 0x04
    2fc0:	26 83       	std	Z+6, r18	; 0x06
    2fc2:	37 83       	std	Z+7, r19	; 0x07
    2fc4:	40 87       	std	Z+8, r20	; 0x08
    2fc6:	51 87       	std	Z+9, r21	; 0x09
    2fc8:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    2fcc:	21 96       	adiw	r28, 0x01	; 1
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
    2fce:	ed b7       	in	r30, 0x3d	; 61
    2fd0:	fe b7       	in	r31, 0x3e	; 62
    2fd2:	3a 96       	adiw	r30, 0x0a	; 10
    2fd4:	0f b6       	in	r0, 0x3f	; 63
    2fd6:	f8 94       	cli
    2fd8:	fe bf       	out	0x3e, r31	; 62
    2fda:	0f be       	out	0x3f, r0	; 63
    2fdc:	ed bf       	out	0x3d, r30	; 61
    2fde:	c4 30       	cpi	r28, 0x04	; 4
    2fe0:	d1 05       	cpc	r29, r1
    2fe2:	09 f0       	breq	.+2      	; 0x2fe6 <updateDisplayChangeValues+0x40c>
    2fe4:	ab cf       	rjmp	.-170    	; 0x2f3c <updateDisplayChangeValues+0x362>
    2fe6:	63 ce       	rjmp	.-826    	; 0x2cae <updateDisplayChangeValues+0xd4>
      sprintf(menu.newDisplayValue[2], "Firmware");
      sprintf(menu.newDisplayValue[3], FW_VERSION);
      break;

    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
    2fe8:	c0 e0       	ldi	r28, 0x00	; 0
    2fea:	d0 e0       	ldi	r29, 0x00	; 0
    2fec:	00 e0       	ldi	r16, 0x00	; 0
    2fee:	10 e0       	ldi	r17, 0x00	; 0

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
    2ff0:	9d e5       	ldi	r25, 0x5D	; 93
    2ff2:	a9 2e       	mov	r10, r25
    2ff4:	91 e0       	ldi	r25, 0x01	; 1
    2ff6:	b9 2e       	mov	r11, r25
    2ff8:	82 e6       	ldi	r24, 0x62	; 98
    2ffa:	88 2e       	mov	r8, r24
    2ffc:	81 e0       	ldi	r24, 0x01	; 1
    2ffe:	98 2e       	mov	r9, r24
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
    3000:	b7 e6       	ldi	r27, 0x67	; 103
    3002:	6b 2e       	mov	r6, r27
    3004:	b1 e0       	ldi	r27, 0x01	; 1
    3006:	7b 2e       	mov	r7, r27
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    3008:	ae e6       	ldi	r26, 0x6E	; 110
    300a:	4a 2e       	mov	r4, r26
    300c:	a1 e0       	ldi	r26, 0x01	; 1
    300e:	5a 2e       	mov	r5, r26
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3010:	80 91 13 03 	lds	r24, 0x0313
    3014:	fc 2e       	mov	r15, r28
    3016:	ed 2e       	mov	r14, r29
    3018:	90 e0       	ldi	r25, 0x00	; 0
    301a:	0c 2e       	mov	r0, r28
    301c:	02 c0       	rjmp	.+4      	; 0x3022 <updateDisplayChangeValues+0x448>
    301e:	95 95       	asr	r25
    3020:	87 95       	ror	r24
    3022:	0a 94       	dec	r0
    3024:	e2 f7       	brpl	.-8      	; 0x301e <updateDisplayChangeValues+0x444>
    3026:	80 fd       	sbrc	r24, 0
    3028:	f5 c3       	rjmp	.+2026   	; 0x3814 <updateDisplayChangeValues+0xc3a>
    302a:	f0 e2       	ldi	r31, 0x20	; 32
    302c:	df 2e       	mov	r13, r31
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
    302e:	ef 2d       	mov	r30, r15
    3030:	fe 2d       	mov	r31, r14
    3032:	ee 0f       	add	r30, r30
    3034:	ff 1f       	adc	r31, r31
    3036:	ee 0f       	add	r30, r30
    3038:	ff 1f       	adc	r31, r31
    303a:	ee 0f       	add	r30, r30
    303c:	ff 1f       	adc	r31, r31
    303e:	cf 01       	movw	r24, r30
    3040:	88 0f       	add	r24, r24
    3042:	99 1f       	adc	r25, r25
    3044:	88 0f       	add	r24, r24
    3046:	99 1f       	adc	r25, r25
    3048:	e8 0f       	add	r30, r24
    304a:	f9 1f       	adc	r31, r25
    304c:	e2 5e       	subi	r30, 0xE2	; 226
    304e:	fb 4f       	sbci	r31, 0xFB	; 251
    3050:	81 8d       	ldd	r24, Z+25	; 0x19
    3052:	88 23       	and	r24, r24
    3054:	09 f4       	brne	.+2      	; 0x3058 <updateDisplayChangeValues+0x47e>
    3056:	93 c4       	rjmp	.+2342   	; 0x397e <updateDisplayChangeValues+0xda4>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
    3058:	ef 2d       	mov	r30, r15
    305a:	fe 2d       	mov	r31, r14
    305c:	ee 0f       	add	r30, r30
    305e:	ff 1f       	adc	r31, r31
    3060:	ee 0f       	add	r30, r30
    3062:	ff 1f       	adc	r31, r31
    3064:	ee 0f       	add	r30, r30
    3066:	ff 1f       	adc	r31, r31
    3068:	cf 01       	movw	r24, r30
    306a:	88 0f       	add	r24, r24
    306c:	99 1f       	adc	r25, r25
    306e:	88 0f       	add	r24, r24
    3070:	99 1f       	adc	r25, r25
    3072:	e8 0f       	add	r30, r24
    3074:	f9 1f       	adc	r31, r25
    3076:	e2 5e       	subi	r30, 0xE2	; 226
    3078:	fb 4f       	sbci	r31, 0xFB	; 251
    307a:	81 8d       	ldd	r24, Z+25	; 0x19
    307c:	81 30       	cpi	r24, 0x01	; 1
    307e:	09 f4       	brne	.+2      	; 0x3082 <updateDisplayChangeValues+0x4a8>
    3080:	fd c5       	rjmp	.+3066   	; 0x3c7c <updateDisplayChangeValues+0x10a2>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
    3082:	ef 2d       	mov	r30, r15
    3084:	fe 2d       	mov	r31, r14
    3086:	ee 0f       	add	r30, r30
    3088:	ff 1f       	adc	r31, r31
    308a:	ee 0f       	add	r30, r30
    308c:	ff 1f       	adc	r31, r31
    308e:	ee 0f       	add	r30, r30
    3090:	ff 1f       	adc	r31, r31
    3092:	cf 01       	movw	r24, r30
    3094:	88 0f       	add	r24, r24
    3096:	99 1f       	adc	r25, r25
    3098:	88 0f       	add	r24, r24
    309a:	99 1f       	adc	r25, r25
    309c:	e8 0f       	add	r30, r24
    309e:	f9 1f       	adc	r31, r25
    30a0:	e2 5e       	subi	r30, 0xE2	; 226
    30a2:	fb 4f       	sbci	r31, 0xFB	; 251
    30a4:	81 8d       	ldd	r24, Z+25	; 0x19
    30a6:	82 30       	cpi	r24, 0x02	; 2
    30a8:	09 f4       	brne	.+2      	; 0x30ac <updateDisplayChangeValues+0x4d2>
    30aa:	b7 c5       	rjmp	.+2926   	; 0x3c1a <updateDisplayChangeValues+0x1040>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    30ac:	21 96       	adiw	r28, 0x01	; 1
    30ae:	0e 5f       	subi	r16, 0xFE	; 254
    30b0:	1f 4f       	sbci	r17, 0xFF	; 255
        }
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
    30b2:	c4 30       	cpi	r28, 0x04	; 4
    30b4:	d1 05       	cpc	r29, r1
    30b6:	09 f0       	breq	.+2      	; 0x30ba <updateDisplayChangeValues+0x4e0>
    30b8:	ab cf       	rjmp	.-170    	; 0x3010 <updateDisplayChangeValues+0x436>
    30ba:	f9 cd       	rjmp	.-1038   	; 0x2cae <updateDisplayChangeValues+0xd4>
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
      sprintf(menu.newDisplayValue[3], "        ");
      break;
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
    30bc:	c0 e0       	ldi	r28, 0x00	; 0
    30be:	d0 e0       	ldi	r29, 0x00	; 0
    30c0:	09 e0       	ldi	r16, 0x09	; 9
    30c2:	12 e0       	ldi	r17, 0x02	; 2
      
    case MENU_SET_GEAR_RATIO:
      for(i = 0; i <= MAX_MOTOR; i++){
        //c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    30c4:	80 91 13 03 	lds	r24, 0x0313
    30c8:	9e 01       	movw	r18, r28
    30ca:	90 e0       	ldi	r25, 0x00	; 0
    30cc:	0c 2e       	mov	r0, r28
    30ce:	02 c0       	rjmp	.+4      	; 0x30d4 <updateDisplayChangeValues+0x4fa>
    30d0:	95 95       	asr	r25
    30d2:	87 95       	ror	r24
    30d4:	0a 94       	dec	r0
    30d6:	e2 f7       	brpl	.-8      	; 0x30d0 <updateDisplayChangeValues+0x4f6>
    30d8:	80 fd       	sbrc	r24, 0
    30da:	aa c3       	rjmp	.+1876   	; 0x3830 <updateDisplayChangeValues+0xc56>
    30dc:	60 e2       	ldi	r22, 0x20	; 32
    30de:	70 e0       	ldi	r23, 0x00	; 0
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        sprintf(menu.newDisplayValue[i], "%c%.3f", c, motor[i].gearRatio);
    30e0:	a0 91 16 03 	lds	r26, 0x0316
    30e4:	b0 91 17 03 	lds	r27, 0x0317
    30e8:	f9 01       	movw	r30, r18
    30ea:	ee 0f       	add	r30, r30
    30ec:	ff 1f       	adc	r31, r31
    30ee:	ee 0f       	add	r30, r30
    30f0:	ff 1f       	adc	r31, r31
    30f2:	ee 0f       	add	r30, r30
    30f4:	ff 1f       	adc	r31, r31
    30f6:	cf 01       	movw	r24, r30
    30f8:	88 0f       	add	r24, r24
    30fa:	99 1f       	adc	r25, r25
    30fc:	88 0f       	add	r24, r24
    30fe:	99 1f       	adc	r25, r25
    3100:	e8 0f       	add	r30, r24
    3102:	f9 1f       	adc	r31, r25
    3104:	e2 5e       	subi	r30, 0xE2	; 226
    3106:	fb 4f       	sbci	r31, 0xFB	; 251
    3108:	25 85       	ldd	r18, Z+13	; 0x0d
    310a:	36 85       	ldd	r19, Z+14	; 0x0e
    310c:	47 85       	ldd	r20, Z+15	; 0x0f
    310e:	50 89       	ldd	r21, Z+16	; 0x10
    3110:	8d b7       	in	r24, 0x3d	; 61
    3112:	9e b7       	in	r25, 0x3e	; 62
    3114:	0a 97       	sbiw	r24, 0x0a	; 10
    3116:	0f b6       	in	r0, 0x3f	; 63
    3118:	f8 94       	cli
    311a:	9e bf       	out	0x3e, r25	; 62
    311c:	0f be       	out	0x3f, r0	; 63
    311e:	8d bf       	out	0x3d, r24	; 61
    3120:	ed b7       	in	r30, 0x3d	; 61
    3122:	fe b7       	in	r31, 0x3e	; 62
    3124:	31 96       	adiw	r30, 0x01	; 1
    3126:	ce 01       	movw	r24, r28
    3128:	88 0f       	add	r24, r24
    312a:	99 1f       	adc	r25, r25
    312c:	a8 0f       	add	r26, r24
    312e:	b9 1f       	adc	r27, r25
    3130:	8d 91       	ld	r24, X+
    3132:	9c 91       	ld	r25, X
    3134:	ad b7       	in	r26, 0x3d	; 61
    3136:	be b7       	in	r27, 0x3e	; 62
    3138:	12 96       	adiw	r26, 0x02	; 2
    313a:	9c 93       	st	X, r25
    313c:	8e 93       	st	-X, r24
    313e:	11 97       	sbiw	r26, 0x01	; 1
    3140:	13 83       	std	Z+3, r17	; 0x03
    3142:	02 83       	std	Z+2, r16	; 0x02
    3144:	75 83       	std	Z+5, r23	; 0x05
    3146:	64 83       	std	Z+4, r22	; 0x04
    3148:	26 83       	std	Z+6, r18	; 0x06
    314a:	37 83       	std	Z+7, r19	; 0x07
    314c:	40 87       	std	Z+8, r20	; 0x08
    314e:	51 87       	std	Z+9, r21	; 0x09
    3150:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3154:	21 96       	adiw	r28, 0x01	; 1
        sprintf(menu.newDisplayValue[i], "%c%.1f A", c, motor[i].current);
      }
      break;
      
    case MENU_SET_GEAR_RATIO:
      for(i = 0; i <= MAX_MOTOR; i++){
    3156:	ed b7       	in	r30, 0x3d	; 61
    3158:	fe b7       	in	r31, 0x3e	; 62
    315a:	3a 96       	adiw	r30, 0x0a	; 10
    315c:	0f b6       	in	r0, 0x3f	; 63
    315e:	f8 94       	cli
    3160:	fe bf       	out	0x3e, r31	; 62
    3162:	0f be       	out	0x3f, r0	; 63
    3164:	ed bf       	out	0x3d, r30	; 61
    3166:	c4 30       	cpi	r28, 0x04	; 4
    3168:	d1 05       	cpc	r29, r1
    316a:	09 f0       	breq	.+2      	; 0x316e <updateDisplayChangeValues+0x594>
    316c:	ab cf       	rjmp	.-170    	; 0x30c4 <updateDisplayChangeValues+0x4ea>
    316e:	9f cd       	rjmp	.-1218   	; 0x2cae <updateDisplayChangeValues+0xd4>
        }
      }
      break;

    case MENU_RUN_PROGRAM:
      sprintf(menu.newDisplayValue[0], "Program ");
    3170:	e0 91 16 03 	lds	r30, 0x0316
    3174:	f0 91 17 03 	lds	r31, 0x0317
    3178:	20 81       	ld	r18, Z
    317a:	31 81       	ldd	r19, Z+1	; 0x01
    317c:	c9 01       	movw	r24, r18
    317e:	dc 01       	movw	r26, r24
    3180:	e6 ee       	ldi	r30, 0xE6	; 230
    3182:	f1 e0       	ldi	r31, 0x01	; 1
    3184:	89 e0       	ldi	r24, 0x09	; 9
    3186:	01 90       	ld	r0, Z+
    3188:	0d 92       	st	X+, r0
    318a:	81 50       	subi	r24, 0x01	; 1
    318c:	e1 f7       	brne	.-8      	; 0x3186 <updateDisplayChangeValues+0x5ac>
      sprintf(menu.newDisplayValue[1], "running ");
    318e:	e0 91 16 03 	lds	r30, 0x0316
    3192:	f0 91 17 03 	lds	r31, 0x0317
    3196:	22 81       	ldd	r18, Z+2	; 0x02
    3198:	33 81       	ldd	r19, Z+3	; 0x03
    319a:	c9 01       	movw	r24, r18
    319c:	dc 01       	movw	r26, r24
    319e:	ef ee       	ldi	r30, 0xEF	; 239
    31a0:	f1 e0       	ldi	r31, 0x01	; 1
    31a2:	89 e0       	ldi	r24, 0x09	; 9
    31a4:	01 90       	ld	r0, Z+
    31a6:	0d 92       	st	X+, r0
    31a8:	81 50       	subi	r24, 0x01	; 1
    31aa:	e1 f7       	brne	.-8      	; 0x31a4 <updateDisplayChangeValues+0x5ca>
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
    31ac:	e0 91 16 03 	lds	r30, 0x0316
    31b0:	f0 91 17 03 	lds	r31, 0x0317
    31b4:	20 91 11 03 	lds	r18, 0x0311
    31b8:	00 d0       	rcall	.+0      	; 0x31ba <updateDisplayChangeValues+0x5e0>
    31ba:	00 d0       	rcall	.+0      	; 0x31bc <updateDisplayChangeValues+0x5e2>
    31bc:	00 d0       	rcall	.+0      	; 0x31be <updateDisplayChangeValues+0x5e4>
    31be:	ad b7       	in	r26, 0x3d	; 61
    31c0:	be b7       	in	r27, 0x3e	; 62
    31c2:	11 96       	adiw	r26, 0x01	; 1
    31c4:	84 81       	ldd	r24, Z+4	; 0x04
    31c6:	95 81       	ldd	r25, Z+5	; 0x05
    31c8:	ed b7       	in	r30, 0x3d	; 61
    31ca:	fe b7       	in	r31, 0x3e	; 62
    31cc:	92 83       	std	Z+2, r25	; 0x02
    31ce:	81 83       	std	Z+1, r24	; 0x01
    31d0:	88 ef       	ldi	r24, 0xF8	; 248
    31d2:	91 e0       	ldi	r25, 0x01	; 1
    31d4:	13 96       	adiw	r26, 0x03	; 3
    31d6:	9c 93       	st	X, r25
    31d8:	8e 93       	st	-X, r24
    31da:	12 97       	sbiw	r26, 0x02	; 2
    31dc:	33 27       	eor	r19, r19
    31de:	27 fd       	sbrc	r18, 7
    31e0:	30 95       	com	r19
    31e2:	15 96       	adiw	r26, 0x05	; 5
    31e4:	3c 93       	st	X, r19
    31e6:	2e 93       	st	-X, r18
    31e8:	14 97       	sbiw	r26, 0x04	; 4
    31ea:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
      sprintf(menu.newDisplayValue[3], "        ");
    31ee:	e0 91 16 03 	lds	r30, 0x0316
    31f2:	f0 91 17 03 	lds	r31, 0x0317
    31f6:	26 81       	ldd	r18, Z+6	; 0x06
    31f8:	37 81       	ldd	r19, Z+7	; 0x07
    31fa:	c9 01       	movw	r24, r18
    31fc:	dc 01       	movw	r26, r24
    31fe:	eb e2       	ldi	r30, 0x2B	; 43
    3200:	f1 e0       	ldi	r31, 0x01	; 1
    3202:	89 e0       	ldi	r24, 0x09	; 9
    3204:	01 90       	ld	r0, Z+
    3206:	0d 92       	st	X+, r0
    3208:	81 50       	subi	r24, 0x01	; 1
    320a:	e1 f7       	brne	.-8      	; 0x3204 <updateDisplayChangeValues+0x62a>
    320c:	2d b7       	in	r18, 0x3d	; 61
    320e:	3e b7       	in	r19, 0x3e	; 62
    3210:	2a 5f       	subi	r18, 0xFA	; 250
    3212:	3f 4f       	sbci	r19, 0xFF	; 255
    3214:	0f b6       	in	r0, 0x3f	; 63
    3216:	f8 94       	cli
    3218:	3e bf       	out	0x3e, r19	; 62
    321a:	0f be       	out	0x3f, r0	; 63
    321c:	2d bf       	out	0x3d, r18	; 61
    321e:	47 cd       	rjmp	.-1394   	; 0x2cae <updateDisplayChangeValues+0xd4>
      break;
    3220:	c0 e0       	ldi	r28, 0x00	; 0
    3222:	d0 e0       	ldi	r29, 0x00	; 0
    3224:	00 e0       	ldi	r16, 0x00	; 0
    3226:	12 e0       	ldi	r17, 0x02	; 2
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3228:	80 91 13 03 	lds	r24, 0x0313
    322c:	9e 01       	movw	r18, r28
    322e:	90 e0       	ldi	r25, 0x00	; 0
    3230:	0c 2e       	mov	r0, r28
    3232:	02 c0       	rjmp	.+4      	; 0x3238 <updateDisplayChangeValues+0x65e>
    3234:	95 95       	asr	r25
    3236:	87 95       	ror	r24
    3238:	0a 94       	dec	r0
    323a:	e2 f7       	brpl	.-8      	; 0x3234 <updateDisplayChangeValues+0x65a>
    323c:	80 fd       	sbrc	r24, 0
    323e:	55 c3       	rjmp	.+1706   	; 0x38ea <updateDisplayChangeValues+0xd10>
    3240:	60 e2       	ldi	r22, 0x20	; 32
    3242:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.1f A", c, motor[i].current);
    3244:	a0 91 16 03 	lds	r26, 0x0316
    3248:	b0 91 17 03 	lds	r27, 0x0317
    324c:	f9 01       	movw	r30, r18
    324e:	ee 0f       	add	r30, r30
    3250:	ff 1f       	adc	r31, r31
    3252:	ee 0f       	add	r30, r30
    3254:	ff 1f       	adc	r31, r31
    3256:	ee 0f       	add	r30, r30
    3258:	ff 1f       	adc	r31, r31
    325a:	cf 01       	movw	r24, r30
    325c:	88 0f       	add	r24, r24
    325e:	99 1f       	adc	r25, r25
    3260:	88 0f       	add	r24, r24
    3262:	99 1f       	adc	r25, r25
    3264:	e8 0f       	add	r30, r24
    3266:	f9 1f       	adc	r31, r25
    3268:	e2 5e       	subi	r30, 0xE2	; 226
    326a:	fb 4f       	sbci	r31, 0xFB	; 251
    326c:	23 a1       	ldd	r18, Z+35	; 0x23
    326e:	34 a1       	ldd	r19, Z+36	; 0x24
    3270:	45 a1       	ldd	r20, Z+37	; 0x25
    3272:	56 a1       	ldd	r21, Z+38	; 0x26
    3274:	8d b7       	in	r24, 0x3d	; 61
    3276:	9e b7       	in	r25, 0x3e	; 62
    3278:	0a 97       	sbiw	r24, 0x0a	; 10
    327a:	0f b6       	in	r0, 0x3f	; 63
    327c:	f8 94       	cli
    327e:	9e bf       	out	0x3e, r25	; 62
    3280:	0f be       	out	0x3f, r0	; 63
    3282:	8d bf       	out	0x3d, r24	; 61
    3284:	ed b7       	in	r30, 0x3d	; 61
    3286:	fe b7       	in	r31, 0x3e	; 62
    3288:	31 96       	adiw	r30, 0x01	; 1
    328a:	ce 01       	movw	r24, r28
    328c:	88 0f       	add	r24, r24
    328e:	99 1f       	adc	r25, r25
    3290:	a8 0f       	add	r26, r24
    3292:	b9 1f       	adc	r27, r25
    3294:	8d 91       	ld	r24, X+
    3296:	9c 91       	ld	r25, X
    3298:	ad b7       	in	r26, 0x3d	; 61
    329a:	be b7       	in	r27, 0x3e	; 62
    329c:	12 96       	adiw	r26, 0x02	; 2
    329e:	9c 93       	st	X, r25
    32a0:	8e 93       	st	-X, r24
    32a2:	11 97       	sbiw	r26, 0x01	; 1
    32a4:	13 83       	std	Z+3, r17	; 0x03
    32a6:	02 83       	std	Z+2, r16	; 0x02
    32a8:	75 83       	std	Z+5, r23	; 0x05
    32aa:	64 83       	std	Z+4, r22	; 0x04
    32ac:	26 83       	std	Z+6, r18	; 0x06
    32ae:	37 83       	std	Z+7, r19	; 0x07
    32b0:	40 87       	std	Z+8, r20	; 0x08
    32b2:	51 87       	std	Z+9, r21	; 0x09
    32b4:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    32b8:	21 96       	adiw	r28, 0x01	; 1
      sprintf(menu.newDisplayValue[2], "Step %d" , menu.currentProgramStep);
      sprintf(menu.newDisplayValue[3], "        ");
      break;
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
    32ba:	ed b7       	in	r30, 0x3d	; 61
    32bc:	fe b7       	in	r31, 0x3e	; 62
    32be:	3a 96       	adiw	r30, 0x0a	; 10
    32c0:	0f b6       	in	r0, 0x3f	; 63
    32c2:	f8 94       	cli
    32c4:	fe bf       	out	0x3e, r31	; 62
    32c6:	0f be       	out	0x3f, r0	; 63
    32c8:	ed bf       	out	0x3d, r30	; 61
    32ca:	c4 30       	cpi	r28, 0x04	; 4
    32cc:	d1 05       	cpc	r29, r1
    32ce:	09 f0       	breq	.+2      	; 0x32d2 <updateDisplayChangeValues+0x6f8>
    32d0:	ab cf       	rjmp	.-170    	; 0x3228 <updateDisplayChangeValues+0x64e>
    32d2:	ed cc       	rjmp	.-1574   	; 0x2cae <updateDisplayChangeValues+0xd4>
        sprintf(menu.newDisplayValue[i], "%c%.3f", c, motor[i].gearRatio);
      }
      break;
      
    case MENU_SET_FULL_ROTATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    32d4:	c0 e0       	ldi	r28, 0x00	; 0
    32d6:	d0 e0       	ldi	r29, 0x00	; 0
    32d8:	00 e0       	ldi	r16, 0x00	; 0
    32da:	10 e0       	ldi	r17, 0x00	; 0

    case MENU_SET_DECAY_MODE:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].decay == DECAY_MODE_SLOW){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "slow");
    32dc:	5d e5       	ldi	r21, 0x5D	; 93
    32de:	a5 2e       	mov	r10, r21
    32e0:	51 e0       	ldi	r21, 0x01	; 1
    32e2:	b5 2e       	mov	r11, r21
    32e4:	40 e1       	ldi	r20, 0x10	; 16
    32e6:	84 2e       	mov	r8, r20
    32e8:	42 e0       	ldi	r20, 0x02	; 2
    32ea:	94 2e       	mov	r9, r20
        }
        if(motor[i].decay == DECAY_MODE_FAST){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "fast");
    32ec:	35 e1       	ldi	r19, 0x15	; 21
    32ee:	63 2e       	mov	r6, r19
    32f0:	32 e0       	ldi	r19, 0x02	; 2
    32f2:	73 2e       	mov	r7, r19
        }
        if(motor[i].decay == DECAY_MODE_MIXED){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "mixed");
    32f4:	2a e1       	ldi	r18, 0x1A	; 26
    32f6:	42 2e       	mov	r4, r18
    32f8:	22 e0       	ldi	r18, 0x02	; 2
    32fa:	52 2e       	mov	r5, r18
      }
      break;

    case MENU_SET_DECAY_MODE:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    32fc:	80 91 13 03 	lds	r24, 0x0313
    3300:	fc 2e       	mov	r15, r28
    3302:	ed 2e       	mov	r14, r29
    3304:	90 e0       	ldi	r25, 0x00	; 0
    3306:	0c 2e       	mov	r0, r28
    3308:	02 c0       	rjmp	.+4      	; 0x330e <updateDisplayChangeValues+0x734>
    330a:	95 95       	asr	r25
    330c:	87 95       	ror	r24
    330e:	0a 94       	dec	r0
    3310:	e2 f7       	brpl	.-8      	; 0x330a <updateDisplayChangeValues+0x730>
    3312:	80 fd       	sbrc	r24, 0
    3314:	95 c2       	rjmp	.+1322   	; 0x3840 <updateDisplayChangeValues+0xc66>
    3316:	90 e2       	ldi	r25, 0x20	; 32
    3318:	d9 2e       	mov	r13, r25
        if(motor[i].decay == DECAY_MODE_SLOW){
    331a:	ef 2d       	mov	r30, r15
    331c:	fe 2d       	mov	r31, r14
    331e:	ee 0f       	add	r30, r30
    3320:	ff 1f       	adc	r31, r31
    3322:	ee 0f       	add	r30, r30
    3324:	ff 1f       	adc	r31, r31
    3326:	ee 0f       	add	r30, r30
    3328:	ff 1f       	adc	r31, r31
    332a:	cf 01       	movw	r24, r30
    332c:	88 0f       	add	r24, r24
    332e:	99 1f       	adc	r25, r25
    3330:	88 0f       	add	r24, r24
    3332:	99 1f       	adc	r25, r25
    3334:	e8 0f       	add	r30, r24
    3336:	f9 1f       	adc	r31, r25
    3338:	e2 5e       	subi	r30, 0xE2	; 226
    333a:	fb 4f       	sbci	r31, 0xFB	; 251
    333c:	87 a1       	ldd	r24, Z+39	; 0x27
    333e:	88 23       	and	r24, r24
    3340:	09 f4       	brne	.+2      	; 0x3344 <updateDisplayChangeValues+0x76a>
    3342:	eb c2       	rjmp	.+1494   	; 0x391a <updateDisplayChangeValues+0xd40>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "slow");
        }
        if(motor[i].decay == DECAY_MODE_FAST){
    3344:	ef 2d       	mov	r30, r15
    3346:	fe 2d       	mov	r31, r14
    3348:	ee 0f       	add	r30, r30
    334a:	ff 1f       	adc	r31, r31
    334c:	ee 0f       	add	r30, r30
    334e:	ff 1f       	adc	r31, r31
    3350:	ee 0f       	add	r30, r30
    3352:	ff 1f       	adc	r31, r31
    3354:	cf 01       	movw	r24, r30
    3356:	88 0f       	add	r24, r24
    3358:	99 1f       	adc	r25, r25
    335a:	88 0f       	add	r24, r24
    335c:	99 1f       	adc	r25, r25
    335e:	e8 0f       	add	r30, r24
    3360:	f9 1f       	adc	r31, r25
    3362:	e2 5e       	subi	r30, 0xE2	; 226
    3364:	fb 4f       	sbci	r31, 0xFB	; 251
    3366:	87 a1       	ldd	r24, Z+39	; 0x27
    3368:	81 30       	cpi	r24, 0x01	; 1
    336a:	09 f4       	brne	.+2      	; 0x336e <updateDisplayChangeValues+0x794>
    336c:	25 c4       	rjmp	.+2122   	; 0x3bb8 <updateDisplayChangeValues+0xfde>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "fast");
        }
        if(motor[i].decay == DECAY_MODE_MIXED){
    336e:	ef 2d       	mov	r30, r15
    3370:	fe 2d       	mov	r31, r14
    3372:	ee 0f       	add	r30, r30
    3374:	ff 1f       	adc	r31, r31
    3376:	ee 0f       	add	r30, r30
    3378:	ff 1f       	adc	r31, r31
    337a:	ee 0f       	add	r30, r30
    337c:	ff 1f       	adc	r31, r31
    337e:	cf 01       	movw	r24, r30
    3380:	88 0f       	add	r24, r24
    3382:	99 1f       	adc	r25, r25
    3384:	88 0f       	add	r24, r24
    3386:	99 1f       	adc	r25, r25
    3388:	e8 0f       	add	r30, r24
    338a:	f9 1f       	adc	r31, r25
    338c:	e2 5e       	subi	r30, 0xE2	; 226
    338e:	fb 4f       	sbci	r31, 0xFB	; 251
    3390:	87 a1       	ldd	r24, Z+39	; 0x27
    3392:	82 30       	cpi	r24, 0x02	; 2
    3394:	09 f4       	brne	.+2      	; 0x3398 <updateDisplayChangeValues+0x7be>
    3396:	df c3       	rjmp	.+1982   	; 0x3b56 <updateDisplayChangeValues+0xf7c>
          sprintf(menu.newDisplayValue[i], "%c%s", c, "mixed");
    3398:	21 96       	adiw	r28, 0x01	; 1
    339a:	0e 5f       	subi	r16, 0xFE	; 254
    339c:	1f 4f       	sbci	r17, 0xFF	; 255
        sprintf(menu.newDisplayValue[i], "%c%.0f", c, motor[i].stepsPerFullRotation);
      }
      break;

    case MENU_SET_DECAY_MODE:
      for(i = 0; i <= MAX_MOTOR; i++){
    339e:	c4 30       	cpi	r28, 0x04	; 4
    33a0:	d1 05       	cpc	r29, r1
    33a2:	09 f0       	breq	.+2      	; 0x33a6 <updateDisplayChangeValues+0x7cc>
    33a4:	ab cf       	rjmp	.-170    	; 0x32fc <updateDisplayChangeValues+0x722>
    33a6:	83 cc       	rjmp	.-1786   	; 0x2cae <updateDisplayChangeValues+0xd4>
        }
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
    33a8:	c0 e0       	ldi	r28, 0x00	; 0
    33aa:	d0 e0       	ldi	r29, 0x00	; 0
    33ac:	05 e7       	ldi	r16, 0x75	; 117
    33ae:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    33b0:	80 91 13 03 	lds	r24, 0x0313
    33b4:	9e 01       	movw	r18, r28
    33b6:	90 e0       	ldi	r25, 0x00	; 0
    33b8:	0c 2e       	mov	r0, r28
    33ba:	02 c0       	rjmp	.+4      	; 0x33c0 <updateDisplayChangeValues+0x7e6>
    33bc:	95 95       	asr	r25
    33be:	87 95       	ror	r24
    33c0:	0a 94       	dec	r0
    33c2:	e2 f7       	brpl	.-8      	; 0x33bc <updateDisplayChangeValues+0x7e2>
    33c4:	80 fd       	sbrc	r24, 0
    33c6:	94 c2       	rjmp	.+1320   	; 0x38f0 <updateDisplayChangeValues+0xd16>
    33c8:	40 e2       	ldi	r20, 0x20	; 32
    33ca:	50 e0       	ldi	r21, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
    33cc:	a0 91 16 03 	lds	r26, 0x0316
    33d0:	b0 91 17 03 	lds	r27, 0x0317
    33d4:	f9 01       	movw	r30, r18
    33d6:	ee 0f       	add	r30, r30
    33d8:	ff 1f       	adc	r31, r31
    33da:	ee 0f       	add	r30, r30
    33dc:	ff 1f       	adc	r31, r31
    33de:	ee 0f       	add	r30, r30
    33e0:	ff 1f       	adc	r31, r31
    33e2:	cf 01       	movw	r24, r30
    33e4:	88 0f       	add	r24, r24
    33e6:	99 1f       	adc	r25, r25
    33e8:	88 0f       	add	r24, r24
    33ea:	99 1f       	adc	r25, r25
    33ec:	e8 0f       	add	r30, r24
    33ee:	f9 1f       	adc	r31, r25
    33f0:	e2 5e       	subi	r30, 0xE2	; 226
    33f2:	fb 4f       	sbci	r31, 0xFB	; 251
    33f4:	26 8d       	ldd	r18, Z+30	; 0x1e
    33f6:	37 8d       	ldd	r19, Z+31	; 0x1f
    33f8:	8d b7       	in	r24, 0x3d	; 61
    33fa:	9e b7       	in	r25, 0x3e	; 62
    33fc:	08 97       	sbiw	r24, 0x08	; 8
    33fe:	0f b6       	in	r0, 0x3f	; 63
    3400:	f8 94       	cli
    3402:	9e bf       	out	0x3e, r25	; 62
    3404:	0f be       	out	0x3f, r0	; 63
    3406:	8d bf       	out	0x3d, r24	; 61
    3408:	ed b7       	in	r30, 0x3d	; 61
    340a:	fe b7       	in	r31, 0x3e	; 62
    340c:	31 96       	adiw	r30, 0x01	; 1
    340e:	ce 01       	movw	r24, r28
    3410:	88 0f       	add	r24, r24
    3412:	99 1f       	adc	r25, r25
    3414:	a8 0f       	add	r26, r24
    3416:	b9 1f       	adc	r27, r25
    3418:	8d 91       	ld	r24, X+
    341a:	9c 91       	ld	r25, X
    341c:	ad b7       	in	r26, 0x3d	; 61
    341e:	be b7       	in	r27, 0x3e	; 62
    3420:	12 96       	adiw	r26, 0x02	; 2
    3422:	9c 93       	st	X, r25
    3424:	8e 93       	st	-X, r24
    3426:	11 97       	sbiw	r26, 0x01	; 1
    3428:	13 83       	std	Z+3, r17	; 0x03
    342a:	02 83       	std	Z+2, r16	; 0x02
    342c:	55 83       	std	Z+5, r21	; 0x05
    342e:	44 83       	std	Z+4, r20	; 0x04
    3430:	37 83       	std	Z+7, r19	; 0x07
    3432:	26 83       	std	Z+6, r18	; 0x06
    3434:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3438:	21 96       	adiw	r28, 0x01	; 1
        }
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
    343a:	ed b7       	in	r30, 0x3d	; 61
    343c:	fe b7       	in	r31, 0x3e	; 62
    343e:	38 96       	adiw	r30, 0x08	; 8
    3440:	0f b6       	in	r0, 0x3f	; 63
    3442:	f8 94       	cli
    3444:	fe bf       	out	0x3e, r31	; 62
    3446:	0f be       	out	0x3f, r0	; 63
    3448:	ed bf       	out	0x3d, r30	; 61
    344a:	c4 30       	cpi	r28, 0x04	; 4
    344c:	d1 05       	cpc	r29, r1
    344e:	09 f0       	breq	.+2      	; 0x3452 <updateDisplayChangeValues+0x878>
    3450:	af cf       	rjmp	.-162    	; 0x33b0 <updateDisplayChangeValues+0x7d6>
    3452:	2d cc       	rjmp	.-1958   	; 0x2cae <updateDisplayChangeValues+0xd4>
      }
      break;

    case MENU_SAVE_CONFIG:
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Save all");
    3454:	e0 91 16 03 	lds	r30, 0x0316
    3458:	f0 91 17 03 	lds	r31, 0x0317
    345c:	20 81       	ld	r18, Z
    345e:	31 81       	ldd	r19, Z+1	; 0x01
    3460:	c9 01       	movw	r24, r18
    3462:	dc 01       	movw	r26, r24
    3464:	ee e9       	ldi	r30, 0x9E	; 158
    3466:	f1 e0       	ldi	r31, 0x01	; 1
    3468:	89 e0       	ldi	r24, 0x09	; 9
    346a:	01 90       	ld	r0, Z+
    346c:	0d 92       	st	X+, r0
    346e:	81 50       	subi	r24, 0x01	; 1
    3470:	e1 f7       	brne	.-8      	; 0x346a <updateDisplayChangeValues+0x890>
      sprintf(menu.newDisplayValue[1], " current");
    3472:	e0 91 16 03 	lds	r30, 0x0316
    3476:	f0 91 17 03 	lds	r31, 0x0317
    347a:	22 81       	ldd	r18, Z+2	; 0x02
    347c:	33 81       	ldd	r19, Z+3	; 0x03
    347e:	c9 01       	movw	r24, r18
    3480:	dc 01       	movw	r26, r24
    3482:	e7 ea       	ldi	r30, 0xA7	; 167
    3484:	f1 e0       	ldi	r31, 0x01	; 1
    3486:	89 e0       	ldi	r24, 0x09	; 9
    3488:	01 90       	ld	r0, Z+
    348a:	0d 92       	st	X+, r0
    348c:	81 50       	subi	r24, 0x01	; 1
    348e:	e1 f7       	brne	.-8      	; 0x3488 <updateDisplayChangeValues+0x8ae>
      sprintf(menu.newDisplayValue[2], "configur");
    3490:	e0 91 16 03 	lds	r30, 0x0316
    3494:	f0 91 17 03 	lds	r31, 0x0317
    3498:	24 81       	ldd	r18, Z+4	; 0x04
    349a:	35 81       	ldd	r19, Z+5	; 0x05
    349c:	c9 01       	movw	r24, r18
    349e:	dc 01       	movw	r26, r24
    34a0:	e0 eb       	ldi	r30, 0xB0	; 176
    34a2:	f1 e0       	ldi	r31, 0x01	; 1
    34a4:	89 e0       	ldi	r24, 0x09	; 9
    34a6:	01 90       	ld	r0, Z+
    34a8:	0d 92       	st	X+, r0
    34aa:	81 50       	subi	r24, 0x01	; 1
    34ac:	e1 f7       	brne	.-8      	; 0x34a6 <updateDisplayChangeValues+0x8cc>
      sprintf(menu.newDisplayValue[3], "ations  ");
    34ae:	e0 91 16 03 	lds	r30, 0x0316
    34b2:	f0 91 17 03 	lds	r31, 0x0317
    34b6:	26 81       	ldd	r18, Z+6	; 0x06
    34b8:	37 81       	ldd	r19, Z+7	; 0x07
    34ba:	c9 01       	movw	r24, r18
    34bc:	dc 01       	movw	r26, r24
    34be:	e9 eb       	ldi	r30, 0xB9	; 185
    34c0:	f1 e0       	ldi	r31, 0x01	; 1
    34c2:	89 e0       	ldi	r24, 0x09	; 9
    34c4:	01 90       	ld	r0, Z+
    34c6:	0d 92       	st	X+, r0
    34c8:	81 50       	subi	r24, 0x01	; 1
    34ca:	e1 f7       	brne	.-8      	; 0x34c4 <updateDisplayChangeValues+0x8ea>
    34cc:	f0 cb       	rjmp	.-2080   	; 0x2cae <updateDisplayChangeValues+0xd4>
      /* select the dummy motor */
      sprintf(menu.newDisplayValue[0], "Load all");
      sprintf(menu.newDisplayValue[1], " saved  ");
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;
    34ce:	c0 e0       	ldi	r28, 0x00	; 0
    34d0:	d0 e0       	ldi	r29, 0x00	; 0
    34d2:	04 e4       	ldi	r16, 0x44	; 68
    34d4:	11 e0       	ldi	r17, 0x01	; 1

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    34d6:	80 91 13 03 	lds	r24, 0x0313
    34da:	9e 01       	movw	r18, r28
    34dc:	90 e0       	ldi	r25, 0x00	; 0
    34de:	0c 2e       	mov	r0, r28
    34e0:	02 c0       	rjmp	.+4      	; 0x34e6 <updateDisplayChangeValues+0x90c>
    34e2:	95 95       	asr	r25
    34e4:	87 95       	ror	r24
    34e6:	0a 94       	dec	r0
    34e8:	e2 f7       	brpl	.-8      	; 0x34e2 <updateDisplayChangeValues+0x908>
    34ea:	80 fd       	sbrc	r24, 0
    34ec:	99 c1       	rjmp	.+818    	; 0x3820 <updateDisplayChangeValues+0xc46>
    34ee:	40 e2       	ldi	r20, 0x20	; 32
    34f0:	50 e0       	ldi	r21, 0x00	; 0
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].opticalZeroPosition);
    34f2:	a0 91 16 03 	lds	r26, 0x0316
    34f6:	b0 91 17 03 	lds	r27, 0x0317
    34fa:	c9 01       	movw	r24, r18
    34fc:	f9 01       	movw	r30, r18
    34fe:	ee 0f       	add	r30, r30
    3500:	ff 1f       	adc	r31, r31
    3502:	ee 0f       	add	r30, r30
    3504:	ff 1f       	adc	r31, r31
    3506:	ee 0f       	add	r30, r30
    3508:	ff 1f       	adc	r31, r31
    350a:	88 0f       	add	r24, r24
    350c:	99 1f       	adc	r25, r25
    350e:	e8 0f       	add	r30, r24
    3510:	f9 1f       	adc	r31, r25
    3512:	ee 0f       	add	r30, r30
    3514:	ff 1f       	adc	r31, r31
    3516:	ee 0f       	add	r30, r30
    3518:	ff 1f       	adc	r31, r31
    351a:	ee 5d       	subi	r30, 0xDE	; 222
    351c:	fb 4f       	sbci	r31, 0xFB	; 251
    351e:	20 81       	ld	r18, Z
    3520:	31 81       	ldd	r19, Z+1	; 0x01
    3522:	8d b7       	in	r24, 0x3d	; 61
    3524:	9e b7       	in	r25, 0x3e	; 62
    3526:	08 97       	sbiw	r24, 0x08	; 8
    3528:	0f b6       	in	r0, 0x3f	; 63
    352a:	f8 94       	cli
    352c:	9e bf       	out	0x3e, r25	; 62
    352e:	0f be       	out	0x3f, r0	; 63
    3530:	8d bf       	out	0x3d, r24	; 61
    3532:	ed b7       	in	r30, 0x3d	; 61
    3534:	fe b7       	in	r31, 0x3e	; 62
    3536:	31 96       	adiw	r30, 0x01	; 1
    3538:	ce 01       	movw	r24, r28
    353a:	88 0f       	add	r24, r24
    353c:	99 1f       	adc	r25, r25
    353e:	a8 0f       	add	r26, r24
    3540:	b9 1f       	adc	r27, r25
    3542:	8d 91       	ld	r24, X+
    3544:	9c 91       	ld	r25, X
    3546:	ad b7       	in	r26, 0x3d	; 61
    3548:	be b7       	in	r27, 0x3e	; 62
    354a:	12 96       	adiw	r26, 0x02	; 2
    354c:	9c 93       	st	X, r25
    354e:	8e 93       	st	-X, r24
    3550:	11 97       	sbiw	r26, 0x01	; 1
    3552:	13 83       	std	Z+3, r17	; 0x03
    3554:	02 83       	std	Z+2, r16	; 0x02
    3556:	55 83       	std	Z+5, r21	; 0x05
    3558:	44 83       	std	Z+4, r20	; 0x04
    355a:	37 83       	std	Z+7, r19	; 0x07
    355c:	26 83       	std	Z+6, r18	; 0x06
    355e:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3562:	21 96       	adiw	r28, 0x01	; 1
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
    3564:	ed b7       	in	r30, 0x3d	; 61
    3566:	fe b7       	in	r31, 0x3e	; 62
    3568:	38 96       	adiw	r30, 0x08	; 8
    356a:	0f b6       	in	r0, 0x3f	; 63
    356c:	f8 94       	cli
    356e:	fe bf       	out	0x3e, r31	; 62
    3570:	0f be       	out	0x3f, r0	; 63
    3572:	ed bf       	out	0x3d, r30	; 61
    3574:	c4 30       	cpi	r28, 0x04	; 4
    3576:	d1 05       	cpc	r29, r1
    3578:	09 f0       	breq	.+2      	; 0x357c <updateDisplayChangeValues+0x9a2>
    357a:	ad cf       	rjmp	.-166    	; 0x34d6 <updateDisplayChangeValues+0x8fc>
    357c:	98 cb       	rjmp	.-2256   	; 0x2cae <updateDisplayChangeValues+0xd4>
        sprintf(menu.newDisplayValue[i], "%c%d ms", c, motor[i].waitBetweenSteps);
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
    357e:	40 e0       	ldi	r20, 0x00	; 0
    3580:	50 e0       	ldi	r21, 0x00	; 0
    3582:	00 e0       	ldi	r16, 0x00	; 0
    3584:	10 e0       	ldi	r17, 0x00	; 0
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          sprintf(menu.newDisplayValue[i], "%cMot %d", c, i+1);
    3586:	7e e8       	ldi	r23, 0x8E	; 142
    3588:	e7 2e       	mov	r14, r23
    358a:	71 e0       	ldi	r23, 0x01	; 1
    358c:	f7 2e       	mov	r15, r23
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    358e:	80 91 13 03 	lds	r24, 0x0313
    3592:	90 e0       	ldi	r25, 0x00	; 0
    3594:	04 2e       	mov	r0, r20
    3596:	02 c0       	rjmp	.+4      	; 0x359c <updateDisplayChangeValues+0x9c2>
    3598:	95 95       	asr	r25
    359a:	87 95       	ror	r24
    359c:	0a 94       	dec	r0
    359e:	e2 f7       	brpl	.-8      	; 0x3598 <updateDisplayChangeValues+0x9be>
    35a0:	80 fd       	sbrc	r24, 0
    35a2:	96 c1       	rjmp	.+812    	; 0x38d0 <updateDisplayChangeValues+0xcf6>
    35a4:	20 e2       	ldi	r18, 0x20	; 32
        if(forbiddenZone[i].active){
    35a6:	fa 01       	movw	r30, r20
    35a8:	ee 0f       	add	r30, r30
    35aa:	ff 1f       	adc	r31, r31
    35ac:	ee 0f       	add	r30, r30
    35ae:	ff 1f       	adc	r31, r31
    35b0:	e4 0f       	add	r30, r20
    35b2:	f5 1f       	adc	r31, r21
    35b4:	ef 5f       	subi	r30, 0xFF	; 255
    35b6:	fb 4f       	sbci	r31, 0xFB	; 251
    35b8:	84 81       	ldd	r24, Z+4	; 0x04
    35ba:	88 23       	and	r24, r24
    35bc:	09 f4       	brne	.+2      	; 0x35c0 <updateDisplayChangeValues+0x9e6>
    35be:	4e c1       	rjmp	.+668    	; 0x385c <updateDisplayChangeValues+0xc82>
          sprintf(menu.newDisplayValue[i], "ForbZone");
    35c0:	e0 91 16 03 	lds	r30, 0x0316
    35c4:	f0 91 17 03 	lds	r31, 0x0317
    35c8:	e0 0f       	add	r30, r16
    35ca:	f1 1f       	adc	r31, r17
    35cc:	20 81       	ld	r18, Z
    35ce:	31 81       	ldd	r19, Z+1	; 0x01
    35d0:	c9 01       	movw	r24, r18
    35d2:	dc 01       	movw	r26, r24
    35d4:	e5 e8       	ldi	r30, 0x85	; 133
    35d6:	f1 e0       	ldi	r31, 0x01	; 1
    35d8:	89 e0       	ldi	r24, 0x09	; 9
    35da:	01 90       	ld	r0, Z+
    35dc:	0d 92       	st	X+, r0
    35de:	81 50       	subi	r24, 0x01	; 1
    35e0:	e1 f7       	brne	.-8      	; 0x35da <updateDisplayChangeValues+0xa00>
    35e2:	ea 01       	movw	r28, r20
    35e4:	21 96       	adiw	r28, 0x01	; 1
    35e6:	6c c1       	rjmp	.+728    	; 0x38c0 <updateDisplayChangeValues+0xce6>
      sprintf(menu.newDisplayValue[2], "configur");
      sprintf(menu.newDisplayValue[3], "ations  ");
      break;

    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
    35e8:	c0 e0       	ldi	r28, 0x00	; 0
    35ea:	d0 e0       	ldi	r29, 0x00	; 0
    35ec:	ee 24       	eor	r14, r14
    35ee:	ff 24       	eor	r15, r15
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    35f0:	90 ee       	ldi	r25, 0xE0	; 224
    35f2:	a9 2e       	mov	r10, r25
    35f4:	91 e0       	ldi	r25, 0x01	; 1
    35f6:	b9 2e       	mov	r11, r25
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
    35f8:	8b ed       	ldi	r24, 0xDB	; 219
    35fa:	88 2e       	mov	r8, r24
    35fc:	81 e0       	ldi	r24, 0x01	; 1
    35fe:	98 2e       	mov	r9, r24
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
    3600:	04 ed       	ldi	r16, 0xD4	; 212
    3602:	60 2e       	mov	r6, r16
    3604:	01 e0       	ldi	r16, 0x01	; 1
    3606:	70 2e       	mov	r7, r16
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3608:	80 91 13 03 	lds	r24, 0x0313
    360c:	90 e0       	ldi	r25, 0x00	; 0
    360e:	0c 2e       	mov	r0, r28
    3610:	02 c0       	rjmp	.+4      	; 0x3616 <updateDisplayChangeValues+0xa3c>
    3612:	95 95       	asr	r25
    3614:	87 95       	ror	r24
    3616:	0a 94       	dec	r0
    3618:	e2 f7       	brpl	.-8      	; 0x3612 <updateDisplayChangeValues+0xa38>
    361a:	80 fd       	sbrc	r24, 0
    361c:	5b c1       	rjmp	.+694    	; 0x38d4 <updateDisplayChangeValues+0xcfa>
    361e:	10 e2       	ldi	r17, 0x20	; 32
    3620:	d1 2e       	mov	r13, r17
        if(forbiddenZone[i].active){
    3622:	fe 01       	movw	r30, r28
    3624:	ee 0f       	add	r30, r30
    3626:	ff 1f       	adc	r31, r31
    3628:	ee 0f       	add	r30, r30
    362a:	ff 1f       	adc	r31, r31
    362c:	ec 0f       	add	r30, r28
    362e:	fd 1f       	adc	r31, r29
    3630:	ef 5f       	subi	r30, 0xFF	; 255
    3632:	fb 4f       	sbci	r31, 0xFB	; 251
    3634:	84 81       	ldd	r24, Z+4	; 0x04
    3636:	88 23       	and	r24, r24
    3638:	09 f0       	breq	.+2      	; 0x363c <updateDisplayChangeValues+0xa62>
    363a:	5d c1       	rjmp	.+698    	; 0x38f6 <updateDisplayChangeValues+0xd1c>
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
    363c:	8e 01       	movw	r16, r28
    363e:	00 0f       	add	r16, r16
    3640:	11 1f       	adc	r17, r17
    3642:	00 0f       	add	r16, r16
    3644:	11 1f       	adc	r17, r17
    3646:	00 0f       	add	r16, r16
    3648:	11 1f       	adc	r17, r17
    364a:	f8 01       	movw	r30, r16
    364c:	ee 0f       	add	r30, r30
    364e:	ff 1f       	adc	r31, r31
    3650:	ee 0f       	add	r30, r30
    3652:	ff 1f       	adc	r31, r31
    3654:	e0 0f       	add	r30, r16
    3656:	f1 1f       	adc	r31, r17
    3658:	e2 5e       	subi	r30, 0xE2	; 226
    365a:	fb 4f       	sbci	r31, 0xFB	; 251
    365c:	82 a1       	ldd	r24, Z+34	; 0x22
    365e:	88 23       	and	r24, r24
    3660:	09 f4       	brne	.+2      	; 0x3664 <updateDisplayChangeValues+0xa8a>
    3662:	52 c2       	rjmp	.+1188   	; 0x3b08 <updateDisplayChangeValues+0xf2e>
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
    3664:	f8 01       	movw	r30, r16
    3666:	ee 0f       	add	r30, r30
    3668:	ff 1f       	adc	r31, r31
    366a:	ee 0f       	add	r30, r30
    366c:	ff 1f       	adc	r31, r31
    366e:	e0 0f       	add	r30, r16
    3670:	f1 1f       	adc	r31, r17
    3672:	e2 5e       	subi	r30, 0xE2	; 226
    3674:	fb 4f       	sbci	r31, 0xFB	; 251
    3676:	82 a1       	ldd	r24, Z+34	; 0x22
    3678:	81 30       	cpi	r24, 0x01	; 1
    367a:	09 f4       	brne	.+2      	; 0x367e <updateDisplayChangeValues+0xaa4>
    367c:	57 c3       	rjmp	.+1710   	; 0x3d2c <updateDisplayChangeValues+0x1152>
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
    367e:	f8 01       	movw	r30, r16
    3680:	ee 0f       	add	r30, r30
    3682:	ff 1f       	adc	r31, r31
    3684:	ee 0f       	add	r30, r30
    3686:	ff 1f       	adc	r31, r31
    3688:	e0 0f       	add	r30, r16
    368a:	f1 1f       	adc	r31, r17
    368c:	e2 5e       	subi	r30, 0xE2	; 226
    368e:	fb 4f       	sbci	r31, 0xFB	; 251
    3690:	82 a1       	ldd	r24, Z+34	; 0x22
    3692:	82 30       	cpi	r24, 0x02	; 2
    3694:	09 f4       	brne	.+2      	; 0x3698 <updateDisplayChangeValues+0xabe>
    3696:	23 c3       	rjmp	.+1606   	; 0x3cde <updateDisplayChangeValues+0x1104>
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    3698:	21 96       	adiw	r28, 0x01	; 1
    369a:	82 e0       	ldi	r24, 0x02	; 2
    369c:	90 e0       	ldi	r25, 0x00	; 0
    369e:	e8 0e       	add	r14, r24
    36a0:	f9 1e       	adc	r15, r25
        sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].opticalZeroPosition);
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
    36a2:	c4 30       	cpi	r28, 0x04	; 4
    36a4:	d1 05       	cpc	r29, r1
    36a6:	09 f0       	breq	.+2      	; 0x36aa <updateDisplayChangeValues+0xad0>
    36a8:	af cf       	rjmp	.-162    	; 0x3608 <updateDisplayChangeValues+0xa2e>
    36aa:	01 cb       	rjmp	.-2558   	; 0x2cae <updateDisplayChangeValues+0xd4>
        sprintf(menu.newDisplayValue[i], "%c%.1f A", c, motor[i].current);
      }
      break;
      
    case MENU_SET_GEAR_RATIO:
      for(i = 0; i <= MAX_MOTOR; i++){
    36ac:	c0 e0       	ldi	r28, 0x00	; 0
    36ae:	d0 e0       	ldi	r29, 0x00	; 0
    36b0:	07 e9       	ldi	r16, 0x97	; 151
    36b2:	11 e0       	ldi	r17, 0x01	; 1
      
    case MENU_SET_FULL_ROTATION:
      for(i = 0; i <= MAX_MOTOR; i++){
        //c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
    36b4:	80 91 13 03 	lds	r24, 0x0313
    36b8:	9e 01       	movw	r18, r28
    36ba:	90 e0       	ldi	r25, 0x00	; 0
    36bc:	0c 2e       	mov	r0, r28
    36be:	02 c0       	rjmp	.+4      	; 0x36c4 <updateDisplayChangeValues+0xaea>
    36c0:	95 95       	asr	r25
    36c2:	87 95       	ror	r24
    36c4:	0a 94       	dec	r0
    36c6:	e2 f7       	brpl	.-8      	; 0x36c0 <updateDisplayChangeValues+0xae6>
    36c8:	80 fd       	sbrc	r24, 0
    36ca:	07 c1       	rjmp	.+526    	; 0x38da <updateDisplayChangeValues+0xd00>
    36cc:	60 e2       	ldi	r22, 0x20	; 32
    36ce:	70 e0       	ldi	r23, 0x00	; 0
          c = 0x7E;
          if(menu.fastMovingMode){
            c = 0x3E;
          }
        }
        sprintf(menu.newDisplayValue[i], "%c%.0f", c, motor[i].stepsPerFullRotation);
    36d0:	a0 91 16 03 	lds	r26, 0x0316
    36d4:	b0 91 17 03 	lds	r27, 0x0317
    36d8:	f9 01       	movw	r30, r18
    36da:	ee 0f       	add	r30, r30
    36dc:	ff 1f       	adc	r31, r31
    36de:	ee 0f       	add	r30, r30
    36e0:	ff 1f       	adc	r31, r31
    36e2:	ee 0f       	add	r30, r30
    36e4:	ff 1f       	adc	r31, r31
    36e6:	cf 01       	movw	r24, r30
    36e8:	88 0f       	add	r24, r24
    36ea:	99 1f       	adc	r25, r25
    36ec:	88 0f       	add	r24, r24
    36ee:	99 1f       	adc	r25, r25
    36f0:	e8 0f       	add	r30, r24
    36f2:	f9 1f       	adc	r31, r25
    36f4:	e2 5e       	subi	r30, 0xE2	; 226
    36f6:	fb 4f       	sbci	r31, 0xFB	; 251
    36f8:	21 89       	ldd	r18, Z+17	; 0x11
    36fa:	32 89       	ldd	r19, Z+18	; 0x12
    36fc:	43 89       	ldd	r20, Z+19	; 0x13
    36fe:	54 89       	ldd	r21, Z+20	; 0x14
    3700:	8d b7       	in	r24, 0x3d	; 61
    3702:	9e b7       	in	r25, 0x3e	; 62
    3704:	0a 97       	sbiw	r24, 0x0a	; 10
    3706:	0f b6       	in	r0, 0x3f	; 63
    3708:	f8 94       	cli
    370a:	9e bf       	out	0x3e, r25	; 62
    370c:	0f be       	out	0x3f, r0	; 63
    370e:	8d bf       	out	0x3d, r24	; 61
    3710:	ed b7       	in	r30, 0x3d	; 61
    3712:	fe b7       	in	r31, 0x3e	; 62
    3714:	31 96       	adiw	r30, 0x01	; 1
    3716:	ce 01       	movw	r24, r28
    3718:	88 0f       	add	r24, r24
    371a:	99 1f       	adc	r25, r25
    371c:	a8 0f       	add	r26, r24
    371e:	b9 1f       	adc	r27, r25
    3720:	8d 91       	ld	r24, X+
    3722:	9c 91       	ld	r25, X
    3724:	ad b7       	in	r26, 0x3d	; 61
    3726:	be b7       	in	r27, 0x3e	; 62
    3728:	12 96       	adiw	r26, 0x02	; 2
    372a:	9c 93       	st	X, r25
    372c:	8e 93       	st	-X, r24
    372e:	11 97       	sbiw	r26, 0x01	; 1
    3730:	13 83       	std	Z+3, r17	; 0x03
    3732:	02 83       	std	Z+2, r16	; 0x02
    3734:	75 83       	std	Z+5, r23	; 0x05
    3736:	64 83       	std	Z+4, r22	; 0x04
    3738:	26 83       	std	Z+6, r18	; 0x06
    373a:	37 83       	std	Z+7, r19	; 0x07
    373c:	40 87       	std	Z+8, r20	; 0x08
    373e:	51 87       	std	Z+9, r21	; 0x09
    3740:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3744:	21 96       	adiw	r28, 0x01	; 1
        sprintf(menu.newDisplayValue[i], "%c%.3f", c, motor[i].gearRatio);
      }
      break;
      
    case MENU_SET_FULL_ROTATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    3746:	ed b7       	in	r30, 0x3d	; 61
    3748:	fe b7       	in	r31, 0x3e	; 62
    374a:	3a 96       	adiw	r30, 0x0a	; 10
    374c:	0f b6       	in	r0, 0x3f	; 63
    374e:	f8 94       	cli
    3750:	fe bf       	out	0x3e, r31	; 62
    3752:	0f be       	out	0x3f, r0	; 63
    3754:	ed bf       	out	0x3d, r30	; 61
    3756:	c4 30       	cpi	r28, 0x04	; 4
    3758:	d1 05       	cpc	r29, r1
    375a:	09 f0       	breq	.+2      	; 0x375e <updateDisplayChangeValues+0xb84>
    375c:	ab cf       	rjmp	.-170    	; 0x36b4 <updateDisplayChangeValues+0xada>
    375e:	a7 ca       	rjmp	.-2738   	; 0x2cae <updateDisplayChangeValues+0xd4>
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    3760:	c0 e0       	ldi	r28, 0x00	; 0
    3762:	d0 e0       	ldi	r29, 0x00	; 0
    3764:	07 e9       	ldi	r16, 0x97	; 151
    3766:	11 e0       	ldi	r17, 0x01	; 1
      }
      break;

    case MENU_CHANGE_SUBSTEPS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3768:	80 91 13 03 	lds	r24, 0x0313
    376c:	9e 01       	movw	r18, r28
    376e:	90 e0       	ldi	r25, 0x00	; 0
    3770:	0c 2e       	mov	r0, r28
    3772:	02 c0       	rjmp	.+4      	; 0x3778 <updateDisplayChangeValues+0xb9e>
    3774:	95 95       	asr	r25
    3776:	87 95       	ror	r24
    3778:	0a 94       	dec	r0
    377a:	e2 f7       	brpl	.-8      	; 0x3774 <updateDisplayChangeValues+0xb9a>
    377c:	80 fd       	sbrc	r24, 0
    377e:	4d c0       	rjmp	.+154    	; 0x381a <updateDisplayChangeValues+0xc40>
    3780:	60 e2       	ldi	r22, 0x20	; 32
    3782:	70 e0       	ldi	r23, 0x00	; 0
        sprintf(menu.newDisplayValue[i], "%c%.0f", c, motor[i].subSteps);
    3784:	a0 91 16 03 	lds	r26, 0x0316
    3788:	b0 91 17 03 	lds	r27, 0x0317
    378c:	f9 01       	movw	r30, r18
    378e:	ee 0f       	add	r30, r30
    3790:	ff 1f       	adc	r31, r31
    3792:	ee 0f       	add	r30, r30
    3794:	ff 1f       	adc	r31, r31
    3796:	ee 0f       	add	r30, r30
    3798:	ff 1f       	adc	r31, r31
    379a:	cf 01       	movw	r24, r30
    379c:	88 0f       	add	r24, r24
    379e:	99 1f       	adc	r25, r25
    37a0:	88 0f       	add	r24, r24
    37a2:	99 1f       	adc	r25, r25
    37a4:	e8 0f       	add	r30, r24
    37a6:	f9 1f       	adc	r31, r25
    37a8:	e2 5e       	subi	r30, 0xE2	; 226
    37aa:	fb 4f       	sbci	r31, 0xFB	; 251
    37ac:	25 89       	ldd	r18, Z+21	; 0x15
    37ae:	36 89       	ldd	r19, Z+22	; 0x16
    37b0:	47 89       	ldd	r20, Z+23	; 0x17
    37b2:	50 8d       	ldd	r21, Z+24	; 0x18
    37b4:	8d b7       	in	r24, 0x3d	; 61
    37b6:	9e b7       	in	r25, 0x3e	; 62
    37b8:	0a 97       	sbiw	r24, 0x0a	; 10
    37ba:	0f b6       	in	r0, 0x3f	; 63
    37bc:	f8 94       	cli
    37be:	9e bf       	out	0x3e, r25	; 62
    37c0:	0f be       	out	0x3f, r0	; 63
    37c2:	8d bf       	out	0x3d, r24	; 61
    37c4:	ed b7       	in	r30, 0x3d	; 61
    37c6:	fe b7       	in	r31, 0x3e	; 62
    37c8:	31 96       	adiw	r30, 0x01	; 1
    37ca:	ce 01       	movw	r24, r28
    37cc:	88 0f       	add	r24, r24
    37ce:	99 1f       	adc	r25, r25
    37d0:	a8 0f       	add	r26, r24
    37d2:	b9 1f       	adc	r27, r25
    37d4:	8d 91       	ld	r24, X+
    37d6:	9c 91       	ld	r25, X
    37d8:	ad b7       	in	r26, 0x3d	; 61
    37da:	be b7       	in	r27, 0x3e	; 62
    37dc:	12 96       	adiw	r26, 0x02	; 2
    37de:	9c 93       	st	X, r25
    37e0:	8e 93       	st	-X, r24
    37e2:	11 97       	sbiw	r26, 0x01	; 1
    37e4:	13 83       	std	Z+3, r17	; 0x03
    37e6:	02 83       	std	Z+2, r16	; 0x02
    37e8:	75 83       	std	Z+5, r23	; 0x05
    37ea:	64 83       	std	Z+4, r22	; 0x04
    37ec:	26 83       	std	Z+6, r18	; 0x06
    37ee:	37 83       	std	Z+7, r19	; 0x07
    37f0:	40 87       	std	Z+8, r20	; 0x08
    37f2:	51 87       	std	Z+9, r21	; 0x09
    37f4:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    37f8:	21 96       	adiw	r28, 0x01	; 1
        }
      }
      break;

    case MENU_CHANGE_SUBSTEPS:
      for(i = 0; i <= MAX_MOTOR; i++){
    37fa:	ed b7       	in	r30, 0x3d	; 61
    37fc:	fe b7       	in	r31, 0x3e	; 62
    37fe:	3a 96       	adiw	r30, 0x0a	; 10
    3800:	0f b6       	in	r0, 0x3f	; 63
    3802:	f8 94       	cli
    3804:	fe bf       	out	0x3e, r31	; 62
    3806:	0f be       	out	0x3f, r0	; 63
    3808:	ed bf       	out	0x3d, r30	; 61
    380a:	c4 30       	cpi	r28, 0x04	; 4
    380c:	d1 05       	cpc	r29, r1
    380e:	09 f0       	breq	.+2      	; 0x3812 <updateDisplayChangeValues+0xc38>
    3810:	ab cf       	rjmp	.-170    	; 0x3768 <updateDisplayChangeValues+0xb8e>
    3812:	4d ca       	rjmp	.-2918   	; 0x2cae <updateDisplayChangeValues+0xd4>
      }
      break;

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3814:	ee e7       	ldi	r30, 0x7E	; 126
    3816:	de 2e       	mov	r13, r30
    3818:	0a cc       	rjmp	.-2028   	; 0x302e <updateDisplayChangeValues+0x454>
      }
      break;

    case MENU_CHANGE_SUBSTEPS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    381a:	6e e7       	ldi	r22, 0x7E	; 126
    381c:	70 e0       	ldi	r23, 0x00	; 0
    381e:	b2 cf       	rjmp	.-156    	; 0x3784 <updateDisplayChangeValues+0xbaa>
    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3820:	80 91 10 03 	lds	r24, 0x0310
    3824:	88 23       	and	r24, r24
    3826:	09 f4       	brne	.+2      	; 0x382a <updateDisplayChangeValues+0xc50>
    3828:	db c0       	rjmp	.+438    	; 0x39e0 <updateDisplayChangeValues+0xe06>
    382a:	4e e3       	ldi	r20, 0x3E	; 62
    382c:	50 e0       	ldi	r21, 0x00	; 0
    382e:	61 ce       	rjmp	.-830    	; 0x34f2 <updateDisplayChangeValues+0x918>
      for(i = 0; i <= MAX_MOTOR; i++){
        //c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3830:	80 91 10 03 	lds	r24, 0x0310
    3834:	88 23       	and	r24, r24
    3836:	09 f4       	brne	.+2      	; 0x383a <updateDisplayChangeValues+0xc60>
    3838:	61 c1       	rjmp	.+706    	; 0x3afc <updateDisplayChangeValues+0xf22>
    383a:	6e e3       	ldi	r22, 0x3E	; 62
    383c:	70 e0       	ldi	r23, 0x00	; 0
    383e:	50 cc       	rjmp	.-1888   	; 0x30e0 <updateDisplayChangeValues+0x506>
      }
      break;

    case MENU_SET_DECAY_MODE:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3840:	8e e7       	ldi	r24, 0x7E	; 126
    3842:	d8 2e       	mov	r13, r24
    3844:	6a cd       	rjmp	.-1324   	; 0x331a <updateDisplayChangeValues+0x740>
    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3846:	80 91 10 03 	lds	r24, 0x0310
    384a:	88 23       	and	r24, r24
    384c:	09 f4       	brne	.+2      	; 0x3850 <updateDisplayChangeValues+0xc76>
    384e:	0f c1       	rjmp	.+542    	; 0x3a6e <updateDisplayChangeValues+0xe94>
    3850:	5e e3       	ldi	r21, 0x3E	; 62
    3852:	d5 2e       	mov	r13, r21
    3854:	11 cb       	rjmp	.-2526   	; 0x2e78 <updateDisplayChangeValues+0x29e>
      }
      break;

    case MENU_SET_STEP_MULTIPL:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    3856:	6e e7       	ldi	r22, 0x7E	; 126
    3858:	70 e0       	ldi	r23, 0x00	; 0
    385a:	7e cb       	rjmp	.-2308   	; 0x2f58 <updateDisplayChangeValues+0x37e>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          sprintf(menu.newDisplayValue[i], "%cMot %d", c, i+1);
    385c:	e0 91 16 03 	lds	r30, 0x0316
    3860:	f0 91 17 03 	lds	r31, 0x0317
    3864:	8d b7       	in	r24, 0x3d	; 61
    3866:	9e b7       	in	r25, 0x3e	; 62
    3868:	08 97       	sbiw	r24, 0x08	; 8
    386a:	0f b6       	in	r0, 0x3f	; 63
    386c:	f8 94       	cli
    386e:	9e bf       	out	0x3e, r25	; 62
    3870:	0f be       	out	0x3f, r0	; 63
    3872:	8d bf       	out	0x3d, r24	; 61
    3874:	ad b7       	in	r26, 0x3d	; 61
    3876:	be b7       	in	r27, 0x3e	; 62
    3878:	11 96       	adiw	r26, 0x01	; 1
    387a:	e0 0f       	add	r30, r16
    387c:	f1 1f       	adc	r31, r17
    387e:	80 81       	ld	r24, Z
    3880:	91 81       	ldd	r25, Z+1	; 0x01
    3882:	ed b7       	in	r30, 0x3d	; 61
    3884:	fe b7       	in	r31, 0x3e	; 62
    3886:	92 83       	std	Z+2, r25	; 0x02
    3888:	81 83       	std	Z+1, r24	; 0x01
    388a:	13 96       	adiw	r26, 0x03	; 3
    388c:	fc 92       	st	X, r15
    388e:	ee 92       	st	-X, r14
    3890:	12 97       	sbiw	r26, 0x02	; 2
    3892:	14 96       	adiw	r26, 0x04	; 4
    3894:	2c 93       	st	X, r18
    3896:	14 97       	sbiw	r26, 0x04	; 4
    3898:	15 96       	adiw	r26, 0x05	; 5
    389a:	1c 92       	st	X, r1
    389c:	15 97       	sbiw	r26, 0x05	; 5
    389e:	ea 01       	movw	r28, r20
    38a0:	21 96       	adiw	r28, 0x01	; 1
    38a2:	17 96       	adiw	r26, 0x07	; 7
    38a4:	dc 93       	st	X, r29
    38a6:	ce 93       	st	-X, r28
    38a8:	16 97       	sbiw	r26, 0x06	; 6
    38aa:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    38ae:	2d b7       	in	r18, 0x3d	; 61
    38b0:	3e b7       	in	r19, 0x3e	; 62
    38b2:	28 5f       	subi	r18, 0xF8	; 248
    38b4:	3f 4f       	sbci	r19, 0xFF	; 255
    38b6:	0f b6       	in	r0, 0x3f	; 63
    38b8:	f8 94       	cli
    38ba:	3e bf       	out	0x3e, r19	; 62
    38bc:	0f be       	out	0x3f, r0	; 63
    38be:	2d bf       	out	0x3d, r18	; 61
    38c0:	ae 01       	movw	r20, r28
    38c2:	0e 5f       	subi	r16, 0xFE	; 254
    38c4:	1f 4f       	sbci	r17, 0xFF	; 255
        sprintf(menu.newDisplayValue[i], "%c%.1fx", c, motor[i].stepMultiplier);
      }
      break;

    case MENU_RUN_ZERO_CALIBRATION:
      for(i = 0; i <= MAX_MOTOR; i++){
    38c6:	c4 30       	cpi	r28, 0x04	; 4
    38c8:	d1 05       	cpc	r29, r1
    38ca:	09 f0       	breq	.+2      	; 0x38ce <updateDisplayChangeValues+0xcf4>
    38cc:	60 ce       	rjmp	.-832    	; 0x358e <updateDisplayChangeValues+0x9b4>
    38ce:	ef c9       	rjmp	.-3106   	; 0x2cae <updateDisplayChangeValues+0xd4>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    38d0:	2e e7       	ldi	r18, 0x7E	; 126
    38d2:	69 ce       	rjmp	.-814    	; 0x35a6 <updateDisplayChangeValues+0x9cc>
      }
      break;

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    38d4:	be e7       	ldi	r27, 0x7E	; 126
    38d6:	db 2e       	mov	r13, r27
    38d8:	a4 ce       	rjmp	.-696    	; 0x3622 <updateDisplayChangeValues+0xa48>
      for(i = 0; i <= MAX_MOTOR; i++){
        //c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    38da:	80 91 10 03 	lds	r24, 0x0310
    38de:	88 23       	and	r24, r24
    38e0:	09 f4       	brne	.+2      	; 0x38e4 <updateDisplayChangeValues+0xd0a>
    38e2:	0f c1       	rjmp	.+542    	; 0x3b02 <updateDisplayChangeValues+0xf28>
    38e4:	6e e3       	ldi	r22, 0x3E	; 62
    38e6:	70 e0       	ldi	r23, 0x00	; 0
    38e8:	f3 ce       	rjmp	.-538    	; 0x36d0 <updateDisplayChangeValues+0xaf6>
      sprintf(menu.newDisplayValue[3], "        ");
      break;
	  
    case MENU_CHANGE_CURR:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    38ea:	6e e7       	ldi	r22, 0x7E	; 126
    38ec:	70 e0       	ldi	r23, 0x00	; 0
    38ee:	aa cc       	rjmp	.-1708   	; 0x3244 <updateDisplayChangeValues+0x66a>
      }
      break;

    case MENU_CHANGE_WAIT_TIME:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
    38f0:	4e e7       	ldi	r20, 0x7E	; 126
    38f2:	50 e0       	ldi	r21, 0x00	; 0
    38f4:	6b cd       	rjmp	.-1322   	; 0x33cc <updateDisplayChangeValues+0x7f2>

    case MENU_CONST_ANGULAR_SPEED:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
    38f6:	e0 91 16 03 	lds	r30, 0x0316
    38fa:	f0 91 17 03 	lds	r31, 0x0317
    38fe:	ee 0d       	add	r30, r14
    3900:	ff 1d       	adc	r31, r15
    3902:	20 81       	ld	r18, Z
    3904:	31 81       	ldd	r19, Z+1	; 0x01
    3906:	c9 01       	movw	r24, r18
    3908:	dc 01       	movw	r26, r24
    390a:	e5 e8       	ldi	r30, 0x85	; 133
    390c:	f1 e0       	ldi	r31, 0x01	; 1
    390e:	89 e0       	ldi	r24, 0x09	; 9
    3910:	01 90       	ld	r0, Z+
    3912:	0d 92       	st	X+, r0
    3914:	81 50       	subi	r24, 0x01	; 1
    3916:	e1 f7       	brne	.-8      	; 0x3910 <updateDisplayChangeValues+0xd36>
    3918:	bf ce       	rjmp	.-642    	; 0x3698 <updateDisplayChangeValues+0xabe>

    case MENU_SET_DECAY_MODE:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].decay == DECAY_MODE_SLOW){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "slow");
    391a:	e0 91 16 03 	lds	r30, 0x0316
    391e:	f0 91 17 03 	lds	r31, 0x0317
    3922:	2d b7       	in	r18, 0x3d	; 61
    3924:	3e b7       	in	r19, 0x3e	; 62
    3926:	28 50       	subi	r18, 0x08	; 8
    3928:	30 40       	sbci	r19, 0x00	; 0
    392a:	0f b6       	in	r0, 0x3f	; 63
    392c:	f8 94       	cli
    392e:	3e bf       	out	0x3e, r19	; 62
    3930:	0f be       	out	0x3f, r0	; 63
    3932:	2d bf       	out	0x3d, r18	; 61
    3934:	ad b7       	in	r26, 0x3d	; 61
    3936:	be b7       	in	r27, 0x3e	; 62
    3938:	11 96       	adiw	r26, 0x01	; 1
    393a:	e0 0f       	add	r30, r16
    393c:	f1 1f       	adc	r31, r17
    393e:	80 81       	ld	r24, Z
    3940:	91 81       	ldd	r25, Z+1	; 0x01
    3942:	ed b7       	in	r30, 0x3d	; 61
    3944:	fe b7       	in	r31, 0x3e	; 62
    3946:	92 83       	std	Z+2, r25	; 0x02
    3948:	81 83       	std	Z+1, r24	; 0x01
    394a:	13 96       	adiw	r26, 0x03	; 3
    394c:	bc 92       	st	X, r11
    394e:	ae 92       	st	-X, r10
    3950:	12 97       	sbiw	r26, 0x02	; 2
    3952:	14 96       	adiw	r26, 0x04	; 4
    3954:	dc 92       	st	X, r13
    3956:	14 97       	sbiw	r26, 0x04	; 4
    3958:	15 96       	adiw	r26, 0x05	; 5
    395a:	1c 92       	st	X, r1
    395c:	15 97       	sbiw	r26, 0x05	; 5
    395e:	17 96       	adiw	r26, 0x07	; 7
    3960:	9c 92       	st	X, r9
    3962:	8e 92       	st	-X, r8
    3964:	16 97       	sbiw	r26, 0x06	; 6
    3966:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    396a:	2d b7       	in	r18, 0x3d	; 61
    396c:	3e b7       	in	r19, 0x3e	; 62
    396e:	28 5f       	subi	r18, 0xF8	; 248
    3970:	3f 4f       	sbci	r19, 0xFF	; 255
    3972:	0f b6       	in	r0, 0x3f	; 63
    3974:	f8 94       	cli
    3976:	3e bf       	out	0x3e, r19	; 62
    3978:	0f be       	out	0x3f, r0	; 63
    397a:	2d bf       	out	0x3d, r18	; 61
    397c:	e3 cc       	rjmp	.-1594   	; 0x3344 <updateDisplayChangeValues+0x76a>

    case MENU_CHANGE_STEP_UNIT:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
    397e:	e0 91 16 03 	lds	r30, 0x0316
    3982:	f0 91 17 03 	lds	r31, 0x0317
    3986:	8d b7       	in	r24, 0x3d	; 61
    3988:	9e b7       	in	r25, 0x3e	; 62
    398a:	08 97       	sbiw	r24, 0x08	; 8
    398c:	0f b6       	in	r0, 0x3f	; 63
    398e:	f8 94       	cli
    3990:	9e bf       	out	0x3e, r25	; 62
    3992:	0f be       	out	0x3f, r0	; 63
    3994:	8d bf       	out	0x3d, r24	; 61
    3996:	ad b7       	in	r26, 0x3d	; 61
    3998:	be b7       	in	r27, 0x3e	; 62
    399a:	11 96       	adiw	r26, 0x01	; 1
    399c:	e0 0f       	add	r30, r16
    399e:	f1 1f       	adc	r31, r17
    39a0:	80 81       	ld	r24, Z
    39a2:	91 81       	ldd	r25, Z+1	; 0x01
    39a4:	ed b7       	in	r30, 0x3d	; 61
    39a6:	fe b7       	in	r31, 0x3e	; 62
    39a8:	92 83       	std	Z+2, r25	; 0x02
    39aa:	81 83       	std	Z+1, r24	; 0x01
    39ac:	13 96       	adiw	r26, 0x03	; 3
    39ae:	bc 92       	st	X, r11
    39b0:	ae 92       	st	-X, r10
    39b2:	12 97       	sbiw	r26, 0x02	; 2
    39b4:	14 96       	adiw	r26, 0x04	; 4
    39b6:	dc 92       	st	X, r13
    39b8:	14 97       	sbiw	r26, 0x04	; 4
    39ba:	15 96       	adiw	r26, 0x05	; 5
    39bc:	1c 92       	st	X, r1
    39be:	15 97       	sbiw	r26, 0x05	; 5
    39c0:	17 96       	adiw	r26, 0x07	; 7
    39c2:	9c 92       	st	X, r9
    39c4:	8e 92       	st	-X, r8
    39c6:	16 97       	sbiw	r26, 0x06	; 6
    39c8:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    39cc:	2d b7       	in	r18, 0x3d	; 61
    39ce:	3e b7       	in	r19, 0x3e	; 62
    39d0:	28 5f       	subi	r18, 0xF8	; 248
    39d2:	3f 4f       	sbci	r19, 0xFF	; 255
    39d4:	0f b6       	in	r0, 0x3f	; 63
    39d6:	f8 94       	cli
    39d8:	3e bf       	out	0x3e, r19	; 62
    39da:	0f be       	out	0x3f, r0	; 63
    39dc:	2d bf       	out	0x3d, r18	; 61
    39de:	3c cb       	rjmp	.-2440   	; 0x3058 <updateDisplayChangeValues+0x47e>
    case MENU_OPTICAL_ZERO_POS:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    39e0:	4e e7       	ldi	r20, 0x7E	; 126
    39e2:	50 e0       	ldi	r21, 0x00	; 0
    39e4:	86 cd       	rjmp	.-1268   	; 0x34f2 <updateDisplayChangeValues+0x918>
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
            break;

          case MOTOR_STEP_UNIT_RADIAN:
            /* 0xF7 is the display code for a greek pi */
            sprintf(menu.newDisplayValue[i], "%c%.3f%c", c, stepsToRadian(i, motor[i].actualPosition), 0xF7);
    39e6:	e0 91 16 03 	lds	r30, 0x0316
    39ea:	f0 91 17 03 	lds	r31, 0x0317
    39ee:	ee 0d       	add	r30, r14
    39f0:	ff 1d       	adc	r31, r15
    39f2:	00 81       	ld	r16, Z
    39f4:	11 81       	ldd	r17, Z+1	; 0x01
    39f6:	f9 01       	movw	r30, r18
    39f8:	ee 0f       	add	r30, r30
    39fa:	ff 1f       	adc	r31, r31
    39fc:	ee 0f       	add	r30, r30
    39fe:	ff 1f       	adc	r31, r31
    3a00:	ee 0f       	add	r30, r30
    3a02:	ff 1f       	adc	r31, r31
    3a04:	cf 01       	movw	r24, r30
    3a06:	88 0f       	add	r24, r24
    3a08:	99 1f       	adc	r25, r25
    3a0a:	88 0f       	add	r24, r24
    3a0c:	99 1f       	adc	r25, r25
    3a0e:	e8 0f       	add	r30, r24
    3a10:	f9 1f       	adc	r31, r25
    3a12:	e2 5e       	subi	r30, 0xE2	; 226
    3a14:	fb 4f       	sbci	r31, 0xFB	; 251
    3a16:	60 81       	ld	r22, Z
    3a18:	71 81       	ldd	r23, Z+1	; 0x01
    3a1a:	84 2f       	mov	r24, r20
    3a1c:	0e 94 62 08 	call	0x10c4	; 0x10c4 <stepsToRadian>
    3a20:	2d b7       	in	r18, 0x3d	; 61
    3a22:	3e b7       	in	r19, 0x3e	; 62
    3a24:	2c 50       	subi	r18, 0x0C	; 12
    3a26:	30 40       	sbci	r19, 0x00	; 0
    3a28:	0f b6       	in	r0, 0x3f	; 63
    3a2a:	f8 94       	cli
    3a2c:	3e bf       	out	0x3e, r19	; 62
    3a2e:	0f be       	out	0x3f, r0	; 63
    3a30:	2d bf       	out	0x3d, r18	; 61
    3a32:	ed b7       	in	r30, 0x3d	; 61
    3a34:	fe b7       	in	r31, 0x3e	; 62
    3a36:	31 96       	adiw	r30, 0x01	; 1
    3a38:	ad b7       	in	r26, 0x3d	; 61
    3a3a:	be b7       	in	r27, 0x3e	; 62
    3a3c:	12 96       	adiw	r26, 0x02	; 2
    3a3e:	1c 93       	st	X, r17
    3a40:	0e 93       	st	-X, r16
    3a42:	11 97       	sbiw	r26, 0x01	; 1
    3a44:	73 82       	std	Z+3, r7	; 0x03
    3a46:	62 82       	std	Z+2, r6	; 0x02
    3a48:	d4 82       	std	Z+4, r13	; 0x04
    3a4a:	15 82       	std	Z+5, r1	; 0x05
    3a4c:	66 83       	std	Z+6, r22	; 0x06
    3a4e:	77 83       	std	Z+7, r23	; 0x07
    3a50:	80 87       	std	Z+8, r24	; 0x08
    3a52:	91 87       	std	Z+9, r25	; 0x09
    3a54:	53 86       	std	Z+11, r5	; 0x0b
    3a56:	42 86       	std	Z+10, r4	; 0x0a
    3a58:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3a5c:	ed b7       	in	r30, 0x3d	; 61
    3a5e:	fe b7       	in	r31, 0x3e	; 62
    3a60:	3c 96       	adiw	r30, 0x0c	; 12
    3a62:	0f b6       	in	r0, 0x3f	; 63
    3a64:	f8 94       	cli
    3a66:	fe bf       	out	0x3e, r31	; 62
    3a68:	0f be       	out	0x3f, r0	; 63
    3a6a:	ed bf       	out	0x3d, r30	; 61
    3a6c:	59 ca       	rjmp	.-2894   	; 0x2f20 <updateDisplayChangeValues+0x346>
    case MENU_CHANGE_POSITION:
      for(i = 0; i <= MAX_MOTOR; i++){
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3a6e:	9e e7       	ldi	r25, 0x7E	; 126
    3a70:	d9 2e       	mov	r13, r25
    3a72:	02 ca       	rjmp	.-3068   	; 0x2e78 <updateDisplayChangeValues+0x29e>
            sprintf(menu.newDisplayValue[i], "%c%dst", c, motor[i].actualPosition);
            break;

          case MOTOR_STEP_UNIT_DEGREE:
            /* 0xDF is the display code for the degree-circle */
            sprintf(menu.newDisplayValue[i], "%c%.1f%c", c, stepsToDegree(i, motor[i].actualPosition), 0xDF);
    3a74:	e0 91 16 03 	lds	r30, 0x0316
    3a78:	f0 91 17 03 	lds	r31, 0x0317
    3a7c:	ee 0d       	add	r30, r14
    3a7e:	ff 1d       	adc	r31, r15
    3a80:	00 81       	ld	r16, Z
    3a82:	11 81       	ldd	r17, Z+1	; 0x01
    3a84:	f9 01       	movw	r30, r18
    3a86:	ee 0f       	add	r30, r30
    3a88:	ff 1f       	adc	r31, r31
    3a8a:	ee 0f       	add	r30, r30
    3a8c:	ff 1f       	adc	r31, r31
    3a8e:	ee 0f       	add	r30, r30
    3a90:	ff 1f       	adc	r31, r31
    3a92:	cf 01       	movw	r24, r30
    3a94:	88 0f       	add	r24, r24
    3a96:	99 1f       	adc	r25, r25
    3a98:	88 0f       	add	r24, r24
    3a9a:	99 1f       	adc	r25, r25
    3a9c:	e8 0f       	add	r30, r24
    3a9e:	f9 1f       	adc	r31, r25
    3aa0:	e2 5e       	subi	r30, 0xE2	; 226
    3aa2:	fb 4f       	sbci	r31, 0xFB	; 251
    3aa4:	60 81       	ld	r22, Z
    3aa6:	71 81       	ldd	r23, Z+1	; 0x01
    3aa8:	84 2f       	mov	r24, r20
    3aaa:	0e 94 dd 07 	call	0xfba	; 0xfba <stepsToDegree>
    3aae:	2d b7       	in	r18, 0x3d	; 61
    3ab0:	3e b7       	in	r19, 0x3e	; 62
    3ab2:	2c 50       	subi	r18, 0x0C	; 12
    3ab4:	30 40       	sbci	r19, 0x00	; 0
    3ab6:	0f b6       	in	r0, 0x3f	; 63
    3ab8:	f8 94       	cli
    3aba:	3e bf       	out	0x3e, r19	; 62
    3abc:	0f be       	out	0x3f, r0	; 63
    3abe:	2d bf       	out	0x3d, r18	; 61
    3ac0:	ed b7       	in	r30, 0x3d	; 61
    3ac2:	fe b7       	in	r31, 0x3e	; 62
    3ac4:	31 96       	adiw	r30, 0x01	; 1
    3ac6:	ad b7       	in	r26, 0x3d	; 61
    3ac8:	be b7       	in	r27, 0x3e	; 62
    3aca:	12 96       	adiw	r26, 0x02	; 2
    3acc:	1c 93       	st	X, r17
    3ace:	0e 93       	st	-X, r16
    3ad0:	11 97       	sbiw	r26, 0x01	; 1
    3ad2:	b3 82       	std	Z+3, r11	; 0x03
    3ad4:	a2 82       	std	Z+2, r10	; 0x02
    3ad6:	d4 82       	std	Z+4, r13	; 0x04
    3ad8:	15 82       	std	Z+5, r1	; 0x05
    3ada:	66 83       	std	Z+6, r22	; 0x06
    3adc:	77 83       	std	Z+7, r23	; 0x07
    3ade:	80 87       	std	Z+8, r24	; 0x08
    3ae0:	91 87       	std	Z+9, r25	; 0x09
    3ae2:	93 86       	std	Z+11, r9	; 0x0b
    3ae4:	82 86       	std	Z+10, r8	; 0x0a
    3ae6:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3aea:	ed b7       	in	r30, 0x3d	; 61
    3aec:	fe b7       	in	r31, 0x3e	; 62
    3aee:	3c 96       	adiw	r30, 0x0c	; 12
    3af0:	0f b6       	in	r0, 0x3f	; 63
    3af2:	f8 94       	cli
    3af4:	fe bf       	out	0x3e, r31	; 62
    3af6:	0f be       	out	0x3f, r0	; 63
    3af8:	ed bf       	out	0x3d, r30	; 61
    3afa:	12 ca       	rjmp	.-3036   	; 0x2f20 <updateDisplayChangeValues+0x346>
      for(i = 0; i <= MAX_MOTOR; i++){
        //c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3afc:	6e e7       	ldi	r22, 0x7E	; 126
    3afe:	70 e0       	ldi	r23, 0x00	; 0
    3b00:	ef ca       	rjmp	.-2594   	; 0x30e0 <updateDisplayChangeValues+0x506>
      for(i = 0; i <= MAX_MOTOR; i++){
        //c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        c = ' ';
        if(menu.selectedMotor & (1 << i)){
          c = 0x7E;
          if(menu.fastMovingMode){
    3b02:	6e e7       	ldi	r22, 0x7E	; 126
    3b04:	70 e0       	ldi	r23, 0x00	; 0
    3b06:	e4 cd       	rjmp	.-1080   	; 0x36d0 <updateDisplayChangeValues+0xaf6>
        if(forbiddenZone[i].active){
          sprintf(menu.newDisplayValue[i], "ForbZone");
        }
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
    3b08:	e0 91 16 03 	lds	r30, 0x0316
    3b0c:	f0 91 17 03 	lds	r31, 0x0317
    3b10:	00 d0       	rcall	.+0      	; 0x3b12 <updateDisplayChangeValues+0xf38>
    3b12:	00 d0       	rcall	.+0      	; 0x3b14 <updateDisplayChangeValues+0xf3a>
    3b14:	00 d0       	rcall	.+0      	; 0x3b16 <updateDisplayChangeValues+0xf3c>
    3b16:	ad b7       	in	r26, 0x3d	; 61
    3b18:	be b7       	in	r27, 0x3e	; 62
    3b1a:	11 96       	adiw	r26, 0x01	; 1
    3b1c:	ee 0d       	add	r30, r14
    3b1e:	ff 1d       	adc	r31, r15
    3b20:	80 81       	ld	r24, Z
    3b22:	91 81       	ldd	r25, Z+1	; 0x01
    3b24:	ed b7       	in	r30, 0x3d	; 61
    3b26:	fe b7       	in	r31, 0x3e	; 62
    3b28:	92 83       	std	Z+2, r25	; 0x02
    3b2a:	81 83       	std	Z+1, r24	; 0x01
    3b2c:	13 96       	adiw	r26, 0x03	; 3
    3b2e:	7c 92       	st	X, r7
    3b30:	6e 92       	st	-X, r6
    3b32:	12 97       	sbiw	r26, 0x02	; 2
    3b34:	14 96       	adiw	r26, 0x04	; 4
    3b36:	dc 92       	st	X, r13
    3b38:	14 97       	sbiw	r26, 0x04	; 4
    3b3a:	15 96       	adiw	r26, 0x05	; 5
    3b3c:	1c 92       	st	X, r1
    3b3e:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3b42:	2d b7       	in	r18, 0x3d	; 61
    3b44:	3e b7       	in	r19, 0x3e	; 62
    3b46:	2a 5f       	subi	r18, 0xFA	; 250
    3b48:	3f 4f       	sbci	r19, 0xFF	; 255
    3b4a:	0f b6       	in	r0, 0x3f	; 63
    3b4c:	f8 94       	cli
    3b4e:	3e bf       	out	0x3e, r19	; 62
    3b50:	0f be       	out	0x3f, r0	; 63
    3b52:	2d bf       	out	0x3d, r18	; 61
    3b54:	87 cd       	rjmp	.-1266   	; 0x3664 <updateDisplayChangeValues+0xa8a>
        }
        if(motor[i].decay == DECAY_MODE_FAST){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "fast");
        }
        if(motor[i].decay == DECAY_MODE_MIXED){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "mixed");
    3b56:	e0 91 16 03 	lds	r30, 0x0316
    3b5a:	f0 91 17 03 	lds	r31, 0x0317
    3b5e:	8d b7       	in	r24, 0x3d	; 61
    3b60:	9e b7       	in	r25, 0x3e	; 62
    3b62:	08 97       	sbiw	r24, 0x08	; 8
    3b64:	0f b6       	in	r0, 0x3f	; 63
    3b66:	f8 94       	cli
    3b68:	9e bf       	out	0x3e, r25	; 62
    3b6a:	0f be       	out	0x3f, r0	; 63
    3b6c:	8d bf       	out	0x3d, r24	; 61
    3b6e:	ad b7       	in	r26, 0x3d	; 61
    3b70:	be b7       	in	r27, 0x3e	; 62
    3b72:	11 96       	adiw	r26, 0x01	; 1
    3b74:	e0 0f       	add	r30, r16
    3b76:	f1 1f       	adc	r31, r17
    3b78:	80 81       	ld	r24, Z
    3b7a:	91 81       	ldd	r25, Z+1	; 0x01
    3b7c:	ed b7       	in	r30, 0x3d	; 61
    3b7e:	fe b7       	in	r31, 0x3e	; 62
    3b80:	92 83       	std	Z+2, r25	; 0x02
    3b82:	81 83       	std	Z+1, r24	; 0x01
    3b84:	13 96       	adiw	r26, 0x03	; 3
    3b86:	bc 92       	st	X, r11
    3b88:	ae 92       	st	-X, r10
    3b8a:	12 97       	sbiw	r26, 0x02	; 2
    3b8c:	14 96       	adiw	r26, 0x04	; 4
    3b8e:	dc 92       	st	X, r13
    3b90:	14 97       	sbiw	r26, 0x04	; 4
    3b92:	15 96       	adiw	r26, 0x05	; 5
    3b94:	1c 92       	st	X, r1
    3b96:	15 97       	sbiw	r26, 0x05	; 5
    3b98:	17 96       	adiw	r26, 0x07	; 7
    3b9a:	5c 92       	st	X, r5
    3b9c:	4e 92       	st	-X, r4
    3b9e:	16 97       	sbiw	r26, 0x06	; 6
    3ba0:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3ba4:	2d b7       	in	r18, 0x3d	; 61
    3ba6:	3e b7       	in	r19, 0x3e	; 62
    3ba8:	28 5f       	subi	r18, 0xF8	; 248
    3baa:	3f 4f       	sbci	r19, 0xFF	; 255
    3bac:	0f b6       	in	r0, 0x3f	; 63
    3bae:	f8 94       	cli
    3bb0:	3e bf       	out	0x3e, r19	; 62
    3bb2:	0f be       	out	0x3f, r0	; 63
    3bb4:	2d bf       	out	0x3d, r18	; 61
    3bb6:	f0 cb       	rjmp	.-2080   	; 0x3398 <updateDisplayChangeValues+0x7be>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].decay == DECAY_MODE_SLOW){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "slow");
        }
        if(motor[i].decay == DECAY_MODE_FAST){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "fast");
    3bb8:	e0 91 16 03 	lds	r30, 0x0316
    3bbc:	f0 91 17 03 	lds	r31, 0x0317
    3bc0:	8d b7       	in	r24, 0x3d	; 61
    3bc2:	9e b7       	in	r25, 0x3e	; 62
    3bc4:	08 97       	sbiw	r24, 0x08	; 8
    3bc6:	0f b6       	in	r0, 0x3f	; 63
    3bc8:	f8 94       	cli
    3bca:	9e bf       	out	0x3e, r25	; 62
    3bcc:	0f be       	out	0x3f, r0	; 63
    3bce:	8d bf       	out	0x3d, r24	; 61
    3bd0:	ad b7       	in	r26, 0x3d	; 61
    3bd2:	be b7       	in	r27, 0x3e	; 62
    3bd4:	11 96       	adiw	r26, 0x01	; 1
    3bd6:	e0 0f       	add	r30, r16
    3bd8:	f1 1f       	adc	r31, r17
    3bda:	80 81       	ld	r24, Z
    3bdc:	91 81       	ldd	r25, Z+1	; 0x01
    3bde:	ed b7       	in	r30, 0x3d	; 61
    3be0:	fe b7       	in	r31, 0x3e	; 62
    3be2:	92 83       	std	Z+2, r25	; 0x02
    3be4:	81 83       	std	Z+1, r24	; 0x01
    3be6:	13 96       	adiw	r26, 0x03	; 3
    3be8:	bc 92       	st	X, r11
    3bea:	ae 92       	st	-X, r10
    3bec:	12 97       	sbiw	r26, 0x02	; 2
    3bee:	14 96       	adiw	r26, 0x04	; 4
    3bf0:	dc 92       	st	X, r13
    3bf2:	14 97       	sbiw	r26, 0x04	; 4
    3bf4:	15 96       	adiw	r26, 0x05	; 5
    3bf6:	1c 92       	st	X, r1
    3bf8:	15 97       	sbiw	r26, 0x05	; 5
    3bfa:	17 96       	adiw	r26, 0x07	; 7
    3bfc:	7c 92       	st	X, r7
    3bfe:	6e 92       	st	-X, r6
    3c00:	16 97       	sbiw	r26, 0x06	; 6
    3c02:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3c06:	2d b7       	in	r18, 0x3d	; 61
    3c08:	3e b7       	in	r19, 0x3e	; 62
    3c0a:	28 5f       	subi	r18, 0xF8	; 248
    3c0c:	3f 4f       	sbci	r19, 0xFF	; 255
    3c0e:	0f b6       	in	r0, 0x3f	; 63
    3c10:	f8 94       	cli
    3c12:	3e bf       	out	0x3e, r19	; 62
    3c14:	0f be       	out	0x3f, r0	; 63
    3c16:	2d bf       	out	0x3d, r18	; 61
    3c18:	aa cb       	rjmp	.-2220   	; 0x336e <updateDisplayChangeValues+0x794>
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_RADIAN){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "radian");
    3c1a:	e0 91 16 03 	lds	r30, 0x0316
    3c1e:	f0 91 17 03 	lds	r31, 0x0317
    3c22:	8d b7       	in	r24, 0x3d	; 61
    3c24:	9e b7       	in	r25, 0x3e	; 62
    3c26:	08 97       	sbiw	r24, 0x08	; 8
    3c28:	0f b6       	in	r0, 0x3f	; 63
    3c2a:	f8 94       	cli
    3c2c:	9e bf       	out	0x3e, r25	; 62
    3c2e:	0f be       	out	0x3f, r0	; 63
    3c30:	8d bf       	out	0x3d, r24	; 61
    3c32:	ad b7       	in	r26, 0x3d	; 61
    3c34:	be b7       	in	r27, 0x3e	; 62
    3c36:	11 96       	adiw	r26, 0x01	; 1
    3c38:	e0 0f       	add	r30, r16
    3c3a:	f1 1f       	adc	r31, r17
    3c3c:	80 81       	ld	r24, Z
    3c3e:	91 81       	ldd	r25, Z+1	; 0x01
    3c40:	ed b7       	in	r30, 0x3d	; 61
    3c42:	fe b7       	in	r31, 0x3e	; 62
    3c44:	92 83       	std	Z+2, r25	; 0x02
    3c46:	81 83       	std	Z+1, r24	; 0x01
    3c48:	13 96       	adiw	r26, 0x03	; 3
    3c4a:	bc 92       	st	X, r11
    3c4c:	ae 92       	st	-X, r10
    3c4e:	12 97       	sbiw	r26, 0x02	; 2
    3c50:	14 96       	adiw	r26, 0x04	; 4
    3c52:	dc 92       	st	X, r13
    3c54:	14 97       	sbiw	r26, 0x04	; 4
    3c56:	15 96       	adiw	r26, 0x05	; 5
    3c58:	1c 92       	st	X, r1
    3c5a:	15 97       	sbiw	r26, 0x05	; 5
    3c5c:	17 96       	adiw	r26, 0x07	; 7
    3c5e:	5c 92       	st	X, r5
    3c60:	4e 92       	st	-X, r4
    3c62:	16 97       	sbiw	r26, 0x06	; 6
    3c64:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3c68:	2d b7       	in	r18, 0x3d	; 61
    3c6a:	3e b7       	in	r19, 0x3e	; 62
    3c6c:	28 5f       	subi	r18, 0xF8	; 248
    3c6e:	3f 4f       	sbci	r19, 0xFF	; 255
    3c70:	0f b6       	in	r0, 0x3f	; 63
    3c72:	f8 94       	cli
    3c74:	3e bf       	out	0x3e, r19	; 62
    3c76:	0f be       	out	0x3f, r0	; 63
    3c78:	2d bf       	out	0x3d, r18	; 61
    3c7a:	18 ca       	rjmp	.-3024   	; 0x30ac <updateDisplayChangeValues+0x4d2>
        c = (menu.selectedMotor & (1 << i)) ? 0x7E : ' ';
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_STEP){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "step");
        }
        if(motor[i].stepUnit == MOTOR_STEP_UNIT_DEGREE){
          sprintf(menu.newDisplayValue[i], "%c%s", c, "degree");
    3c7c:	e0 91 16 03 	lds	r30, 0x0316
    3c80:	f0 91 17 03 	lds	r31, 0x0317
    3c84:	8d b7       	in	r24, 0x3d	; 61
    3c86:	9e b7       	in	r25, 0x3e	; 62
    3c88:	08 97       	sbiw	r24, 0x08	; 8
    3c8a:	0f b6       	in	r0, 0x3f	; 63
    3c8c:	f8 94       	cli
    3c8e:	9e bf       	out	0x3e, r25	; 62
    3c90:	0f be       	out	0x3f, r0	; 63
    3c92:	8d bf       	out	0x3d, r24	; 61
    3c94:	ad b7       	in	r26, 0x3d	; 61
    3c96:	be b7       	in	r27, 0x3e	; 62
    3c98:	11 96       	adiw	r26, 0x01	; 1
    3c9a:	e0 0f       	add	r30, r16
    3c9c:	f1 1f       	adc	r31, r17
    3c9e:	80 81       	ld	r24, Z
    3ca0:	91 81       	ldd	r25, Z+1	; 0x01
    3ca2:	ed b7       	in	r30, 0x3d	; 61
    3ca4:	fe b7       	in	r31, 0x3e	; 62
    3ca6:	92 83       	std	Z+2, r25	; 0x02
    3ca8:	81 83       	std	Z+1, r24	; 0x01
    3caa:	13 96       	adiw	r26, 0x03	; 3
    3cac:	bc 92       	st	X, r11
    3cae:	ae 92       	st	-X, r10
    3cb0:	12 97       	sbiw	r26, 0x02	; 2
    3cb2:	14 96       	adiw	r26, 0x04	; 4
    3cb4:	dc 92       	st	X, r13
    3cb6:	14 97       	sbiw	r26, 0x04	; 4
    3cb8:	15 96       	adiw	r26, 0x05	; 5
    3cba:	1c 92       	st	X, r1
    3cbc:	15 97       	sbiw	r26, 0x05	; 5
    3cbe:	17 96       	adiw	r26, 0x07	; 7
    3cc0:	7c 92       	st	X, r7
    3cc2:	6e 92       	st	-X, r6
    3cc4:	16 97       	sbiw	r26, 0x06	; 6
    3cc6:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3cca:	2d b7       	in	r18, 0x3d	; 61
    3ccc:	3e b7       	in	r19, 0x3e	; 62
    3cce:	28 5f       	subi	r18, 0xF8	; 248
    3cd0:	3f 4f       	sbci	r19, 0xFF	; 255
    3cd2:	0f b6       	in	r0, 0x3f	; 63
    3cd4:	f8 94       	cli
    3cd6:	3e bf       	out	0x3e, r19	; 62
    3cd8:	0f be       	out	0x3f, r0	; 63
    3cda:	2d bf       	out	0x3d, r18	; 61
    3cdc:	d2 c9       	rjmp	.-3164   	; 0x3082 <updateDisplayChangeValues+0x4a8>
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CCW){
            sprintf(menu.newDisplayValue[i], "%cCCW", c);
    3cde:	e0 91 16 03 	lds	r30, 0x0316
    3ce2:	f0 91 17 03 	lds	r31, 0x0317
    3ce6:	00 d0       	rcall	.+0      	; 0x3ce8 <updateDisplayChangeValues+0x110e>
    3ce8:	00 d0       	rcall	.+0      	; 0x3cea <updateDisplayChangeValues+0x1110>
    3cea:	00 d0       	rcall	.+0      	; 0x3cec <updateDisplayChangeValues+0x1112>
    3cec:	ad b7       	in	r26, 0x3d	; 61
    3cee:	be b7       	in	r27, 0x3e	; 62
    3cf0:	11 96       	adiw	r26, 0x01	; 1
    3cf2:	ee 0d       	add	r30, r14
    3cf4:	ff 1d       	adc	r31, r15
    3cf6:	80 81       	ld	r24, Z
    3cf8:	91 81       	ldd	r25, Z+1	; 0x01
    3cfa:	ed b7       	in	r30, 0x3d	; 61
    3cfc:	fe b7       	in	r31, 0x3e	; 62
    3cfe:	92 83       	std	Z+2, r25	; 0x02
    3d00:	81 83       	std	Z+1, r24	; 0x01
    3d02:	13 96       	adiw	r26, 0x03	; 3
    3d04:	bc 92       	st	X, r11
    3d06:	ae 92       	st	-X, r10
    3d08:	12 97       	sbiw	r26, 0x02	; 2
    3d0a:	14 96       	adiw	r26, 0x04	; 4
    3d0c:	dc 92       	st	X, r13
    3d0e:	14 97       	sbiw	r26, 0x04	; 4
    3d10:	15 96       	adiw	r26, 0x05	; 5
    3d12:	1c 92       	st	X, r1
    3d14:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3d18:	2d b7       	in	r18, 0x3d	; 61
    3d1a:	3e b7       	in	r19, 0x3e	; 62
    3d1c:	2a 5f       	subi	r18, 0xFA	; 250
    3d1e:	3f 4f       	sbci	r19, 0xFF	; 255
    3d20:	0f b6       	in	r0, 0x3f	; 63
    3d22:	f8 94       	cli
    3d24:	3e bf       	out	0x3e, r19	; 62
    3d26:	0f be       	out	0x3f, r0	; 63
    3d28:	2d bf       	out	0x3d, r18	; 61
    3d2a:	b6 cc       	rjmp	.-1684   	; 0x3698 <updateDisplayChangeValues+0xabe>
        else{
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_STOP){
            sprintf(menu.newDisplayValue[i], "%cSTOP", c);
          }
          if(motor[i].angularVelocity == MOTOR_MOVE_INFINITE_CW){
            sprintf(menu.newDisplayValue[i], "%cCW", c);
    3d2c:	e0 91 16 03 	lds	r30, 0x0316
    3d30:	f0 91 17 03 	lds	r31, 0x0317
    3d34:	00 d0       	rcall	.+0      	; 0x3d36 <updateDisplayChangeValues+0x115c>
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <updateDisplayChangeValues+0x115e>
    3d38:	00 d0       	rcall	.+0      	; 0x3d3a <updateDisplayChangeValues+0x1160>
    3d3a:	ad b7       	in	r26, 0x3d	; 61
    3d3c:	be b7       	in	r27, 0x3e	; 62
    3d3e:	11 96       	adiw	r26, 0x01	; 1
    3d40:	ee 0d       	add	r30, r14
    3d42:	ff 1d       	adc	r31, r15
    3d44:	80 81       	ld	r24, Z
    3d46:	91 81       	ldd	r25, Z+1	; 0x01
    3d48:	ed b7       	in	r30, 0x3d	; 61
    3d4a:	fe b7       	in	r31, 0x3e	; 62
    3d4c:	92 83       	std	Z+2, r25	; 0x02
    3d4e:	81 83       	std	Z+1, r24	; 0x01
    3d50:	13 96       	adiw	r26, 0x03	; 3
    3d52:	9c 92       	st	X, r9
    3d54:	8e 92       	st	-X, r8
    3d56:	12 97       	sbiw	r26, 0x02	; 2
    3d58:	14 96       	adiw	r26, 0x04	; 4
    3d5a:	dc 92       	st	X, r13
    3d5c:	14 97       	sbiw	r26, 0x04	; 4
    3d5e:	15 96       	adiw	r26, 0x05	; 5
    3d60:	1c 92       	st	X, r1
    3d62:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    3d66:	2d b7       	in	r18, 0x3d	; 61
    3d68:	3e b7       	in	r19, 0x3e	; 62
    3d6a:	2a 5f       	subi	r18, 0xFA	; 250
    3d6c:	3f 4f       	sbci	r19, 0xFF	; 255
    3d6e:	0f b6       	in	r0, 0x3f	; 63
    3d70:	f8 94       	cli
    3d72:	3e bf       	out	0x3e, r19	; 62
    3d74:	0f be       	out	0x3f, r0	; 63
    3d76:	2d bf       	out	0x3d, r18	; 61
    3d78:	82 cc       	rjmp	.-1788   	; 0x367e <updateDisplayChangeValues+0xaa4>

00003d7a <commandSetProgStep>:
    param5: absolute or relative movement

    always gets param1..param4 in steps (calculated by python interface)
 --------------------------------------------------------------------- */
void commandSetProgStep(char* param0, char* param1, char* param2,
                        char* param3, char* param4, char* param5){
    3d7a:	8f 92       	push	r8
    3d7c:	9f 92       	push	r9
    3d7e:	af 92       	push	r10
    3d80:	bf 92       	push	r11
    3d82:	cf 92       	push	r12
    3d84:	df 92       	push	r13
    3d86:	ef 92       	push	r14
    3d88:	ff 92       	push	r15
    3d8a:	0f 93       	push	r16
    3d8c:	1f 93       	push	r17
    3d8e:	cf 93       	push	r28
    3d90:	df 93       	push	r29
    3d92:	eb 01       	movw	r28, r22
    3d94:	6a 01       	movw	r12, r20
    3d96:	59 01       	movw	r10, r18
    3d98:	48 01       	movw	r8, r16

  uint8_t step, i;

  step = (uint8_t)strtol(param0, (char **)NULL, 10);
    3d9a:	60 e0       	ldi	r22, 0x00	; 0
    3d9c:	70 e0       	ldi	r23, 0x00	; 0
    3d9e:	4a e0       	ldi	r20, 0x0A	; 10
    3da0:	50 e0       	ldi	r21, 0x00	; 0
    3da2:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    3da6:	16 2f       	mov	r17, r22

  if(step >= MAX_PROGRAM_STEPS){
    3da8:	60 31       	cpi	r22, 0x10	; 16
    3daa:	68 f0       	brcs	.+26     	; 0x3dc6 <commandSetProgStep+0x4c>
  if(strcmp(param5, "REL") == 0){
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
  }

  return;
}
    3dac:	df 91       	pop	r29
    3dae:	cf 91       	pop	r28
    3db0:	1f 91       	pop	r17
    3db2:	0f 91       	pop	r16
    3db4:	ff 90       	pop	r15
    3db6:	ef 90       	pop	r14
    3db8:	df 90       	pop	r13
    3dba:	cf 90       	pop	r12
    3dbc:	bf 90       	pop	r11
    3dbe:	af 90       	pop	r10
    3dc0:	9f 90       	pop	r9
    3dc2:	8f 90       	pop	r8
    3dc4:	08 95       	ret
  if(step >= MAX_PROGRAM_STEPS){
    /* not more than MAX_PROGAM_STEPS allowed */
    return;
  }

  if(strcmp(param5, "NONE") == 0){
    3dc6:	c7 01       	movw	r24, r14
    3dc8:	69 e2       	ldi	r22, 0x29	; 41
    3dca:	72 e0       	ldi	r23, 0x02	; 2
    3dcc:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    3dd0:	00 97       	sbiw	r24, 0x00	; 0
    3dd2:	09 f0       	breq	.+2      	; 0x3dd6 <commandSetProgStep+0x5c>
    3dd4:	66 c0       	rjmp	.+204    	; 0x3ea2 <commandSetProgStep+0x128>
    programList[step].isActive = 0;
    3dd6:	81 2f       	mov	r24, r17
    3dd8:	90 e0       	ldi	r25, 0x00	; 0
    3dda:	fc 01       	movw	r30, r24
    3ddc:	ee 0f       	add	r30, r30
    3dde:	ff 1f       	adc	r31, r31
    3de0:	ee 0f       	add	r30, r30
    3de2:	ff 1f       	adc	r31, r31
    3de4:	ee 0f       	add	r30, r30
    3de6:	ff 1f       	adc	r31, r31
    3de8:	88 0f       	add	r24, r24
    3dea:	99 1f       	adc	r25, r25
    3dec:	e8 0f       	add	r30, r24
    3dee:	f9 1f       	adc	r31, r25
    3df0:	ef 5d       	subi	r30, 0xDF	; 223
    3df2:	fc 4f       	sbci	r31, 0xFC	; 252
    3df4:	10 82       	st	Z, r1
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
    3df6:	81 2f       	mov	r24, r17
    3df8:	90 e0       	ldi	r25, 0x00	; 0
    3dfa:	fc 01       	movw	r30, r24
    3dfc:	ee 0f       	add	r30, r30
    3dfe:	ff 1f       	adc	r31, r31
    3e00:	ee 0f       	add	r30, r30
    3e02:	ff 1f       	adc	r31, r31
    3e04:	ee 0f       	add	r30, r30
    3e06:	ff 1f       	adc	r31, r31
    3e08:	88 0f       	add	r24, r24
    3e0a:	99 1f       	adc	r25, r25
    3e0c:	e8 0f       	add	r30, r24
    3e0e:	f9 1f       	adc	r31, r25
    3e10:	ef 5d       	subi	r30, 0xDF	; 223
    3e12:	fc 4f       	sbci	r31, 0xFC	; 252
    3e14:	81 e0       	ldi	r24, 0x01	; 1
    3e16:	81 87       	std	Z+9, r24	; 0x09
    for(i = 0; i <= MAX_MOTOR; i++){
      programList[step].position[i] = 0;
    3e18:	81 2f       	mov	r24, r17
    3e1a:	90 e0       	ldi	r25, 0x00	; 0
    3e1c:	fc 01       	movw	r30, r24
    3e1e:	ee 0f       	add	r30, r30
    3e20:	ff 1f       	adc	r31, r31
    3e22:	ee 0f       	add	r30, r30
    3e24:	ff 1f       	adc	r31, r31
    3e26:	ee 0f       	add	r30, r30
    3e28:	ff 1f       	adc	r31, r31
    3e2a:	88 0f       	add	r24, r24
    3e2c:	99 1f       	adc	r25, r25
    3e2e:	e8 0f       	add	r30, r24
    3e30:	f9 1f       	adc	r31, r25
    3e32:	ef 5d       	subi	r30, 0xDF	; 223
    3e34:	fc 4f       	sbci	r31, 0xFC	; 252
    3e36:	12 82       	std	Z+2, r1	; 0x02
    3e38:	11 82       	std	Z+1, r1	; 0x01
    3e3a:	81 2f       	mov	r24, r17
    3e3c:	90 e0       	ldi	r25, 0x00	; 0
    3e3e:	fc 01       	movw	r30, r24
    3e40:	ee 0f       	add	r30, r30
    3e42:	ff 1f       	adc	r31, r31
    3e44:	ee 0f       	add	r30, r30
    3e46:	ff 1f       	adc	r31, r31
    3e48:	ee 0f       	add	r30, r30
    3e4a:	ff 1f       	adc	r31, r31
    3e4c:	88 0f       	add	r24, r24
    3e4e:	99 1f       	adc	r25, r25
    3e50:	e8 0f       	add	r30, r24
    3e52:	f9 1f       	adc	r31, r25
    3e54:	ef 5d       	subi	r30, 0xDF	; 223
    3e56:	fc 4f       	sbci	r31, 0xFC	; 252
    3e58:	14 82       	std	Z+4, r1	; 0x04
    3e5a:	13 82       	std	Z+3, r1	; 0x03
    3e5c:	81 2f       	mov	r24, r17
    3e5e:	90 e0       	ldi	r25, 0x00	; 0
    3e60:	fc 01       	movw	r30, r24
    3e62:	ee 0f       	add	r30, r30
    3e64:	ff 1f       	adc	r31, r31
    3e66:	ee 0f       	add	r30, r30
    3e68:	ff 1f       	adc	r31, r31
    3e6a:	ee 0f       	add	r30, r30
    3e6c:	ff 1f       	adc	r31, r31
    3e6e:	88 0f       	add	r24, r24
    3e70:	99 1f       	adc	r25, r25
    3e72:	e8 0f       	add	r30, r24
    3e74:	f9 1f       	adc	r31, r25
    3e76:	ef 5d       	subi	r30, 0xDF	; 223
    3e78:	fc 4f       	sbci	r31, 0xFC	; 252
    3e7a:	16 82       	std	Z+6, r1	; 0x06
    3e7c:	15 82       	std	Z+5, r1	; 0x05
    3e7e:	81 2f       	mov	r24, r17
    3e80:	90 e0       	ldi	r25, 0x00	; 0
    3e82:	fc 01       	movw	r30, r24
    3e84:	ee 0f       	add	r30, r30
    3e86:	ff 1f       	adc	r31, r31
    3e88:	ee 0f       	add	r30, r30
    3e8a:	ff 1f       	adc	r31, r31
    3e8c:	ee 0f       	add	r30, r30
    3e8e:	ff 1f       	adc	r31, r31
    3e90:	88 0f       	add	r24, r24
    3e92:	99 1f       	adc	r25, r25
    3e94:	e8 0f       	add	r30, r24
    3e96:	f9 1f       	adc	r31, r25
    3e98:	ef 5d       	subi	r30, 0xDF	; 223
    3e9a:	fc 4f       	sbci	r31, 0xFC	; 252
    3e9c:	10 86       	std	Z+8, r1	; 0x08
    3e9e:	17 82       	std	Z+7, r1	; 0x07
    3ea0:	85 cf       	rjmp	.-246    	; 0x3dac <commandSetProgStep+0x32>
    }
    return;
  }

  programList[step].position[0] = (int16_t)strtol(param1, (char **)NULL, 10);
    3ea2:	ce 01       	movw	r24, r28
    3ea4:	60 e0       	ldi	r22, 0x00	; 0
    3ea6:	70 e0       	ldi	r23, 0x00	; 0
    3ea8:	4a e0       	ldi	r20, 0x0A	; 10
    3eaa:	50 e0       	ldi	r21, 0x00	; 0
    3eac:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    3eb0:	21 2f       	mov	r18, r17
    3eb2:	30 e0       	ldi	r19, 0x00	; 0
    3eb4:	f9 01       	movw	r30, r18
    3eb6:	ee 0f       	add	r30, r30
    3eb8:	ff 1f       	adc	r31, r31
    3eba:	ee 0f       	add	r30, r30
    3ebc:	ff 1f       	adc	r31, r31
    3ebe:	ee 0f       	add	r30, r30
    3ec0:	ff 1f       	adc	r31, r31
    3ec2:	22 0f       	add	r18, r18
    3ec4:	33 1f       	adc	r19, r19
    3ec6:	e2 0f       	add	r30, r18
    3ec8:	f3 1f       	adc	r31, r19
    3eca:	ef 5d       	subi	r30, 0xDF	; 223
    3ecc:	fc 4f       	sbci	r31, 0xFC	; 252
    3ece:	72 83       	std	Z+2, r23	; 0x02
    3ed0:	61 83       	std	Z+1, r22	; 0x01
  programList[step].position[1] = (int16_t)strtol(param2, (char **)NULL, 10);
    3ed2:	c6 01       	movw	r24, r12
    3ed4:	60 e0       	ldi	r22, 0x00	; 0
    3ed6:	70 e0       	ldi	r23, 0x00	; 0
    3ed8:	4a e0       	ldi	r20, 0x0A	; 10
    3eda:	50 e0       	ldi	r21, 0x00	; 0
    3edc:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    3ee0:	21 2f       	mov	r18, r17
    3ee2:	30 e0       	ldi	r19, 0x00	; 0
    3ee4:	f9 01       	movw	r30, r18
    3ee6:	ee 0f       	add	r30, r30
    3ee8:	ff 1f       	adc	r31, r31
    3eea:	ee 0f       	add	r30, r30
    3eec:	ff 1f       	adc	r31, r31
    3eee:	ee 0f       	add	r30, r30
    3ef0:	ff 1f       	adc	r31, r31
    3ef2:	22 0f       	add	r18, r18
    3ef4:	33 1f       	adc	r19, r19
    3ef6:	e2 0f       	add	r30, r18
    3ef8:	f3 1f       	adc	r31, r19
    3efa:	ef 5d       	subi	r30, 0xDF	; 223
    3efc:	fc 4f       	sbci	r31, 0xFC	; 252
    3efe:	74 83       	std	Z+4, r23	; 0x04
    3f00:	63 83       	std	Z+3, r22	; 0x03
  programList[step].position[2] = (int16_t)strtol(param3, (char **)NULL, 10);
    3f02:	c5 01       	movw	r24, r10
    3f04:	60 e0       	ldi	r22, 0x00	; 0
    3f06:	70 e0       	ldi	r23, 0x00	; 0
    3f08:	4a e0       	ldi	r20, 0x0A	; 10
    3f0a:	50 e0       	ldi	r21, 0x00	; 0
    3f0c:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    3f10:	21 2f       	mov	r18, r17
    3f12:	30 e0       	ldi	r19, 0x00	; 0
    3f14:	f9 01       	movw	r30, r18
    3f16:	ee 0f       	add	r30, r30
    3f18:	ff 1f       	adc	r31, r31
    3f1a:	ee 0f       	add	r30, r30
    3f1c:	ff 1f       	adc	r31, r31
    3f1e:	ee 0f       	add	r30, r30
    3f20:	ff 1f       	adc	r31, r31
    3f22:	22 0f       	add	r18, r18
    3f24:	33 1f       	adc	r19, r19
    3f26:	e2 0f       	add	r30, r18
    3f28:	f3 1f       	adc	r31, r19
    3f2a:	ef 5d       	subi	r30, 0xDF	; 223
    3f2c:	fc 4f       	sbci	r31, 0xFC	; 252
    3f2e:	76 83       	std	Z+6, r23	; 0x06
    3f30:	65 83       	std	Z+5, r22	; 0x05
  programList[step].position[3] = (int16_t)strtol(param4, (char **)NULL, 10);
    3f32:	c4 01       	movw	r24, r8
    3f34:	60 e0       	ldi	r22, 0x00	; 0
    3f36:	70 e0       	ldi	r23, 0x00	; 0
    3f38:	4a e0       	ldi	r20, 0x0A	; 10
    3f3a:	50 e0       	ldi	r21, 0x00	; 0
    3f3c:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    3f40:	21 2f       	mov	r18, r17
    3f42:	30 e0       	ldi	r19, 0x00	; 0
    3f44:	f9 01       	movw	r30, r18
    3f46:	ee 0f       	add	r30, r30
    3f48:	ff 1f       	adc	r31, r31
    3f4a:	ee 0f       	add	r30, r30
    3f4c:	ff 1f       	adc	r31, r31
    3f4e:	ee 0f       	add	r30, r30
    3f50:	ff 1f       	adc	r31, r31
    3f52:	22 0f       	add	r18, r18
    3f54:	33 1f       	adc	r19, r19
    3f56:	e2 0f       	add	r30, r18
    3f58:	f3 1f       	adc	r31, r19
    3f5a:	ef 5d       	subi	r30, 0xDF	; 223
    3f5c:	fc 4f       	sbci	r31, 0xFC	; 252
    3f5e:	70 87       	std	Z+8, r23	; 0x08
    3f60:	67 83       	std	Z+7, r22	; 0x07

  programList[step].isActive = 1;
    3f62:	81 2f       	mov	r24, r17
    3f64:	90 e0       	ldi	r25, 0x00	; 0
    3f66:	fc 01       	movw	r30, r24
    3f68:	ee 0f       	add	r30, r30
    3f6a:	ff 1f       	adc	r31, r31
    3f6c:	ee 0f       	add	r30, r30
    3f6e:	ff 1f       	adc	r31, r31
    3f70:	ee 0f       	add	r30, r30
    3f72:	ff 1f       	adc	r31, r31
    3f74:	88 0f       	add	r24, r24
    3f76:	99 1f       	adc	r25, r25
    3f78:	e8 0f       	add	r30, r24
    3f7a:	f9 1f       	adc	r31, r25
    3f7c:	ef 5d       	subi	r30, 0xDF	; 223
    3f7e:	fc 4f       	sbci	r31, 0xFC	; 252
    3f80:	81 e0       	ldi	r24, 0x01	; 1
    3f82:	80 83       	st	Z, r24

  if(strcmp(param5, "ABS") == 0){
    3f84:	c7 01       	movw	r24, r14
    3f86:	6e e2       	ldi	r22, 0x2E	; 46
    3f88:	72 e0       	ldi	r23, 0x02	; 2
    3f8a:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    3f8e:	00 97       	sbiw	r24, 0x00	; 0
    3f90:	81 f4       	brne	.+32     	; 0x3fb2 <commandSetProgStep+0x238>
    programList[step].absRel = PROG_ABSOLUTE_MOVEMENT;
    3f92:	81 2f       	mov	r24, r17
    3f94:	90 e0       	ldi	r25, 0x00	; 0
    3f96:	fc 01       	movw	r30, r24
    3f98:	ee 0f       	add	r30, r30
    3f9a:	ff 1f       	adc	r31, r31
    3f9c:	ee 0f       	add	r30, r30
    3f9e:	ff 1f       	adc	r31, r31
    3fa0:	ee 0f       	add	r30, r30
    3fa2:	ff 1f       	adc	r31, r31
    3fa4:	88 0f       	add	r24, r24
    3fa6:	99 1f       	adc	r25, r25
    3fa8:	e8 0f       	add	r30, r24
    3faa:	f9 1f       	adc	r31, r25
    3fac:	ef 5d       	subi	r30, 0xDF	; 223
    3fae:	fc 4f       	sbci	r31, 0xFC	; 252
    3fb0:	11 86       	std	Z+9, r1	; 0x09
  }
  if(strcmp(param5, "REL") == 0){
    3fb2:	c7 01       	movw	r24, r14
    3fb4:	62 e3       	ldi	r22, 0x32	; 50
    3fb6:	72 e0       	ldi	r23, 0x02	; 2
    3fb8:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    3fbc:	00 97       	sbiw	r24, 0x00	; 0
    3fbe:	09 f0       	breq	.+2      	; 0x3fc2 <commandSetProgStep+0x248>
    3fc0:	f5 ce       	rjmp	.-534    	; 0x3dac <commandSetProgStep+0x32>
    programList[step].absRel = PROG_RELATIVE_MOVEMENT;
    3fc2:	81 2f       	mov	r24, r17
    3fc4:	90 e0       	ldi	r25, 0x00	; 0
    3fc6:	fc 01       	movw	r30, r24
    3fc8:	ee 0f       	add	r30, r30
    3fca:	ff 1f       	adc	r31, r31
    3fcc:	ee 0f       	add	r30, r30
    3fce:	ff 1f       	adc	r31, r31
    3fd0:	ee 0f       	add	r30, r30
    3fd2:	ff 1f       	adc	r31, r31
    3fd4:	88 0f       	add	r24, r24
    3fd6:	99 1f       	adc	r25, r25
    3fd8:	e8 0f       	add	r30, r24
    3fda:	f9 1f       	adc	r31, r25
    3fdc:	ef 5d       	subi	r30, 0xDF	; 223
    3fde:	fc 4f       	sbci	r31, 0xFC	; 252
    3fe0:	81 e0       	ldi	r24, 0x01	; 1
    3fe2:	81 87       	std	Z+9, r24	; 0x09
    3fe4:	e3 ce       	rjmp	.-570    	; 0x3dac <commandSetProgStep+0x32>

00003fe6 <commandGetMotorPosition>:

/* ---------------------------------------------------------------------
    returns the actual motor position as string
    the format depends on the given unit
 --------------------------------------------------------------------- */
char* commandGetMotorPosition(char* param0, char* param1){
    3fe6:	0f 93       	push	r16
    3fe8:	cf 93       	push	r28
    3fea:	df 93       	push	r29
    3fec:	eb 01       	movw	r28, r22

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    3fee:	60 e0       	ldi	r22, 0x00	; 0
    3ff0:	70 e0       	ldi	r23, 0x00	; 0
    3ff2:	4a e0       	ldi	r20, 0x0A	; 10
    3ff4:	50 e0       	ldi	r21, 0x00	; 0
    3ff6:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    3ffa:	06 2f       	mov	r16, r22

  if(i > MAX_MOTOR){
    3ffc:	64 30       	cpi	r22, 0x04	; 4
    3ffe:	08 f0       	brcs	.+2      	; 0x4002 <commandGetMotorPosition+0x1c>
    4000:	ac c0       	rjmp	.+344    	; 0x415a <__stack+0x5b>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(strcmp(param1, "steps") == 0){
    4002:	ce 01       	movw	r24, r28
    4004:	66 e3       	ldi	r22, 0x36	; 54
    4006:	72 e0       	ldi	r23, 0x02	; 2
    4008:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    400c:	00 97       	sbiw	r24, 0x00	; 0
    400e:	59 f1       	breq	.+86     	; 0x4066 <commandGetMotorPosition+0x80>
      sprintf(txString.buffer, "%d", motor[i].actualPosition);
    }
    else if(strcmp(param1, "deg") == 0){
    4010:	ce 01       	movw	r24, r28
    4012:	6c e3       	ldi	r22, 0x3C	; 60
    4014:	72 e0       	ldi	r23, 0x02	; 2
    4016:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    401a:	00 97       	sbiw	r24, 0x00	; 0
    401c:	09 f4       	brne	.+2      	; 0x4020 <commandGetMotorPosition+0x3a>
    401e:	60 c0       	rjmp	.+192    	; 0x40e0 <commandGetMotorPosition+0xfa>
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    }
    else if(strcmp(param1, "pi") == 0){
    4020:	ce 01       	movw	r24, r28
    4022:	60 e4       	ldi	r22, 0x40	; 64
    4024:	72 e0       	ldi	r23, 0x02	; 2
    4026:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    402a:	00 97       	sbiw	r24, 0x00	; 0
    402c:	09 f0       	breq	.+2      	; 0x4030 <commandGetMotorPosition+0x4a>
    402e:	58 c0       	rjmp	.+176    	; 0x40e0 <commandGetMotorPosition+0xfa>
      sprintf(txString.buffer, "%f", stepsToRadian(i, motor[i].actualPosition));
    4030:	c0 91 15 04 	lds	r28, 0x0415
    4034:	d0 91 16 04 	lds	r29, 0x0416
    4038:	e0 2f       	mov	r30, r16
    403a:	f0 e0       	ldi	r31, 0x00	; 0
    403c:	ee 0f       	add	r30, r30
    403e:	ff 1f       	adc	r31, r31
    4040:	ee 0f       	add	r30, r30
    4042:	ff 1f       	adc	r31, r31
    4044:	ee 0f       	add	r30, r30
    4046:	ff 1f       	adc	r31, r31
    4048:	cf 01       	movw	r24, r30
    404a:	88 0f       	add	r24, r24
    404c:	99 1f       	adc	r25, r25
    404e:	88 0f       	add	r24, r24
    4050:	99 1f       	adc	r25, r25
    4052:	e8 0f       	add	r30, r24
    4054:	f9 1f       	adc	r31, r25
    4056:	e2 5e       	subi	r30, 0xE2	; 226
    4058:	fb 4f       	sbci	r31, 0xFB	; 251
    405a:	60 81       	ld	r22, Z
    405c:	71 81       	ldd	r23, Z+1	; 0x01
    405e:	80 2f       	mov	r24, r16
    4060:	0e 94 62 08 	call	0x10c4	; 0x10c4 <stepsToRadian>
    4064:	57 c0       	rjmp	.+174    	; 0x4114 <__stack+0x15>
  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(strcmp(param1, "steps") == 0){
      sprintf(txString.buffer, "%d", motor[i].actualPosition);
    4066:	40 91 15 04 	lds	r20, 0x0415
    406a:	50 91 16 04 	lds	r21, 0x0416
    406e:	e0 2f       	mov	r30, r16
    4070:	f0 e0       	ldi	r31, 0x00	; 0
    4072:	ee 0f       	add	r30, r30
    4074:	ff 1f       	adc	r31, r31
    4076:	ee 0f       	add	r30, r30
    4078:	ff 1f       	adc	r31, r31
    407a:	ee 0f       	add	r30, r30
    407c:	ff 1f       	adc	r31, r31
    407e:	cf 01       	movw	r24, r30
    4080:	88 0f       	add	r24, r24
    4082:	99 1f       	adc	r25, r25
    4084:	88 0f       	add	r24, r24
    4086:	99 1f       	adc	r25, r25
    4088:	e8 0f       	add	r30, r24
    408a:	f9 1f       	adc	r31, r25
    408c:	e2 5e       	subi	r30, 0xE2	; 226
    408e:	fb 4f       	sbci	r31, 0xFB	; 251
    4090:	20 81       	ld	r18, Z
    4092:	31 81       	ldd	r19, Z+1	; 0x01
    4094:	00 d0       	rcall	.+0      	; 0x4096 <commandGetMotorPosition+0xb0>
    4096:	00 d0       	rcall	.+0      	; 0x4098 <commandGetMotorPosition+0xb2>
    4098:	00 d0       	rcall	.+0      	; 0x409a <commandGetMotorPosition+0xb4>
    409a:	ed b7       	in	r30, 0x3d	; 61
    409c:	fe b7       	in	r31, 0x3e	; 62
    409e:	31 96       	adiw	r30, 0x01	; 1
    40a0:	ad b7       	in	r26, 0x3d	; 61
    40a2:	be b7       	in	r27, 0x3e	; 62
    40a4:	12 96       	adiw	r26, 0x02	; 2
    40a6:	5c 93       	st	X, r21
    40a8:	4e 93       	st	-X, r20
    40aa:	11 97       	sbiw	r26, 0x01	; 1
    40ac:	87 e1       	ldi	r24, 0x17	; 23
    40ae:	91 e0       	ldi	r25, 0x01	; 1
    40b0:	93 83       	std	Z+3, r25	; 0x03
    40b2:	82 83       	std	Z+2, r24	; 0x02
    40b4:	35 83       	std	Z+5, r19	; 0x05
    40b6:	24 83       	std	Z+4, r18	; 0x04
    40b8:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    40bc:	2d b7       	in	r18, 0x3d	; 61
    40be:	3e b7       	in	r19, 0x3e	; 62
    40c0:	2a 5f       	subi	r18, 0xFA	; 250
    40c2:	3f 4f       	sbci	r19, 0xFF	; 255
    40c4:	0f b6       	in	r0, 0x3f	; 63
    40c6:	f8 94       	cli
    40c8:	3e bf       	out	0x3e, r19	; 62
    40ca:	0f be       	out	0x3f, r0	; 63
    40cc:	2d bf       	out	0x3d, r18	; 61
      /* wrong unit argument returns in degree */
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    }
  }

  return txString.buffer;
    40ce:	20 91 15 04 	lds	r18, 0x0415
    40d2:	30 91 16 04 	lds	r19, 0x0416
}
    40d6:	c9 01       	movw	r24, r18
    40d8:	df 91       	pop	r29
    40da:	cf 91       	pop	r28
    40dc:	0f 91       	pop	r16
    40de:	08 95       	ret
    else if(strcmp(param1, "pi") == 0){
      sprintf(txString.buffer, "%f", stepsToRadian(i, motor[i].actualPosition));
    }
    else{
      /* wrong unit argument returns in degree */
      sprintf(txString.buffer, "%f", stepsToDegree(i, motor[i].actualPosition));
    40e0:	c0 91 15 04 	lds	r28, 0x0415
    40e4:	d0 91 16 04 	lds	r29, 0x0416
    40e8:	e0 2f       	mov	r30, r16
    40ea:	f0 e0       	ldi	r31, 0x00	; 0
    40ec:	ee 0f       	add	r30, r30
    40ee:	ff 1f       	adc	r31, r31
    40f0:	ee 0f       	add	r30, r30
    40f2:	ff 1f       	adc	r31, r31
    40f4:	ee 0f       	add	r30, r30
    40f6:	ff 1f       	adc	r31, r31
    40f8:	cf 01       	movw	r24, r30
    40fa:	88 0f       	add	r24, r24
    40fc:	99 1f       	adc	r25, r25
    40fe:	88 0f       	add	r24, r24
    4100:	99 1f       	adc	r25, r25
    4102:	e8 0f       	add	r30, r24
    4104:	f9 1f       	adc	r31, r25
    4106:	e2 5e       	subi	r30, 0xE2	; 226
    4108:	fb 4f       	sbci	r31, 0xFB	; 251
    410a:	60 81       	ld	r22, Z
    410c:	71 81       	ldd	r23, Z+1	; 0x01
    410e:	80 2f       	mov	r24, r16
    4110:	0e 94 dd 07 	call	0xfba	; 0xfba <stepsToDegree>
    4114:	ad b7       	in	r26, 0x3d	; 61
    4116:	be b7       	in	r27, 0x3e	; 62
    4118:	18 97       	sbiw	r26, 0x08	; 8
    411a:	0f b6       	in	r0, 0x3f	; 63
    411c:	f8 94       	cli
    411e:	be bf       	out	0x3e, r27	; 62
    4120:	0f be       	out	0x3f, r0	; 63
    4122:	ad bf       	out	0x3d, r26	; 61
    4124:	ed b7       	in	r30, 0x3d	; 61
    4126:	fe b7       	in	r31, 0x3e	; 62
    4128:	31 96       	adiw	r30, 0x01	; 1
    412a:	12 96       	adiw	r26, 0x02	; 2
    412c:	dc 93       	st	X, r29
    412e:	ce 93       	st	-X, r28
    4130:	11 97       	sbiw	r26, 0x01	; 1
    4132:	2f e1       	ldi	r18, 0x1F	; 31
    4134:	31 e0       	ldi	r19, 0x01	; 1
    4136:	33 83       	std	Z+3, r19	; 0x03
    4138:	22 83       	std	Z+2, r18	; 0x02
    413a:	64 83       	std	Z+4, r22	; 0x04
    413c:	75 83       	std	Z+5, r23	; 0x05
    413e:	86 83       	std	Z+6, r24	; 0x06
    4140:	97 83       	std	Z+7, r25	; 0x07
    4142:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    4146:	2d b7       	in	r18, 0x3d	; 61
    4148:	3e b7       	in	r19, 0x3e	; 62
    414a:	28 5f       	subi	r18, 0xF8	; 248
    414c:	3f 4f       	sbci	r19, 0xFF	; 255
    414e:	0f b6       	in	r0, 0x3f	; 63
    4150:	f8 94       	cli
    4152:	3e bf       	out	0x3e, r19	; 62
    4154:	0f be       	out	0x3f, r0	; 63
    4156:	2d bf       	out	0x3d, r18	; 61
    4158:	ba cf       	rjmp	.-140    	; 0x40ce <commandGetMotorPosition+0xe8>
  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    415a:	80 91 15 04 	lds	r24, 0x0415
    415e:	90 91 16 04 	lds	r25, 0x0416
    4162:	00 d0       	rcall	.+0      	; 0x4164 <__stack+0x65>
    4164:	00 d0       	rcall	.+0      	; 0x4166 <__stack+0x67>
    4166:	00 d0       	rcall	.+0      	; 0x4168 <__stack+0x69>
    4168:	ed b7       	in	r30, 0x3d	; 61
    416a:	fe b7       	in	r31, 0x3e	; 62
    416c:	31 96       	adiw	r30, 0x01	; 1
    416e:	ad b7       	in	r26, 0x3d	; 61
    4170:	be b7       	in	r27, 0x3e	; 62
    4172:	12 96       	adiw	r26, 0x02	; 2
    4174:	9c 93       	st	X, r25
    4176:	8e 93       	st	-X, r24
    4178:	11 97       	sbiw	r26, 0x01	; 1
    417a:	80 e0       	ldi	r24, 0x00	; 0
    417c:	91 e0       	ldi	r25, 0x01	; 1
    417e:	93 83       	std	Z+3, r25	; 0x03
    4180:	82 83       	std	Z+2, r24	; 0x02
    4182:	04 83       	std	Z+4, r16	; 0x04
    4184:	15 82       	std	Z+5, r1	; 0x05
    4186:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    418a:	2d b7       	in	r18, 0x3d	; 61
    418c:	3e b7       	in	r19, 0x3e	; 62
    418e:	2a 5f       	subi	r18, 0xFA	; 250
    4190:	3f 4f       	sbci	r19, 0xFF	; 255
    4192:	0f b6       	in	r0, 0x3f	; 63
    4194:	f8 94       	cli
    4196:	3e bf       	out	0x3e, r19	; 62
    4198:	0f be       	out	0x3f, r0	; 63
    419a:	2d bf       	out	0x3d, r18	; 61
    419c:	98 cf       	rjmp	.-208    	; 0x40ce <commandGetMotorPosition+0xe8>

0000419e <changeDisplayMenu>:

  uint8_t j = 0;
  uint8_t k = 0;
  uint8_t sLen = 0;

  menuPtr  = (menuItem*)pgm_read_word(&menuList[i]);
    419e:	90 e0       	ldi	r25, 0x00	; 0
    41a0:	88 0f       	add	r24, r24
    41a2:	99 1f       	adc	r25, r25
    41a4:	86 5a       	subi	r24, 0xA6	; 166
    41a6:	9a 4f       	sbci	r25, 0xFA	; 250
    41a8:	fc 01       	movw	r30, r24
    41aa:	25 91       	lpm	r18, Z+
    41ac:	34 91       	lpm	r19, Z+
  menuText = (char*)pgm_read_word(&menuPtr->displayText);
    41ae:	f9 01       	movw	r30, r18
    41b0:	65 91       	lpm	r22, Z+
    41b2:	74 91       	lpm	r23, Z+

  strcpy_P(displayBuffer, menuText);
    41b4:	80 91 19 04 	lds	r24, 0x0419
    41b8:	90 91 1a 04 	lds	r25, 0x041A
    41bc:	0e 94 11 49 	call	0x9222	; 0x9222 <strcpy_P>

  displayBuffer = strtok(displayBuffer, "\n");
    41c0:	80 91 19 04 	lds	r24, 0x0419
    41c4:	90 91 1a 04 	lds	r25, 0x041A
    41c8:	63 e4       	ldi	r22, 0x43	; 67
    41ca:	72 e0       	ldi	r23, 0x02	; 2
    41cc:	0e 94 23 49 	call	0x9246	; 0x9246 <strtok>
    41d0:	bc 01       	movw	r22, r24
    41d2:	90 93 1a 04 	sts	0x041A, r25
    41d6:	80 93 19 04 	sts	0x0419, r24
  strcpy(menu.newMenuText[0], displayBuffer);
    41da:	e0 91 1a 03 	lds	r30, 0x031A
    41de:	f0 91 1b 03 	lds	r31, 0x031B
    41e2:	80 81       	ld	r24, Z
    41e4:	91 81       	ldd	r25, Z+1	; 0x01
    41e6:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
  displayBuffer = strtok(NULL, "\0");
    41ea:	80 e0       	ldi	r24, 0x00	; 0
    41ec:	90 e0       	ldi	r25, 0x00	; 0
    41ee:	65 e4       	ldi	r22, 0x45	; 69
    41f0:	72 e0       	ldi	r23, 0x02	; 2
    41f2:	0e 94 23 49 	call	0x9246	; 0x9246 <strtok>
    41f6:	bc 01       	movw	r22, r24
    41f8:	90 93 1a 04 	sts	0x041A, r25
    41fc:	80 93 19 04 	sts	0x0419, r24
  strcpy(menu.newMenuText[1], displayBuffer);
    4200:	e0 91 1a 03 	lds	r30, 0x031A
    4204:	f0 91 1b 03 	lds	r31, 0x031B
    4208:	82 81       	ldd	r24, Z+2	; 0x02
    420a:	93 81       	ldd	r25, Z+3	; 0x03
    420c:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
    4210:	20 e0       	ldi	r18, 0x00	; 0
    4212:	30 e0       	ldi	r19, 0x00	; 0

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
      menu.newMenuText[j][k] = ' ';
    4214:	90 e2       	ldi	r25, 0x20	; 32
  displayBuffer = strtok(NULL, "\0");
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    4216:	a0 91 1a 03 	lds	r26, 0x031A
    421a:	b0 91 1b 03 	lds	r27, 0x031B
    421e:	a2 0f       	add	r26, r18
    4220:	b3 1f       	adc	r27, r19
    4222:	ec 91       	ld	r30, X
    4224:	11 96       	adiw	r26, 0x01	; 1
    4226:	fc 91       	ld	r31, X
    4228:	df 01       	movw	r26, r30
    422a:	0d 90       	ld	r0, X+
    422c:	00 20       	and	r0, r0
    422e:	e9 f7       	brne	.-6      	; 0x422a <changeDisplayMenu+0x8c>
    4230:	11 97       	sbiw	r26, 0x01	; 1
    4232:	ae 1b       	sub	r26, r30
    4234:	bf 0b       	sbc	r27, r31
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
    4236:	a0 31       	cpi	r26, 0x10	; 16
    4238:	80 f4       	brcc	.+32     	; 0x425a <changeDisplayMenu+0xbc>
    423a:	8a 2f       	mov	r24, r26
      menu.newMenuText[j][k] = ' ';
    423c:	e0 91 1a 03 	lds	r30, 0x031A
    4240:	f0 91 1b 03 	lds	r31, 0x031B
    4244:	e2 0f       	add	r30, r18
    4246:	f3 1f       	adc	r31, r19
    4248:	01 90       	ld	r0, Z+
    424a:	f0 81       	ld	r31, Z
    424c:	e0 2d       	mov	r30, r0
    424e:	e8 0f       	add	r30, r24
    4250:	f1 1d       	adc	r31, r1
    4252:	90 83       	st	Z, r25
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    sLen = strlen(menu.newMenuText[j]);
    for(k = sLen; k < DISPLAY_MENU_STRING_LENGTH-1; k++){
    4254:	8f 5f       	subi	r24, 0xFF	; 255
    4256:	80 31       	cpi	r24, 0x10	; 16
    4258:	88 f3       	brcs	.-30     	; 0x423c <changeDisplayMenu+0x9e>
      menu.newMenuText[j][k] = ' ';
    }
    menu.newMenuText[j][DISPLAY_MENU_STRING_LENGTH-1] = '\0';
    425a:	e0 91 1a 03 	lds	r30, 0x031A
    425e:	f0 91 1b 03 	lds	r31, 0x031B
    4262:	e2 0f       	add	r30, r18
    4264:	f3 1f       	adc	r31, r19
    4266:	01 90       	ld	r0, Z+
    4268:	f0 81       	ld	r31, Z
    426a:	e0 2d       	mov	r30, r0
    426c:	10 8a       	std	Z+16, r1	; 0x10
    426e:	2e 5f       	subi	r18, 0xFE	; 254
    4270:	3f 4f       	sbci	r19, 0xFF	; 255
  strcpy(menu.newMenuText[0], displayBuffer);
  displayBuffer = strtok(NULL, "\0");
  strcpy(menu.newMenuText[1], displayBuffer);

  /* fill the strings up with spaces */
  for(j = 0; j < NUMBER_DISPLAY_MENU_STRINGS; j++){
    4272:	24 30       	cpi	r18, 0x04	; 4
    4274:	31 05       	cpc	r19, r1
    4276:	79 f6       	brne	.-98     	; 0x4216 <changeDisplayMenu+0x78>
    }
    menu.newMenuText[j][DISPLAY_MENU_STRING_LENGTH-1] = '\0';
  }

  return;
}
    4278:	08 95       	ret

0000427a <parseCommand>:
}

/* ---------------------------------------------------------------------
    returns the command code and fills the parameter list
 --------------------------------------------------------------------- */
uint8_t parseCommand(void){
    427a:	af 92       	push	r10
    427c:	bf 92       	push	r11
    427e:	cf 92       	push	r12
    4280:	df 92       	push	r13
    4282:	ef 92       	push	r14
    4284:	ff 92       	push	r15
    4286:	0f 93       	push	r16
    4288:	1f 93       	push	r17
    428a:	cf 93       	push	r28
    428c:	df 93       	push	r29
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    428e:	f8 94       	cli
  //uint8_t j = 0;
  command *cmdPtr;
  char *token;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
    4290:	80 91 c0 04 	lds	r24, 0x04C0
    4294:	88 23       	and	r24, r24
    4296:	79 f4       	brne	.+30     	; 0x42b6 <parseCommand+0x3c>
    4298:	b0 e8       	ldi	r27, 0x80	; 128
    429a:	ab 2e       	mov	r10, r27
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    429c:	78 94       	sei
      commandString.readyToProcess = 0;
    }
  }

  return commandCode;
}
    429e:	8a 2d       	mov	r24, r10
    42a0:	df 91       	pop	r29
    42a2:	cf 91       	pop	r28
    42a4:	1f 91       	pop	r17
    42a6:	0f 91       	pop	r16
    42a8:	ff 90       	pop	r15
    42aa:	ef 90       	pop	r14
    42ac:	df 90       	pop	r13
    42ae:	cf 90       	pop	r12
    42b0:	bf 90       	pop	r11
    42b2:	af 90       	pop	r10
    42b4:	08 95       	ret
  char *token;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
      /* extract command and get cmdCode */
      token = strtok(commandString.buffer, ALLOWED_CMD_DELIMITERS);
    42b6:	80 91 be 04 	lds	r24, 0x04BE
    42ba:	90 91 bf 04 	lds	r25, 0x04BF
    42be:	67 e4       	ldi	r22, 0x47	; 71
    42c0:	72 e0       	ldi	r23, 0x02	; 2
    42c2:	0e 94 23 49 	call	0x9246	; 0x9246 <strtok>
    42c6:	6c 01       	movw	r12, r24
    42c8:	0e e2       	ldi	r16, 0x2E	; 46
    42ca:	13 e0       	ldi	r17, 0x03	; 3
    42cc:	a0 e8       	ldi	r26, 0x80	; 128
    42ce:	aa 2e       	mov	r10, r26
    42d0:	bb 24       	eor	r11, r11
    42d2:	e0 90 04 03 	lds	r14, 0x0304
    42d6:	f0 90 05 03 	lds	r15, 0x0305

      for(i = 0; i < TOTAL_NUMBER_OF_COMMANDS; i++){            /* loop over all commands */
        cmdPtr = (command*)pgm_read_word(&commandList[i]);      /* pointer to struct in flash */
    42da:	f8 01       	movw	r30, r16
    42dc:	c5 91       	lpm	r28, Z+
    42de:	d4 91       	lpm	r29, Z+
        strcpy_P(commandParam[0], pgm_read_word(&cmdPtr->cmd)); /* contents of command code in flash */
    42e0:	fe 01       	movw	r30, r28
    42e2:	65 91       	lpm	r22, Z+
    42e4:	74 91       	lpm	r23, Z+
    42e6:	d7 01       	movw	r26, r14
    42e8:	8d 91       	ld	r24, X+
    42ea:	9c 91       	ld	r25, X
    42ec:	0e 94 11 49 	call	0x9222	; 0x9222 <strcpy_P>

        if(strcmp(token, commandParam[0]) == 0){
    42f0:	e0 90 04 03 	lds	r14, 0x0304
    42f4:	f0 90 05 03 	lds	r15, 0x0305
    42f8:	f7 01       	movw	r30, r14
    42fa:	60 81       	ld	r22, Z
    42fc:	71 81       	ldd	r23, Z+1	; 0x01
    42fe:	c6 01       	movw	r24, r12
    4300:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4304:	00 97       	sbiw	r24, 0x00	; 0
    4306:	41 f4       	brne	.+16     	; 0x4318 <parseCommand+0x9e>
          /* found a known command */
          commandCode = (uint8_t)pgm_read_byte(&cmdPtr->cmdCode);
    4308:	23 96       	adiw	r28, 0x03	; 3
    430a:	fe 01       	movw	r30, r28
    430c:	94 91       	lpm	r25, Z+
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
    430e:	21 97       	sbiw	r28, 0x01	; 1
    4310:	fe 01       	movw	r30, r28
    4312:	84 91       	lpm	r24, Z+
    4314:	a9 2e       	mov	r10, r25
    4316:	b8 2e       	mov	r11, r24
    4318:	0e 5f       	subi	r16, 0xFE	; 254
    431a:	1f 4f       	sbci	r17, 0xFF	; 255
  ATOMIC_BLOCK(ATOMIC_FORCEON){
    if(commandString.readyToProcess){
      /* extract command and get cmdCode */
      token = strtok(commandString.buffer, ALLOWED_CMD_DELIMITERS);

      for(i = 0; i < TOTAL_NUMBER_OF_COMMANDS; i++){            /* loop over all commands */
    431c:	f3 e0       	ldi	r31, 0x03	; 3
    431e:	08 37       	cpi	r16, 0x78	; 120
    4320:	1f 07       	cpc	r17, r31
    4322:	d9 f6       	brne	.-74     	; 0x42da <parseCommand+0x60>
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
        }
      }

      /* now parse the command parameters into tokens */
      for(i = 1; i <= noOfOpts; i++){
    4324:	bb 20       	and	r11, r11
    4326:	c9 f0       	breq	.+50     	; 0x435a <parseCommand+0xe0>
    4328:	11 e0       	ldi	r17, 0x01	; 1
        token = strtok(NULL, ALLOWED_CMD_DELIMITERS);
    432a:	80 e0       	ldi	r24, 0x00	; 0
    432c:	90 e0       	ldi	r25, 0x00	; 0
    432e:	67 e4       	ldi	r22, 0x47	; 71
    4330:	72 e0       	ldi	r23, 0x02	; 2
    4332:	0e 94 23 49 	call	0x9246	; 0x9246 <strtok>
    4336:	bc 01       	movw	r22, r24
        strcpy(commandParam[i], token);
    4338:	81 2f       	mov	r24, r17
    433a:	90 e0       	ldi	r25, 0x00	; 0
    433c:	88 0f       	add	r24, r24
    433e:	99 1f       	adc	r25, r25
    4340:	e0 91 04 03 	lds	r30, 0x0304
    4344:	f0 91 05 03 	lds	r31, 0x0305
    4348:	e8 0f       	add	r30, r24
    434a:	f9 1f       	adc	r31, r25
    434c:	80 81       	ld	r24, Z
    434e:	91 81       	ldd	r25, Z+1	; 0x01
    4350:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
          noOfOpts = (int8_t)pgm_read_byte(&cmdPtr->numberOfOptions);
        }
      }

      /* now parse the command parameters into tokens */
      for(i = 1; i <= noOfOpts; i++){
    4354:	1f 5f       	subi	r17, 0xFF	; 255
    4356:	b1 16       	cp	r11, r17
    4358:	40 f7       	brcc	.-48     	; 0x432a <parseCommand+0xb0>
        token = strtok(NULL, ALLOWED_CMD_DELIMITERS);
        strcpy(commandParam[i], token);
      }

      memset(commandString.buffer, 0, SERIAL_BUFFERSIZE);
    435a:	e0 91 be 04 	lds	r30, 0x04BE
    435e:	f0 91 bf 04 	lds	r31, 0x04BF
    4362:	80 e4       	ldi	r24, 0x40	; 64
    4364:	df 01       	movw	r26, r30
    4366:	1d 92       	st	X+, r1
    4368:	8a 95       	dec	r24
    436a:	e9 f7       	brne	.-6      	; 0x4366 <parseCommand+0xec>
      commandString.readyToProcess = 0;
    436c:	10 92 c0 04 	sts	0x04C0, r1
    4370:	95 cf       	rjmp	.-214    	; 0x429c <parseCommand+0x22>

00004372 <sendText>:
}

/* ---------------------------------------------------------------------
    sends a terminated string via RS232
 --------------------------------------------------------------------- */
void sendText(char *c){
    4372:	fc 01       	movw	r30, r24

  while(*c){
    4374:	90 81       	ld	r25, Z
    4376:	99 23       	and	r25, r25
    4378:	51 f0       	breq	.+20     	; 0x438e <sendText+0x1c>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    437a:	80 91 c0 00 	lds	r24, 0x00C0
    437e:	85 ff       	sbrs	r24, 5
    4380:	fc cf       	rjmp	.-8      	; 0x437a <sendText+0x8>
    ;
  }

  UDR0 = c;
    4382:	90 93 c6 00 	sts	0x00C6, r25
 --------------------------------------------------------------------- */
void sendText(char *c){

  while(*c){
    sendChar(*c);
    c++;
    4386:	31 96       	adiw	r30, 0x01	; 1
/* ---------------------------------------------------------------------
    sends a terminated string via RS232
 --------------------------------------------------------------------- */
void sendText(char *c){

  while(*c){
    4388:	90 81       	ld	r25, Z
    438a:	99 23       	and	r25, r25
    438c:	b1 f7       	brne	.-20     	; 0x437a <sendText+0x8>
/* ---------------------------------------------------------------------
    sends a character via RS232
 --------------------------------------------------------------------- */
void sendChar(char c){

  while(!(UCSR0A & (1<<UDRE0))){
    438e:	80 91 c0 00 	lds	r24, 0x00C0
    4392:	85 ff       	sbrs	r24, 5
    4394:	fc cf       	rjmp	.-8      	; 0x438e <sendText+0x1c>
    ;
  }

  UDR0 = c;
    4396:	8a e0       	ldi	r24, 0x0A	; 10
    4398:	80 93 c6 00 	sts	0x00C6, r24
    c++;
  }
  /* send LF after finishing text sending */
  sendChar('\n');

  memset(txString.buffer, 0, SERIAL_BUFFERSIZE);
    439c:	e0 91 15 04 	lds	r30, 0x0415
    43a0:	f0 91 16 04 	lds	r31, 0x0416
    43a4:	80 e4       	ldi	r24, 0x40	; 64
    43a6:	df 01       	movw	r26, r30
    43a8:	1d 92       	st	X+, r1
    43aa:	8a 95       	dec	r24
    43ac:	e9 f7       	brne	.-6      	; 0x43a8 <sendText+0x36>

  return;
}
    43ae:	08 95       	ret

000043b0 <commandLED>:


/* ---------------------------------------------------------------------
    debugging output for anything we'd like to know
 --------------------------------------------------------------------- */
void commandLED(char* param0, char* param1, char* param2){
    43b0:	df 92       	push	r13
    43b2:	ef 92       	push	r14
    43b4:	ff 92       	push	r15
    43b6:	0f 93       	push	r16
    43b8:	1f 93       	push	r17
    43ba:	8b 01       	movw	r16, r22
    43bc:	7a 01       	movw	r14, r20

  uint8_t a, b, c;

  a = (uint8_t)strtol(param0, (char **)NULL, 10);
    43be:	60 e0       	ldi	r22, 0x00	; 0
    43c0:	70 e0       	ldi	r23, 0x00	; 0
    43c2:	4a e0       	ldi	r20, 0x0A	; 10
    43c4:	50 e0       	ldi	r21, 0x00	; 0
    43c6:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    43ca:	d6 2e       	mov	r13, r22
  b = (uint8_t)strtol(param1, (char **)NULL, 10);
    43cc:	c8 01       	movw	r24, r16
    43ce:	60 e0       	ldi	r22, 0x00	; 0
    43d0:	70 e0       	ldi	r23, 0x00	; 0
    43d2:	4a e0       	ldi	r20, 0x0A	; 10
    43d4:	50 e0       	ldi	r21, 0x00	; 0
    43d6:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    43da:	06 2f       	mov	r16, r22
  c = (uint8_t)strtol(param2, (char **)NULL, 16);
    43dc:	c7 01       	movw	r24, r14
    43de:	60 e0       	ldi	r22, 0x00	; 0
    43e0:	70 e0       	ldi	r23, 0x00	; 0
    43e2:	40 e1       	ldi	r20, 0x10	; 16
    43e4:	50 e0       	ldi	r21, 0x00	; 0
    43e6:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    43ea:	16 2f       	mov	r17, r22
  
  sprintf(txString.buffer, "\na=%d\nb=%d\nc=%d", a, b, c);
    43ec:	80 91 15 04 	lds	r24, 0x0415
    43f0:	90 91 16 04 	lds	r25, 0x0416
    43f4:	2d b7       	in	r18, 0x3d	; 61
    43f6:	3e b7       	in	r19, 0x3e	; 62
    43f8:	2a 50       	subi	r18, 0x0A	; 10
    43fa:	30 40       	sbci	r19, 0x00	; 0
    43fc:	0f b6       	in	r0, 0x3f	; 63
    43fe:	f8 94       	cli
    4400:	3e bf       	out	0x3e, r19	; 62
    4402:	0f be       	out	0x3f, r0	; 63
    4404:	2d bf       	out	0x3d, r18	; 61
    4406:	ed b7       	in	r30, 0x3d	; 61
    4408:	fe b7       	in	r31, 0x3e	; 62
    440a:	31 96       	adiw	r30, 0x01	; 1
    440c:	ad b7       	in	r26, 0x3d	; 61
    440e:	be b7       	in	r27, 0x3e	; 62
    4410:	12 96       	adiw	r26, 0x02	; 2
    4412:	9c 93       	st	X, r25
    4414:	8e 93       	st	-X, r24
    4416:	11 97       	sbiw	r26, 0x01	; 1
    4418:	8c e4       	ldi	r24, 0x4C	; 76
    441a:	92 e0       	ldi	r25, 0x02	; 2
    441c:	93 83       	std	Z+3, r25	; 0x03
    441e:	82 83       	std	Z+2, r24	; 0x02
    4420:	d4 82       	std	Z+4, r13	; 0x04
    4422:	15 82       	std	Z+5, r1	; 0x05
    4424:	06 83       	std	Z+6, r16	; 0x06
    4426:	17 82       	std	Z+7, r1	; 0x07
    4428:	10 87       	std	Z+8, r17	; 0x08
    442a:	11 86       	std	Z+9, r1	; 0x09
    442c:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
  sendText(txString.buffer);
    4430:	80 91 15 04 	lds	r24, 0x0415
    4434:	90 91 16 04 	lds	r25, 0x0416
    4438:	2d b7       	in	r18, 0x3d	; 61
    443a:	3e b7       	in	r19, 0x3e	; 62
    443c:	26 5f       	subi	r18, 0xF6	; 246
    443e:	3f 4f       	sbci	r19, 0xFF	; 255
    4440:	0f b6       	in	r0, 0x3f	; 63
    4442:	f8 94       	cli
    4444:	3e bf       	out	0x3e, r19	; 62
    4446:	0f be       	out	0x3f, r0	; 63
    4448:	2d bf       	out	0x3d, r18	; 61
    444a:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>

  changeButtonLED(a, b, c);
    444e:	8d 2d       	mov	r24, r13
    4450:	60 2f       	mov	r22, r16
    4452:	41 2f       	mov	r20, r17
    4454:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
  updateLEDs();
    4458:	0e 94 6b 07 	call	0xed6	; 0xed6 <updateLEDs>
  
  return;
}
    445c:	1f 91       	pop	r17
    445e:	0f 91       	pop	r16
    4460:	ff 90       	pop	r15
    4462:	ef 90       	pop	r14
    4464:	df 90       	pop	r13
    4466:	08 95       	ret

00004468 <commandDebugReadout>:
}

/* ---------------------------------------------------------------------
    debugging output for anything we'd like to know
 --------------------------------------------------------------------- */
void commandDebugReadout(){
    4468:	af 92       	push	r10
    446a:	bf 92       	push	r11
    446c:	cf 92       	push	r12
    446e:	df 92       	push	r13
    4470:	ef 92       	push	r14
    4472:	ff 92       	push	r15
    4474:	0f 93       	push	r16
    4476:	1f 93       	push	r17
    4478:	cf 93       	push	r28
    447a:	df 93       	push	r29
    447c:	c0 e0       	ldi	r28, 0x00	; 0
    447e:	d0 e0       	ldi	r29, 0x00	; 0
    4480:	7c e5       	ldi	r23, 0x5C	; 92
    4482:	c7 2e       	mov	r12, r23
    4484:	72 e0       	ldi	r23, 0x02	; 2
    4486:	d7 2e       	mov	r13, r23

  uint8_t i = 0;

  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    sprintf(txString.buffer, "%d %d %d %d %d %d %d", i, programList[i].position[0],
    4488:	e0 90 15 04 	lds	r14, 0x0415
    448c:	f0 90 16 04 	lds	r15, 0x0416
    4490:	ce 01       	movw	r24, r28
    4492:	fe 01       	movw	r30, r28
    4494:	ee 0f       	add	r30, r30
    4496:	ff 1f       	adc	r31, r31
    4498:	ee 0f       	add	r30, r30
    449a:	ff 1f       	adc	r31, r31
    449c:	ee 0f       	add	r30, r30
    449e:	ff 1f       	adc	r31, r31
    44a0:	88 0f       	add	r24, r24
    44a2:	99 1f       	adc	r25, r25
    44a4:	e8 0f       	add	r30, r24
    44a6:	f9 1f       	adc	r31, r25
    44a8:	ef 5d       	subi	r30, 0xDF	; 223
    44aa:	fc 4f       	sbci	r31, 0xFC	; 252
    44ac:	01 81       	ldd	r16, Z+1	; 0x01
    44ae:	12 81       	ldd	r17, Z+2	; 0x02
    44b0:	ce 01       	movw	r24, r28
    44b2:	fe 01       	movw	r30, r28
    44b4:	ee 0f       	add	r30, r30
    44b6:	ff 1f       	adc	r31, r31
    44b8:	ee 0f       	add	r30, r30
    44ba:	ff 1f       	adc	r31, r31
    44bc:	ee 0f       	add	r30, r30
    44be:	ff 1f       	adc	r31, r31
    44c0:	88 0f       	add	r24, r24
    44c2:	99 1f       	adc	r25, r25
    44c4:	e8 0f       	add	r30, r24
    44c6:	f9 1f       	adc	r31, r25
    44c8:	ef 5d       	subi	r30, 0xDF	; 223
    44ca:	fc 4f       	sbci	r31, 0xFC	; 252
    44cc:	a3 80       	ldd	r10, Z+3	; 0x03
    44ce:	b4 80       	ldd	r11, Z+4	; 0x04
    44d0:	ce 01       	movw	r24, r28
    44d2:	fe 01       	movw	r30, r28
    44d4:	ee 0f       	add	r30, r30
    44d6:	ff 1f       	adc	r31, r31
    44d8:	ee 0f       	add	r30, r30
    44da:	ff 1f       	adc	r31, r31
    44dc:	ee 0f       	add	r30, r30
    44de:	ff 1f       	adc	r31, r31
    44e0:	88 0f       	add	r24, r24
    44e2:	99 1f       	adc	r25, r25
    44e4:	e8 0f       	add	r30, r24
    44e6:	f9 1f       	adc	r31, r25
    44e8:	ef 5d       	subi	r30, 0xDF	; 223
    44ea:	fc 4f       	sbci	r31, 0xFC	; 252
    44ec:	45 81       	ldd	r20, Z+5	; 0x05
    44ee:	56 81       	ldd	r21, Z+6	; 0x06
    44f0:	ce 01       	movw	r24, r28
    44f2:	fe 01       	movw	r30, r28
    44f4:	ee 0f       	add	r30, r30
    44f6:	ff 1f       	adc	r31, r31
    44f8:	ee 0f       	add	r30, r30
    44fa:	ff 1f       	adc	r31, r31
    44fc:	ee 0f       	add	r30, r30
    44fe:	ff 1f       	adc	r31, r31
    4500:	88 0f       	add	r24, r24
    4502:	99 1f       	adc	r25, r25
    4504:	e8 0f       	add	r30, r24
    4506:	f9 1f       	adc	r31, r25
    4508:	ef 5d       	subi	r30, 0xDF	; 223
    450a:	fc 4f       	sbci	r31, 0xFC	; 252
    450c:	27 81       	ldd	r18, Z+7	; 0x07
    450e:	30 85       	ldd	r19, Z+8	; 0x08
    4510:	ce 01       	movw	r24, r28
    4512:	fe 01       	movw	r30, r28
    4514:	ee 0f       	add	r30, r30
    4516:	ff 1f       	adc	r31, r31
    4518:	ee 0f       	add	r30, r30
    451a:	ff 1f       	adc	r31, r31
    451c:	ee 0f       	add	r30, r30
    451e:	ff 1f       	adc	r31, r31
    4520:	88 0f       	add	r24, r24
    4522:	99 1f       	adc	r25, r25
    4524:	e8 0f       	add	r30, r24
    4526:	f9 1f       	adc	r31, r25
    4528:	ef 5d       	subi	r30, 0xDF	; 223
    452a:	fc 4f       	sbci	r31, 0xFC	; 252
    452c:	61 85       	ldd	r22, Z+9	; 0x09
    452e:	ce 01       	movw	r24, r28
    4530:	fe 01       	movw	r30, r28
    4532:	ee 0f       	add	r30, r30
    4534:	ff 1f       	adc	r31, r31
    4536:	ee 0f       	add	r30, r30
    4538:	ff 1f       	adc	r31, r31
    453a:	ee 0f       	add	r30, r30
    453c:	ff 1f       	adc	r31, r31
    453e:	88 0f       	add	r24, r24
    4540:	99 1f       	adc	r25, r25
    4542:	e8 0f       	add	r30, r24
    4544:	f9 1f       	adc	r31, r25
    4546:	ef 5d       	subi	r30, 0xDF	; 223
    4548:	fc 4f       	sbci	r31, 0xFC	; 252
    454a:	80 81       	ld	r24, Z
    454c:	ad b7       	in	r26, 0x3d	; 61
    454e:	be b7       	in	r27, 0x3e	; 62
    4550:	52 97       	sbiw	r26, 0x12	; 18
    4552:	0f b6       	in	r0, 0x3f	; 63
    4554:	f8 94       	cli
    4556:	be bf       	out	0x3e, r27	; 62
    4558:	0f be       	out	0x3f, r0	; 63
    455a:	ad bf       	out	0x3d, r26	; 61
    455c:	ed b7       	in	r30, 0x3d	; 61
    455e:	fe b7       	in	r31, 0x3e	; 62
    4560:	31 96       	adiw	r30, 0x01	; 1
    4562:	12 96       	adiw	r26, 0x02	; 2
    4564:	fc 92       	st	X, r15
    4566:	ee 92       	st	-X, r14
    4568:	11 97       	sbiw	r26, 0x01	; 1
    456a:	d3 82       	std	Z+3, r13	; 0x03
    456c:	c2 82       	std	Z+2, r12	; 0x02
    456e:	c4 83       	std	Z+4, r28	; 0x04
    4570:	d5 83       	std	Z+5, r29	; 0x05
    4572:	17 83       	std	Z+7, r17	; 0x07
    4574:	06 83       	std	Z+6, r16	; 0x06
    4576:	b1 86       	std	Z+9, r11	; 0x09
    4578:	a0 86       	std	Z+8, r10	; 0x08
    457a:	53 87       	std	Z+11, r21	; 0x0b
    457c:	42 87       	std	Z+10, r20	; 0x0a
    457e:	35 87       	std	Z+13, r19	; 0x0d
    4580:	24 87       	std	Z+12, r18	; 0x0c
    4582:	66 87       	std	Z+14, r22	; 0x0e
    4584:	17 86       	std	Z+15, r1	; 0x0f
    4586:	80 8b       	std	Z+16, r24	; 0x10
    4588:	11 8a       	std	Z+17, r1	; 0x11
    458a:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
                                                        programList[i].position[1],
                                                        programList[i].position[2],
                                                        programList[i].position[3],
                                                        programList[i].absRel,
                                                        programList[i].isActive);
    sendText(txString.buffer);
    458e:	80 91 15 04 	lds	r24, 0x0415
    4592:	90 91 16 04 	lds	r25, 0x0416
    4596:	ed b7       	in	r30, 0x3d	; 61
    4598:	fe b7       	in	r31, 0x3e	; 62
    459a:	72 96       	adiw	r30, 0x12	; 18
    459c:	0f b6       	in	r0, 0x3f	; 63
    459e:	f8 94       	cli
    45a0:	fe bf       	out	0x3e, r31	; 62
    45a2:	0f be       	out	0x3f, r0	; 63
    45a4:	ed bf       	out	0x3d, r30	; 61
    45a6:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    45aa:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void commandDebugReadout(){

  uint8_t i = 0;

  for(i = 0; i < MAX_PROGRAM_STEPS; i++){
    45ac:	c0 31       	cpi	r28, 0x10	; 16
    45ae:	d1 05       	cpc	r29, r1
    45b0:	09 f0       	breq	.+2      	; 0x45b4 <commandDebugReadout+0x14c>
    45b2:	6a cf       	rjmp	.-300    	; 0x4488 <commandDebugReadout+0x20>
                                                        programList[i].isActive);
    sendText(txString.buffer);
  }

  return;
}
    45b4:	df 91       	pop	r29
    45b6:	cf 91       	pop	r28
    45b8:	1f 91       	pop	r17
    45ba:	0f 91       	pop	r16
    45bc:	ff 90       	pop	r15
    45be:	ef 90       	pop	r14
    45c0:	df 90       	pop	r13
    45c2:	cf 90       	pop	r12
    45c4:	bf 90       	pop	r11
    45c6:	af 90       	pop	r10
    45c8:	08 95       	ret

000045ca <commandGetMotorState>:
void commandGetMotorState(char* param0){

  uint8_t i = 0;
  //uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    45ca:	60 e0       	ldi	r22, 0x00	; 0
    45cc:	70 e0       	ldi	r23, 0x00	; 0
    45ce:	4a e0       	ldi	r20, 0x0A	; 10
    45d0:	50 e0       	ldi	r21, 0x00	; 0
    45d2:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    45d6:	64 30       	cpi	r22, 0x04	; 4
    45d8:	90 f5       	brcc	.+100    	; 0x463e <commandGetMotorState+0x74>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    if(motor[i].isTurnedOn){
    45da:	e6 2f       	mov	r30, r22
    45dc:	f0 e0       	ldi	r31, 0x00	; 0
    45de:	ee 0f       	add	r30, r30
    45e0:	ff 1f       	adc	r31, r31
    45e2:	ee 0f       	add	r30, r30
    45e4:	ff 1f       	adc	r31, r31
    45e6:	ee 0f       	add	r30, r30
    45e8:	ff 1f       	adc	r31, r31
    45ea:	cf 01       	movw	r24, r30
    45ec:	88 0f       	add	r24, r24
    45ee:	99 1f       	adc	r25, r25
    45f0:	88 0f       	add	r24, r24
    45f2:	99 1f       	adc	r25, r25
    45f4:	e8 0f       	add	r30, r24
    45f6:	f9 1f       	adc	r31, r25
    45f8:	e2 5e       	subi	r30, 0xE2	; 226
    45fa:	fb 4f       	sbci	r31, 0xFB	; 251
    45fc:	83 85       	ldd	r24, Z+11	; 0x0b
    45fe:	88 23       	and	r24, r24
    4600:	79 f4       	brne	.+30     	; 0x4620 <commandGetMotorState+0x56>
      sprintf(txString.buffer, "1");
    }
    else{
      sprintf(txString.buffer, "0");
    4602:	e0 91 15 04 	lds	r30, 0x0415
    4606:	f0 91 16 04 	lds	r31, 0x0416
    460a:	80 e3       	ldi	r24, 0x30	; 48
    460c:	90 e0       	ldi	r25, 0x00	; 0
    460e:	91 83       	std	Z+1, r25	; 0x01
    4610:	80 83       	st	Z, r24
    }

    sendText(txString.buffer);
    4612:	80 91 15 04 	lds	r24, 0x0415
    4616:	90 91 16 04 	lds	r25, 0x0416
    461a:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    461e:	08 95       	ret
    sendText(txString.buffer);
    return;
  }
  else{
    if(motor[i].isTurnedOn){
      sprintf(txString.buffer, "1");
    4620:	e0 91 15 04 	lds	r30, 0x0415
    4624:	f0 91 16 04 	lds	r31, 0x0416
    4628:	81 e3       	ldi	r24, 0x31	; 49
    462a:	90 e0       	ldi	r25, 0x00	; 0
    462c:	91 83       	std	Z+1, r25	; 0x01
    462e:	80 83       	st	Z, r24
    }
    else{
      sprintf(txString.buffer, "0");
    }

    sendText(txString.buffer);
    4630:	80 91 15 04 	lds	r24, 0x0415
    4634:	90 91 16 04 	lds	r25, 0x0416
    4638:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    463c:	08 95       	ret
  //uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    463e:	a0 91 15 04 	lds	r26, 0x0415
    4642:	b0 91 16 04 	lds	r27, 0x0416
    4646:	e1 e7       	ldi	r30, 0x71	; 113
    4648:	f2 e0       	ldi	r31, 0x02	; 2
    464a:	83 e1       	ldi	r24, 0x13	; 19
    464c:	01 90       	ld	r0, Z+
    464e:	0d 92       	st	X+, r0
    4650:	81 50       	subi	r24, 0x01	; 1
    4652:	e1 f7       	brne	.-8      	; 0x464c <commandGetMotorState+0x82>
    4654:	de cf       	rjmp	.-68     	; 0x4612 <commandGetMotorState+0x48>

00004656 <commandEnableForbiddenZone>:
}

/* ---------------------------------------------------------------------
    enable/disable forbidden zone
 --------------------------------------------------------------------- */
void commandEnableForbiddenZone(char* param0, char* param1){
    4656:	1f 93       	push	r17
    4658:	cf 93       	push	r28
    465a:	df 93       	push	r29
    465c:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    465e:	60 e0       	ldi	r22, 0x00	; 0
    4660:	70 e0       	ldi	r23, 0x00	; 0
    4662:	4a e0       	ldi	r20, 0x0A	; 10
    4664:	50 e0       	ldi	r21, 0x00	; 0
    4666:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    466a:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    466c:	64 30       	cpi	r22, 0x04	; 4
    466e:	b8 f4       	brcc	.+46     	; 0x469e <commandEnableForbiddenZone+0x48>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    val = (uint8_t)strtol(param1, (char **)NULL, 10);
    4670:	ce 01       	movw	r24, r28
    4672:	60 e0       	ldi	r22, 0x00	; 0
    4674:	70 e0       	ldi	r23, 0x00	; 0
    4676:	4a e0       	ldi	r20, 0x0A	; 10
    4678:	50 e0       	ldi	r21, 0x00	; 0
    467a:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    forbiddenZone[i].active = val;
    467e:	81 2f       	mov	r24, r17
    4680:	90 e0       	ldi	r25, 0x00	; 0
    4682:	fc 01       	movw	r30, r24
    4684:	ee 0f       	add	r30, r30
    4686:	ff 1f       	adc	r31, r31
    4688:	ee 0f       	add	r30, r30
    468a:	ff 1f       	adc	r31, r31
    468c:	e8 0f       	add	r30, r24
    468e:	f9 1f       	adc	r31, r25
    4690:	ef 5f       	subi	r30, 0xFF	; 255
    4692:	fb 4f       	sbci	r31, 0xFB	; 251
    4694:	64 83       	std	Z+4, r22	; 0x04
  }

  return;
}
    4696:	df 91       	pop	r29
    4698:	cf 91       	pop	r28
    469a:	1f 91       	pop	r17
    469c:	08 95       	ret
  uint8_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    469e:	a0 91 15 04 	lds	r26, 0x0415
    46a2:	b0 91 16 04 	lds	r27, 0x0416
    46a6:	e1 e7       	ldi	r30, 0x71	; 113
    46a8:	f2 e0       	ldi	r31, 0x02	; 2
    46aa:	83 e1       	ldi	r24, 0x13	; 19
    46ac:	01 90       	ld	r0, Z+
    46ae:	0d 92       	st	X+, r0
    46b0:	81 50       	subi	r24, 0x01	; 1
    46b2:	e1 f7       	brne	.-8      	; 0x46ac <commandEnableForbiddenZone+0x56>
    sendText(txString.buffer);
    46b4:	80 91 15 04 	lds	r24, 0x0415
    46b8:	90 91 16 04 	lds	r25, 0x0416
    46bc:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    46c0:	ea cf       	rjmp	.-44     	; 0x4696 <commandEnableForbiddenZone+0x40>

000046c2 <commandSetForbiddenZone>:
}

/* ---------------------------------------------------------------------
    defines forbidden zone
 --------------------------------------------------------------------- */
void commandSetForbiddenZone(char* param0, char* param1, char* param2){
    46c2:	ff 92       	push	r15
    46c4:	0f 93       	push	r16
    46c6:	1f 93       	push	r17
    46c8:	cf 93       	push	r28
    46ca:	df 93       	push	r29
    46cc:	eb 01       	movw	r28, r22
    46ce:	8a 01       	movw	r16, r20
  uint8_t i = 0;
  int16_t start = 0;
  int16_t stop  = 0;
  int16_t swap = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    46d0:	60 e0       	ldi	r22, 0x00	; 0
    46d2:	70 e0       	ldi	r23, 0x00	; 0
    46d4:	4a e0       	ldi	r20, 0x0A	; 10
    46d6:	50 e0       	ldi	r21, 0x00	; 0
    46d8:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    46dc:	f6 2e       	mov	r15, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    46de:	83 e0       	ldi	r24, 0x03	; 3
    46e0:	8f 15       	cp	r24, r15
    46e2:	28 f1       	brcs	.+74     	; 0x472e <commandSetForbiddenZone+0x6c>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    start = (int16_t)atoi(param1);
    46e4:	ce 01       	movw	r24, r28
    46e6:	0e 94 13 48 	call	0x9026	; 0x9026 <atoi>
    46ea:	ec 01       	movw	r28, r24
    stop  = (int16_t)atoi(param2);
    46ec:	c8 01       	movw	r24, r16
    46ee:	0e 94 13 48 	call	0x9026	; 0x9026 <atoi>
    46f2:	ac 01       	movw	r20, r24

    if(start == stop){
    46f4:	c8 17       	cp	r28, r24
    46f6:	d9 07       	cpc	r29, r25
    46f8:	79 f1       	breq	.+94     	; 0x4758 <commandSetForbiddenZone+0x96>
      forbiddenZone[i].stop   = 0;
      forbiddenZone[i].active = 0;
      return;
    }

    if(start > stop){
    46fa:	8c 17       	cp	r24, r28
    46fc:	9d 07       	cpc	r25, r29
    46fe:	4c f1       	brlt	.+82     	; 0x4752 <commandSetForbiddenZone+0x90>
      swap = stop;
      stop = start;
      start = swap;
    }

    forbiddenZone[i].start  = start;
    4700:	8f 2d       	mov	r24, r15
    4702:	90 e0       	ldi	r25, 0x00	; 0
    4704:	fc 01       	movw	r30, r24
    4706:	ee 0f       	add	r30, r30
    4708:	ff 1f       	adc	r31, r31
    470a:	ee 0f       	add	r30, r30
    470c:	ff 1f       	adc	r31, r31
    470e:	e8 0f       	add	r30, r24
    4710:	f9 1f       	adc	r31, r25
    4712:	ef 5f       	subi	r30, 0xFF	; 255
    4714:	fb 4f       	sbci	r31, 0xFB	; 251
    4716:	d1 83       	std	Z+1, r29	; 0x01
    4718:	c0 83       	st	Z, r28
    forbiddenZone[i].stop   = stop;
    471a:	53 83       	std	Z+3, r21	; 0x03
    471c:	42 83       	std	Z+2, r20	; 0x02
    forbiddenZone[i].active = 1;
    471e:	81 e0       	ldi	r24, 0x01	; 1
    4720:	84 83       	std	Z+4, r24	; 0x04
  }

  return;
}
    4722:	df 91       	pop	r29
    4724:	cf 91       	pop	r28
    4726:	1f 91       	pop	r17
    4728:	0f 91       	pop	r16
    472a:	ff 90       	pop	r15
    472c:	08 95       	ret
  int16_t swap = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    472e:	a0 91 15 04 	lds	r26, 0x0415
    4732:	b0 91 16 04 	lds	r27, 0x0416
    4736:	e1 e7       	ldi	r30, 0x71	; 113
    4738:	f2 e0       	ldi	r31, 0x02	; 2
    473a:	83 e1       	ldi	r24, 0x13	; 19
    473c:	01 90       	ld	r0, Z+
    473e:	0d 92       	st	X+, r0
    4740:	81 50       	subi	r24, 0x01	; 1
    4742:	e1 f7       	brne	.-8      	; 0x473c <commandSetForbiddenZone+0x7a>
    sendText(txString.buffer);
    4744:	80 91 15 04 	lds	r24, 0x0415
    4748:	90 91 16 04 	lds	r25, 0x0416
    474c:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    4750:	e8 cf       	rjmp	.-48     	; 0x4722 <commandSetForbiddenZone+0x60>
      forbiddenZone[i].stop   = 0;
      forbiddenZone[i].active = 0;
      return;
    }

    if(start > stop){
    4752:	ae 01       	movw	r20, r28
    4754:	ec 01       	movw	r28, r24
    4756:	d4 cf       	rjmp	.-88     	; 0x4700 <commandSetForbiddenZone+0x3e>
  else{
    start = (int16_t)atoi(param1);
    stop  = (int16_t)atoi(param2);

    if(start == stop){
      forbiddenZone[i].start  = 0;
    4758:	8f 2d       	mov	r24, r15
    475a:	90 e0       	ldi	r25, 0x00	; 0
    475c:	fc 01       	movw	r30, r24
    475e:	ee 0f       	add	r30, r30
    4760:	ff 1f       	adc	r31, r31
    4762:	ee 0f       	add	r30, r30
    4764:	ff 1f       	adc	r31, r31
    4766:	e8 0f       	add	r30, r24
    4768:	f9 1f       	adc	r31, r25
    476a:	ef 5f       	subi	r30, 0xFF	; 255
    476c:	fb 4f       	sbci	r31, 0xFB	; 251
    476e:	11 82       	std	Z+1, r1	; 0x01
    4770:	10 82       	st	Z, r1
      forbiddenZone[i].stop   = 0;
    4772:	13 82       	std	Z+3, r1	; 0x03
    4774:	12 82       	std	Z+2, r1	; 0x02
      forbiddenZone[i].active = 0;
    4776:	14 82       	std	Z+4, r1	; 0x04
    forbiddenZone[i].stop   = stop;
    forbiddenZone[i].active = 1;
  }

  return;
}
    4778:	df 91       	pop	r29
    477a:	cf 91       	pop	r28
    477c:	1f 91       	pop	r17
    477e:	0f 91       	pop	r16
    4780:	ff 90       	pop	r15
    4782:	08 95       	ret

00004784 <commandSetConstSpeed>:
}

/* ---------------------------------------------------------------------
    sets the infinite moving mode
 --------------------------------------------------------------------- */
void commandSetConstSpeed(char* param0, char* param1, char* param2){
    4784:	2f 92       	push	r2
    4786:	3f 92       	push	r3
    4788:	4f 92       	push	r4
    478a:	5f 92       	push	r5
    478c:	6f 92       	push	r6
    478e:	7f 92       	push	r7
    4790:	8f 92       	push	r8
    4792:	9f 92       	push	r9
    4794:	af 92       	push	r10
    4796:	bf 92       	push	r11
    4798:	cf 92       	push	r12
    479a:	df 92       	push	r13
    479c:	ef 92       	push	r14
    479e:	ff 92       	push	r15
    47a0:	0f 93       	push	r16
    47a2:	1f 93       	push	r17
    47a4:	df 93       	push	r29
    47a6:	cf 93       	push	r28
    47a8:	00 d0       	rcall	.+0      	; 0x47aa <commandSetConstSpeed+0x26>
    47aa:	00 d0       	rcall	.+0      	; 0x47ac <commandSetConstSpeed+0x28>
    47ac:	00 d0       	rcall	.+0      	; 0x47ae <commandSetConstSpeed+0x2a>
    47ae:	cd b7       	in	r28, 0x3d	; 61
    47b0:	de b7       	in	r29, 0x3e	; 62
    47b2:	7a 83       	std	Y+2, r23	; 0x02
    47b4:	69 83       	std	Y+1, r22	; 0x01
    47b6:	8a 01       	movw	r16, r20

  uint8_t i = 0;
  double val = 0.0;
  uint16_t waitTime = 1;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    47b8:	60 e0       	ldi	r22, 0x00	; 0
    47ba:	70 e0       	ldi	r23, 0x00	; 0
    47bc:	4a e0       	ldi	r20, 0x0A	; 10
    47be:	50 e0       	ldi	r21, 0x00	; 0
    47c0:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    47c4:	64 30       	cpi	r22, 0x04	; 4
    47c6:	08 f0       	brcs	.+2      	; 0x47ca <commandSetConstSpeed+0x46>
    47c8:	62 c0       	rjmp	.+196    	; 0x488e <commandSetConstSpeed+0x10a>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    if(forbiddenZone[i].active){
    47ca:	e6 2e       	mov	r14, r22
    47cc:	ff 24       	eor	r15, r15
    47ce:	97 01       	movw	r18, r14
    47d0:	22 0f       	add	r18, r18
    47d2:	33 1f       	adc	r19, r19
    47d4:	22 0f       	add	r18, r18
    47d6:	33 1f       	adc	r19, r19
    47d8:	3c 83       	std	Y+4, r19	; 0x04
    47da:	2b 83       	std	Y+3, r18	; 0x03
    47dc:	f9 01       	movw	r30, r18
    47de:	ee 0d       	add	r30, r14
    47e0:	ff 1d       	adc	r31, r15
    47e2:	ef 5f       	subi	r30, 0xFF	; 255
    47e4:	fb 4f       	sbci	r31, 0xFB	; 251
    47e6:	84 81       	ldd	r24, Z+4	; 0x04
    47e8:	88 23       	and	r24, r24
    47ea:	c9 f0       	breq	.+50     	; 0x481e <commandSetConstSpeed+0x9a>
      motor[i].desiredPosition += -1;
    }
  }

  return;
}
    47ec:	26 96       	adiw	r28, 0x06	; 6
    47ee:	0f b6       	in	r0, 0x3f	; 63
    47f0:	f8 94       	cli
    47f2:	de bf       	out	0x3e, r29	; 62
    47f4:	0f be       	out	0x3f, r0	; 63
    47f6:	cd bf       	out	0x3d, r28	; 61
    47f8:	cf 91       	pop	r28
    47fa:	df 91       	pop	r29
    47fc:	1f 91       	pop	r17
    47fe:	0f 91       	pop	r16
    4800:	ff 90       	pop	r15
    4802:	ef 90       	pop	r14
    4804:	df 90       	pop	r13
    4806:	cf 90       	pop	r12
    4808:	bf 90       	pop	r11
    480a:	af 90       	pop	r10
    480c:	9f 90       	pop	r9
    480e:	8f 90       	pop	r8
    4810:	7f 90       	pop	r7
    4812:	6f 90       	pop	r6
    4814:	5f 90       	pop	r5
    4816:	4f 90       	pop	r4
    4818:	3f 90       	pop	r3
    481a:	2f 90       	pop	r2
    481c:	08 95       	ret
      /* command not allowed if forbidden zone is set */
      return;
    }

    /* this is the wait-time for a full rotation in seconds */
    val = atof(param2);
    481e:	c8 01       	movw	r24, r16
    4820:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    4824:	3b 01       	movw	r6, r22
    4826:	4c 01       	movw	r8, r24

    if(strcmp(param1, "STOP") == 0){
    4828:	89 81       	ldd	r24, Y+1	; 0x01
    482a:	9a 81       	ldd	r25, Y+2	; 0x02
    482c:	64 e8       	ldi	r22, 0x84	; 132
    482e:	72 e0       	ldi	r23, 0x02	; 2
    4830:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4834:	00 97       	sbiw	r24, 0x00	; 0
    4836:	09 f0       	breq	.+2      	; 0x483a <commandSetConstSpeed+0xb6>
    4838:	3c c0       	rjmp	.+120    	; 0x48b2 <commandSetConstSpeed+0x12e>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    483a:	f8 94       	cli
      ATOMIC_BLOCK(ATOMIC_FORCEON){
        motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    483c:	c7 01       	movw	r24, r14
    483e:	88 0f       	add	r24, r24
    4840:	99 1f       	adc	r25, r25
    4842:	88 0f       	add	r24, r24
    4844:	99 1f       	adc	r25, r25
    4846:	88 0f       	add	r24, r24
    4848:	99 1f       	adc	r25, r25
    484a:	fc 01       	movw	r30, r24
    484c:	ee 0f       	add	r30, r30
    484e:	ff 1f       	adc	r31, r31
    4850:	ee 0f       	add	r30, r30
    4852:	ff 1f       	adc	r31, r31
    4854:	e8 0f       	add	r30, r24
    4856:	f9 1f       	adc	r31, r25
    4858:	e2 5e       	subi	r30, 0xE2	; 226
    485a:	fb 4f       	sbci	r31, 0xFB	; 251
    485c:	14 86       	std	Z+12, r1	; 0x0c
        motor[i].waitBetweenSteps = 3;
    485e:	83 e0       	ldi	r24, 0x03	; 3
    4860:	90 e0       	ldi	r25, 0x00	; 0
    4862:	97 8f       	std	Z+31, r25	; 0x1f
    4864:	86 8f       	std	Z+30, r24	; 0x1e
        motor[i].desiredPosition  = motor[i].actualPosition;
    4866:	80 81       	ld	r24, Z
    4868:	91 81       	ldd	r25, Z+1	; 0x01
    486a:	eb 81       	ldd	r30, Y+3	; 0x03
    486c:	fc 81       	ldd	r31, Y+4	; 0x04
    486e:	ee 0f       	add	r30, r30
    4870:	ff 1f       	adc	r31, r31
    4872:	ee 0f       	add	r30, r30
    4874:	ff 1f       	adc	r31, r31
    4876:	ab 81       	ldd	r26, Y+3	; 0x03
    4878:	bc 81       	ldd	r27, Y+4	; 0x04
    487a:	ea 0f       	add	r30, r26
    487c:	fb 1f       	adc	r31, r27
    487e:	ee 0f       	add	r30, r30
    4880:	ff 1f       	adc	r31, r31
    4882:	e0 5e       	subi	r30, 0xE0	; 224
    4884:	fb 4f       	sbci	r31, 0xFB	; 251
    4886:	91 83       	std	Z+1, r25	; 0x01
    4888:	80 83       	st	Z, r24
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    488a:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    488c:	af cf       	rjmp	.-162    	; 0x47ec <commandSetConstSpeed+0x68>
  uint16_t waitTime = 1;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    488e:	a0 91 15 04 	lds	r26, 0x0415
    4892:	b0 91 16 04 	lds	r27, 0x0416
    4896:	e1 e7       	ldi	r30, 0x71	; 113
    4898:	f2 e0       	ldi	r31, 0x02	; 2
    489a:	83 e1       	ldi	r24, 0x13	; 19
    489c:	01 90       	ld	r0, Z+
    489e:	0d 92       	st	X+, r0
    48a0:	81 50       	subi	r24, 0x01	; 1
    48a2:	e1 f7       	brne	.-8      	; 0x489c <commandSetConstSpeed+0x118>
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
    48a4:	80 91 15 04 	lds	r24, 0x0415
    48a8:	90 91 16 04 	lds	r25, 0x0416
    48ac:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    48b0:	9d cf       	rjmp	.-198    	; 0x47ec <commandSetConstSpeed+0x68>
      }
      return;
    }

    /* now calculate wait time between two steps in ms */
    waitTime = (uint16_t)round((fabs(val)*1000.0f) / ( motor[i].gearRatio
    48b2:	f7 01       	movw	r30, r14
    48b4:	ee 0f       	add	r30, r30
    48b6:	ff 1f       	adc	r31, r31
    48b8:	ee 0f       	add	r30, r30
    48ba:	ff 1f       	adc	r31, r31
    48bc:	ee 0f       	add	r30, r30
    48be:	ff 1f       	adc	r31, r31
    48c0:	fe 83       	std	Y+6, r31	; 0x06
    48c2:	ed 83       	std	Y+5, r30	; 0x05
    48c4:	ee 0f       	add	r30, r30
    48c6:	ff 1f       	adc	r31, r31
    48c8:	ee 0f       	add	r30, r30
    48ca:	ff 1f       	adc	r31, r31
    48cc:	2d 81       	ldd	r18, Y+5	; 0x05
    48ce:	3e 81       	ldd	r19, Y+6	; 0x06
    48d0:	e2 0f       	add	r30, r18
    48d2:	f3 1f       	adc	r31, r19
    48d4:	e2 5e       	subi	r30, 0xE2	; 226
    48d6:	fb 4f       	sbci	r31, 0xFB	; 251
    48d8:	e5 84       	ldd	r14, Z+13	; 0x0d
    48da:	f6 84       	ldd	r15, Z+14	; 0x0e
    48dc:	07 85       	ldd	r16, Z+15	; 0x0f
    48de:	10 89       	ldd	r17, Z+16	; 0x10
    48e0:	a1 88       	ldd	r10, Z+17	; 0x11
    48e2:	b2 88       	ldd	r11, Z+18	; 0x12
    48e4:	c3 88       	ldd	r12, Z+19	; 0x13
    48e6:	d4 88       	ldd	r13, Z+20	; 0x14
    48e8:	25 88       	ldd	r2, Z+21	; 0x15
    48ea:	36 88       	ldd	r3, Z+22	; 0x16
    48ec:	47 88       	ldd	r4, Z+23	; 0x17
    48ee:	50 8c       	ldd	r5, Z+24	; 0x18
    48f0:	c4 01       	movw	r24, r8
    48f2:	b3 01       	movw	r22, r6
    48f4:	9f 77       	andi	r25, 0x7F	; 127
    48f6:	20 e0       	ldi	r18, 0x00	; 0
    48f8:	30 e0       	ldi	r19, 0x00	; 0
    48fa:	4a e7       	ldi	r20, 0x7A	; 122
    48fc:	54 e4       	ldi	r21, 0x44	; 68
    48fe:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    4902:	3b 01       	movw	r6, r22
    4904:	4c 01       	movw	r8, r24
    4906:	c8 01       	movw	r24, r16
    4908:	b7 01       	movw	r22, r14
    490a:	a6 01       	movw	r20, r12
    490c:	95 01       	movw	r18, r10
    490e:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    4912:	a2 01       	movw	r20, r4
    4914:	91 01       	movw	r18, r2
    4916:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    491a:	9b 01       	movw	r18, r22
    491c:	ac 01       	movw	r20, r24
    491e:	c4 01       	movw	r24, r8
    4920:	b3 01       	movw	r22, r6
    4922:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    4926:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    492a:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
    492e:	8b 01       	movw	r16, r22
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
    4930:	67 2b       	or	r22, r23
    4932:	09 f4       	brne	.+2      	; 0x4936 <commandSetConstSpeed+0x1b2>
    4934:	77 c0       	rjmp	.+238    	; 0x4a24 <commandSetConstSpeed+0x2a0>
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
      return;
    }
    if(waitTime > 9999){
    4936:	37 e2       	ldi	r19, 0x27	; 39
    4938:	60 31       	cpi	r22, 0x10	; 16
    493a:	73 07       	cpc	r23, r19
    493c:	08 f0       	brcs	.+2      	; 0x4940 <commandSetConstSpeed+0x1bc>
    493e:	60 c0       	rjmp	.+192    	; 0x4a00 <commandSetConstSpeed+0x27c>
    sprintf(txString.buffer, "err: time too long");
    sendText(txString.buffer);
    }

    if(strcmp(param1, "CW")  == 0){
    4940:	89 81       	ldd	r24, Y+1	; 0x01
    4942:	9a 81       	ldd	r25, Y+2	; 0x02
    4944:	60 eb       	ldi	r22, 0xB0	; 176
    4946:	72 e0       	ldi	r23, 0x02	; 2
    4948:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    494c:	00 97       	sbiw	r24, 0x00	; 0
    494e:	39 f5       	brne	.+78     	; 0x499e <commandSetConstSpeed+0x21a>
      motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CW;
    4950:	ed 81       	ldd	r30, Y+5	; 0x05
    4952:	fe 81       	ldd	r31, Y+6	; 0x06
    4954:	ee 0f       	add	r30, r30
    4956:	ff 1f       	adc	r31, r31
    4958:	ee 0f       	add	r30, r30
    495a:	ff 1f       	adc	r31, r31
    495c:	8d 81       	ldd	r24, Y+5	; 0x05
    495e:	9e 81       	ldd	r25, Y+6	; 0x06
    4960:	e8 0f       	add	r30, r24
    4962:	f9 1f       	adc	r31, r25
    4964:	e2 5e       	subi	r30, 0xE2	; 226
    4966:	fb 4f       	sbci	r31, 0xFB	; 251
    4968:	81 e0       	ldi	r24, 0x01	; 1
    496a:	84 87       	std	Z+12, r24	; 0x0c
      motor[i].waitBetweenSteps = waitTime;
    496c:	17 8f       	std	Z+31, r17	; 0x1f
    496e:	06 8f       	std	Z+30, r16	; 0x1e
      motor[i].desiredPosition  = motor[i].actualPosition;
    4970:	80 81       	ld	r24, Z
    4972:	91 81       	ldd	r25, Z+1	; 0x01
    4974:	eb 81       	ldd	r30, Y+3	; 0x03
    4976:	fc 81       	ldd	r31, Y+4	; 0x04
    4978:	ee 0f       	add	r30, r30
    497a:	ff 1f       	adc	r31, r31
    497c:	ee 0f       	add	r30, r30
    497e:	ff 1f       	adc	r31, r31
    4980:	ab 81       	ldd	r26, Y+3	; 0x03
    4982:	bc 81       	ldd	r27, Y+4	; 0x04
    4984:	ea 0f       	add	r30, r26
    4986:	fb 1f       	adc	r31, r27
    4988:	ee 0f       	add	r30, r30
    498a:	ff 1f       	adc	r31, r31
    498c:	e0 5e       	subi	r30, 0xE0	; 224
    498e:	fb 4f       	sbci	r31, 0xFB	; 251
    4990:	91 83       	std	Z+1, r25	; 0x01
    4992:	80 83       	st	Z, r24
      motor[i].desiredPosition += 1;
    4994:	80 81       	ld	r24, Z
    4996:	91 81       	ldd	r25, Z+1	; 0x01
    4998:	01 96       	adiw	r24, 0x01	; 1
    499a:	91 83       	std	Z+1, r25	; 0x01
    499c:	80 83       	st	Z, r24
    }
    if(strcmp(param1, "CCW") == 0){
    499e:	89 81       	ldd	r24, Y+1	; 0x01
    49a0:	9a 81       	ldd	r25, Y+2	; 0x02
    49a2:	63 eb       	ldi	r22, 0xB3	; 179
    49a4:	72 e0       	ldi	r23, 0x02	; 2
    49a6:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    49aa:	00 97       	sbiw	r24, 0x00	; 0
    49ac:	09 f0       	breq	.+2      	; 0x49b0 <commandSetConstSpeed+0x22c>
    49ae:	1e cf       	rjmp	.-452    	; 0x47ec <commandSetConstSpeed+0x68>
      motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_CCW;
    49b0:	ed 81       	ldd	r30, Y+5	; 0x05
    49b2:	fe 81       	ldd	r31, Y+6	; 0x06
    49b4:	ee 0f       	add	r30, r30
    49b6:	ff 1f       	adc	r31, r31
    49b8:	ee 0f       	add	r30, r30
    49ba:	ff 1f       	adc	r31, r31
    49bc:	2d 81       	ldd	r18, Y+5	; 0x05
    49be:	3e 81       	ldd	r19, Y+6	; 0x06
    49c0:	e2 0f       	add	r30, r18
    49c2:	f3 1f       	adc	r31, r19
    49c4:	e2 5e       	subi	r30, 0xE2	; 226
    49c6:	fb 4f       	sbci	r31, 0xFB	; 251
    49c8:	82 e0       	ldi	r24, 0x02	; 2
    49ca:	84 87       	std	Z+12, r24	; 0x0c
      motor[i].waitBetweenSteps = waitTime;
    49cc:	17 8f       	std	Z+31, r17	; 0x1f
    49ce:	06 8f       	std	Z+30, r16	; 0x1e
      motor[i].desiredPosition  = motor[i].actualPosition;
    49d0:	80 81       	ld	r24, Z
    49d2:	91 81       	ldd	r25, Z+1	; 0x01
    49d4:	eb 81       	ldd	r30, Y+3	; 0x03
    49d6:	fc 81       	ldd	r31, Y+4	; 0x04
    49d8:	ee 0f       	add	r30, r30
    49da:	ff 1f       	adc	r31, r31
    49dc:	ee 0f       	add	r30, r30
    49de:	ff 1f       	adc	r31, r31
    49e0:	ab 81       	ldd	r26, Y+3	; 0x03
    49e2:	bc 81       	ldd	r27, Y+4	; 0x04
    49e4:	ea 0f       	add	r30, r26
    49e6:	fb 1f       	adc	r31, r27
    49e8:	ee 0f       	add	r30, r30
    49ea:	ff 1f       	adc	r31, r31
    49ec:	e0 5e       	subi	r30, 0xE0	; 224
    49ee:	fb 4f       	sbci	r31, 0xFB	; 251
    49f0:	91 83       	std	Z+1, r25	; 0x01
    49f2:	80 83       	st	Z, r24
      motor[i].desiredPosition += -1;
    49f4:	80 81       	ld	r24, Z
    49f6:	91 81       	ldd	r25, Z+1	; 0x01
    49f8:	01 97       	sbiw	r24, 0x01	; 1
    49fa:	91 83       	std	Z+1, r25	; 0x01
    49fc:	80 83       	st	Z, r24
    49fe:	f6 ce       	rjmp	.-532    	; 0x47ec <commandSetConstSpeed+0x68>
      sprintf(txString.buffer, "err: time too short");
      sendText(txString.buffer);
      return;
    }
    if(waitTime > 9999){
    sprintf(txString.buffer, "err: time too long");
    4a00:	a0 91 15 04 	lds	r26, 0x0415
    4a04:	b0 91 16 04 	lds	r27, 0x0416
    4a08:	ed e9       	ldi	r30, 0x9D	; 157
    4a0a:	f2 e0       	ldi	r31, 0x02	; 2
    4a0c:	83 e1       	ldi	r24, 0x13	; 19
    4a0e:	01 90       	ld	r0, Z+
    4a10:	0d 92       	st	X+, r0
    4a12:	81 50       	subi	r24, 0x01	; 1
    4a14:	e1 f7       	brne	.-8      	; 0x4a0e <commandSetConstSpeed+0x28a>
    sendText(txString.buffer);
    4a16:	80 91 15 04 	lds	r24, 0x0415
    4a1a:	90 91 16 04 	lds	r25, 0x0416
    4a1e:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    4a22:	8e cf       	rjmp	.-228    	; 0x4940 <commandSetConstSpeed+0x1bc>
    waitTime = (uint16_t)round((fabs(val)*1000.0f) / ( motor[i].gearRatio
                                                      *motor[i].stepsPerFullRotation
                                                      *motor[i].subSteps));

    if(waitTime < 1){
      sprintf(txString.buffer, "err: time too short");
    4a24:	a0 91 15 04 	lds	r26, 0x0415
    4a28:	b0 91 16 04 	lds	r27, 0x0416
    4a2c:	e9 e8       	ldi	r30, 0x89	; 137
    4a2e:	f2 e0       	ldi	r31, 0x02	; 2
    4a30:	84 e1       	ldi	r24, 0x14	; 20
    4a32:	01 90       	ld	r0, Z+
    4a34:	0d 92       	st	X+, r0
    4a36:	81 50       	subi	r24, 0x01	; 1
    4a38:	e1 f7       	brne	.-8      	; 0x4a32 <commandSetConstSpeed+0x2ae>
    4a3a:	34 cf       	rjmp	.-408    	; 0x48a4 <commandSetConstSpeed+0x120>

00004a3c <commandSetWaitTime>:
}

/* ---------------------------------------------------------------------
    sets the wait time between two single steps
 --------------------------------------------------------------------- */
void commandSetWaitTime(char* param0, char* param1){
    4a3c:	1f 93       	push	r17
    4a3e:	cf 93       	push	r28
    4a40:	df 93       	push	r29
    4a42:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4a44:	60 e0       	ldi	r22, 0x00	; 0
    4a46:	70 e0       	ldi	r23, 0x00	; 0
    4a48:	4a e0       	ldi	r20, 0x0A	; 10
    4a4a:	50 e0       	ldi	r21, 0x00	; 0
    4a4c:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4a50:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4a52:	64 30       	cpi	r22, 0x04	; 4
    4a54:	d8 f4       	brcc	.+54     	; 0x4a8c <commandSetWaitTime+0x50>
    sprintf(txString.buffer, "err: unknown motor");
    sendText(txString.buffer);
    return;
  }
  else{
    val = (uint16_t)atoi(param1);
    4a56:	ce 01       	movw	r24, r28
    4a58:	0e 94 13 48 	call	0x9026	; 0x9026 <atoi>
    4a5c:	9c 01       	movw	r18, r24
    motor[i].waitBetweenSteps = val;
    4a5e:	e1 2f       	mov	r30, r17
    4a60:	f0 e0       	ldi	r31, 0x00	; 0
    4a62:	ee 0f       	add	r30, r30
    4a64:	ff 1f       	adc	r31, r31
    4a66:	ee 0f       	add	r30, r30
    4a68:	ff 1f       	adc	r31, r31
    4a6a:	ee 0f       	add	r30, r30
    4a6c:	ff 1f       	adc	r31, r31
    4a6e:	cf 01       	movw	r24, r30
    4a70:	88 0f       	add	r24, r24
    4a72:	99 1f       	adc	r25, r25
    4a74:	88 0f       	add	r24, r24
    4a76:	99 1f       	adc	r25, r25
    4a78:	e8 0f       	add	r30, r24
    4a7a:	f9 1f       	adc	r31, r25
    4a7c:	e2 5e       	subi	r30, 0xE2	; 226
    4a7e:	fb 4f       	sbci	r31, 0xFB	; 251
    4a80:	37 8f       	std	Z+31, r19	; 0x1f
    4a82:	26 8f       	std	Z+30, r18	; 0x1e
  }

  return;
}
    4a84:	df 91       	pop	r29
    4a86:	cf 91       	pop	r28
    4a88:	1f 91       	pop	r17
    4a8a:	08 95       	ret
  uint16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor");
    4a8c:	a0 91 15 04 	lds	r26, 0x0415
    4a90:	b0 91 16 04 	lds	r27, 0x0416
    4a94:	e1 e7       	ldi	r30, 0x71	; 113
    4a96:	f2 e0       	ldi	r31, 0x02	; 2
    4a98:	83 e1       	ldi	r24, 0x13	; 19
    4a9a:	01 90       	ld	r0, Z+
    4a9c:	0d 92       	st	X+, r0
    4a9e:	81 50       	subi	r24, 0x01	; 1
    4aa0:	e1 f7       	brne	.-8      	; 0x4a9a <commandSetWaitTime+0x5e>
    sendText(txString.buffer);
    4aa2:	80 91 15 04 	lds	r24, 0x0415
    4aa6:	90 91 16 04 	lds	r25, 0x0416
    4aaa:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    4aae:	ea cf       	rjmp	.-44     	; 0x4a84 <commandSetWaitTime+0x48>

00004ab0 <commandSetFullRotation>:
}

/* ---------------------------------------------------------------------
    sets the steps per full rotation w/o substeps
 --------------------------------------------------------------------- */
void commandSetFullRotation(char* param0, char* param1){
    4ab0:	1f 93       	push	r17
    4ab2:	cf 93       	push	r28
    4ab4:	df 93       	push	r29
    4ab6:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4ab8:	60 e0       	ldi	r22, 0x00	; 0
    4aba:	70 e0       	ldi	r23, 0x00	; 0
    4abc:	4a e0       	ldi	r20, 0x0A	; 10
    4abe:	50 e0       	ldi	r21, 0x00	; 0
    4ac0:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4ac4:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4ac6:	64 30       	cpi	r22, 0x04	; 4
    4ac8:	e0 f4       	brcc	.+56     	; 0x4b02 <commandSetFullRotation+0x52>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    4aca:	ce 01       	movw	r24, r28
    4acc:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    motor[i].stepsPerFullRotation = val;
    4ad0:	e1 2f       	mov	r30, r17
    4ad2:	f0 e0       	ldi	r31, 0x00	; 0
    4ad4:	ee 0f       	add	r30, r30
    4ad6:	ff 1f       	adc	r31, r31
    4ad8:	ee 0f       	add	r30, r30
    4ada:	ff 1f       	adc	r31, r31
    4adc:	ee 0f       	add	r30, r30
    4ade:	ff 1f       	adc	r31, r31
    4ae0:	9f 01       	movw	r18, r30
    4ae2:	22 0f       	add	r18, r18
    4ae4:	33 1f       	adc	r19, r19
    4ae6:	22 0f       	add	r18, r18
    4ae8:	33 1f       	adc	r19, r19
    4aea:	e2 0f       	add	r30, r18
    4aec:	f3 1f       	adc	r31, r19
    4aee:	e2 5e       	subi	r30, 0xE2	; 226
    4af0:	fb 4f       	sbci	r31, 0xFB	; 251
    4af2:	61 8b       	std	Z+17, r22	; 0x11
    4af4:	72 8b       	std	Z+18, r23	; 0x12
    4af6:	83 8b       	std	Z+19, r24	; 0x13
    4af8:	94 8b       	std	Z+20, r25	; 0x14
  }

  return;
}
    4afa:	df 91       	pop	r29
    4afc:	cf 91       	pop	r28
    4afe:	1f 91       	pop	r17
    4b00:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4b02:	80 91 15 04 	lds	r24, 0x0415
    4b06:	90 91 16 04 	lds	r25, 0x0416
    4b0a:	00 d0       	rcall	.+0      	; 0x4b0c <commandSetFullRotation+0x5c>
    4b0c:	00 d0       	rcall	.+0      	; 0x4b0e <commandSetFullRotation+0x5e>
    4b0e:	00 d0       	rcall	.+0      	; 0x4b10 <commandSetFullRotation+0x60>
    4b10:	ed b7       	in	r30, 0x3d	; 61
    4b12:	fe b7       	in	r31, 0x3e	; 62
    4b14:	31 96       	adiw	r30, 0x01	; 1
    4b16:	ad b7       	in	r26, 0x3d	; 61
    4b18:	be b7       	in	r27, 0x3e	; 62
    4b1a:	12 96       	adiw	r26, 0x02	; 2
    4b1c:	9c 93       	st	X, r25
    4b1e:	8e 93       	st	-X, r24
    4b20:	11 97       	sbiw	r26, 0x01	; 1
    4b22:	80 e0       	ldi	r24, 0x00	; 0
    4b24:	91 e0       	ldi	r25, 0x01	; 1
    4b26:	93 83       	std	Z+3, r25	; 0x03
    4b28:	82 83       	std	Z+2, r24	; 0x02
    4b2a:	14 83       	std	Z+4, r17	; 0x04
    4b2c:	15 82       	std	Z+5, r1	; 0x05
    4b2e:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    sendText(txString.buffer);
    4b32:	80 91 15 04 	lds	r24, 0x0415
    4b36:	90 91 16 04 	lds	r25, 0x0416
    4b3a:	2d b7       	in	r18, 0x3d	; 61
    4b3c:	3e b7       	in	r19, 0x3e	; 62
    4b3e:	2a 5f       	subi	r18, 0xFA	; 250
    4b40:	3f 4f       	sbci	r19, 0xFF	; 255
    4b42:	0f b6       	in	r0, 0x3f	; 63
    4b44:	f8 94       	cli
    4b46:	3e bf       	out	0x3e, r19	; 62
    4b48:	0f be       	out	0x3f, r0	; 63
    4b4a:	2d bf       	out	0x3d, r18	; 61
    4b4c:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    val = (double)atof(param1);
    motor[i].stepsPerFullRotation = val;
  }

  return;
}
    4b50:	df 91       	pop	r29
    4b52:	cf 91       	pop	r28
    4b54:	1f 91       	pop	r17
    4b56:	08 95       	ret

00004b58 <commandSetGearRatio>:
}

/* ---------------------------------------------------------------------
    sets the mechanical gear ratio
 --------------------------------------------------------------------- */
void commandSetGearRatio(char* param0, char* param1){
    4b58:	1f 93       	push	r17
    4b5a:	cf 93       	push	r28
    4b5c:	df 93       	push	r29
    4b5e:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4b60:	60 e0       	ldi	r22, 0x00	; 0
    4b62:	70 e0       	ldi	r23, 0x00	; 0
    4b64:	4a e0       	ldi	r20, 0x0A	; 10
    4b66:	50 e0       	ldi	r21, 0x00	; 0
    4b68:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4b6c:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4b6e:	64 30       	cpi	r22, 0x04	; 4
    4b70:	e0 f4       	brcc	.+56     	; 0x4baa <commandSetGearRatio+0x52>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    4b72:	ce 01       	movw	r24, r28
    4b74:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    motor[i].gearRatio = val;
    4b78:	e1 2f       	mov	r30, r17
    4b7a:	f0 e0       	ldi	r31, 0x00	; 0
    4b7c:	ee 0f       	add	r30, r30
    4b7e:	ff 1f       	adc	r31, r31
    4b80:	ee 0f       	add	r30, r30
    4b82:	ff 1f       	adc	r31, r31
    4b84:	ee 0f       	add	r30, r30
    4b86:	ff 1f       	adc	r31, r31
    4b88:	9f 01       	movw	r18, r30
    4b8a:	22 0f       	add	r18, r18
    4b8c:	33 1f       	adc	r19, r19
    4b8e:	22 0f       	add	r18, r18
    4b90:	33 1f       	adc	r19, r19
    4b92:	e2 0f       	add	r30, r18
    4b94:	f3 1f       	adc	r31, r19
    4b96:	e2 5e       	subi	r30, 0xE2	; 226
    4b98:	fb 4f       	sbci	r31, 0xFB	; 251
    4b9a:	65 87       	std	Z+13, r22	; 0x0d
    4b9c:	76 87       	std	Z+14, r23	; 0x0e
    4b9e:	87 87       	std	Z+15, r24	; 0x0f
    4ba0:	90 8b       	std	Z+16, r25	; 0x10
  }

  return;
}
    4ba2:	df 91       	pop	r29
    4ba4:	cf 91       	pop	r28
    4ba6:	1f 91       	pop	r17
    4ba8:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4baa:	80 91 15 04 	lds	r24, 0x0415
    4bae:	90 91 16 04 	lds	r25, 0x0416
    4bb2:	00 d0       	rcall	.+0      	; 0x4bb4 <commandSetGearRatio+0x5c>
    4bb4:	00 d0       	rcall	.+0      	; 0x4bb6 <commandSetGearRatio+0x5e>
    4bb6:	00 d0       	rcall	.+0      	; 0x4bb8 <commandSetGearRatio+0x60>
    4bb8:	ed b7       	in	r30, 0x3d	; 61
    4bba:	fe b7       	in	r31, 0x3e	; 62
    4bbc:	31 96       	adiw	r30, 0x01	; 1
    4bbe:	ad b7       	in	r26, 0x3d	; 61
    4bc0:	be b7       	in	r27, 0x3e	; 62
    4bc2:	12 96       	adiw	r26, 0x02	; 2
    4bc4:	9c 93       	st	X, r25
    4bc6:	8e 93       	st	-X, r24
    4bc8:	11 97       	sbiw	r26, 0x01	; 1
    4bca:	80 e0       	ldi	r24, 0x00	; 0
    4bcc:	91 e0       	ldi	r25, 0x01	; 1
    4bce:	93 83       	std	Z+3, r25	; 0x03
    4bd0:	82 83       	std	Z+2, r24	; 0x02
    4bd2:	14 83       	std	Z+4, r17	; 0x04
    4bd4:	15 82       	std	Z+5, r1	; 0x05
    4bd6:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    sendText(txString.buffer);
    4bda:	80 91 15 04 	lds	r24, 0x0415
    4bde:	90 91 16 04 	lds	r25, 0x0416
    4be2:	2d b7       	in	r18, 0x3d	; 61
    4be4:	3e b7       	in	r19, 0x3e	; 62
    4be6:	2a 5f       	subi	r18, 0xFA	; 250
    4be8:	3f 4f       	sbci	r19, 0xFF	; 255
    4bea:	0f b6       	in	r0, 0x3f	; 63
    4bec:	f8 94       	cli
    4bee:	3e bf       	out	0x3e, r19	; 62
    4bf0:	0f be       	out	0x3f, r0	; 63
    4bf2:	2d bf       	out	0x3d, r18	; 61
    4bf4:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    val = (double)atof(param1);
    motor[i].gearRatio = val;
  }

  return;
}
    4bf8:	df 91       	pop	r29
    4bfa:	cf 91       	pop	r28
    4bfc:	1f 91       	pop	r17
    4bfe:	08 95       	ret

00004c00 <commandSetOptZeroPos>:

/* ---------------------------------------------------------------------
    sets the optical zero position
    as offset from magnetic zero position
 --------------------------------------------------------------------- */
void commandSetOptZeroPos(char* param0, char* param1){
    4c00:	1f 93       	push	r17
    4c02:	cf 93       	push	r28
    4c04:	df 93       	push	r29
    4c06:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  int16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4c08:	60 e0       	ldi	r22, 0x00	; 0
    4c0a:	70 e0       	ldi	r23, 0x00	; 0
    4c0c:	4a e0       	ldi	r20, 0x0A	; 10
    4c0e:	50 e0       	ldi	r21, 0x00	; 0
    4c10:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4c14:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    4c16:	64 30       	cpi	r22, 0x04	; 4
    4c18:	00 f5       	brcc	.+64     	; 0x4c5a <commandSetOptZeroPos+0x5a>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (int16_t)strtol(param1, (char **)NULL, 10);
    4c1a:	ce 01       	movw	r24, r28
    4c1c:	60 e0       	ldi	r22, 0x00	; 0
    4c1e:	70 e0       	ldi	r23, 0x00	; 0
    4c20:	4a e0       	ldi	r20, 0x0A	; 10
    4c22:	50 e0       	ldi	r21, 0x00	; 0
    4c24:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    motor[i].opticalZeroPosition = val;
    4c28:	21 2f       	mov	r18, r17
    4c2a:	30 e0       	ldi	r19, 0x00	; 0
    4c2c:	f9 01       	movw	r30, r18
    4c2e:	ee 0f       	add	r30, r30
    4c30:	ff 1f       	adc	r31, r31
    4c32:	ee 0f       	add	r30, r30
    4c34:	ff 1f       	adc	r31, r31
    4c36:	ee 0f       	add	r30, r30
    4c38:	ff 1f       	adc	r31, r31
    4c3a:	22 0f       	add	r18, r18
    4c3c:	33 1f       	adc	r19, r19
    4c3e:	e2 0f       	add	r30, r18
    4c40:	f3 1f       	adc	r31, r19
    4c42:	ee 0f       	add	r30, r30
    4c44:	ff 1f       	adc	r31, r31
    4c46:	ee 0f       	add	r30, r30
    4c48:	ff 1f       	adc	r31, r31
    4c4a:	ee 5d       	subi	r30, 0xDE	; 222
    4c4c:	fb 4f       	sbci	r31, 0xFB	; 251
    4c4e:	71 83       	std	Z+1, r23	; 0x01
    4c50:	60 83       	st	Z, r22
  }

  return;
}
    4c52:	df 91       	pop	r29
    4c54:	cf 91       	pop	r28
    4c56:	1f 91       	pop	r17
    4c58:	08 95       	ret
  int16_t val = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    4c5a:	80 91 15 04 	lds	r24, 0x0415
    4c5e:	90 91 16 04 	lds	r25, 0x0416
    4c62:	00 d0       	rcall	.+0      	; 0x4c64 <commandSetOptZeroPos+0x64>
    4c64:	00 d0       	rcall	.+0      	; 0x4c66 <commandSetOptZeroPos+0x66>
    4c66:	00 d0       	rcall	.+0      	; 0x4c68 <commandSetOptZeroPos+0x68>
    4c68:	ed b7       	in	r30, 0x3d	; 61
    4c6a:	fe b7       	in	r31, 0x3e	; 62
    4c6c:	31 96       	adiw	r30, 0x01	; 1
    4c6e:	ad b7       	in	r26, 0x3d	; 61
    4c70:	be b7       	in	r27, 0x3e	; 62
    4c72:	12 96       	adiw	r26, 0x02	; 2
    4c74:	9c 93       	st	X, r25
    4c76:	8e 93       	st	-X, r24
    4c78:	11 97       	sbiw	r26, 0x01	; 1
    4c7a:	80 e0       	ldi	r24, 0x00	; 0
    4c7c:	91 e0       	ldi	r25, 0x01	; 1
    4c7e:	93 83       	std	Z+3, r25	; 0x03
    4c80:	82 83       	std	Z+2, r24	; 0x02
    4c82:	14 83       	std	Z+4, r17	; 0x04
    4c84:	15 82       	std	Z+5, r1	; 0x05
    4c86:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    sendText(txString.buffer);
    4c8a:	80 91 15 04 	lds	r24, 0x0415
    4c8e:	90 91 16 04 	lds	r25, 0x0416
    4c92:	2d b7       	in	r18, 0x3d	; 61
    4c94:	3e b7       	in	r19, 0x3e	; 62
    4c96:	2a 5f       	subi	r18, 0xFA	; 250
    4c98:	3f 4f       	sbci	r19, 0xFF	; 255
    4c9a:	0f b6       	in	r0, 0x3f	; 63
    4c9c:	f8 94       	cli
    4c9e:	3e bf       	out	0x3e, r19	; 62
    4ca0:	0f be       	out	0x3f, r0	; 63
    4ca2:	2d bf       	out	0x3d, r18	; 61
    4ca4:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    val = (int16_t)strtol(param1, (char **)NULL, 10);
    motor[i].opticalZeroPosition = val;
  }

  return;
}
    4ca8:	df 91       	pop	r29
    4caa:	cf 91       	pop	r28
    4cac:	1f 91       	pop	r17
    4cae:	08 95       	ret

00004cb0 <commandMoveRel>:
}

/* ---------------------------------------------------------------------
    moves the motor relative to the actual position
 --------------------------------------------------------------------- */
void commandMoveRel(char* param0, char* param1, char* param2){
    4cb0:	ff 92       	push	r15
    4cb2:	0f 93       	push	r16
    4cb4:	1f 93       	push	r17
    4cb6:	cf 93       	push	r28
    4cb8:	df 93       	push	r29
    4cba:	eb 01       	movw	r28, r22
    4cbc:	8a 01       	movw	r16, r20

  uint8_t i = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4cbe:	60 e0       	ldi	r22, 0x00	; 0
    4cc0:	70 e0       	ldi	r23, 0x00	; 0
    4cc2:	4a e0       	ldi	r20, 0x0A	; 10
    4cc4:	50 e0       	ldi	r21, 0x00	; 0
    4cc6:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4cca:	f6 2e       	mov	r15, r22

  if(i > MAX_MOTOR){
    4ccc:	83 e0       	ldi	r24, 0x03	; 3
    4cce:	8f 15       	cp	r24, r15
    4cd0:	30 f4       	brcc	.+12     	; 0x4cde <commandMoveRel+0x2e>
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    4cd2:	df 91       	pop	r29
    4cd4:	cf 91       	pop	r28
    4cd6:	1f 91       	pop	r17
    4cd8:	0f 91       	pop	r16
    4cda:	ff 90       	pop	r15
    4cdc:	08 95       	ret

  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    4cde:	c8 01       	movw	r24, r16
    4ce0:	66 e3       	ldi	r22, 0x36	; 54
    4ce2:	72 e0       	ldi	r23, 0x02	; 2
    4ce4:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4ce8:	00 97       	sbiw	r24, 0x00	; 0
    4cea:	a9 f0       	breq	.+42     	; 0x4d16 <commandMoveRel+0x66>
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    4cec:	c8 01       	movw	r24, r16
    4cee:	6c e3       	ldi	r22, 0x3C	; 60
    4cf0:	72 e0       	ldi	r23, 0x02	; 2
    4cf2:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4cf6:	00 97       	sbiw	r24, 0x00	; 0
    4cf8:	09 f4       	brne	.+2      	; 0x4cfc <commandMoveRel+0x4c>
    4cfa:	42 c0       	rjmp	.+132    	; 0x4d80 <commandMoveRel+0xd0>
    degreeToSteps(i, atof(param1), 1.0f);
  }
  else if(strcmp(param2, "pi") == 0){
    4cfc:	c8 01       	movw	r24, r16
    4cfe:	60 e4       	ldi	r22, 0x40	; 64
    4d00:	72 e0       	ldi	r23, 0x02	; 2
    4d02:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4d06:	00 97       	sbiw	r24, 0x00	; 0
    4d08:	09 f4       	brne	.+2      	; 0x4d0c <commandMoveRel+0x5c>
    4d0a:	47 c0       	rjmp	.+142    	; 0x4d9a <commandMoveRel+0xea>
    radiansToSteps(i, atof(param1), 1.0f);
  }
  else{
    sendText("ERROR: unknown unit");
    4d0c:	87 eb       	ldi	r24, 0xB7	; 183
    4d0e:	92 e0       	ldi	r25, 0x02	; 2
    4d10:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    4d14:	de cf       	rjmp	.-68     	; 0x4cd2 <commandMoveRel+0x22>
  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
    4d16:	ef 2d       	mov	r30, r15
    4d18:	f0 e0       	ldi	r31, 0x00	; 0
    4d1a:	ee 0f       	add	r30, r30
    4d1c:	ff 1f       	adc	r31, r31
    4d1e:	ee 0f       	add	r30, r30
    4d20:	ff 1f       	adc	r31, r31
    4d22:	cf 01       	movw	r24, r30
    4d24:	88 0f       	add	r24, r24
    4d26:	99 1f       	adc	r25, r25
    4d28:	88 0f       	add	r24, r24
    4d2a:	99 1f       	adc	r25, r25
    4d2c:	e8 0f       	add	r30, r24
    4d2e:	f9 1f       	adc	r31, r25
    4d30:	ee 0f       	add	r30, r30
    4d32:	ff 1f       	adc	r31, r31
    4d34:	e0 5e       	subi	r30, 0xE0	; 224
    4d36:	fb 4f       	sbci	r31, 0xFB	; 251
    4d38:	00 81       	ld	r16, Z
    4d3a:	11 81       	ldd	r17, Z+1	; 0x01
    4d3c:	ce 01       	movw	r24, r28
    4d3e:	60 e0       	ldi	r22, 0x00	; 0
    4d40:	70 e0       	ldi	r23, 0x00	; 0
    4d42:	4a e0       	ldi	r20, 0x0A	; 10
    4d44:	50 e0       	ldi	r21, 0x00	; 0
    4d46:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4d4a:	06 0f       	add	r16, r22
    4d4c:	17 1f       	adc	r17, r23
    4d4e:	ef 2d       	mov	r30, r15
    4d50:	f0 e0       	ldi	r31, 0x00	; 0
    4d52:	ee 0f       	add	r30, r30
    4d54:	ff 1f       	adc	r31, r31
    4d56:	ee 0f       	add	r30, r30
    4d58:	ff 1f       	adc	r31, r31
    4d5a:	cf 01       	movw	r24, r30
    4d5c:	88 0f       	add	r24, r24
    4d5e:	99 1f       	adc	r25, r25
    4d60:	88 0f       	add	r24, r24
    4d62:	99 1f       	adc	r25, r25
    4d64:	e8 0f       	add	r30, r24
    4d66:	f9 1f       	adc	r31, r25
    4d68:	ee 0f       	add	r30, r30
    4d6a:	ff 1f       	adc	r31, r31
    4d6c:	e0 5e       	subi	r30, 0xE0	; 224
    4d6e:	fb 4f       	sbci	r31, 0xFB	; 251
    4d70:	11 83       	std	Z+1, r17	; 0x01
    4d72:	00 83       	st	Z, r16
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    4d74:	df 91       	pop	r29
    4d76:	cf 91       	pop	r28
    4d78:	1f 91       	pop	r17
    4d7a:	0f 91       	pop	r16
    4d7c:	ff 90       	pop	r15
    4d7e:	08 95       	ret

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition += (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    degreeToSteps(i, atof(param1), 1.0f);
    4d80:	ce 01       	movw	r24, r28
    4d82:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    4d86:	ab 01       	movw	r20, r22
    4d88:	bc 01       	movw	r22, r24
    4d8a:	8f 2d       	mov	r24, r15
    4d8c:	00 e0       	ldi	r16, 0x00	; 0
    4d8e:	10 e0       	ldi	r17, 0x00	; 0
    4d90:	20 e8       	ldi	r18, 0x80	; 128
    4d92:	3f e3       	ldi	r19, 0x3F	; 63
    4d94:	0e 94 52 11 	call	0x22a4	; 0x22a4 <degreeToSteps>
    4d98:	9c cf       	rjmp	.-200    	; 0x4cd2 <commandMoveRel+0x22>
  }
  else if(strcmp(param2, "pi") == 0){
    radiansToSteps(i, atof(param1), 1.0f);
    4d9a:	ce 01       	movw	r24, r28
    4d9c:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    4da0:	ab 01       	movw	r20, r22
    4da2:	bc 01       	movw	r22, r24
    4da4:	8f 2d       	mov	r24, r15
    4da6:	00 e0       	ldi	r16, 0x00	; 0
    4da8:	10 e0       	ldi	r17, 0x00	; 0
    4daa:	20 e8       	ldi	r18, 0x80	; 128
    4dac:	3f e3       	ldi	r19, 0x3F	; 63
    4dae:	0e 94 0b 10 	call	0x2016	; 0x2016 <radiansToSteps>
    4db2:	8f cf       	rjmp	.-226    	; 0x4cd2 <commandMoveRel+0x22>

00004db4 <commandMoveAbs>:
}

/* ---------------------------------------------------------------------
    moves the motor to an absolute position
 --------------------------------------------------------------------- */
void commandMoveAbs(char* param0, char* param1, char* param2){
    4db4:	df 92       	push	r13
    4db6:	ef 92       	push	r14
    4db8:	ff 92       	push	r15
    4dba:	0f 93       	push	r16
    4dbc:	1f 93       	push	r17
    4dbe:	cf 93       	push	r28
    4dc0:	df 93       	push	r29
    4dc2:	eb 01       	movw	r28, r22
    4dc4:	8a 01       	movw	r16, r20

  uint8_t i = 0;
  double actMotorPos = 0.0f;
  double posDiff = 0.0f;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    4dc6:	60 e0       	ldi	r22, 0x00	; 0
    4dc8:	70 e0       	ldi	r23, 0x00	; 0
    4dca:	4a e0       	ldi	r20, 0x0A	; 10
    4dcc:	50 e0       	ldi	r21, 0x00	; 0
    4dce:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4dd2:	d6 2e       	mov	r13, r22

  if(i > MAX_MOTOR){
    4dd4:	83 e0       	ldi	r24, 0x03	; 3
    4dd6:	8d 15       	cp	r24, r13
    4dd8:	40 f4       	brcc	.+16     	; 0x4dea <commandMoveAbs+0x36>
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    4dda:	df 91       	pop	r29
    4ddc:	cf 91       	pop	r28
    4dde:	1f 91       	pop	r17
    4de0:	0f 91       	pop	r16
    4de2:	ff 90       	pop	r15
    4de4:	ef 90       	pop	r14
    4de6:	df 90       	pop	r13
    4de8:	08 95       	ret

  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    4dea:	c8 01       	movw	r24, r16
    4dec:	66 e3       	ldi	r22, 0x36	; 54
    4dee:	72 e0       	ldi	r23, 0x02	; 2
    4df0:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4df4:	00 97       	sbiw	r24, 0x00	; 0
    4df6:	a1 f0       	breq	.+40     	; 0x4e20 <commandMoveAbs+0x6c>
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    4df8:	c8 01       	movw	r24, r16
    4dfa:	6c e3       	ldi	r22, 0x3C	; 60
    4dfc:	72 e0       	ldi	r23, 0x02	; 2
    4dfe:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4e02:	00 97       	sbiw	r24, 0x00	; 0
    4e04:	79 f1       	breq	.+94     	; 0x4e64 <commandMoveAbs+0xb0>
    actMotorPos = stepsToDegree(i, motor[i].actualPosition);
    posDiff = atof(param1) - actMotorPos;
    degreeToSteps(i, posDiff, 1.0);
  }
  else if(strcmp(param2, "pi") == 0){
    4e06:	c8 01       	movw	r24, r16
    4e08:	60 e4       	ldi	r22, 0x40	; 64
    4e0a:	72 e0       	ldi	r23, 0x02	; 2
    4e0c:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    4e10:	00 97       	sbiw	r24, 0x00	; 0
    4e12:	09 f4       	brne	.+2      	; 0x4e16 <commandMoveAbs+0x62>
    4e14:	50 c0       	rjmp	.+160    	; 0x4eb6 <commandMoveAbs+0x102>
    actMotorPos = stepsToRadian(i, motor[i].actualPosition);
    posDiff = atof(param1) - actMotorPos;
    radiansToSteps(i, posDiff, 1.0);
  }
  else{
    sendText("ERROR: unknown unit");
    4e16:	87 eb       	ldi	r24, 0xB7	; 183
    4e18:	92 e0       	ldi	r25, 0x02	; 2
    4e1a:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    4e1e:	dd cf       	rjmp	.-70     	; 0x4dda <commandMoveAbs+0x26>
  if(i > MAX_MOTOR){
    return;
  }

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
    4e20:	ce 01       	movw	r24, r28
    4e22:	60 e0       	ldi	r22, 0x00	; 0
    4e24:	70 e0       	ldi	r23, 0x00	; 0
    4e26:	4a e0       	ldi	r20, 0x0A	; 10
    4e28:	50 e0       	ldi	r21, 0x00	; 0
    4e2a:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    4e2e:	ed 2d       	mov	r30, r13
    4e30:	f0 e0       	ldi	r31, 0x00	; 0
    4e32:	ee 0f       	add	r30, r30
    4e34:	ff 1f       	adc	r31, r31
    4e36:	ee 0f       	add	r30, r30
    4e38:	ff 1f       	adc	r31, r31
    4e3a:	9f 01       	movw	r18, r30
    4e3c:	22 0f       	add	r18, r18
    4e3e:	33 1f       	adc	r19, r19
    4e40:	22 0f       	add	r18, r18
    4e42:	33 1f       	adc	r19, r19
    4e44:	e2 0f       	add	r30, r18
    4e46:	f3 1f       	adc	r31, r19
    4e48:	ee 0f       	add	r30, r30
    4e4a:	ff 1f       	adc	r31, r31
    4e4c:	e0 5e       	subi	r30, 0xE0	; 224
    4e4e:	fb 4f       	sbci	r31, 0xFB	; 251
    4e50:	71 83       	std	Z+1, r23	; 0x01
    4e52:	60 83       	st	Z, r22
  else{
    sendText("ERROR: unknown unit");
  }

  return;
}
    4e54:	df 91       	pop	r29
    4e56:	cf 91       	pop	r28
    4e58:	1f 91       	pop	r17
    4e5a:	0f 91       	pop	r16
    4e5c:	ff 90       	pop	r15
    4e5e:	ef 90       	pop	r14
    4e60:	df 90       	pop	r13
    4e62:	08 95       	ret

  if(strcmp(param2, "steps") == 0){
    motor[i].desiredPosition = (int16_t)strtol(param1, (char **)NULL, 10);
  }
  else if(strcmp(param2, "deg") == 0){
    actMotorPos = stepsToDegree(i, motor[i].actualPosition);
    4e64:	ed 2d       	mov	r30, r13
    4e66:	f0 e0       	ldi	r31, 0x00	; 0
    4e68:	ee 0f       	add	r30, r30
    4e6a:	ff 1f       	adc	r31, r31
    4e6c:	ee 0f       	add	r30, r30
    4e6e:	ff 1f       	adc	r31, r31
    4e70:	ee 0f       	add	r30, r30
    4e72:	ff 1f       	adc	r31, r31
    4e74:	cf 01       	movw	r24, r30
    4e76:	88 0f       	add	r24, r24
    4e78:	99 1f       	adc	r25, r25
    4e7a:	88 0f       	add	r24, r24
    4e7c:	99 1f       	adc	r25, r25
    4e7e:	e8 0f       	add	r30, r24
    4e80:	f9 1f       	adc	r31, r25
    4e82:	e2 5e       	subi	r30, 0xE2	; 226
    4e84:	fb 4f       	sbci	r31, 0xFB	; 251
    4e86:	60 81       	ld	r22, Z
    4e88:	71 81       	ldd	r23, Z+1	; 0x01
    4e8a:	8d 2d       	mov	r24, r13
    4e8c:	0e 94 dd 07 	call	0xfba	; 0xfba <stepsToDegree>
    4e90:	7b 01       	movw	r14, r22
    4e92:	8c 01       	movw	r16, r24
    posDiff = atof(param1) - actMotorPos;
    4e94:	ce 01       	movw	r24, r28
    4e96:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    degreeToSteps(i, posDiff, 1.0);
    4e9a:	a8 01       	movw	r20, r16
    4e9c:	97 01       	movw	r18, r14
    4e9e:	0e 94 26 43 	call	0x864c	; 0x864c <__subsf3>
    4ea2:	ab 01       	movw	r20, r22
    4ea4:	bc 01       	movw	r22, r24
    4ea6:	8d 2d       	mov	r24, r13
    4ea8:	00 e0       	ldi	r16, 0x00	; 0
    4eaa:	10 e0       	ldi	r17, 0x00	; 0
    4eac:	20 e8       	ldi	r18, 0x80	; 128
    4eae:	3f e3       	ldi	r19, 0x3F	; 63
    4eb0:	0e 94 52 11 	call	0x22a4	; 0x22a4 <degreeToSteps>
    4eb4:	92 cf       	rjmp	.-220    	; 0x4dda <commandMoveAbs+0x26>
  }
  else if(strcmp(param2, "pi") == 0){
    actMotorPos = stepsToRadian(i, motor[i].actualPosition);
    4eb6:	ed 2d       	mov	r30, r13
    4eb8:	f0 e0       	ldi	r31, 0x00	; 0
    4eba:	ee 0f       	add	r30, r30
    4ebc:	ff 1f       	adc	r31, r31
    4ebe:	ee 0f       	add	r30, r30
    4ec0:	ff 1f       	adc	r31, r31
    4ec2:	ee 0f       	add	r30, r30
    4ec4:	ff 1f       	adc	r31, r31
    4ec6:	cf 01       	movw	r24, r30
    4ec8:	88 0f       	add	r24, r24
    4eca:	99 1f       	adc	r25, r25
    4ecc:	88 0f       	add	r24, r24
    4ece:	99 1f       	adc	r25, r25
    4ed0:	e8 0f       	add	r30, r24
    4ed2:	f9 1f       	adc	r31, r25
    4ed4:	e2 5e       	subi	r30, 0xE2	; 226
    4ed6:	fb 4f       	sbci	r31, 0xFB	; 251
    4ed8:	60 81       	ld	r22, Z
    4eda:	71 81       	ldd	r23, Z+1	; 0x01
    4edc:	8d 2d       	mov	r24, r13
    4ede:	0e 94 62 08 	call	0x10c4	; 0x10c4 <stepsToRadian>
    4ee2:	7b 01       	movw	r14, r22
    4ee4:	8c 01       	movw	r16, r24
    posDiff = atof(param1) - actMotorPos;
    4ee6:	ce 01       	movw	r24, r28
    4ee8:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    radiansToSteps(i, posDiff, 1.0);
    4eec:	a8 01       	movw	r20, r16
    4eee:	97 01       	movw	r18, r14
    4ef0:	0e 94 26 43 	call	0x864c	; 0x864c <__subsf3>
    4ef4:	ab 01       	movw	r20, r22
    4ef6:	bc 01       	movw	r22, r24
    4ef8:	8d 2d       	mov	r24, r13
    4efa:	00 e0       	ldi	r16, 0x00	; 0
    4efc:	10 e0       	ldi	r17, 0x00	; 0
    4efe:	20 e8       	ldi	r18, 0x80	; 128
    4f00:	3f e3       	ldi	r19, 0x3F	; 63
    4f02:	0e 94 0b 10 	call	0x2016	; 0x2016 <radiansToSteps>
    4f06:	69 cf       	rjmp	.-302    	; 0x4dda <commandMoveAbs+0x26>

00004f08 <initBuffers>:

  uint8_t i,j;

  /* command parameters */
  for(j = 0; j < PARAMETER_LENGTH; j++){
    commandParam[i][j] = 0;
    4f08:	20 e0       	ldi	r18, 0x00	; 0
    4f0a:	30 e0       	ldi	r19, 0x00	; 0
    4f0c:	80 e0       	ldi	r24, 0x00	; 0
    4f0e:	90 e0       	ldi	r25, 0x00	; 0
    4f10:	e0 91 04 03 	lds	r30, 0x0304
    4f14:	f0 91 05 03 	lds	r31, 0x0305
    4f18:	01 90       	ld	r0, Z+
    4f1a:	f0 81       	ld	r31, Z
    4f1c:	e0 2d       	mov	r30, r0
    4f1e:	e8 0f       	add	r30, r24
    4f20:	f9 1f       	adc	r31, r25
    4f22:	10 82       	st	Z, r1
    4f24:	01 96       	adiw	r24, 0x01	; 1
void initBuffers(void){

  uint8_t i,j;

  /* command parameters */
  for(j = 0; j < PARAMETER_LENGTH; j++){
    4f26:	84 31       	cpi	r24, 0x14	; 20
    4f28:	91 05       	cpc	r25, r1
    4f2a:	91 f7       	brne	.-28     	; 0x4f10 <initBuffers+0x8>
    4f2c:	80 e0       	ldi	r24, 0x00	; 0
    4f2e:	90 e0       	ldi	r25, 0x00	; 0
    commandParam[i][j] = 0;
  }

  /* buffers for the display */
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    menu.currentDisplayValue[i][j] = 0;
    4f30:	e0 91 14 03 	lds	r30, 0x0314
    4f34:	f0 91 15 03 	lds	r31, 0x0315
    4f38:	e2 0f       	add	r30, r18
    4f3a:	f3 1f       	adc	r31, r19
    4f3c:	01 90       	ld	r0, Z+
    4f3e:	f0 81       	ld	r31, Z
    4f40:	e0 2d       	mov	r30, r0
    4f42:	e8 0f       	add	r30, r24
    4f44:	f9 1f       	adc	r31, r25
    4f46:	10 82       	st	Z, r1
    menu.newDisplayValue[i][j]     = 0;
    4f48:	e0 91 16 03 	lds	r30, 0x0316
    4f4c:	f0 91 17 03 	lds	r31, 0x0317
    4f50:	e2 0f       	add	r30, r18
    4f52:	f3 1f       	adc	r31, r19
    4f54:	01 90       	ld	r0, Z+
    4f56:	f0 81       	ld	r31, Z
    4f58:	e0 2d       	mov	r30, r0
    4f5a:	e8 0f       	add	r30, r24
    4f5c:	f9 1f       	adc	r31, r25
    4f5e:	10 82       	st	Z, r1
    4f60:	01 96       	adiw	r24, 0x01	; 1
  for(j = 0; j < PARAMETER_LENGTH; j++){
    commandParam[i][j] = 0;
  }

  /* buffers for the display */
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    4f62:	89 30       	cpi	r24, 0x09	; 9
    4f64:	91 05       	cpc	r25, r1
    4f66:	21 f7       	brne	.-56     	; 0x4f30 <initBuffers+0x28>
    4f68:	80 e0       	ldi	r24, 0x00	; 0
    4f6a:	90 e0       	ldi	r25, 0x00	; 0
    menu.currentDisplayValue[i][j] = 0;
    menu.newDisplayValue[i][j]     = 0;
  }

  for(j = 0; j < DISPLAY_MENU_STRING_LENGTH; j++){
    menu.currentMenuText[i][j] = 0;
    4f6c:	e0 91 18 03 	lds	r30, 0x0318
    4f70:	f0 91 19 03 	lds	r31, 0x0319
    4f74:	e2 0f       	add	r30, r18
    4f76:	f3 1f       	adc	r31, r19
    4f78:	01 90       	ld	r0, Z+
    4f7a:	f0 81       	ld	r31, Z
    4f7c:	e0 2d       	mov	r30, r0
    4f7e:	e8 0f       	add	r30, r24
    4f80:	f9 1f       	adc	r31, r25
    4f82:	10 82       	st	Z, r1
    menu.newMenuText[i][j]     = 0;
    4f84:	e0 91 1a 03 	lds	r30, 0x031A
    4f88:	f0 91 1b 03 	lds	r31, 0x031B
    4f8c:	e2 0f       	add	r30, r18
    4f8e:	f3 1f       	adc	r31, r19
    4f90:	01 90       	ld	r0, Z+
    4f92:	f0 81       	ld	r31, Z
    4f94:	e0 2d       	mov	r30, r0
    4f96:	e8 0f       	add	r30, r24
    4f98:	f9 1f       	adc	r31, r25
    4f9a:	10 82       	st	Z, r1
    4f9c:	01 96       	adiw	r24, 0x01	; 1
  for(j = 0; j < DISPLAY_VALUE_STRING_LENGTH; j++){
    menu.currentDisplayValue[i][j] = 0;
    menu.newDisplayValue[i][j]     = 0;
  }

  for(j = 0; j < DISPLAY_MENU_STRING_LENGTH; j++){
    4f9e:	81 31       	cpi	r24, 0x11	; 17
    4fa0:	91 05       	cpc	r25, r1
    4fa2:	21 f7       	brne	.-56     	; 0x4f6c <initBuffers+0x64>
    menu.currentMenuText[i][j] = 0;
    menu.newMenuText[i][j]     = 0;
  }

  memset(rxString.buffer, 0, SERIAL_BUFFERSIZE);
    4fa4:	e0 91 1c 03 	lds	r30, 0x031C
    4fa8:	f0 91 1d 03 	lds	r31, 0x031D
    4fac:	80 e4       	ldi	r24, 0x40	; 64
    4fae:	df 01       	movw	r26, r30
    4fb0:	98 2f       	mov	r25, r24
    4fb2:	1d 92       	st	X+, r1
    4fb4:	9a 95       	dec	r25
    4fb6:	e9 f7       	brne	.-6      	; 0x4fb2 <initBuffers+0xaa>
  memset(txString.buffer, 0, SERIAL_BUFFERSIZE);
    4fb8:	e0 91 15 04 	lds	r30, 0x0415
    4fbc:	f0 91 16 04 	lds	r31, 0x0416
    4fc0:	df 01       	movw	r26, r30
    4fc2:	98 2f       	mov	r25, r24
    4fc4:	1d 92       	st	X+, r1
    4fc6:	9a 95       	dec	r25
    4fc8:	e9 f7       	brne	.-6      	; 0x4fc4 <initBuffers+0xbc>
  memset(commandString.buffer, 0, SERIAL_BUFFERSIZE);
    4fca:	e0 91 be 04 	lds	r30, 0x04BE
    4fce:	f0 91 bf 04 	lds	r31, 0x04BF
    4fd2:	df 01       	movw	r26, r30
    4fd4:	1d 92       	st	X+, r1
    4fd6:	8a 95       	dec	r24
    4fd8:	e9 f7       	brne	.-6      	; 0x4fd4 <initBuffers+0xcc>
  memset(displayBuffer, 0, DISPLAY_BUFFER_SIZE);
    4fda:	e0 91 19 04 	lds	r30, 0x0419
    4fde:	f0 91 1a 04 	lds	r31, 0x041A
    4fe2:	88 e2       	ldi	r24, 0x28	; 40
    4fe4:	df 01       	movw	r26, r30
    4fe6:	1d 92       	st	X+, r1
    4fe8:	8a 95       	dec	r24
    4fea:	e9 f7       	brne	.-6      	; 0x4fe6 <initBuffers+0xde>

  return;
}
    4fec:	08 95       	ret

00004fee <copyRXstring>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    4fee:	f8 94       	cli
    copy command to internal buffer
 --------------------------------------------------------------------- */
void copyRXstring(void){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    memcpy(commandString.buffer, rxString.buffer, SERIAL_BUFFERSIZE);
    4ff0:	80 91 be 04 	lds	r24, 0x04BE
    4ff4:	90 91 bf 04 	lds	r25, 0x04BF
    4ff8:	20 91 1c 03 	lds	r18, 0x031C
    4ffc:	30 91 1d 03 	lds	r19, 0x031D
    5000:	dc 01       	movw	r26, r24
    5002:	f9 01       	movw	r30, r18
    5004:	80 e4       	ldi	r24, 0x40	; 64
    5006:	01 90       	ld	r0, Z+
    5008:	0d 92       	st	X+, r0
    500a:	81 50       	subi	r24, 0x01	; 1
    500c:	e1 f7       	brne	.-8      	; 0x5006 <copyRXstring+0x18>
    commandString.readyToProcess = 1;
    500e:	81 e0       	ldi	r24, 0x01	; 1
    5010:	80 93 c0 04 	sts	0x04C0, r24

    memset(rxString.buffer, 0, SERIAL_BUFFERSIZE);
    5014:	e0 91 1c 03 	lds	r30, 0x031C
    5018:	f0 91 1d 03 	lds	r31, 0x031D
    501c:	80 e4       	ldi	r24, 0x40	; 64
    501e:	df 01       	movw	r26, r30
    5020:	1d 92       	st	X+, r1
    5022:	8a 95       	dec	r24
    5024:	e9 f7       	brne	.-6      	; 0x5020 <copyRXstring+0x32>
    rxString.charCount = 0;
    5026:	10 92 1f 03 	sts	0x031F, r1
    rxString.readyToProcess = 0;
    502a:	10 92 1e 03 	sts	0x031E, r1
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    502e:	78 94       	sei
  }

  return;
}
    5030:	08 95       	ret

00005032 <getMotorCurrent>:
  float curr = 0.0;
  uint8_t addr = 0;
  uint16_t data = 0;
  uint8_t val = 0;

  addr = getDACAddress(mot);
    5032:	0e 94 da 09 	call	0x13b4	; 0x13b4 <getDACAddress>

  IICread(addr, IIC.data, 2);
    5036:	60 91 1b 04 	lds	r22, 0x041B
    503a:	70 91 1c 04 	lds	r23, 0x041C
    503e:	42 e0       	ldi	r20, 0x02	; 2
    5040:	0e 94 35 3f 	call	0x7e6a	; 0x7e6a <IICread>

  data |= (uint16_t)((IIC.data[0] << 8) & 0xFF00);  /* high byte */
    5044:	e0 91 1b 04 	lds	r30, 0x041B
    5048:	f0 91 1c 04 	lds	r31, 0x041C
  data |= (uint16_t)((IIC.data[1]) & 0x00FF);       /* low byte  */
    504c:	a0 91 1b 04 	lds	r26, 0x041B
    5050:	b0 91 1c 04 	lds	r27, 0x041C
    5054:	70 81       	ld	r23, Z
    5056:	60 e0       	ldi	r22, 0x00	; 0
    5058:	11 96       	adiw	r26, 0x01	; 1
    505a:	2c 91       	ld	r18, X
    505c:	30 e0       	ldi	r19, 0x00	; 0
    505e:	62 2b       	or	r22, r18
    5060:	73 2b       	or	r23, r19
    5062:	72 95       	swap	r23
    5064:	62 95       	swap	r22
    5066:	6f 70       	andi	r22, 0x0F	; 15
    5068:	67 27       	eor	r22, r23
    506a:	7f 70       	andi	r23, 0x0F	; 15
    506c:	67 27       	eor	r22, r23
    506e:	70 e0       	ldi	r23, 0x00	; 0
    5070:	80 e0       	ldi	r24, 0x00	; 0
    5072:	90 e0       	ldi	r25, 0x00	; 0
    5074:	0e 94 28 44 	call	0x8850	; 0x8850 <__floatunsisf>
    5078:	26 e6       	ldi	r18, 0x66	; 102
    507a:	36 e6       	ldi	r19, 0x66	; 102
    507c:	4a e9       	ldi	r20, 0x9A	; 154
    507e:	52 e4       	ldi	r21, 0x42	; 66
    5080:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>

  /* according to setMotorCurrent() max(val) = 193 */
  curr = ((float)val) / 77.2;

  return curr;
}
    5084:	08 95       	ret

00005086 <commandGetMotorCurrent>:
char* commandGetMotorCurrent(char* param0){

  uint8_t i = 0;
  double curr = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    5086:	60 e0       	ldi	r22, 0x00	; 0
    5088:	70 e0       	ldi	r23, 0x00	; 0
    508a:	4a e0       	ldi	r20, 0x0A	; 10
    508c:	50 e0       	ldi	r21, 0x00	; 0
    508e:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>

  if(i < MOTOR0 || i > MAX_MOTOR){
    5092:	64 30       	cpi	r22, 0x04	; 4
    5094:	78 f5       	brcc	.+94     	; 0x50f4 <commandGetMotorCurrent+0x6e>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    curr = getMotorCurrent(i);
    5096:	86 2f       	mov	r24, r22
    5098:	0e 94 19 28 	call	0x5032	; 0x5032 <getMotorCurrent>
    sprintf(txString.buffer, "%f", curr);
    509c:	20 91 15 04 	lds	r18, 0x0415
    50a0:	30 91 16 04 	lds	r19, 0x0416
    50a4:	ad b7       	in	r26, 0x3d	; 61
    50a6:	be b7       	in	r27, 0x3e	; 62
    50a8:	18 97       	sbiw	r26, 0x08	; 8
    50aa:	0f b6       	in	r0, 0x3f	; 63
    50ac:	f8 94       	cli
    50ae:	be bf       	out	0x3e, r27	; 62
    50b0:	0f be       	out	0x3f, r0	; 63
    50b2:	ad bf       	out	0x3d, r26	; 61
    50b4:	ed b7       	in	r30, 0x3d	; 61
    50b6:	fe b7       	in	r31, 0x3e	; 62
    50b8:	31 96       	adiw	r30, 0x01	; 1
    50ba:	12 96       	adiw	r26, 0x02	; 2
    50bc:	3c 93       	st	X, r19
    50be:	2e 93       	st	-X, r18
    50c0:	11 97       	sbiw	r26, 0x01	; 1
    50c2:	2f e1       	ldi	r18, 0x1F	; 31
    50c4:	31 e0       	ldi	r19, 0x01	; 1
    50c6:	33 83       	std	Z+3, r19	; 0x03
    50c8:	22 83       	std	Z+2, r18	; 0x02
    50ca:	64 83       	std	Z+4, r22	; 0x04
    50cc:	75 83       	std	Z+5, r23	; 0x05
    50ce:	86 83       	std	Z+6, r24	; 0x06
    50d0:	97 83       	std	Z+7, r25	; 0x07
    50d2:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    50d6:	4d b7       	in	r20, 0x3d	; 61
    50d8:	5e b7       	in	r21, 0x3e	; 62
    50da:	48 5f       	subi	r20, 0xF8	; 248
    50dc:	5f 4f       	sbci	r21, 0xFF	; 255
    50de:	0f b6       	in	r0, 0x3f	; 63
    50e0:	f8 94       	cli
    50e2:	5e bf       	out	0x3e, r21	; 62
    50e4:	0f be       	out	0x3f, r0	; 63
    50e6:	4d bf       	out	0x3d, r20	; 61
  }
  
  return txString.buffer;
    50e8:	20 91 15 04 	lds	r18, 0x0415
    50ec:	30 91 16 04 	lds	r19, 0x0416
}
    50f0:	c9 01       	movw	r24, r18
    50f2:	08 95       	ret
  double curr = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    50f4:	80 91 15 04 	lds	r24, 0x0415
    50f8:	90 91 16 04 	lds	r25, 0x0416
    50fc:	00 d0       	rcall	.+0      	; 0x50fe <commandGetMotorCurrent+0x78>
    50fe:	00 d0       	rcall	.+0      	; 0x5100 <commandGetMotorCurrent+0x7a>
    5100:	00 d0       	rcall	.+0      	; 0x5102 <commandGetMotorCurrent+0x7c>
    5102:	ed b7       	in	r30, 0x3d	; 61
    5104:	fe b7       	in	r31, 0x3e	; 62
    5106:	31 96       	adiw	r30, 0x01	; 1
    5108:	ad b7       	in	r26, 0x3d	; 61
    510a:	be b7       	in	r27, 0x3e	; 62
    510c:	12 96       	adiw	r26, 0x02	; 2
    510e:	9c 93       	st	X, r25
    5110:	8e 93       	st	-X, r24
    5112:	11 97       	sbiw	r26, 0x01	; 1
    5114:	80 e0       	ldi	r24, 0x00	; 0
    5116:	91 e0       	ldi	r25, 0x01	; 1
    5118:	93 83       	std	Z+3, r25	; 0x03
    511a:	82 83       	std	Z+2, r24	; 0x02
    511c:	64 83       	std	Z+4, r22	; 0x04
    511e:	15 82       	std	Z+5, r1	; 0x05
    5120:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    5124:	4d b7       	in	r20, 0x3d	; 61
    5126:	5e b7       	in	r21, 0x3e	; 62
    5128:	4a 5f       	subi	r20, 0xFA	; 250
    512a:	5f 4f       	sbci	r21, 0xFF	; 255
    512c:	0f b6       	in	r0, 0x3f	; 63
    512e:	f8 94       	cli
    5130:	5e bf       	out	0x3e, r21	; 62
    5132:	0f be       	out	0x3f, r0	; 63
    5134:	4d bf       	out	0x3d, r20	; 61
  else{
    curr = getMotorCurrent(i);
    sprintf(txString.buffer, "%f", curr);
  }
  
  return txString.buffer;
    5136:	20 91 15 04 	lds	r18, 0x0415
    513a:	30 91 16 04 	lds	r19, 0x0416
}
    513e:	c9 01       	movw	r24, r18
    5140:	08 95       	ret

00005142 <setMotorCurrent>:
}

/* ---------------------------------------------------------------------
   sets the motor current for DRV8825
 --------------------------------------------------------------------- */
void setMotorCurrent(uint8_t mot, float curr){
    5142:	df 92       	push	r13
    5144:	ef 92       	push	r14
    5146:	ff 92       	push	r15
    5148:	0f 93       	push	r16
    514a:	1f 93       	push	r17
    514c:	d8 2e       	mov	r13, r24
    514e:	7a 01       	movw	r14, r20
    5150:	8b 01       	movw	r16, r22

  uint8_t addr = 0;
  uint8_t val = 0;
  //uint16_t reg = 0;

  if(curr < 0.0){
    5152:	cb 01       	movw	r24, r22
    5154:	ba 01       	movw	r22, r20
    5156:	20 e0       	ldi	r18, 0x00	; 0
    5158:	30 e0       	ldi	r19, 0x00	; 0
    515a:	40 e0       	ldi	r20, 0x00	; 0
    515c:	50 e0       	ldi	r21, 0x00	; 0
    515e:	0e 94 8b 43 	call	0x8716	; 0x8716 <__cmpsf2>
    5162:	88 23       	and	r24, r24
    5164:	34 f1       	brlt	.+76     	; 0x51b2 <setMotorCurrent+0x70>
    curr = 0.0;
  }

  if(curr > 2.5){ /* maximum for DRV8825: 2.5 Ampere */
    5166:	c8 01       	movw	r24, r16
    5168:	b7 01       	movw	r22, r14
    516a:	20 e0       	ldi	r18, 0x00	; 0
    516c:	30 e0       	ldi	r19, 0x00	; 0
    516e:	40 e2       	ldi	r20, 0x20	; 32
    5170:	50 e4       	ldi	r21, 0x40	; 64
    5172:	0e 94 2d 45 	call	0x8a5a	; 0x8a5a <__gesf2>
    5176:	18 16       	cp	r1, r24
    5178:	fc f4       	brge	.+62     	; 0x51b8 <setMotorCurrent+0x76>
    517a:	0c e0       	ldi	r16, 0x0C	; 12
    517c:	10 e1       	ldi	r17, 0x10	; 16
    curr = 2.5;
  }

  addr = getDACAddress(mot);
    517e:	8d 2d       	mov	r24, r13
    5180:	0e 94 da 09 	call	0x13b4	; 0x13b4 <getDACAddress>
  /* 255 / 3.3V * 2.5A = 193 */
  /* 193 <=> 2.5 A, 193/2.5 = 77.2 */

  val = (uint8_t)floor(77.2 * curr);

  IIC.data[0] = (val & 0xF0) >> 4;
    5184:	e0 91 1b 04 	lds	r30, 0x041B
    5188:	f0 91 1c 04 	lds	r31, 0x041C
    518c:	00 83       	st	Z, r16
  IIC.data[1] = (val & 0x0F) << 4;
    518e:	e0 91 1b 04 	lds	r30, 0x041B
    5192:	f0 91 1c 04 	lds	r31, 0x041C
    5196:	11 83       	std	Z+1, r17	; 0x01

  IICwrite(addr, IIC.data, 2);
    5198:	60 91 1b 04 	lds	r22, 0x041B
    519c:	70 91 1c 04 	lds	r23, 0x041C
    51a0:	42 e0       	ldi	r20, 0x02	; 2
    51a2:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>

  return;
}
    51a6:	1f 91       	pop	r17
    51a8:	0f 91       	pop	r16
    51aa:	ff 90       	pop	r15
    51ac:	ef 90       	pop	r14
    51ae:	df 90       	pop	r13
    51b0:	08 95       	ret

  uint8_t addr = 0;
  uint8_t val = 0;
  //uint16_t reg = 0;

  if(curr < 0.0){
    51b2:	00 e0       	ldi	r16, 0x00	; 0
    51b4:	10 e0       	ldi	r17, 0x00	; 0
    51b6:	e3 cf       	rjmp	.-58     	; 0x517e <setMotorCurrent+0x3c>
}

/* ---------------------------------------------------------------------
   sets the motor current for DRV8825
 --------------------------------------------------------------------- */
void setMotorCurrent(uint8_t mot, float curr){
    51b8:	c8 01       	movw	r24, r16
    51ba:	b7 01       	movw	r22, r14
    51bc:	26 e6       	ldi	r18, 0x66	; 102
    51be:	36 e6       	ldi	r19, 0x66	; 102
    51c0:	4a e9       	ldi	r20, 0x9A	; 154
    51c2:	52 e4       	ldi	r21, 0x42	; 66
    51c4:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    51c8:	0e 94 65 44 	call	0x88ca	; 0x88ca <floor>
    51cc:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
    51d0:	06 2f       	mov	r16, r22
    51d2:	02 95       	swap	r16
    51d4:	0f 70       	andi	r16, 0x0F	; 15
    51d6:	16 2f       	mov	r17, r22
    51d8:	12 95       	swap	r17
    51da:	10 7f       	andi	r17, 0xF0	; 240
    51dc:	d0 cf       	rjmp	.-96     	; 0x517e <setMotorCurrent+0x3c>

000051de <commandSetMotorCurrent>:
}

/* ---------------------------------------------------------------------
    sets the desired motor current
 --------------------------------------------------------------------- */
void commandSetMotorCurrent(char* param0, char* param1){
    51de:	1f 93       	push	r17
    51e0:	cf 93       	push	r28
    51e2:	df 93       	push	r29
    51e4:	eb 01       	movw	r28, r22
  
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    51e6:	60 e0       	ldi	r22, 0x00	; 0
    51e8:	70 e0       	ldi	r23, 0x00	; 0
    51ea:	4a e0       	ldi	r20, 0x0A	; 10
    51ec:	50 e0       	ldi	r21, 0x00	; 0
    51ee:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    51f2:	16 2f       	mov	r17, r22
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    51f4:	64 30       	cpi	r22, 0x04	; 4
    51f6:	a0 f5       	brcc	.+104    	; 0x5260 <commandSetMotorCurrent+0x82>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
  }
  else{
    motor[i].current = atof(param1);
    51f8:	ce 01       	movw	r24, r28
    51fa:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    51fe:	e1 2f       	mov	r30, r17
    5200:	f0 e0       	ldi	r31, 0x00	; 0
    5202:	ee 0f       	add	r30, r30
    5204:	ff 1f       	adc	r31, r31
    5206:	ee 0f       	add	r30, r30
    5208:	ff 1f       	adc	r31, r31
    520a:	ee 0f       	add	r30, r30
    520c:	ff 1f       	adc	r31, r31
    520e:	9f 01       	movw	r18, r30
    5210:	22 0f       	add	r18, r18
    5212:	33 1f       	adc	r19, r19
    5214:	22 0f       	add	r18, r18
    5216:	33 1f       	adc	r19, r19
    5218:	e2 0f       	add	r30, r18
    521a:	f3 1f       	adc	r31, r19
    521c:	e2 5e       	subi	r30, 0xE2	; 226
    521e:	fb 4f       	sbci	r31, 0xFB	; 251
    5220:	63 a3       	std	Z+35, r22	; 0x23
    5222:	74 a3       	std	Z+36, r23	; 0x24
    5224:	85 a3       	std	Z+37, r24	; 0x25
    5226:	96 a3       	std	Z+38, r25	; 0x26
    setMotorCurrent(i, motor[i].current);
    5228:	e1 2f       	mov	r30, r17
    522a:	f0 e0       	ldi	r31, 0x00	; 0
    522c:	ee 0f       	add	r30, r30
    522e:	ff 1f       	adc	r31, r31
    5230:	ee 0f       	add	r30, r30
    5232:	ff 1f       	adc	r31, r31
    5234:	ee 0f       	add	r30, r30
    5236:	ff 1f       	adc	r31, r31
    5238:	cf 01       	movw	r24, r30
    523a:	88 0f       	add	r24, r24
    523c:	99 1f       	adc	r25, r25
    523e:	88 0f       	add	r24, r24
    5240:	99 1f       	adc	r25, r25
    5242:	e8 0f       	add	r30, r24
    5244:	f9 1f       	adc	r31, r25
    5246:	e2 5e       	subi	r30, 0xE2	; 226
    5248:	fb 4f       	sbci	r31, 0xFB	; 251
    524a:	43 a1       	ldd	r20, Z+35	; 0x23
    524c:	54 a1       	ldd	r21, Z+36	; 0x24
    524e:	65 a1       	ldd	r22, Z+37	; 0x25
    5250:	76 a1       	ldd	r23, Z+38	; 0x26
    5252:	81 2f       	mov	r24, r17
    5254:	0e 94 a1 28 	call	0x5142	; 0x5142 <setMotorCurrent>
  }

  return;
}
    5258:	df 91       	pop	r29
    525a:	cf 91       	pop	r28
    525c:	1f 91       	pop	r17
    525e:	08 95       	ret
  uint8_t i = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    5260:	80 91 15 04 	lds	r24, 0x0415
    5264:	90 91 16 04 	lds	r25, 0x0416
    5268:	00 d0       	rcall	.+0      	; 0x526a <commandSetMotorCurrent+0x8c>
    526a:	00 d0       	rcall	.+0      	; 0x526c <commandSetMotorCurrent+0x8e>
    526c:	00 d0       	rcall	.+0      	; 0x526e <commandSetMotorCurrent+0x90>
    526e:	ed b7       	in	r30, 0x3d	; 61
    5270:	fe b7       	in	r31, 0x3e	; 62
    5272:	31 96       	adiw	r30, 0x01	; 1
    5274:	ad b7       	in	r26, 0x3d	; 61
    5276:	be b7       	in	r27, 0x3e	; 62
    5278:	12 96       	adiw	r26, 0x02	; 2
    527a:	9c 93       	st	X, r25
    527c:	8e 93       	st	-X, r24
    527e:	11 97       	sbiw	r26, 0x01	; 1
    5280:	80 e0       	ldi	r24, 0x00	; 0
    5282:	91 e0       	ldi	r25, 0x01	; 1
    5284:	93 83       	std	Z+3, r25	; 0x03
    5286:	82 83       	std	Z+2, r24	; 0x02
    5288:	14 83       	std	Z+4, r17	; 0x04
    528a:	15 82       	std	Z+5, r1	; 0x05
    528c:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    sendText(txString.buffer);
    5290:	80 91 15 04 	lds	r24, 0x0415
    5294:	90 91 16 04 	lds	r25, 0x0416
    5298:	2d b7       	in	r18, 0x3d	; 61
    529a:	3e b7       	in	r19, 0x3e	; 62
    529c:	2a 5f       	subi	r18, 0xFA	; 250
    529e:	3f 4f       	sbci	r19, 0xFF	; 255
    52a0:	0f b6       	in	r0, 0x3f	; 63
    52a2:	f8 94       	cli
    52a4:	3e bf       	out	0x3e, r19	; 62
    52a6:	0f be       	out	0x3f, r0	; 63
    52a8:	2d bf       	out	0x3d, r18	; 61
    52aa:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    motor[i].current = atof(param1);
    setMotorCurrent(i, motor[i].current);
  }

  return;
}
    52ae:	df 91       	pop	r29
    52b0:	cf 91       	pop	r28
    52b2:	1f 91       	pop	r17
    52b4:	08 95       	ret

000052b6 <initDAC>:
 --------------------------------------------------------------------- */
void initDAC(uint8_t mot){

  uint8_t addr = 0;

  addr = getDACAddress(mot);
    52b6:	0e 94 da 09 	call	0x13b4	; 0x13b4 <getDACAddress>
  IIC.data[0] = 0x00; IIC.data[1] = 0x00;
    52ba:	e0 91 1b 04 	lds	r30, 0x041B
    52be:	f0 91 1c 04 	lds	r31, 0x041C
    52c2:	10 82       	st	Z, r1
    52c4:	e0 91 1b 04 	lds	r30, 0x041B
    52c8:	f0 91 1c 04 	lds	r31, 0x041C
    52cc:	11 82       	std	Z+1, r1	; 0x01
  IICwrite(addr, IIC.data, 2);
    52ce:	60 91 1b 04 	lds	r22, 0x041B
    52d2:	70 91 1c 04 	lds	r23, 0x041C
    52d6:	42 e0       	ldi	r20, 0x02	; 2
    52d8:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>

  return;
}
    52dc:	08 95       	ret

000052de <writePortExpanderRegister>:
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    52de:	f8 94       	cli
   write port expander register
 --------------------------------------------------------------------- */
void writePortExpanderRegister(uint8_t addr, uint8_t reg, uint8_t val){

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    IIC.data[0] = reg; IIC.data[1] = val;
    52e0:	e0 91 1b 04 	lds	r30, 0x041B
    52e4:	f0 91 1c 04 	lds	r31, 0x041C
    52e8:	60 83       	st	Z, r22
    52ea:	e0 91 1b 04 	lds	r30, 0x041B
    52ee:	f0 91 1c 04 	lds	r31, 0x041C
    52f2:	41 83       	std	Z+1, r20	; 0x01
    IICwrite(addr, IIC.data, 2);
    52f4:	60 91 1b 04 	lds	r22, 0x041B
    52f8:	70 91 1c 04 	lds	r23, 0x041C
    52fc:	42 e0       	ldi	r20, 0x02	; 2
    52fe:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    5302:	78 94       	sei
  }

  return;
}
    5304:	08 95       	ret

00005306 <initPortExpander>:
====================================================================== */

/* ---------------------------------------------------------------------
   initialize I2C port expanders in byte mode
 --------------------------------------------------------------------- */
void initPortExpander(uint8_t addr){
    5306:	0f 93       	push	r16
    5308:	1f 93       	push	r17
    530a:	18 2f       	mov	r17, r24
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    530c:	f8 94       	cli

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    /*  register addr  |  register value   |       send it        */
    IIC.data[0] = IOCONA; IIC.data[1] = 0x20; IICwrite(addr, IIC.data, 2);
    530e:	e0 91 1b 04 	lds	r30, 0x041B
    5312:	f0 91 1c 04 	lds	r31, 0x041C
    5316:	8a e0       	ldi	r24, 0x0A	; 10
    5318:	80 83       	st	Z, r24
    531a:	e0 91 1b 04 	lds	r30, 0x041B
    531e:	f0 91 1c 04 	lds	r31, 0x041C
    5322:	80 e2       	ldi	r24, 0x20	; 32
    5324:	81 83       	std	Z+1, r24	; 0x01
    5326:	60 91 1b 04 	lds	r22, 0x041B
    532a:	70 91 1c 04 	lds	r23, 0x041C
    532e:	81 2f       	mov	r24, r17
    5330:	42 e0       	ldi	r20, 0x02	; 2
    5332:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>

    IIC.data[0] = IODIRA; IIC.data[1] = 0x00; IICwrite(addr, IIC.data, 2);
    5336:	e0 91 1b 04 	lds	r30, 0x041B
    533a:	f0 91 1c 04 	lds	r31, 0x041C
    533e:	10 82       	st	Z, r1
    5340:	e0 91 1b 04 	lds	r30, 0x041B
    5344:	f0 91 1c 04 	lds	r31, 0x041C
    5348:	11 82       	std	Z+1, r1	; 0x01
    534a:	60 91 1b 04 	lds	r22, 0x041B
    534e:	70 91 1c 04 	lds	r23, 0x041C
    5352:	81 2f       	mov	r24, r17
    5354:	42 e0       	ldi	r20, 0x02	; 2
    5356:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>
    IIC.data[0] = IODIRB; IIC.data[1] = 0xFF; IICwrite(addr, IIC.data, 2);
    535a:	e0 91 1b 04 	lds	r30, 0x041B
    535e:	f0 91 1c 04 	lds	r31, 0x041C
    5362:	81 e0       	ldi	r24, 0x01	; 1
    5364:	80 83       	st	Z, r24
    5366:	e0 91 1b 04 	lds	r30, 0x041B
    536a:	f0 91 1c 04 	lds	r31, 0x041C
    536e:	8f ef       	ldi	r24, 0xFF	; 255
    5370:	81 83       	std	Z+1, r24	; 0x01
    5372:	60 91 1b 04 	lds	r22, 0x041B
    5376:	70 91 1c 04 	lds	r23, 0x041C
    537a:	81 2f       	mov	r24, r17
    537c:	42 e0       	ldi	r20, 0x02	; 2
    537e:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>
    IIC.data[0] = GPINTENB; IIC.data[1] = 0x1D; IICwrite(addr, IIC.data, 2);
    5382:	e0 91 1b 04 	lds	r30, 0x041B
    5386:	f0 91 1c 04 	lds	r31, 0x041C
    538a:	85 e0       	ldi	r24, 0x05	; 5
    538c:	80 83       	st	Z, r24
    538e:	e0 91 1b 04 	lds	r30, 0x041B
    5392:	f0 91 1c 04 	lds	r31, 0x041C
    5396:	8d e1       	ldi	r24, 0x1D	; 29
    5398:	81 83       	std	Z+1, r24	; 0x01
    539a:	60 91 1b 04 	lds	r22, 0x041B
    539e:	70 91 1c 04 	lds	r23, 0x041C
    53a2:	81 2f       	mov	r24, r17
    53a4:	42 e0       	ldi	r20, 0x02	; 2
    53a6:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>
    IIC.data[0] = DEFVALB; IIC.data[1] = 0x03; IICwrite(addr, IIC.data, 2);
    53aa:	e0 91 1b 04 	lds	r30, 0x041B
    53ae:	f0 91 1c 04 	lds	r31, 0x041C
    53b2:	87 e0       	ldi	r24, 0x07	; 7
    53b4:	80 83       	st	Z, r24
    53b6:	e0 91 1b 04 	lds	r30, 0x041B
    53ba:	f0 91 1c 04 	lds	r31, 0x041C
    53be:	03 e0       	ldi	r16, 0x03	; 3
    53c0:	01 83       	std	Z+1, r16	; 0x01
    53c2:	60 91 1b 04 	lds	r22, 0x041B
    53c6:	70 91 1c 04 	lds	r23, 0x041C
    53ca:	81 2f       	mov	r24, r17
    53cc:	42 e0       	ldi	r20, 0x02	; 2
    53ce:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>
    IIC.data[0] = INTCONB; IIC.data[1] = 0x03; IICwrite(addr, IIC.data, 2);
    53d2:	e0 91 1b 04 	lds	r30, 0x041B
    53d6:	f0 91 1c 04 	lds	r31, 0x041C
    53da:	89 e0       	ldi	r24, 0x09	; 9
    53dc:	80 83       	st	Z, r24
    53de:	e0 91 1b 04 	lds	r30, 0x041B
    53e2:	f0 91 1c 04 	lds	r31, 0x041C
    53e6:	01 83       	std	Z+1, r16	; 0x01
    53e8:	60 91 1b 04 	lds	r22, 0x041B
    53ec:	70 91 1c 04 	lds	r23, 0x041C
    53f0:	81 2f       	mov	r24, r17
    53f2:	42 e0       	ldi	r20, 0x02	; 2
    53f4:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>
    IIC.data[0] = GPIOA; IIC.data[1] = 0x78; IICwrite(addr, IIC.data, 2);
    53f8:	e0 91 1b 04 	lds	r30, 0x041B
    53fc:	f0 91 1c 04 	lds	r31, 0x041C
    5400:	82 e1       	ldi	r24, 0x12	; 18
    5402:	80 83       	st	Z, r24
    5404:	e0 91 1b 04 	lds	r30, 0x041B
    5408:	f0 91 1c 04 	lds	r31, 0x041C
    540c:	88 e7       	ldi	r24, 0x78	; 120
    540e:	81 83       	std	Z+1, r24	; 0x01
    5410:	60 91 1b 04 	lds	r22, 0x041B
    5414:	70 91 1c 04 	lds	r23, 0x041C
    5418:	81 2f       	mov	r24, r17
    541a:	42 e0       	ldi	r20, 0x02	; 2
    541c:	0e 94 08 3f 	call	0x7e10	; 0x7e10 <IICwrite>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    5420:	78 94       	sei
  }

  return;
}
    5422:	1f 91       	pop	r17
    5424:	0f 91       	pop	r16
    5426:	08 95       	ret

00005428 <readPortExpanderRegister>:
}

/* ---------------------------------------------------------------------
   read port expander register
 --------------------------------------------------------------------- */
uint8_t readPortExpanderRegister(uint8_t addr, uint8_t reg){
    5428:	0f 93       	push	r16
    542a:	1f 93       	push	r17
    542c:	08 2f       	mov	r16, r24
    542e:	16 2f       	mov	r17, r22
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    5430:	f8 94       	cli

  uint8_t val = 0;

  ATOMIC_BLOCK(ATOMIC_FORCEON){
    IICstart();
    5432:	0e 94 da 3e 	call	0x7db4	; 0x7db4 <IICstart>
    if(IICgetStatus() != TW_START){
    5436:	0e 94 04 3f 	call	0x7e08	; 0x7e08 <IICgetStatus>
      /* error handling */
    }

    IICsendByte(addr | TW_WRITE);
    543a:	80 2f       	mov	r24, r16
    543c:	0e 94 e6 3e 	call	0x7dcc	; 0x7dcc <IICsendByte>
    if(IICgetStatus() !=  TW_MR_SLA_ACK){
    5440:	0e 94 04 3f 	call	0x7e08	; 0x7e08 <IICgetStatus>
      /* error handling */
    }

    IICsendByte(reg);
    5444:	81 2f       	mov	r24, r17
    5446:	0e 94 e6 3e 	call	0x7dcc	; 0x7dcc <IICsendByte>
    if(IICgetStatus() !=  TW_MR_SLA_ACK){
    544a:	0e 94 04 3f 	call	0x7e08	; 0x7e08 <IICgetStatus>
      /* error handling */
    }

    IICstart();
    544e:	0e 94 da 3e 	call	0x7db4	; 0x7db4 <IICstart>
    if(IICgetStatus() != TW_START){
    5452:	0e 94 04 3f 	call	0x7e08	; 0x7e08 <IICgetStatus>
      /* error handling */
    }

    IICsendByte(addr | TW_READ);
    5456:	80 2f       	mov	r24, r16
    5458:	81 60       	ori	r24, 0x01	; 1
    545a:	0e 94 e6 3e 	call	0x7dcc	; 0x7dcc <IICsendByte>
    if(IICgetStatus() !=  TW_MR_SLA_ACK){
    545e:	0e 94 04 3f 	call	0x7e08	; 0x7e08 <IICgetStatus>
      /* error handling */
    }

    val = IICreadNACK();
    5462:	0e 94 fa 3e 	call	0x7df4	; 0x7df4 <IICreadNACK>
    5466:	18 2f       	mov	r17, r24
    if(IICgetStatus() !=  TW_MR_DATA_NACK){
    5468:	0e 94 04 3f 	call	0x7e08	; 0x7e08 <IICgetStatus>
      /* error handling */
    }

    IICstop();
    546c:	0e 94 e2 3e 	call	0x7dc4	; 0x7dc4 <IICstop>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    5470:	78 94       	sei
  }

  return val;
}
    5472:	81 2f       	mov	r24, r17
    5474:	1f 91       	pop	r17
    5476:	0f 91       	pop	r16
    5478:	08 95       	ret

0000547a <__vector_1>:
}

/* ---------------------------------------------------------------------
    a button seems to be pressed ;-)
 --------------------------------------------------------------------- */
ISR(INT0_vect){
    547a:	1f 92       	push	r1
    547c:	0f 92       	push	r0
    547e:	0f b6       	in	r0, 0x3f	; 63
    5480:	0f 92       	push	r0
    5482:	0b b6       	in	r0, 0x3b	; 59
    5484:	0f 92       	push	r0
    5486:	11 24       	eor	r1, r1
    5488:	2f 93       	push	r18
    548a:	3f 93       	push	r19
    548c:	4f 93       	push	r20
    548e:	5f 93       	push	r21
    5490:	6f 93       	push	r22
    5492:	7f 93       	push	r23
    5494:	8f 93       	push	r24
    5496:	9f 93       	push	r25
    5498:	af 93       	push	r26
    549a:	bf 93       	push	r27
    549c:	ef 93       	push	r30
    549e:	ff 93       	push	r31
   
  //sendText("INT0");
  
  uint8_t regVal = 0;
  
  regVal = readPortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, INTCAP);
    54a0:	80 e4       	ldi	r24, 0x40	; 64
    54a2:	68 e0       	ldi	r22, 0x08	; 8
    54a4:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>
    54a8:	98 2f       	mov	r25, r24
  
  /* check if a button is actually in process */
  if(buttonState.readyToProcess){
    54aa:	80 91 0c 03 	lds	r24, 0x030C
    54ae:	88 23       	and	r24, r24
    54b0:	29 f4       	brne	.+10     	; 0x54bc <__vector_1+0x42>
    return;
  }
  else{
    buttonState.inputRegister = regVal;
    54b2:	90 93 0a 03 	sts	0x030A, r25
    buttonState.readyToProcess = 1;
    54b6:	81 e0       	ldi	r24, 0x01	; 1
    54b8:	80 93 0c 03 	sts	0x030C, r24
  }

}
    54bc:	ff 91       	pop	r31
    54be:	ef 91       	pop	r30
    54c0:	bf 91       	pop	r27
    54c2:	af 91       	pop	r26
    54c4:	9f 91       	pop	r25
    54c6:	8f 91       	pop	r24
    54c8:	7f 91       	pop	r23
    54ca:	6f 91       	pop	r22
    54cc:	5f 91       	pop	r21
    54ce:	4f 91       	pop	r20
    54d0:	3f 91       	pop	r19
    54d2:	2f 91       	pop	r18
    54d4:	0f 90       	pop	r0
    54d6:	0b be       	out	0x3b, r0	; 59
    54d8:	0f 90       	pop	r0
    54da:	0f be       	out	0x3f, r0	; 63
    54dc:	0f 90       	pop	r0
    54de:	1f 90       	pop	r1
    54e0:	18 95       	reti

000054e2 <initManualOperatingButtons>:
   initializes all buttons and turns on the required interrupts
 --------------------------------------------------------------------- */
void initManualOperatingButtons(void){

  /* only for rotary encoder + its button */
  PORTC |= (1<<PC5)|(1<<PC4)|(1<<PC3);   /* set internal pull-ups */
    54e2:	88 b1       	in	r24, 0x08	; 8
    54e4:	88 63       	ori	r24, 0x38	; 56
    54e6:	88 b9       	out	0x08, r24	; 8
  /* init port expander for buttons
   *
   * http://www.gammon.com.au/forum/?id=10945
   *
   */
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IOCON, 0x22);
    54e8:	80 e4       	ldi	r24, 0x40	; 64
    54ea:	65 e0       	ldi	r22, 0x05	; 5
    54ec:	42 e2       	ldi	r20, 0x22	; 34
    54ee:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IODIR, 0xFF);
    54f2:	80 e4       	ldi	r24, 0x40	; 64
    54f4:	60 e0       	ldi	r22, 0x00	; 0
    54f6:	4f ef       	ldi	r20, 0xFF	; 255
    54f8:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, IPOL, 0xFF);
    54fc:	80 e4       	ldi	r24, 0x40	; 64
    54fe:	61 e0       	ldi	r22, 0x01	; 1
    5500:	4f ef       	ldi	r20, 0xFF	; 255
    5502:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPINTEN, 0xF8);
    5506:	80 e4       	ldi	r24, 0x40	; 64
    5508:	62 e0       	ldi	r22, 0x02	; 2
    550a:	48 ef       	ldi	r20, 0xF8	; 248
    550c:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, DEFVAL, 0x03);
    5510:	80 e4       	ldi	r24, 0x40	; 64
    5512:	63 e0       	ldi	r22, 0x03	; 3
    5514:	43 e0       	ldi	r20, 0x03	; 3
    5516:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, INTCON, 0x00);
    551a:	80 e4       	ldi	r24, 0x40	; 64
    551c:	64 e0       	ldi	r22, 0x04	; 4
    551e:	40 e0       	ldi	r20, 0x00	; 0
    5520:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  writePortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPPU, 0xFF);
    5524:	80 e4       	ldi	r24, 0x40	; 64
    5526:	66 e0       	ldi	r22, 0x06	; 6
    5528:	4f ef       	ldi	r20, 0xFF	; 255
    552a:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  
  //read GPIO register to clear the interrupt
  uint8_t tmp = 0;
  tmp = readPortExpanderRegister(IIC_BUTTON_PORTEXP_ADDR, GPIO);
    552e:	80 e4       	ldi	r24, 0x40	; 64
    5530:	69 e0       	ldi	r22, 0x09	; 9
    5532:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>

  /* activate interrupt on INT0 (PD2) */
  EICRA |= (1<<ISC01)|(1<<ISC00);  /* rising edge causes interrupt */
    5536:	e9 e6       	ldi	r30, 0x69	; 105
    5538:	f0 e0       	ldi	r31, 0x00	; 0
    553a:	80 81       	ld	r24, Z
    553c:	83 60       	ori	r24, 0x03	; 3
    553e:	80 83       	st	Z, r24
  EIMSK |= (1<<INT0);   /* enable interrupt pin INT0 */
    5540:	e8 9a       	sbi	0x1d, 0	; 29

  /* set up a timer for button/rotary_encoder polling
   *
   * the 8-bit Timer/Counter0 is used for that
   */
  TCCR0A |= (1<<WGM01);   /* enable CTC */
    5542:	84 b5       	in	r24, 0x24	; 36
    5544:	82 60       	ori	r24, 0x02	; 2
    5546:	84 bd       	out	0x24, r24	; 36
  OCR0A   = 40;           /* 40 is an empirical value for best behavior of the rotEnc. */
    5548:	88 e2       	ldi	r24, 0x28	; 40
    554a:	87 bd       	out	0x27, r24	; 39
  TIMSK0 |= (1<<OCIE0A);  /* enable interrupt */
    554c:	ee e6       	ldi	r30, 0x6E	; 110
    554e:	f0 e0       	ldi	r31, 0x00	; 0
    5550:	80 81       	ld	r24, Z
    5552:	82 60       	ori	r24, 0x02	; 2
    5554:	80 83       	st	Z, r24
  TCNT0   = 0;
    5556:	16 bc       	out	0x26, r1	; 38

  /* start the timer/counter */
  TCCR0B |= (1<<CS02)|(1<<CS00);  /* prescaler = 1024 --> 51.2 us per cycle */
    5558:	85 b5       	in	r24, 0x25	; 37
    555a:	85 60       	ori	r24, 0x05	; 5
    555c:	85 bd       	out	0x25, r24	; 37

  return;
}
    555e:	08 95       	ret

00005560 <getMotorSens>:
}

/* ---------------------------------------------------------------------
     read motor port expander input pin
 --------------------------------------------------------------------- */
uint8_t getMotorSens(uint8_t mot, uint8_t sens){
    5560:	1f 93       	push	r17
    5562:	16 2f       	mov	r17, r22

  uint8_t addr = 0;
  uint8_t regval = 0;
  uint8_t state = 0;

  addr = getPortExpanderAddress(mot);
    5564:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
  regval = readPortExpanderRegister(addr, GPIOB);
    5568:	63 e1       	ldi	r22, 0x13	; 19
    556a:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>
    556e:	21 e0       	ldi	r18, 0x01	; 1
    5570:	30 e0       	ldi	r19, 0x00	; 0
    5572:	02 c0       	rjmp	.+4      	; 0x5578 <getMotorSens+0x18>
    5574:	22 0f       	add	r18, r18
    5576:	33 1f       	adc	r19, r19
    5578:	1a 95       	dec	r17
    557a:	e2 f7       	brpl	.-8      	; 0x5574 <getMotorSens+0x14>
    557c:	82 23       	and	r24, r18
    557e:	09 f0       	breq	.+2      	; 0x5582 <getMotorSens+0x22>
    5580:	81 e0       	ldi	r24, 0x01	; 1
  else{
    state = 0;
  }

  return state;
}
    5582:	1f 91       	pop	r17
    5584:	08 95       	ret

00005586 <commandIsConnected>:
}

/* ---------------------------------------------------------------------
    returns whether a motor is connected or not
 --------------------------------------------------------------------- */
char* commandIsConnected(char* param0){
    5586:	1f 93       	push	r17

  uint8_t i = 0;
  //uint8_t mota = 0;
  //uint8_t motb = 0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    5588:	60 e0       	ldi	r22, 0x00	; 0
    558a:	70 e0       	ldi	r23, 0x00	; 0
    558c:	4a e0       	ldi	r20, 0x0A	; 10
    558e:	50 e0       	ldi	r21, 0x00	; 0
    5590:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    5594:	16 2f       	mov	r17, r22
  //motb = getMotorSens(i, PORTEXP_MOTOR_MOTB);
  
  //sprintf(txString.buffer, "\nmota=%d\nmotb=%d\n", mota, motb);
  //sendText(txString.buffer);

  if(i > MAX_MOTOR){
    5596:	64 30       	cpi	r22, 0x04	; 4
    5598:	20 f5       	brcc	.+72     	; 0x55e2 <commandIsConnected+0x5c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(getMotorSens(i, PORTEXP_MOTOR_MOTA) && getMotorSens(i, PORTEXP_MOTOR_MOTB)){
    559a:	86 2f       	mov	r24, r22
    559c:	65 e0       	ldi	r22, 0x05	; 5
    559e:	0e 94 b0 2a 	call	0x5560	; 0x5560 <getMotorSens>
    55a2:	88 23       	and	r24, r24
    55a4:	79 f4       	brne	.+30     	; 0x55c4 <commandIsConnected+0x3e>
      sprintf(txString.buffer, "0"); //motor is not connected
    }
    else{
      sprintf(txString.buffer, "1"); //motor is connected
    55a6:	e0 91 15 04 	lds	r30, 0x0415
    55aa:	f0 91 16 04 	lds	r31, 0x0416
    55ae:	81 e3       	ldi	r24, 0x31	; 49
    55b0:	90 e0       	ldi	r25, 0x00	; 0
    55b2:	91 83       	std	Z+1, r25	; 0x01
    55b4:	80 83       	st	Z, r24
    }
  }

  return txString.buffer;
    55b6:	20 91 15 04 	lds	r18, 0x0415
    55ba:	30 91 16 04 	lds	r19, 0x0416
}
    55be:	c9 01       	movw	r24, r18
    55c0:	1f 91       	pop	r17
    55c2:	08 95       	ret

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
  }
  else{
    if(getMotorSens(i, PORTEXP_MOTOR_MOTA) && getMotorSens(i, PORTEXP_MOTOR_MOTB)){
    55c4:	81 2f       	mov	r24, r17
    55c6:	66 e0       	ldi	r22, 0x06	; 6
    55c8:	0e 94 b0 2a 	call	0x5560	; 0x5560 <getMotorSens>
    55cc:	88 23       	and	r24, r24
    55ce:	59 f3       	breq	.-42     	; 0x55a6 <commandIsConnected+0x20>
      sprintf(txString.buffer, "0"); //motor is not connected
    55d0:	e0 91 15 04 	lds	r30, 0x0415
    55d4:	f0 91 16 04 	lds	r31, 0x0416
    55d8:	80 e3       	ldi	r24, 0x30	; 48
    55da:	90 e0       	ldi	r25, 0x00	; 0
    55dc:	91 83       	std	Z+1, r25	; 0x01
    55de:	80 83       	st	Z, r24
    55e0:	ea cf       	rjmp	.-44     	; 0x55b6 <commandIsConnected+0x30>
  
  //sprintf(txString.buffer, "\nmota=%d\nmotb=%d\n", mota, motb);
  //sendText(txString.buffer);

  if(i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    55e2:	80 91 15 04 	lds	r24, 0x0415
    55e6:	90 91 16 04 	lds	r25, 0x0416
    55ea:	00 d0       	rcall	.+0      	; 0x55ec <commandIsConnected+0x66>
    55ec:	00 d0       	rcall	.+0      	; 0x55ee <commandIsConnected+0x68>
    55ee:	00 d0       	rcall	.+0      	; 0x55f0 <commandIsConnected+0x6a>
    55f0:	ed b7       	in	r30, 0x3d	; 61
    55f2:	fe b7       	in	r31, 0x3e	; 62
    55f4:	31 96       	adiw	r30, 0x01	; 1
    55f6:	ad b7       	in	r26, 0x3d	; 61
    55f8:	be b7       	in	r27, 0x3e	; 62
    55fa:	12 96       	adiw	r26, 0x02	; 2
    55fc:	9c 93       	st	X, r25
    55fe:	8e 93       	st	-X, r24
    5600:	11 97       	sbiw	r26, 0x01	; 1
    5602:	80 e0       	ldi	r24, 0x00	; 0
    5604:	91 e0       	ldi	r25, 0x01	; 1
    5606:	93 83       	std	Z+3, r25	; 0x03
    5608:	82 83       	std	Z+2, r24	; 0x02
    560a:	14 83       	std	Z+4, r17	; 0x04
    560c:	15 82       	std	Z+5, r1	; 0x05
    560e:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    5612:	8d b7       	in	r24, 0x3d	; 61
    5614:	9e b7       	in	r25, 0x3e	; 62
    5616:	06 96       	adiw	r24, 0x06	; 6
    5618:	0f b6       	in	r0, 0x3f	; 63
    561a:	f8 94       	cli
    561c:	9e bf       	out	0x3e, r25	; 62
    561e:	0f be       	out	0x3f, r0	; 63
    5620:	8d bf       	out	0x3d, r24	; 61
    else{
      sprintf(txString.buffer, "1"); //motor is connected
    }
  }

  return txString.buffer;
    5622:	20 91 15 04 	lds	r18, 0x0415
    5626:	30 91 16 04 	lds	r19, 0x0416
}
    562a:	c9 01       	movw	r24, r18
    562c:	1f 91       	pop	r17
    562e:	08 95       	ret

00005630 <wakeMotorUp>:
}

/* ---------------------------------------------------------------------
     get motor out of bed
 --------------------------------------------------------------------- */
void wakeMotorUp(uint8_t mot){
    5630:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    5632:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
    5636:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    5638:	62 e1       	ldi	r22, 0x12	; 18
    563a:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>

  regval |= (1<<PORTEXP_MOTOR_SLEEP);

  writePortExpanderRegister(addr, GPIOA, regval);
    563e:	48 2f       	mov	r20, r24
    5640:	40 62       	ori	r20, 0x20	; 32
    5642:	81 2f       	mov	r24, r17
    5644:	62 e1       	ldi	r22, 0x12	; 18
    5646:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    564a:	80 e1       	ldi	r24, 0x10	; 16
    564c:	97 e2       	ldi	r25, 0x27	; 39
    564e:	01 97       	sbiw	r24, 0x01	; 1
    5650:	f1 f7       	brne	.-4      	; 0x564e <wakeMotorUp+0x1e>
  _delay_ms(2);

  return;
}
    5652:	1f 91       	pop	r17
    5654:	08 95       	ret

00005656 <setMotorSleep>:
}

/* ---------------------------------------------------------------------
     send motor to bed (active LOW)
 --------------------------------------------------------------------- */
void setMotorSleep(uint8_t mot){
    5656:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    5658:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
    565c:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    565e:	62 e1       	ldi	r22, 0x12	; 18
    5660:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>

  regval &= ~(1<<PORTEXP_MOTOR_SLEEP);

  writePortExpanderRegister(addr, GPIOA, regval);
    5664:	48 2f       	mov	r20, r24
    5666:	4f 7d       	andi	r20, 0xDF	; 223
    5668:	81 2f       	mov	r24, r17
    566a:	62 e1       	ldi	r22, 0x12	; 18
    566c:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>

  return;
}
    5670:	1f 91       	pop	r17
    5672:	08 95       	ret

00005674 <resetMotorLogic>:
     resets the internal motor logic (active LOW):
     - step table
     - home position
     - disables H-bridges
 --------------------------------------------------------------------- */
void resetMotorLogic(uint8_t mot){
    5674:	0f 93       	push	r16
    5676:	1f 93       	push	r17

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    5678:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
    567c:	08 2f       	mov	r16, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    567e:	62 e1       	ldi	r22, 0x12	; 18
    5680:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>

  regval &= ~(1<<PORTEXP_MOTOR_RESET);
    5684:	18 2f       	mov	r17, r24
    5686:	1f 7b       	andi	r17, 0xBF	; 191
  writePortExpanderRegister(addr, GPIOA, regval);
    5688:	80 2f       	mov	r24, r16
    568a:	62 e1       	ldi	r22, 0x12	; 18
    568c:	41 2f       	mov	r20, r17
    568e:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  regval |= (1<<PORTEXP_MOTOR_RESET);
  writePortExpanderRegister(addr, GPIOA, regval);
    5692:	10 64       	ori	r17, 0x40	; 64
    5694:	80 2f       	mov	r24, r16
    5696:	62 e1       	ldi	r22, 0x12	; 18
    5698:	41 2f       	mov	r20, r17
    569a:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>

  return;
}
    569e:	1f 91       	pop	r17
    56a0:	0f 91       	pop	r16
    56a2:	08 95       	ret

000056a4 <motorZeroRun>:
/* ---------------------------------------------------------------------
    zero run: position calibration for the motor.
    After zero run motor will have the fast axis position of any
    wave plate.
 --------------------------------------------------------------------- */
void motorZeroRun(uint8_t i){
    56a4:	2f 92       	push	r2
    56a6:	3f 92       	push	r3
    56a8:	4f 92       	push	r4
    56aa:	5f 92       	push	r5
    56ac:	6f 92       	push	r6
    56ae:	7f 92       	push	r7
    56b0:	8f 92       	push	r8
    56b2:	9f 92       	push	r9
    56b4:	bf 92       	push	r11
    56b6:	cf 92       	push	r12
    56b8:	df 92       	push	r13
    56ba:	ef 92       	push	r14
    56bc:	ff 92       	push	r15
    56be:	0f 93       	push	r16
    56c0:	1f 93       	push	r17
    56c2:	cf 93       	push	r28
    56c4:	df 93       	push	r29
    56c6:	b8 2e       	mov	r11, r24
  uint16_t keepWaitTime = 0;
  double stepsPerRound = 0.0f;
  //uint16_t thres = 50;  /* threshold for the ADC reading of the Hall sensor */
  uint16_t j = 0;

  if(forbiddenZone[i].active){
    56c8:	88 2e       	mov	r8, r24
    56ca:	99 24       	eor	r9, r9
    56cc:	24 01       	movw	r4, r8
    56ce:	44 0c       	add	r4, r4
    56d0:	55 1c       	adc	r5, r5
    56d2:	44 0c       	add	r4, r4
    56d4:	55 1c       	adc	r5, r5
    56d6:	f2 01       	movw	r30, r4
    56d8:	e8 0d       	add	r30, r8
    56da:	f9 1d       	adc	r31, r9
    56dc:	ef 5f       	subi	r30, 0xFF	; 255
    56de:	fb 4f       	sbci	r31, 0xFB	; 251
    56e0:	84 81       	ldd	r24, Z+4	; 0x04
    56e2:	88 23       	and	r24, r24
    56e4:	09 f0       	breq	.+2      	; 0x56e8 <motorZeroRun+0x44>
    56e6:	c8 c0       	rjmp	.+400    	; 0x5878 <motorZeroRun+0x1d4>
    /* zerorun not allowed if forbidden zone is active */
    return;
  }

  /* stop any motor movements (stop timer/counter2) */
  TCCR2B &= ~0x07;
    56e8:	80 91 b1 00 	lds	r24, 0x00B1
    56ec:	88 7f       	andi	r24, 0xF8	; 248
    56ee:	80 93 b1 00 	sts	0x00B1, r24

  keepWaitTime = motor[i].waitBetweenSteps;
    56f2:	34 01       	movw	r6, r8
    56f4:	66 0c       	add	r6, r6
    56f6:	77 1c       	adc	r7, r7
    56f8:	66 0c       	add	r6, r6
    56fa:	77 1c       	adc	r7, r7
    56fc:	66 0c       	add	r6, r6
    56fe:	77 1c       	adc	r7, r7
    5700:	83 01       	movw	r16, r6
    5702:	00 0f       	add	r16, r16
    5704:	11 1f       	adc	r17, r17
    5706:	00 0f       	add	r16, r16
    5708:	11 1f       	adc	r17, r17
    570a:	06 0d       	add	r16, r6
    570c:	17 1d       	adc	r17, r7
    570e:	02 5e       	subi	r16, 0xE2	; 226
    5710:	1b 4f       	sbci	r17, 0xFB	; 251
    5712:	f8 01       	movw	r30, r16
    5714:	26 8c       	ldd	r2, Z+30	; 0x1e
    5716:	37 8c       	ldd	r3, Z+31	; 0x1f

  stepsPerRound = motor[i].stepsPerFullRotation
    5718:	61 89       	ldd	r22, Z+17	; 0x11
    571a:	72 89       	ldd	r23, Z+18	; 0x12
    571c:	83 89       	ldd	r24, Z+19	; 0x13
    571e:	94 89       	ldd	r25, Z+20	; 0x14
    5720:	25 85       	ldd	r18, Z+13	; 0x0d
    5722:	36 85       	ldd	r19, Z+14	; 0x0e
    5724:	47 85       	ldd	r20, Z+15	; 0x0f
    5726:	50 89       	ldd	r21, Z+16	; 0x10
    5728:	c5 88       	ldd	r12, Z+21	; 0x15
    572a:	d6 88       	ldd	r13, Z+22	; 0x16
    572c:	e7 88       	ldd	r14, Z+23	; 0x17
    572e:	f0 8c       	ldd	r15, Z+24	; 0x18
    5730:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    5734:	a7 01       	movw	r20, r14
    5736:	96 01       	movw	r18, r12
    5738:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    573c:	6b 01       	movw	r12, r22
    573e:	7c 01       	movw	r14, r24
                  * motor[i].subSteps;

  /* fist step:
   * move 360 degree to find the roughly position of the magnetic zero point.
   * this will be done with fast moving */
  motor[i].waitBetweenSteps = 1;    /* set 1 ms for fast moving */
    5740:	81 e0       	ldi	r24, 0x01	; 1
    5742:	90 e0       	ldi	r25, 0x00	; 0
    5744:	f8 01       	movw	r30, r16
    5746:	97 8f       	std	Z+31, r25	; 0x1f
    5748:	86 8f       	std	Z+30, r24	; 0x1e
    574a:	05 c0       	rjmp	.+10     	; 0x5756 <motorZeroRun+0xb2>

  /* in case we are at any possible zero position: move out */
  //while(getADCvalue(i) < thres){
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, -200);
    574c:	8b 2d       	mov	r24, r11
    574e:	68 e3       	ldi	r22, 0x38	; 56
    5750:	7f ef       	ldi	r23, 0xFF	; 255
    5752:	0e 94 17 06 	call	0xc2e	; 0xc2e <moveMotorRelative>
   * this will be done with fast moving */
  motor[i].waitBetweenSteps = 1;    /* set 1 ms for fast moving */

  /* in case we are at any possible zero position: move out */
  //while(getADCvalue(i) < thres){
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    5756:	8b 2d       	mov	r24, r11
    5758:	64 e0       	ldi	r22, 0x04	; 4
    575a:	0e 94 b0 2a 	call	0x5560	; 0x5560 <getMotorSens>
    575e:	88 23       	and	r24, r24
    5760:	a9 f7       	brne	.-22     	; 0x574c <motorZeroRun+0xa8>
/* ---------------------------------------------------------------------
    zero run: position calibration for the motor.
    After zero run motor will have the fast axis position of any
    wave plate.
 --------------------------------------------------------------------- */
void motorZeroRun(uint8_t i){
    5762:	c7 01       	movw	r24, r14
    5764:	b6 01       	movw	r22, r12
    5766:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    576a:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
    576e:	8b 01       	movw	r16, r22
    5770:	c0 e0       	ldi	r28, 0x00	; 0
    5772:	d0 e0       	ldi	r29, 0x00	; 0
    5774:	0c c0       	rjmp	.+24     	; 0x578e <motorZeroRun+0xea>
    moveMotorRelative(i, -200);
  }

  /* start first search for zero point */
  for(j = 0; j < (uint16_t)round(stepsPerRound); j++){
    moveMotorRelative(i, 1);
    5776:	8b 2d       	mov	r24, r11
    5778:	61 e0       	ldi	r22, 0x01	; 1
    577a:	70 e0       	ldi	r23, 0x00	; 0
    577c:	0e 94 17 06 	call	0xc2e	; 0xc2e <moveMotorRelative>
    //if(getADCvalue(i) < thres){
	if(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    5780:	8b 2d       	mov	r24, r11
    5782:	64 e0       	ldi	r22, 0x04	; 4
    5784:	0e 94 b0 2a 	call	0x5560	; 0x5560 <getMotorSens>
    5788:	88 23       	and	r24, r24
    578a:	21 f4       	brne	.+8      	; 0x5794 <motorZeroRun+0xf0>
  while(getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, -200);
  }

  /* start first search for zero point */
  for(j = 0; j < (uint16_t)round(stepsPerRound); j++){
    578c:	21 96       	adiw	r28, 0x01	; 1
    578e:	c0 17       	cp	r28, r16
    5790:	d1 07       	cpc	r29, r17
    5792:	88 f3       	brcs	.-30     	; 0x5776 <motorZeroRun+0xd2>
      break;
    }
  }

  /* move 90 degree forward */
  moveMotorRelative(i, (int16_t)round(0.25*stepsPerRound));
    5794:	c7 01       	movw	r24, r14
    5796:	b6 01       	movw	r22, r12
    5798:	20 e0       	ldi	r18, 0x00	; 0
    579a:	30 e0       	ldi	r19, 0x00	; 0
    579c:	40 e8       	ldi	r20, 0x80	; 128
    579e:	5e e3       	ldi	r21, 0x3E	; 62
    57a0:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    57a4:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    57a8:	0e 94 f7 43 	call	0x87ee	; 0x87ee <__fixsfsi>
    57ac:	9b 01       	movw	r18, r22
    57ae:	ac 01       	movw	r20, r24
    57b0:	8b 2d       	mov	r24, r11
    57b2:	b9 01       	movw	r22, r18
    57b4:	0e 94 17 06 	call	0xc2e	; 0xc2e <moveMotorRelative>
  /* second step:
   * move again to 200 steps before the former found zero position fast.
   * then move slowly to find the exact magnetic zero position. */

  /* now move till 200 steps before the zero-position */
  moveMotorRelative(i, (int16_t)round(0.75*stepsPerRound) - 200);
    57b8:	c7 01       	movw	r24, r14
    57ba:	b6 01       	movw	r22, r12
    57bc:	20 e0       	ldi	r18, 0x00	; 0
    57be:	30 e0       	ldi	r19, 0x00	; 0
    57c0:	40 e4       	ldi	r20, 0x40	; 64
    57c2:	5f e3       	ldi	r21, 0x3F	; 63
    57c4:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    57c8:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    57cc:	0e 94 f7 43 	call	0x87ee	; 0x87ee <__fixsfsi>
    57d0:	9b 01       	movw	r18, r22
    57d2:	ac 01       	movw	r20, r24
    57d4:	28 5c       	subi	r18, 0xC8	; 200
    57d6:	30 40       	sbci	r19, 0x00	; 0
    57d8:	8b 2d       	mov	r24, r11
    57da:	b9 01       	movw	r22, r18
    57dc:	0e 94 17 06 	call	0xc2e	; 0xc2e <moveMotorRelative>

  /* now get slow to find zero position precisely */
  motor[i].waitBetweenSteps = 5;
    57e0:	f3 01       	movw	r30, r6
    57e2:	ee 0f       	add	r30, r30
    57e4:	ff 1f       	adc	r31, r31
    57e6:	ee 0f       	add	r30, r30
    57e8:	ff 1f       	adc	r31, r31
    57ea:	e6 0d       	add	r30, r6
    57ec:	f7 1d       	adc	r31, r7
    57ee:	e2 5e       	subi	r30, 0xE2	; 226
    57f0:	fb 4f       	sbci	r31, 0xFB	; 251
    57f2:	85 e0       	ldi	r24, 0x05	; 5
    57f4:	90 e0       	ldi	r25, 0x00	; 0
    57f6:	97 8f       	std	Z+31, r25	; 0x1f
    57f8:	86 8f       	std	Z+30, r24	; 0x1e
    57fa:	05 c0       	rjmp	.+10     	; 0x5806 <motorZeroRun+0x162>

  /* and move till the threshold is reached */
  //while(getADCvalue(i) > thres){
  while(!getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    moveMotorRelative(i, 1);
    57fc:	8b 2d       	mov	r24, r11
    57fe:	61 e0       	ldi	r22, 0x01	; 1
    5800:	70 e0       	ldi	r23, 0x00	; 0
    5802:	0e 94 17 06 	call	0xc2e	; 0xc2e <moveMotorRelative>
  /* now get slow to find zero position precisely */
  motor[i].waitBetweenSteps = 5;

  /* and move till the threshold is reached */
  //while(getADCvalue(i) > thres){
  while(!getMotorSens(i, PORTEXP_MOTOR_SENSA)){
    5806:	8b 2d       	mov	r24, r11
    5808:	64 e0       	ldi	r22, 0x04	; 4
    580a:	0e 94 b0 2a 	call	0x5560	; 0x5560 <getMotorSens>
    580e:	88 23       	and	r24, r24
    5810:	a9 f3       	breq	.-22     	; 0x57fc <motorZeroRun+0x158>
  }
  /* and here we found our magnetic zero position :-) */

  /* third step:
   * go to the internal saved optical zero position */
  motor[i].waitBetweenSteps = keepWaitTime;
    5812:	83 01       	movw	r16, r6
    5814:	00 0f       	add	r16, r16
    5816:	11 1f       	adc	r17, r17
    5818:	00 0f       	add	r16, r16
    581a:	11 1f       	adc	r17, r17
    581c:	06 0d       	add	r16, r6
    581e:	17 1d       	adc	r17, r7
    5820:	02 5e       	subi	r16, 0xE2	; 226
    5822:	1b 4f       	sbci	r17, 0xFB	; 251
    5824:	f8 01       	movw	r30, r16
    5826:	37 8e       	std	Z+31, r3	; 0x1f
    5828:	26 8e       	std	Z+30, r2	; 0x1e
  moveMotorRelative(i, motor[i].opticalZeroPosition);
    582a:	88 0c       	add	r8, r8
    582c:	99 1c       	adc	r9, r9
    582e:	86 0c       	add	r8, r6
    5830:	97 1c       	adc	r9, r7
    5832:	88 0c       	add	r8, r8
    5834:	99 1c       	adc	r9, r9
    5836:	88 0c       	add	r8, r8
    5838:	99 1c       	adc	r9, r9
    583a:	82 e2       	ldi	r24, 0x22	; 34
    583c:	94 e0       	ldi	r25, 0x04	; 4
    583e:	88 0e       	add	r8, r24
    5840:	99 1e       	adc	r9, r25
    5842:	f4 01       	movw	r30, r8
    5844:	60 81       	ld	r22, Z
    5846:	71 81       	ldd	r23, Z+1	; 0x01
    5848:	8b 2d       	mov	r24, r11
    584a:	0e 94 17 06 	call	0xc2e	; 0xc2e <moveMotorRelative>

  /* now set motor into a defined state */
  motor[i].actualPosition = 0;
    584e:	f8 01       	movw	r30, r16
    5850:	11 82       	std	Z+1, r1	; 0x01
    5852:	10 82       	st	Z, r1
  motor[i].desiredPosition = 0;
    5854:	f2 01       	movw	r30, r4
    5856:	ee 0f       	add	r30, r30
    5858:	ff 1f       	adc	r31, r31
    585a:	ee 0f       	add	r30, r30
    585c:	ff 1f       	adc	r31, r31
    585e:	e4 0d       	add	r30, r4
    5860:	f5 1d       	adc	r31, r5
    5862:	ee 0f       	add	r30, r30
    5864:	ff 1f       	adc	r31, r31
    5866:	e0 5e       	subi	r30, 0xE0	; 224
    5868:	fb 4f       	sbci	r31, 0xFB	; 251
    586a:	11 82       	std	Z+1, r1	; 0x01
    586c:	10 82       	st	Z, r1

  resetMotorLogic(i);
    586e:	8b 2d       	mov	r24, r11
    5870:	0e 94 3a 2b 	call	0x5674	; 0x5674 <resetMotorLogic>

  /* allow motor movements again */
  initMotorDelayTimer();
    5874:	0e 94 02 06 	call	0xc04	; 0xc04 <initMotorDelayTimer>

  return;
}
    5878:	df 91       	pop	r29
    587a:	cf 91       	pop	r28
    587c:	1f 91       	pop	r17
    587e:	0f 91       	pop	r16
    5880:	ff 90       	pop	r15
    5882:	ef 90       	pop	r14
    5884:	df 90       	pop	r13
    5886:	cf 90       	pop	r12
    5888:	bf 90       	pop	r11
    588a:	9f 90       	pop	r9
    588c:	8f 90       	pop	r8
    588e:	7f 90       	pop	r7
    5890:	6f 90       	pop	r6
    5892:	5f 90       	pop	r5
    5894:	4f 90       	pop	r4
    5896:	3f 90       	pop	r3
    5898:	2f 90       	pop	r2
    589a:	08 95       	ret

0000589c <setMotorDecay>:
}

/* ---------------------------------------------------------------------
     sets the motor decay (SLOW = 0, FAST = 1, MIXED = 2)
 --------------------------------------------------------------------- */
void setMotorDecay(uint8_t mot, uint8_t state){
    589c:	ff 92       	push	r15
    589e:	0f 93       	push	r16
    58a0:	1f 93       	push	r17
    58a2:	f6 2e       	mov	r15, r22

  uint8_t addr = 0;
  uint8_t regval = 0;
  uint8_t iodir = 0;

  addr = getPortExpanderAddress(mot);
    58a4:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
    58a8:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    58aa:	62 e1       	ldi	r22, 0x12	; 18
    58ac:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>
    58b0:	08 2f       	mov	r16, r24
  iodir = readPortExpanderRegister(addr, IODIRA);
    58b2:	81 2f       	mov	r24, r17
    58b4:	60 e0       	ldi	r22, 0x00	; 0
    58b6:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>

  if(state == DECAY_MODE_FAST){ //fast decay
    58ba:	91 e0       	ldi	r25, 0x01	; 1
    58bc:	f9 16       	cp	r15, r25
    58be:	a9 f0       	breq	.+42     	; 0x58ea <setMotorDecay+0x4e>
    regval |= (1<<PORTEXP_MOTOR_DECAY);
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
  }
  else if(state == DECAY_MODE_MIXED){ //mixed decay
    58c0:	92 e0       	ldi	r25, 0x02	; 2
    58c2:	f9 16       	cp	r15, r25
    58c4:	b9 f0       	breq	.+46     	; 0x58f4 <setMotorDecay+0x58>
    iodir  |= (1<<PORTEXP_MOTOR_DECAY); //set as input so pin is "open"
  }
  else{ //slow decay
    regval &= ~(1<<PORTEXP_MOTOR_DECAY);
    58c6:	0f 7e       	andi	r16, 0xEF	; 239
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
    58c8:	3f ee       	ldi	r19, 0xEF	; 239
    58ca:	f3 2e       	mov	r15, r19
    58cc:	f8 22       	and	r15, r24
  }

  writePortExpanderRegister(addr, GPIOA, regval);
    58ce:	81 2f       	mov	r24, r17
    58d0:	62 e1       	ldi	r22, 0x12	; 18
    58d2:	40 2f       	mov	r20, r16
    58d4:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  writePortExpanderRegister(addr, IODIRA, iodir);
    58d8:	81 2f       	mov	r24, r17
    58da:	60 e0       	ldi	r22, 0x00	; 0
    58dc:	4f 2d       	mov	r20, r15
    58de:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>

  return;
}
    58e2:	1f 91       	pop	r17
    58e4:	0f 91       	pop	r16
    58e6:	ff 90       	pop	r15
    58e8:	08 95       	ret
  addr = getPortExpanderAddress(mot);
  regval = readPortExpanderRegister(addr, GPIOA);
  iodir = readPortExpanderRegister(addr, IODIRA);

  if(state == DECAY_MODE_FAST){ //fast decay
    regval |= (1<<PORTEXP_MOTOR_DECAY);
    58ea:	00 61       	ori	r16, 0x10	; 16
    iodir  &= ~(1<<PORTEXP_MOTOR_DECAY);
    58ec:	5f ee       	ldi	r21, 0xEF	; 239
    58ee:	f5 2e       	mov	r15, r21
    58f0:	f8 22       	and	r15, r24
    58f2:	ed cf       	rjmp	.-38     	; 0x58ce <setMotorDecay+0x32>
  }
  else if(state == DECAY_MODE_MIXED){ //mixed decay
    iodir  |= (1<<PORTEXP_MOTOR_DECAY); //set as input so pin is "open"
    58f4:	40 e1       	ldi	r20, 0x10	; 16
    58f6:	f4 2e       	mov	r15, r20
    58f8:	f8 2a       	or	r15, r24
    58fa:	e9 cf       	rjmp	.-46     	; 0x58ce <setMotorDecay+0x32>

000058fc <commandSetMotorDecay>:
}

/* ---------------------------------------------------------------------
    sets the desired motor decay
 --------------------------------------------------------------------- */
void commandSetMotorDecay(char* param0, char* param1){
    58fc:	ff 92       	push	r15
    58fe:	0f 93       	push	r16
    5900:	1f 93       	push	r17
    5902:	8b 01       	movw	r16, r22
  
  uint8_t i = 0;
  uint8_t decay = 0;
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    5904:	60 e0       	ldi	r22, 0x00	; 0
    5906:	70 e0       	ldi	r23, 0x00	; 0
    5908:	4a e0       	ldi	r20, 0x0A	; 10
    590a:	50 e0       	ldi	r21, 0x00	; 0
    590c:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    5910:	f6 2e       	mov	r15, r22
  decay = (uint8_t)strtol(param1, (char **)NULL, 10);
    5912:	c8 01       	movw	r24, r16
    5914:	60 e0       	ldi	r22, 0x00	; 0
    5916:	70 e0       	ldi	r23, 0x00	; 0
    5918:	4a e0       	ldi	r20, 0x0A	; 10
    591a:	50 e0       	ldi	r21, 0x00	; 0
    591c:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    5920:	06 2f       	mov	r16, r22
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    5922:	23 e0       	ldi	r18, 0x03	; 3
    5924:	2f 15       	cp	r18, r15
    5926:	08 f4       	brcc	.+2      	; 0x592a <commandSetMotorDecay+0x2e>
    5928:	3f c0       	rjmp	.+126    	; 0x59a8 <commandSetMotorDecay+0xac>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
  }
  if(decay < DECAY_MODE_SLOW || decay > DECAY_MODE_MIXED){
    592a:	03 30       	cpi	r16, 0x03	; 3
    592c:	58 f5       	brcc	.+86     	; 0x5984 <commandSetMotorDecay+0x88>
    sprintf(txString.buffer, "err: unknown decay mode");
    sendText(txString.buffer);
  }
  else{
    //motor[i].decay = atof(param1);
    motor[i].decay = decay;
    592e:	ef 2d       	mov	r30, r15
    5930:	f0 e0       	ldi	r31, 0x00	; 0
    5932:	ee 0f       	add	r30, r30
    5934:	ff 1f       	adc	r31, r31
    5936:	ee 0f       	add	r30, r30
    5938:	ff 1f       	adc	r31, r31
    593a:	ee 0f       	add	r30, r30
    593c:	ff 1f       	adc	r31, r31
    593e:	cf 01       	movw	r24, r30
    5940:	88 0f       	add	r24, r24
    5942:	99 1f       	adc	r25, r25
    5944:	88 0f       	add	r24, r24
    5946:	99 1f       	adc	r25, r25
    5948:	e8 0f       	add	r30, r24
    594a:	f9 1f       	adc	r31, r25
    594c:	e2 5e       	subi	r30, 0xE2	; 226
    594e:	fb 4f       	sbci	r31, 0xFB	; 251
    5950:	07 a3       	std	Z+39, r16	; 0x27
    setMotorDecay(i, motor[i].decay);
    5952:	ef 2d       	mov	r30, r15
    5954:	f0 e0       	ldi	r31, 0x00	; 0
    5956:	ee 0f       	add	r30, r30
    5958:	ff 1f       	adc	r31, r31
    595a:	ee 0f       	add	r30, r30
    595c:	ff 1f       	adc	r31, r31
    595e:	ee 0f       	add	r30, r30
    5960:	ff 1f       	adc	r31, r31
    5962:	cf 01       	movw	r24, r30
    5964:	88 0f       	add	r24, r24
    5966:	99 1f       	adc	r25, r25
    5968:	88 0f       	add	r24, r24
    596a:	99 1f       	adc	r25, r25
    596c:	e8 0f       	add	r30, r24
    596e:	f9 1f       	adc	r31, r25
    5970:	e2 5e       	subi	r30, 0xE2	; 226
    5972:	fb 4f       	sbci	r31, 0xFB	; 251
    5974:	67 a1       	ldd	r22, Z+39	; 0x27
    5976:	8f 2d       	mov	r24, r15
    5978:	0e 94 4e 2c 	call	0x589c	; 0x589c <setMotorDecay>
  }

  return;
}
    597c:	1f 91       	pop	r17
    597e:	0f 91       	pop	r16
    5980:	ff 90       	pop	r15
    5982:	08 95       	ret
  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
  }
  if(decay < DECAY_MODE_SLOW || decay > DECAY_MODE_MIXED){
    sprintf(txString.buffer, "err: unknown decay mode");
    5984:	a0 91 15 04 	lds	r26, 0x0415
    5988:	b0 91 16 04 	lds	r27, 0x0416
    598c:	eb ec       	ldi	r30, 0xCB	; 203
    598e:	f2 e0       	ldi	r31, 0x02	; 2
    5990:	88 e1       	ldi	r24, 0x18	; 24
    5992:	01 90       	ld	r0, Z+
    5994:	0d 92       	st	X+, r0
    5996:	81 50       	subi	r24, 0x01	; 1
    5998:	e1 f7       	brne	.-8      	; 0x5992 <commandSetMotorDecay+0x96>
    sendText(txString.buffer);
    599a:	80 91 15 04 	lds	r24, 0x0415
    599e:	90 91 16 04 	lds	r25, 0x0416
    59a2:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    59a6:	ea cf       	rjmp	.-44     	; 0x597c <commandSetMotorDecay+0x80>
  
  i = (uint8_t)strtol(param0, (char **)NULL, 10);
  decay = (uint8_t)strtol(param1, (char **)NULL, 10);
  
  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    59a8:	80 91 15 04 	lds	r24, 0x0415
    59ac:	90 91 16 04 	lds	r25, 0x0416
    59b0:	00 d0       	rcall	.+0      	; 0x59b2 <commandSetMotorDecay+0xb6>
    59b2:	00 d0       	rcall	.+0      	; 0x59b4 <commandSetMotorDecay+0xb8>
    59b4:	00 d0       	rcall	.+0      	; 0x59b6 <commandSetMotorDecay+0xba>
    59b6:	ed b7       	in	r30, 0x3d	; 61
    59b8:	fe b7       	in	r31, 0x3e	; 62
    59ba:	31 96       	adiw	r30, 0x01	; 1
    59bc:	ad b7       	in	r26, 0x3d	; 61
    59be:	be b7       	in	r27, 0x3e	; 62
    59c0:	12 96       	adiw	r26, 0x02	; 2
    59c2:	9c 93       	st	X, r25
    59c4:	8e 93       	st	-X, r24
    59c6:	11 97       	sbiw	r26, 0x01	; 1
    59c8:	80 e0       	ldi	r24, 0x00	; 0
    59ca:	91 e0       	ldi	r25, 0x01	; 1
    59cc:	93 83       	std	Z+3, r25	; 0x03
    59ce:	82 83       	std	Z+2, r24	; 0x02
    59d0:	f4 82       	std	Z+4, r15	; 0x04
    59d2:	15 82       	std	Z+5, r1	; 0x05
    59d4:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    sendText(txString.buffer);
    59d8:	80 91 15 04 	lds	r24, 0x0415
    59dc:	90 91 16 04 	lds	r25, 0x0416
    59e0:	2d b7       	in	r18, 0x3d	; 61
    59e2:	3e b7       	in	r19, 0x3e	; 62
    59e4:	2a 5f       	subi	r18, 0xFA	; 250
    59e6:	3f 4f       	sbci	r19, 0xFF	; 255
    59e8:	0f b6       	in	r0, 0x3f	; 63
    59ea:	f8 94       	cli
    59ec:	3e bf       	out	0x3e, r19	; 62
    59ee:	0f be       	out	0x3f, r0	; 63
    59f0:	2d bf       	out	0x3d, r18	; 61
    59f2:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    59f6:	99 cf       	rjmp	.-206    	; 0x592a <commandSetMotorDecay+0x2e>

000059f8 <setMotorState>:

/* ---------------------------------------------------------------------
    setMotorState: turns motor on/off
    nENBL: active low
 --------------------------------------------------------------------- */
void setMotorState(uint8_t mot, uint8_t state){
    59f8:	ff 92       	push	r15
    59fa:	0f 93       	push	r16
    59fc:	1f 93       	push	r17
    59fe:	08 2f       	mov	r16, r24
    5a00:	f6 2e       	mov	r15, r22

  uint8_t addr = 0;
  uint8_t regval = 0;

  addr = getPortExpanderAddress(mot);
    5a02:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
    5a06:	18 2f       	mov	r17, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    5a08:	62 e1       	ldi	r22, 0x12	; 18
    5a0a:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>

  if(state){
    5a0e:	ff 20       	and	r15, r15
    5a10:	e1 f4       	brne	.+56     	; 0x5a4a <setMotorState+0x52>
    regval &= ~(1<<PORTEXP_MOTOR_ENABLE);
  }
  else{
    regval |= (1<<PORTEXP_MOTOR_ENABLE);
    5a12:	48 2f       	mov	r20, r24
    5a14:	48 60       	ori	r20, 0x08	; 8
  }

  writePortExpanderRegister(addr, GPIOA, regval);
    5a16:	81 2f       	mov	r24, r17
    5a18:	62 e1       	ldi	r22, 0x12	; 18
    5a1a:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  motor[mot].isTurnedOn = state;
    5a1e:	e0 2f       	mov	r30, r16
    5a20:	f0 e0       	ldi	r31, 0x00	; 0
    5a22:	ee 0f       	add	r30, r30
    5a24:	ff 1f       	adc	r31, r31
    5a26:	ee 0f       	add	r30, r30
    5a28:	ff 1f       	adc	r31, r31
    5a2a:	ee 0f       	add	r30, r30
    5a2c:	ff 1f       	adc	r31, r31
    5a2e:	cf 01       	movw	r24, r30
    5a30:	88 0f       	add	r24, r24
    5a32:	99 1f       	adc	r25, r25
    5a34:	88 0f       	add	r24, r24
    5a36:	99 1f       	adc	r25, r25
    5a38:	e8 0f       	add	r30, r24
    5a3a:	f9 1f       	adc	r31, r25
    5a3c:	e2 5e       	subi	r30, 0xE2	; 226
    5a3e:	fb 4f       	sbci	r31, 0xFB	; 251
    5a40:	f3 86       	std	Z+11, r15	; 0x0b

  return;
}
    5a42:	1f 91       	pop	r17
    5a44:	0f 91       	pop	r16
    5a46:	ff 90       	pop	r15
    5a48:	08 95       	ret

  addr = getPortExpanderAddress(mot);
  regval = readPortExpanderRegister(addr, GPIOA);

  if(state){
    regval &= ~(1<<PORTEXP_MOTOR_ENABLE);
    5a4a:	48 2f       	mov	r20, r24
    5a4c:	47 7f       	andi	r20, 0xF7	; 247
    5a4e:	e3 cf       	rjmp	.-58     	; 0x5a16 <setMotorState+0x1e>

00005a50 <commandEnable>:
}

/* ---------------------------------------------------------------------
    enables/disables a motor
 --------------------------------------------------------------------- */
void commandEnable(char* param0, char* param1){
    5a50:	0f 93       	push	r16
    5a52:	df 93       	push	r29
    5a54:	cf 93       	push	r28
    5a56:	00 d0       	rcall	.+0      	; 0x5a58 <commandEnable+0x8>
    5a58:	cd b7       	in	r28, 0x3d	; 61
    5a5a:	de b7       	in	r29, 0x3e	; 62
    5a5c:	7a 83       	std	Y+2, r23	; 0x02
    5a5e:	69 83       	std	Y+1, r22	; 0x01

  uint8_t i   = 0;
  uint8_t val = 0;

  i   = (uint8_t)strtol(param0, (char **)NULL, 10);
    5a60:	60 e0       	ldi	r22, 0x00	; 0
    5a62:	70 e0       	ldi	r23, 0x00	; 0
    5a64:	4a e0       	ldi	r20, 0x0A	; 10
    5a66:	50 e0       	ldi	r21, 0x00	; 0
    5a68:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    5a6c:	06 2f       	mov	r16, r22
  val = (uint8_t)strtol(param1, (char **)NULL, 10);
    5a6e:	89 81       	ldd	r24, Y+1	; 0x01
    5a70:	9a 81       	ldd	r25, Y+2	; 0x02
    5a72:	60 e0       	ldi	r22, 0x00	; 0
    5a74:	70 e0       	ldi	r23, 0x00	; 0
    5a76:	4a e0       	ldi	r20, 0x0A	; 10
    5a78:	50 e0       	ldi	r21, 0x00	; 0
    5a7a:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>



  if(i > MAX_MOTOR){
    5a7e:	04 30       	cpi	r16, 0x04	; 4
    5a80:	30 f4       	brcc	.+12     	; 0x5a8e <commandEnable+0x3e>
    return;
  }
  else{
    if(val){
    5a82:	66 23       	and	r22, r22
    5a84:	51 f4       	brne	.+20     	; 0x5a9a <commandEnable+0x4a>
      setMotorState(i, ON);
    }
    else{
      setMotorState(i, OFF);
    5a86:	80 2f       	mov	r24, r16
    5a88:	60 e0       	ldi	r22, 0x00	; 0
    5a8a:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
      //sendChar('a');
    }
  }

  return;
}
    5a8e:	0f 90       	pop	r0
    5a90:	0f 90       	pop	r0
    5a92:	cf 91       	pop	r28
    5a94:	df 91       	pop	r29
    5a96:	0f 91       	pop	r16
    5a98:	08 95       	ret
  if(i > MAX_MOTOR){
    return;
  }
  else{
    if(val){
      setMotorState(i, ON);
    5a9a:	80 2f       	mov	r24, r16
    5a9c:	61 e0       	ldi	r22, 0x01	; 1
    5a9e:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
      //sendChar('a');
    }
  }

  return;
}
    5aa2:	0f 90       	pop	r0
    5aa4:	0f 90       	pop	r0
    5aa6:	cf 91       	pop	r28
    5aa8:	df 91       	pop	r29
    5aaa:	0f 91       	pop	r16
    5aac:	08 95       	ret

00005aae <prepareReset>:
  */

  /* turn off all available motors */
  uint8_t i;
  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorState(i, OFF);
    5aae:	80 e0       	ldi	r24, 0x00	; 0
    5ab0:	60 e0       	ldi	r22, 0x00	; 0
    5ab2:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
    5ab6:	81 e0       	ldi	r24, 0x01	; 1
    5ab8:	60 e0       	ldi	r22, 0x00	; 0
    5aba:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
    5abe:	82 e0       	ldi	r24, 0x02	; 2
    5ac0:	60 e0       	ldi	r22, 0x00	; 0
    5ac2:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
    5ac6:	83 e0       	ldi	r24, 0x03	; 3
    5ac8:	60 e0       	ldi	r22, 0x00	; 0
    5aca:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
  }

  /* stop polling timer for manual operating system */
  TCCR0B = 0;
    5ace:	15 bc       	out	0x25, r1	; 37

  /* stop motor movement timer */
  TCCR2B = 0;
    5ad0:	10 92 b1 00 	sts	0x00B1, r1

  return;
}
    5ad4:	08 95       	ret

00005ad6 <setSubSteps>:

/* ---------------------------------------------------------------------
   sets the desired motor substeps
   function takes a value 1...32   
 --------------------------------------------------------------------- */
void setSubSteps(uint8_t mot, uint8_t steps){
    5ad6:	af 92       	push	r10
    5ad8:	bf 92       	push	r11
    5ada:	cf 92       	push	r12
    5adc:	df 92       	push	r13
    5ade:	ef 92       	push	r14
    5ae0:	ff 92       	push	r15
    5ae2:	0f 93       	push	r16
    5ae4:	1f 93       	push	r17
    5ae6:	a8 2e       	mov	r10, r24
    5ae8:	06 2f       	mov	r16, r22
  if(steps > 5){
    steps = 5;
  }
  */
  
  if(steps > 32){
    5aea:	61 32       	cpi	r22, 0x21	; 33
    5aec:	08 f4       	brcc	.+2      	; 0x5af0 <setSubSteps+0x1a>
    5aee:	49 c0       	rjmp	.+146    	; 0x5b82 <setSubSteps+0xac>
    5af0:	80 e2       	ldi	r24, 0x20	; 32
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    5af2:	00 e0       	ldi	r16, 0x00	; 0
    tmp_steps = tmp_steps >> 1;
    5af4:	86 95       	lsr	r24
	steps++ ;
    5af6:	0f 5f       	subi	r16, 0xFF	; 255
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    5af8:	81 30       	cpi	r24, 0x01	; 1
    5afa:	e1 f7       	brne	.-8      	; 0x5af4 <setSubSteps+0x1e>
    5afc:	61 e0       	ldi	r22, 0x01	; 1
    5afe:	70 e0       	ldi	r23, 0x00	; 0
    5b00:	00 2e       	mov	r0, r16
    5b02:	02 c0       	rjmp	.+4      	; 0x5b08 <setSubSteps+0x32>
    5b04:	66 0f       	add	r22, r22
    5b06:	77 1f       	adc	r23, r23
    5b08:	0a 94       	dec	r0
    5b0a:	e2 f7       	brpl	.-8      	; 0x5b04 <setSubSteps+0x2e>
    5b0c:	88 27       	eor	r24, r24
    5b0e:	77 fd       	sbrc	r23, 7
    5b10:	80 95       	com	r24
    5b12:	98 2f       	mov	r25, r24
    5b14:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    5b18:	6b 01       	movw	r12, r22
    5b1a:	7c 01       	movw	r14, r24
    tmp_steps = tmp_steps >> 1;
	steps++ ;
  }
  
  addr = getPortExpanderAddress(mot);
    5b1c:	8a 2d       	mov	r24, r10
    5b1e:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
    5b22:	b8 2e       	mov	r11, r24
  regval = readPortExpanderRegister(addr, GPIOA);
    5b24:	62 e1       	ldi	r22, 0x12	; 18
    5b26:	0e 94 14 2a 	call	0x5428	; 0x5428 <readPortExpanderRegister>
    5b2a:	18 2f       	mov	r17, r24

  regval &= 0xF8;

  regval |= (reverseBitOrder(steps) & 0xE0) >> 5;
    5b2c:	80 2f       	mov	r24, r16
    5b2e:	0e 94 ec 09 	call	0x13d8	; 0x13d8 <reverseBitOrder>
    5b32:	18 7f       	andi	r17, 0xF8	; 248
    5b34:	82 95       	swap	r24
    5b36:	86 95       	lsr	r24
    5b38:	87 70       	andi	r24, 0x07	; 7
    5b3a:	18 2b       	or	r17, r24
  writePortExpanderRegister(addr, GPIOA, regval);
    5b3c:	8b 2d       	mov	r24, r11
    5b3e:	62 e1       	ldi	r22, 0x12	; 18
    5b40:	41 2f       	mov	r20, r17
    5b42:	0e 94 6f 29 	call	0x52de	; 0x52de <writePortExpanderRegister>
  
  motor[mot].subSteps = (1<<steps);
    5b46:	ea 2d       	mov	r30, r10
    5b48:	f0 e0       	ldi	r31, 0x00	; 0
    5b4a:	ee 0f       	add	r30, r30
    5b4c:	ff 1f       	adc	r31, r31
    5b4e:	ee 0f       	add	r30, r30
    5b50:	ff 1f       	adc	r31, r31
    5b52:	ee 0f       	add	r30, r30
    5b54:	ff 1f       	adc	r31, r31
    5b56:	cf 01       	movw	r24, r30
    5b58:	88 0f       	add	r24, r24
    5b5a:	99 1f       	adc	r25, r25
    5b5c:	88 0f       	add	r24, r24
    5b5e:	99 1f       	adc	r25, r25
    5b60:	e8 0f       	add	r30, r24
    5b62:	f9 1f       	adc	r31, r25
    5b64:	e2 5e       	subi	r30, 0xE2	; 226
    5b66:	fb 4f       	sbci	r31, 0xFB	; 251
    5b68:	c5 8a       	std	Z+21, r12	; 0x15
    5b6a:	d6 8a       	std	Z+22, r13	; 0x16
    5b6c:	e7 8a       	std	Z+23, r14	; 0x17
    5b6e:	f0 8e       	std	Z+24, r15	; 0x18

  return;
}
    5b70:	1f 91       	pop	r17
    5b72:	0f 91       	pop	r16
    5b74:	ff 90       	pop	r15
    5b76:	ef 90       	pop	r14
    5b78:	df 90       	pop	r13
    5b7a:	cf 90       	pop	r12
    5b7c:	bf 90       	pop	r11
    5b7e:	af 90       	pop	r10
    5b80:	08 95       	ret
  */
  
  if(steps > 32){
    steps = 32;
  }
  if(steps < 1){
    5b82:	66 23       	and	r22, r22
    5b84:	59 f4       	brne	.+22     	; 0x5b9c <setSubSteps+0xc6>
  //convert steps from 1...32 to 0...5
  uint8_t tmp_steps = 0;
  tmp_steps = steps;
  steps = 0;
  
  while(tmp_steps != 1){
    5b86:	0f 2e       	mov	r0, r31
    5b88:	f0 e0       	ldi	r31, 0x00	; 0
    5b8a:	cf 2e       	mov	r12, r31
    5b8c:	f0 e0       	ldi	r31, 0x00	; 0
    5b8e:	df 2e       	mov	r13, r31
    5b90:	f0 e8       	ldi	r31, 0x80	; 128
    5b92:	ef 2e       	mov	r14, r31
    5b94:	ff e3       	ldi	r31, 0x3F	; 63
    5b96:	ff 2e       	mov	r15, r31
    5b98:	f0 2d       	mov	r31, r0
    5b9a:	c0 cf       	rjmp	.-128    	; 0x5b1c <setSubSteps+0x46>
    5b9c:	61 30       	cpi	r22, 0x01	; 1
    5b9e:	11 f0       	breq	.+4      	; 0x5ba4 <setSubSteps+0xce>
    5ba0:	86 2f       	mov	r24, r22
    5ba2:	a7 cf       	rjmp	.-178    	; 0x5af2 <setSubSteps+0x1c>
    5ba4:	00 e0       	ldi	r16, 0x00	; 0
    5ba6:	ef cf       	rjmp	.-34     	; 0x5b86 <setSubSteps+0xb0>

00005ba8 <commandSetSubSteps>:
}

/* ---------------------------------------------------------------------
    sets the desired substeps
 --------------------------------------------------------------------- */
void commandSetSubSteps(char* param0, char* param1){
    5ba8:	1f 93       	push	r17
    5baa:	cf 93       	push	r28
    5bac:	df 93       	push	r29
    5bae:	eb 01       	movw	r28, r22

  uint8_t i = 0;
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);
    5bb0:	60 e0       	ldi	r22, 0x00	; 0
    5bb2:	70 e0       	ldi	r23, 0x00	; 0
    5bb4:	4a e0       	ldi	r20, 0x0A	; 10
    5bb6:	50 e0       	ldi	r21, 0x00	; 0
    5bb8:	0e 94 e0 46 	call	0x8dc0	; 0x8dc0 <strtol>
    5bbc:	16 2f       	mov	r17, r22

  if(i < MOTOR0 || i > MAX_MOTOR){
    5bbe:	64 30       	cpi	r22, 0x04	; 4
    5bc0:	88 f4       	brcc	.+34     	; 0x5be4 <commandSetSubSteps+0x3c>
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    sendText(txString.buffer);
    return;
  }
  else{
    val = (double)atof(param1);
    5bc2:	ce 01       	movw	r24, r28
    5bc4:	0e 94 0f 48 	call	0x901e	; 0x901e <atof>
    //motor[i].subSteps = val;
    setSubSteps(i, (uint8_t)round(val));
    5bc8:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    5bcc:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
    5bd0:	9b 01       	movw	r18, r22
    5bd2:	ac 01       	movw	r20, r24
    5bd4:	81 2f       	mov	r24, r17
    5bd6:	62 2f       	mov	r22, r18
    5bd8:	0e 94 6b 2d 	call	0x5ad6	; 0x5ad6 <setSubSteps>
  }

  return;
}
    5bdc:	df 91       	pop	r29
    5bde:	cf 91       	pop	r28
    5be0:	1f 91       	pop	r17
    5be2:	08 95       	ret
  double val = 0.0;

  i = (uint8_t)strtol(param0, (char **)NULL, 10);

  if(i < MOTOR0 || i > MAX_MOTOR){
    sprintf(txString.buffer, "err: unknown motor: %d", i);
    5be4:	80 91 15 04 	lds	r24, 0x0415
    5be8:	90 91 16 04 	lds	r25, 0x0416
    5bec:	00 d0       	rcall	.+0      	; 0x5bee <commandSetSubSteps+0x46>
    5bee:	00 d0       	rcall	.+0      	; 0x5bf0 <commandSetSubSteps+0x48>
    5bf0:	00 d0       	rcall	.+0      	; 0x5bf2 <commandSetSubSteps+0x4a>
    5bf2:	ed b7       	in	r30, 0x3d	; 61
    5bf4:	fe b7       	in	r31, 0x3e	; 62
    5bf6:	31 96       	adiw	r30, 0x01	; 1
    5bf8:	ad b7       	in	r26, 0x3d	; 61
    5bfa:	be b7       	in	r27, 0x3e	; 62
    5bfc:	12 96       	adiw	r26, 0x02	; 2
    5bfe:	9c 93       	st	X, r25
    5c00:	8e 93       	st	-X, r24
    5c02:	11 97       	sbiw	r26, 0x01	; 1
    5c04:	80 e0       	ldi	r24, 0x00	; 0
    5c06:	91 e0       	ldi	r25, 0x01	; 1
    5c08:	93 83       	std	Z+3, r25	; 0x03
    5c0a:	82 83       	std	Z+2, r24	; 0x02
    5c0c:	14 83       	std	Z+4, r17	; 0x04
    5c0e:	15 82       	std	Z+5, r1	; 0x05
    5c10:	0e 94 9e 49 	call	0x933c	; 0x933c <sprintf>
    sendText(txString.buffer);
    5c14:	80 91 15 04 	lds	r24, 0x0415
    5c18:	90 91 16 04 	lds	r25, 0x0416
    5c1c:	2d b7       	in	r18, 0x3d	; 61
    5c1e:	3e b7       	in	r19, 0x3e	; 62
    5c20:	2a 5f       	subi	r18, 0xFA	; 250
    5c22:	3f 4f       	sbci	r19, 0xFF	; 255
    5c24:	0f b6       	in	r0, 0x3f	; 63
    5c26:	f8 94       	cli
    5c28:	3e bf       	out	0x3e, r19	; 62
    5c2a:	0f be       	out	0x3f, r0	; 63
    5c2c:	2d bf       	out	0x3d, r18	; 61
    5c2e:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    //motor[i].subSteps = val;
    setSubSteps(i, (uint8_t)round(val));
  }

  return;
}
    5c32:	df 91       	pop	r29
    5c34:	cf 91       	pop	r28
    5c36:	1f 91       	pop	r17
    5c38:	08 95       	ret

00005c3a <updateIICvalues>:
}

/* ---------------------------------------------------------------------
   update IIC values for all motors
 --------------------------------------------------------------------- */
void updateIICvalues(void){
    5c3a:	cf 93       	push	r28
    5c3c:	df 93       	push	r29
    5c3e:	c0 e0       	ldi	r28, 0x00	; 0
    5c40:	d0 e0       	ldi	r29, 0x00	; 0

  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorCurrent(i, motor[i].current);
    5c42:	fe 01       	movw	r30, r28
    5c44:	ee 0f       	add	r30, r30
    5c46:	ff 1f       	adc	r31, r31
    5c48:	ee 0f       	add	r30, r30
    5c4a:	ff 1f       	adc	r31, r31
    5c4c:	ee 0f       	add	r30, r30
    5c4e:	ff 1f       	adc	r31, r31
    5c50:	cf 01       	movw	r24, r30
    5c52:	88 0f       	add	r24, r24
    5c54:	99 1f       	adc	r25, r25
    5c56:	88 0f       	add	r24, r24
    5c58:	99 1f       	adc	r25, r25
    5c5a:	e8 0f       	add	r30, r24
    5c5c:	f9 1f       	adc	r31, r25
    5c5e:	e2 5e       	subi	r30, 0xE2	; 226
    5c60:	fb 4f       	sbci	r31, 0xFB	; 251
    5c62:	43 a1       	ldd	r20, Z+35	; 0x23
    5c64:	54 a1       	ldd	r21, Z+36	; 0x24
    5c66:	65 a1       	ldd	r22, Z+37	; 0x25
    5c68:	76 a1       	ldd	r23, Z+38	; 0x26
    5c6a:	8c 2f       	mov	r24, r28
    5c6c:	0e 94 a1 28 	call	0x5142	; 0x5142 <setMotorCurrent>
    setMotorDecay(i, motor[i].decay);
    5c70:	fe 01       	movw	r30, r28
    5c72:	ee 0f       	add	r30, r30
    5c74:	ff 1f       	adc	r31, r31
    5c76:	ee 0f       	add	r30, r30
    5c78:	ff 1f       	adc	r31, r31
    5c7a:	ee 0f       	add	r30, r30
    5c7c:	ff 1f       	adc	r31, r31
    5c7e:	cf 01       	movw	r24, r30
    5c80:	88 0f       	add	r24, r24
    5c82:	99 1f       	adc	r25, r25
    5c84:	88 0f       	add	r24, r24
    5c86:	99 1f       	adc	r25, r25
    5c88:	e8 0f       	add	r30, r24
    5c8a:	f9 1f       	adc	r31, r25
    5c8c:	e2 5e       	subi	r30, 0xE2	; 226
    5c8e:	fb 4f       	sbci	r31, 0xFB	; 251
    5c90:	67 a1       	ldd	r22, Z+39	; 0x27
    5c92:	8c 2f       	mov	r24, r28
    5c94:	0e 94 4e 2c 	call	0x589c	; 0x589c <setMotorDecay>
    setSubSteps(i, (uint8_t)round(motor[i].subSteps));
    5c98:	fe 01       	movw	r30, r28
    5c9a:	ee 0f       	add	r30, r30
    5c9c:	ff 1f       	adc	r31, r31
    5c9e:	ee 0f       	add	r30, r30
    5ca0:	ff 1f       	adc	r31, r31
    5ca2:	ee 0f       	add	r30, r30
    5ca4:	ff 1f       	adc	r31, r31
    5ca6:	cf 01       	movw	r24, r30
    5ca8:	88 0f       	add	r24, r24
    5caa:	99 1f       	adc	r25, r25
    5cac:	88 0f       	add	r24, r24
    5cae:	99 1f       	adc	r25, r25
    5cb0:	e8 0f       	add	r30, r24
    5cb2:	f9 1f       	adc	r31, r25
    5cb4:	e2 5e       	subi	r30, 0xE2	; 226
    5cb6:	fb 4f       	sbci	r31, 0xFB	; 251
    5cb8:	65 89       	ldd	r22, Z+21	; 0x15
    5cba:	76 89       	ldd	r23, Z+22	; 0x16
    5cbc:	87 89       	ldd	r24, Z+23	; 0x17
    5cbe:	90 8d       	ldd	r25, Z+24	; 0x18
    5cc0:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    5cc4:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
    5cc8:	9b 01       	movw	r18, r22
    5cca:	ac 01       	movw	r20, r24
    5ccc:	8c 2f       	mov	r24, r28
    5cce:	62 2f       	mov	r22, r18
    5cd0:	0e 94 6b 2d 	call	0x5ad6	; 0x5ad6 <setSubSteps>
    5cd4:	21 96       	adiw	r28, 0x01	; 1
 --------------------------------------------------------------------- */
void updateIICvalues(void){

  uint8_t i = 0;

  for(i = 0; i <= MAX_MOTOR; i++){
    5cd6:	c4 30       	cpi	r28, 0x04	; 4
    5cd8:	d1 05       	cpc	r29, r1
    5cda:	09 f0       	breq	.+2      	; 0x5cde <updateIICvalues+0xa4>
    5cdc:	b2 cf       	rjmp	.-156    	; 0x5c42 <updateIICvalues+0x8>
    setMotorDecay(i, motor[i].decay);
    setSubSteps(i, (uint8_t)round(motor[i].subSteps));
  }

  return;
}
    5cde:	df 91       	pop	r29
    5ce0:	cf 91       	pop	r28
    5ce2:	08 95       	ret

00005ce4 <updateDisplay>:
 --------------------------------------------------------------------- */
void updateDisplay(void){

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    5ce4:	80 91 12 03 	lds	r24, 0x0312
    5ce8:	82 30       	cpi	r24, 0x02	; 2
    5cea:	09 f4       	brne	.+2      	; 0x5cee <updateDisplay+0xa>
    5cec:	6f c0       	rjmp	.+222    	; 0x5dcc <updateDisplay+0xe8>
    5cee:	83 30       	cpi	r24, 0x03	; 3
    5cf0:	08 f4       	brcc	.+2      	; 0x5cf4 <updateDisplay+0x10>
    5cf2:	64 c0       	rjmp	.+200    	; 0x5dbc <updateDisplay+0xd8>
    5cf4:	83 30       	cpi	r24, 0x03	; 3
    5cf6:	09 f4       	brne	.+2      	; 0x5cfa <updateDisplay+0x16>
    5cf8:	c6 c0       	rjmp	.+396    	; 0x5e86 <updateDisplay+0x1a2>
    5cfa:	85 30       	cpi	r24, 0x05	; 5
    5cfc:	09 f0       	breq	.+2      	; 0x5d00 <updateDisplay+0x1c>
    5cfe:	61 c0       	rjmp	.+194    	; 0x5dc2 <updateDisplay+0xde>
        }
      }
      break;
      
    case MENU_SETTINGS_MODE:
      if(menu.currentDisplayedMenu != menu.newDisplayedMenu){
    5d00:	90 91 0e 03 	lds	r25, 0x030E
    5d04:	80 91 0d 03 	lds	r24, 0x030D
    5d08:	98 17       	cp	r25, r24
    5d0a:	09 f4       	brne	.+2      	; 0x5d0e <updateDisplay+0x2a>
    5d0c:	5a c0       	rjmp	.+180    	; 0x5dc2 <updateDisplay+0xde>
        changeDisplayMenu(menu.newDisplayedMenu);
    5d0e:	80 91 0d 03 	lds	r24, 0x030D
    5d12:	0e 94 cf 20 	call	0x419e	; 0x419e <changeDisplayMenu>
        //lcd_setcursor(0, 1);  /* line 1 */
        //lcd_string(menu.newMenuText[0]);
        OLEDsetCursor(0, 0);
    5d16:	80 e0       	ldi	r24, 0x00	; 0
    5d18:	60 e0       	ldi	r22, 0x00	; 0
    5d1a:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[0]);
    5d1e:	e0 91 1a 03 	lds	r30, 0x031A
    5d22:	f0 91 1b 03 	lds	r31, 0x031B
    5d26:	80 81       	ld	r24, Z
    5d28:	91 81       	ldd	r25, Z+1	; 0x01
    5d2a:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentMenuText[0], menu.newMenuText[0]);
    5d2e:	a0 91 18 03 	lds	r26, 0x0318
    5d32:	b0 91 19 03 	lds	r27, 0x0319
    5d36:	e0 91 1a 03 	lds	r30, 0x031A
    5d3a:	f0 91 1b 03 	lds	r31, 0x031B
    5d3e:	60 81       	ld	r22, Z
    5d40:	71 81       	ldd	r23, Z+1	; 0x01
    5d42:	8d 91       	ld	r24, X+
    5d44:	9c 91       	ld	r25, X
    5d46:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
        //lcd_setcursor(0, 2);  /* line 2 */
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
    5d4a:	80 e0       	ldi	r24, 0x00	; 0
    5d4c:	61 e0       	ldi	r22, 0x01	; 1
    5d4e:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[1]);
    5d52:	e0 91 1a 03 	lds	r30, 0x031A
    5d56:	f0 91 1b 03 	lds	r31, 0x031B
    5d5a:	82 81       	ldd	r24, Z+2	; 0x02
    5d5c:	93 81       	ldd	r25, Z+3	; 0x03
    5d5e:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
    5d62:	a0 91 18 03 	lds	r26, 0x0318
    5d66:	b0 91 19 03 	lds	r27, 0x0319
    5d6a:	e0 91 1a 03 	lds	r30, 0x031A
    5d6e:	f0 91 1b 03 	lds	r31, 0x031B
    5d72:	62 81       	ldd	r22, Z+2	; 0x02
    5d74:	73 81       	ldd	r23, Z+3	; 0x03
    5d76:	12 96       	adiw	r26, 0x02	; 2
    5d78:	8d 91       	ld	r24, X+
    5d7a:	9c 91       	ld	r25, X
    5d7c:	13 97       	sbiw	r26, 0x03	; 3
    5d7e:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
    5d82:	80 91 0d 03 	lds	r24, 0x030D
    5d86:	80 93 0e 03 	sts	0x030E, r24
    5d8a:	40 e0       	ldi	r20, 0x00	; 0
    5d8c:	50 e0       	ldi	r21, 0x00	; 0
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
          sprintf(menu.currentDisplayValue[j], "no text");
    5d8e:	e0 91 14 03 	lds	r30, 0x0314
    5d92:	f0 91 15 03 	lds	r31, 0x0315
    5d96:	e4 0f       	add	r30, r20
    5d98:	f5 1f       	adc	r31, r21
    5d9a:	20 81       	ld	r18, Z
    5d9c:	31 81       	ldd	r19, Z+1	; 0x01
    5d9e:	c9 01       	movw	r24, r18
    5da0:	dc 01       	movw	r26, r24
    5da2:	e3 ee       	ldi	r30, 0xE3	; 227
    5da4:	f2 e0       	ldi	r31, 0x02	; 2
    5da6:	88 e0       	ldi	r24, 0x08	; 8
    5da8:	01 90       	ld	r0, Z+
    5daa:	0d 92       	st	X+, r0
    5dac:	81 50       	subi	r24, 0x01	; 1
    5dae:	e1 f7       	brne	.-8      	; 0x5da8 <updateDisplay+0xc4>
    5db0:	4e 5f       	subi	r20, 0xFE	; 254
    5db2:	5f 4f       	sbci	r21, 0xFF	; 255
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newMenuText[1]);
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
    5db4:	4a 30       	cpi	r20, 0x0A	; 10
    5db6:	51 05       	cpc	r21, r1
    5db8:	51 f7       	brne	.-44     	; 0x5d8e <updateDisplay+0xaa>
    5dba:	03 c0       	rjmp	.+6      	; 0x5dc2 <updateDisplay+0xde>
 --------------------------------------------------------------------- */
void updateDisplay(void){

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    5dbc:	81 30       	cpi	r24, 0x01	; 1
    5dbe:	09 f4       	brne	.+2      	; 0x5dc2 <updateDisplay+0xde>
    5dc0:	62 c0       	rjmp	.+196    	; 0x5e86 <updateDisplay+0x1a2>

    default:
      break;
  }

  menu.currentMenuMode = menu.newMenuMode;
    5dc2:	80 91 0f 03 	lds	r24, 0x030F
    5dc6:	80 93 12 03 	sts	0x0312, r24

  return;
}
    5dca:	08 95       	ret

  uint8_t j = 0;

  switch(menu.currentMenuMode){
    case MENU_SCROLL_MODE:
      if(menu.currentDisplayedMenu != menu.newDisplayedMenu){
    5dcc:	90 91 0e 03 	lds	r25, 0x030E
    5dd0:	80 91 0d 03 	lds	r24, 0x030D
    5dd4:	98 17       	cp	r25, r24
    5dd6:	a9 f3       	breq	.-22     	; 0x5dc2 <updateDisplay+0xde>
        changeDisplayMenu(menu.newDisplayedMenu);
    5dd8:	80 91 0d 03 	lds	r24, 0x030D
    5ddc:	0e 94 cf 20 	call	0x419e	; 0x419e <changeDisplayMenu>
        //lcd_setcursor(0, 1);  /* line 1 */
        //lcd_string(menu.newMenuText[0]);
        OLEDsetCursor(0, 0);
    5de0:	80 e0       	ldi	r24, 0x00	; 0
    5de2:	60 e0       	ldi	r22, 0x00	; 0
    5de4:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[0]);
    5de8:	e0 91 1a 03 	lds	r30, 0x031A
    5dec:	f0 91 1b 03 	lds	r31, 0x031B
    5df0:	80 81       	ld	r24, Z
    5df2:	91 81       	ldd	r25, Z+1	; 0x01
    5df4:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentMenuText[0], menu.newMenuText[0]);
    5df8:	a0 91 18 03 	lds	r26, 0x0318
    5dfc:	b0 91 19 03 	lds	r27, 0x0319
    5e00:	e0 91 1a 03 	lds	r30, 0x031A
    5e04:	f0 91 1b 03 	lds	r31, 0x031B
    5e08:	60 81       	ld	r22, Z
    5e0a:	71 81       	ldd	r23, Z+1	; 0x01
    5e0c:	8d 91       	ld	r24, X+
    5e0e:	9c 91       	ld	r25, X
    5e10:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
        //lcd_setcursor(0, 2);  /* line 2 */
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
    5e14:	80 e0       	ldi	r24, 0x00	; 0
    5e16:	61 e0       	ldi	r22, 0x01	; 1
    5e18:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newMenuText[1]);
    5e1c:	e0 91 1a 03 	lds	r30, 0x031A
    5e20:	f0 91 1b 03 	lds	r31, 0x031B
    5e24:	82 81       	ldd	r24, Z+2	; 0x02
    5e26:	93 81       	ldd	r25, Z+3	; 0x03
    5e28:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
    5e2c:	a0 91 18 03 	lds	r26, 0x0318
    5e30:	b0 91 19 03 	lds	r27, 0x0319
    5e34:	e0 91 1a 03 	lds	r30, 0x031A
    5e38:	f0 91 1b 03 	lds	r31, 0x031B
    5e3c:	62 81       	ldd	r22, Z+2	; 0x02
    5e3e:	73 81       	ldd	r23, Z+3	; 0x03
    5e40:	12 96       	adiw	r26, 0x02	; 2
    5e42:	8d 91       	ld	r24, X+
    5e44:	9c 91       	ld	r25, X
    5e46:	13 97       	sbiw	r26, 0x03	; 3
    5e48:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
    5e4c:	80 91 0d 03 	lds	r24, 0x030D
    5e50:	80 93 0e 03 	sts	0x030E, r24
    5e54:	40 e0       	ldi	r20, 0x00	; 0
    5e56:	50 e0       	ldi	r21, 0x00	; 0
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
          sprintf(menu.currentDisplayValue[j], "no text");
    5e58:	e0 91 14 03 	lds	r30, 0x0314
    5e5c:	f0 91 15 03 	lds	r31, 0x0315
    5e60:	e4 0f       	add	r30, r20
    5e62:	f5 1f       	adc	r31, r21
    5e64:	20 81       	ld	r18, Z
    5e66:	31 81       	ldd	r19, Z+1	; 0x01
    5e68:	c9 01       	movw	r24, r18
    5e6a:	dc 01       	movw	r26, r24
    5e6c:	e3 ee       	ldi	r30, 0xE3	; 227
    5e6e:	f2 e0       	ldi	r31, 0x02	; 2
    5e70:	88 e0       	ldi	r24, 0x08	; 8
    5e72:	01 90       	ld	r0, Z+
    5e74:	0d 92       	st	X+, r0
    5e76:	81 50       	subi	r24, 0x01	; 1
    5e78:	e1 f7       	brne	.-8      	; 0x5e72 <updateDisplay+0x18e>
    5e7a:	4e 5f       	subi	r20, 0xFE	; 254
    5e7c:	5f 4f       	sbci	r21, 0xFF	; 255
        //lcd_string(menu.newMenuText[1]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newMenuText[1]);
        strcpy(menu.currentMenuText[1], menu.newMenuText[1]);
        menu.currentDisplayedMenu = menu.newDisplayedMenu;
        for(j = 0; j <= NUMBER_DISPLAY_VALUE_STRINGS; j++){
    5e7e:	4a 30       	cpi	r20, 0x0A	; 10
    5e80:	51 05       	cpc	r21, r1
    5e82:	51 f7       	brne	.-44     	; 0x5e58 <updateDisplay+0x174>
    5e84:	9e cf       	rjmp	.-196    	; 0x5dc2 <updateDisplay+0xde>
      }
      break;

    case MENU_CHANGE_MODE:
    case MENU_VALUE_CHANGE:
      updateDisplayChangeValues(menu.currentDisplayedMenu);
    5e86:	80 91 0e 03 	lds	r24, 0x030E
    5e8a:	0e 94 ed 15 	call	0x2bda	; 0x2bda <updateDisplayChangeValues>
      if(strcmp(menu.currentDisplayValue[0], menu.newDisplayValue[0])){
    5e8e:	a0 91 14 03 	lds	r26, 0x0314
    5e92:	b0 91 15 03 	lds	r27, 0x0315
    5e96:	e0 91 16 03 	lds	r30, 0x0316
    5e9a:	f0 91 17 03 	lds	r31, 0x0317
    5e9e:	60 81       	ld	r22, Z
    5ea0:	71 81       	ldd	r23, Z+1	; 0x01
    5ea2:	8d 91       	ld	r24, X+
    5ea4:	9c 91       	ld	r25, X
    5ea6:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    5eaa:	00 97       	sbiw	r24, 0x00	; 0
    5eac:	09 f0       	breq	.+2      	; 0x5eb0 <updateDisplay+0x1cc>
    5eae:	8f c0       	rjmp	.+286    	; 0x5fce <updateDisplay+0x2ea>
        //lcd_string(menu.newDisplayValue[0]);
        OLEDsetCursor(0, 0);
        OLEDprintCC(menu.newDisplayValue[0]);
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
      }
      if(strcmp(menu.currentDisplayValue[1], menu.newDisplayValue[1])){
    5eb0:	a0 91 14 03 	lds	r26, 0x0314
    5eb4:	b0 91 15 03 	lds	r27, 0x0315
    5eb8:	e0 91 16 03 	lds	r30, 0x0316
    5ebc:	f0 91 17 03 	lds	r31, 0x0317
    5ec0:	62 81       	ldd	r22, Z+2	; 0x02
    5ec2:	73 81       	ldd	r23, Z+3	; 0x03
    5ec4:	12 96       	adiw	r26, 0x02	; 2
    5ec6:	8d 91       	ld	r24, X+
    5ec8:	9c 91       	ld	r25, X
    5eca:	13 97       	sbiw	r26, 0x03	; 3
    5ecc:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    5ed0:	00 97       	sbiw	r24, 0x00	; 0
    5ed2:	09 f0       	breq	.+2      	; 0x5ed6 <updateDisplay+0x1f2>
    5ed4:	5f c0       	rjmp	.+190    	; 0x5f94 <updateDisplay+0x2b0>
        //lcd_string(menu.newDisplayValue[1]);
        OLEDsetCursor(8, 0);
        OLEDprintCC(menu.newDisplayValue[1]);
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
      }
      if(strcmp(menu.currentDisplayValue[2], menu.newDisplayValue[2])){
    5ed6:	a0 91 14 03 	lds	r26, 0x0314
    5eda:	b0 91 15 03 	lds	r27, 0x0315
    5ede:	e0 91 16 03 	lds	r30, 0x0316
    5ee2:	f0 91 17 03 	lds	r31, 0x0317
    5ee6:	64 81       	ldd	r22, Z+4	; 0x04
    5ee8:	75 81       	ldd	r23, Z+5	; 0x05
    5eea:	14 96       	adiw	r26, 0x04	; 4
    5eec:	8d 91       	ld	r24, X+
    5eee:	9c 91       	ld	r25, X
    5ef0:	15 97       	sbiw	r26, 0x05	; 5
    5ef2:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    5ef6:	00 97       	sbiw	r24, 0x00	; 0
    5ef8:	81 f5       	brne	.+96     	; 0x5f5a <updateDisplay+0x276>
        //lcd_string(menu.newDisplayValue[2]);
        OLEDsetCursor(0, 1);
        OLEDprintCC(menu.newDisplayValue[2]);
        strcpy(menu.currentDisplayValue[2], menu.newDisplayValue[2]);
      }
      if(strcmp(menu.currentDisplayValue[3], menu.newDisplayValue[3])){
    5efa:	a0 91 14 03 	lds	r26, 0x0314
    5efe:	b0 91 15 03 	lds	r27, 0x0315
    5f02:	e0 91 16 03 	lds	r30, 0x0316
    5f06:	f0 91 17 03 	lds	r31, 0x0317
    5f0a:	66 81       	ldd	r22, Z+6	; 0x06
    5f0c:	77 81       	ldd	r23, Z+7	; 0x07
    5f0e:	16 96       	adiw	r26, 0x06	; 6
    5f10:	8d 91       	ld	r24, X+
    5f12:	9c 91       	ld	r25, X
    5f14:	17 97       	sbiw	r26, 0x07	; 7
    5f16:	0e 94 28 49 	call	0x9250	; 0x9250 <strcmp>
    5f1a:	00 97       	sbiw	r24, 0x00	; 0
    5f1c:	09 f4       	brne	.+2      	; 0x5f20 <updateDisplay+0x23c>
    5f1e:	51 cf       	rjmp	.-350    	; 0x5dc2 <updateDisplay+0xde>
        //lcd_setcursor(8, 2);
        //lcd_string(menu.newDisplayValue[3]);
        OLEDsetCursor(8, 1);
    5f20:	88 e0       	ldi	r24, 0x08	; 8
    5f22:	61 e0       	ldi	r22, 0x01	; 1
    5f24:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[3]);
    5f28:	e0 91 16 03 	lds	r30, 0x0316
    5f2c:	f0 91 17 03 	lds	r31, 0x0317
    5f30:	86 81       	ldd	r24, Z+6	; 0x06
    5f32:	97 81       	ldd	r25, Z+7	; 0x07
    5f34:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentDisplayValue[3], menu.newDisplayValue[3]);
    5f38:	a0 91 14 03 	lds	r26, 0x0314
    5f3c:	b0 91 15 03 	lds	r27, 0x0315
    5f40:	e0 91 16 03 	lds	r30, 0x0316
    5f44:	f0 91 17 03 	lds	r31, 0x0317
    5f48:	66 81       	ldd	r22, Z+6	; 0x06
    5f4a:	77 81       	ldd	r23, Z+7	; 0x07
    5f4c:	16 96       	adiw	r26, 0x06	; 6
    5f4e:	8d 91       	ld	r24, X+
    5f50:	9c 91       	ld	r25, X
    5f52:	17 97       	sbiw	r26, 0x07	; 7
    5f54:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
    5f58:	34 cf       	rjmp	.-408    	; 0x5dc2 <updateDisplay+0xde>
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
      }
      if(strcmp(menu.currentDisplayValue[2], menu.newDisplayValue[2])){
        //lcd_setcursor(0, 2);
        //lcd_string(menu.newDisplayValue[2]);
        OLEDsetCursor(0, 1);
    5f5a:	80 e0       	ldi	r24, 0x00	; 0
    5f5c:	61 e0       	ldi	r22, 0x01	; 1
    5f5e:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[2]);
    5f62:	e0 91 16 03 	lds	r30, 0x0316
    5f66:	f0 91 17 03 	lds	r31, 0x0317
    5f6a:	84 81       	ldd	r24, Z+4	; 0x04
    5f6c:	95 81       	ldd	r25, Z+5	; 0x05
    5f6e:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentDisplayValue[2], menu.newDisplayValue[2]);
    5f72:	a0 91 14 03 	lds	r26, 0x0314
    5f76:	b0 91 15 03 	lds	r27, 0x0315
    5f7a:	e0 91 16 03 	lds	r30, 0x0316
    5f7e:	f0 91 17 03 	lds	r31, 0x0317
    5f82:	64 81       	ldd	r22, Z+4	; 0x04
    5f84:	75 81       	ldd	r23, Z+5	; 0x05
    5f86:	14 96       	adiw	r26, 0x04	; 4
    5f88:	8d 91       	ld	r24, X+
    5f8a:	9c 91       	ld	r25, X
    5f8c:	15 97       	sbiw	r26, 0x05	; 5
    5f8e:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
    5f92:	b3 cf       	rjmp	.-154    	; 0x5efa <updateDisplay+0x216>
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
      }
      if(strcmp(menu.currentDisplayValue[1], menu.newDisplayValue[1])){
        //lcd_setcursor(8, 1);
        //lcd_string(menu.newDisplayValue[1]);
        OLEDsetCursor(8, 0);
    5f94:	88 e0       	ldi	r24, 0x08	; 8
    5f96:	60 e0       	ldi	r22, 0x00	; 0
    5f98:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[1]);
    5f9c:	e0 91 16 03 	lds	r30, 0x0316
    5fa0:	f0 91 17 03 	lds	r31, 0x0317
    5fa4:	82 81       	ldd	r24, Z+2	; 0x02
    5fa6:	93 81       	ldd	r25, Z+3	; 0x03
    5fa8:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentDisplayValue[1], menu.newDisplayValue[1]);
    5fac:	a0 91 14 03 	lds	r26, 0x0314
    5fb0:	b0 91 15 03 	lds	r27, 0x0315
    5fb4:	e0 91 16 03 	lds	r30, 0x0316
    5fb8:	f0 91 17 03 	lds	r31, 0x0317
    5fbc:	62 81       	ldd	r22, Z+2	; 0x02
    5fbe:	73 81       	ldd	r23, Z+3	; 0x03
    5fc0:	12 96       	adiw	r26, 0x02	; 2
    5fc2:	8d 91       	ld	r24, X+
    5fc4:	9c 91       	ld	r25, X
    5fc6:	13 97       	sbiw	r26, 0x03	; 3
    5fc8:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
    5fcc:	84 cf       	rjmp	.-248    	; 0x5ed6 <updateDisplay+0x1f2>
    case MENU_VALUE_CHANGE:
      updateDisplayChangeValues(menu.currentDisplayedMenu);
      if(strcmp(menu.currentDisplayValue[0], menu.newDisplayValue[0])){
        //lcd_setcursor(0, 1);
        //lcd_string(menu.newDisplayValue[0]);
        OLEDsetCursor(0, 0);
    5fce:	80 e0       	ldi	r24, 0x00	; 0
    5fd0:	60 e0       	ldi	r22, 0x00	; 0
    5fd2:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
        OLEDprintCC(menu.newDisplayValue[0]);
    5fd6:	e0 91 16 03 	lds	r30, 0x0316
    5fda:	f0 91 17 03 	lds	r31, 0x0317
    5fde:	80 81       	ld	r24, Z
    5fe0:	91 81       	ldd	r25, Z+1	; 0x01
    5fe2:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
        strcpy(menu.currentDisplayValue[0], menu.newDisplayValue[0]);
    5fe6:	a0 91 14 03 	lds	r26, 0x0314
    5fea:	b0 91 15 03 	lds	r27, 0x0315
    5fee:	e0 91 16 03 	lds	r30, 0x0316
    5ff2:	f0 91 17 03 	lds	r31, 0x0317
    5ff6:	60 81       	ld	r22, Z
    5ff8:	71 81       	ldd	r23, Z+1	; 0x01
    5ffa:	8d 91       	ld	r24, X+
    5ffc:	9c 91       	ld	r25, X
    5ffe:	0e 94 31 49 	call	0x9262	; 0x9262 <strcpy>
    6002:	56 cf       	rjmp	.-340    	; 0x5eb0 <updateDisplay+0x1cc>

00006004 <updateMenu>:


/* ---------------------------------------------------------------------
   implementing the display state machine
 --------------------------------------------------------------------- */
void updateMenu(void){
    6004:	4f 92       	push	r4
    6006:	5f 92       	push	r5
    6008:	6f 92       	push	r6
    600a:	7f 92       	push	r7
    600c:	8f 92       	push	r8
    600e:	9f 92       	push	r9
    6010:	af 92       	push	r10
    6012:	bf 92       	push	r11
    6014:	cf 92       	push	r12
    6016:	df 92       	push	r13
    6018:	ef 92       	push	r14
    601a:	ff 92       	push	r15
    601c:	0f 93       	push	r16
    601e:	1f 93       	push	r17
    6020:	cf 93       	push	r28
    6022:	df 93       	push	r29

  uint8_t i = 0;
  uint8_t tmp = 0;

  /* first check if we have something to change at all */
  if(buttonState.readyToProcess == 0 && rotEnc.readyToProcess == 0){
    6024:	80 91 0c 03 	lds	r24, 0x030C
    6028:	88 23       	and	r24, r24
    602a:	21 f4       	brne	.+8      	; 0x6034 <updateMenu+0x30>
    602c:	80 91 fe 03 	lds	r24, 0x03FE
    6030:	88 23       	and	r24, r24
    6032:	a1 f0       	breq	.+40     	; 0x605c <updateMenu+0x58>
    /* nothing to be done */
    return;
  }

  /* now get information about the actual display prompt */
  menuPrompt = menu.currentDisplayedMenu;
    6034:	00 91 0e 03 	lds	r16, 0x030E
  menuState  = menu.currentMenuMode;
    6038:	10 91 12 03 	lds	r17, 0x0312

  if(menuState == MENU_SCROLL_MODE){
    603c:	12 30       	cpi	r17, 0x02	; 2
    603e:	09 f4       	brne	.+2      	; 0x6042 <updateMenu+0x3e>
    6040:	d3 c0       	rjmp	.+422    	; 0x61e8 <updateMenu+0x1e4>
      menu.newMenuMode = MENU_SETTINGS_MODE;
      menu.newDisplayedMenu = MENU_SET_GEAR_RATIO; //first submenu, that should be displayed
    }
  }
  
  if(menuState == MENU_SETTINGS_MODE){
    6042:	15 30       	cpi	r17, 0x05	; 5
    6044:	09 f4       	brne	.+2      	; 0x6048 <updateMenu+0x44>
    6046:	fd c0       	rjmp	.+506    	; 0x6242 <updateMenu+0x23e>
      menu.newDisplayedMenu = MENU_SETTINGS;
    }
  }
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    6048:	11 30       	cpi	r17, 0x01	; 1
    604a:	c9 f0       	breq	.+50     	; 0x607e <updateMenu+0x7a>
    604c:	13 30       	cpi	r17, 0x03	; 3
    604e:	b9 f0       	breq	.+46     	; 0x607e <updateMenu+0x7a>
          break;
      }
    }
  }

  buttonState.readyToProcess = 0;
    6050:	10 92 0c 03 	sts	0x030C, r1
  rotEnc.readyToProcess = 0;
    6054:	10 92 fe 03 	sts	0x03FE, r1
  rotEnc.buttonPressed = 0;
    6058:	10 92 ff 03 	sts	0x03FF, r1

  return;
}
    605c:	df 91       	pop	r29
    605e:	cf 91       	pop	r28
    6060:	1f 91       	pop	r17
    6062:	0f 91       	pop	r16
    6064:	ff 90       	pop	r15
    6066:	ef 90       	pop	r14
    6068:	df 90       	pop	r13
    606a:	cf 90       	pop	r12
    606c:	bf 90       	pop	r11
    606e:	af 90       	pop	r10
    6070:	9f 90       	pop	r9
    6072:	8f 90       	pop	r8
    6074:	7f 90       	pop	r7
    6076:	6f 90       	pop	r6
    6078:	5f 90       	pop	r5
    607a:	4f 90       	pop	r4
    607c:	08 95       	ret
  }
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    607e:	0e 94 10 0a 	call	0x1420	; 0x1420 <getButtonEvent>
    switch(buttonVal){
    6082:	85 30       	cpi	r24, 0x05	; 5
    6084:	09 f4       	brne	.+2      	; 0x6088 <updateMenu+0x84>
    6086:	26 c1       	rjmp	.+588    	; 0x62d4 <updateMenu+0x2d0>
    6088:	86 30       	cpi	r24, 0x06	; 6
    608a:	08 f0       	brcs	.+2      	; 0x608e <updateMenu+0x8a>
    608c:	9b c0       	rjmp	.+310    	; 0x61c4 <updateMenu+0x1c0>
    608e:	83 30       	cpi	r24, 0x03	; 3
    6090:	09 f4       	brne	.+2      	; 0x6094 <updateMenu+0x90>
    6092:	13 c1       	rjmp	.+550    	; 0x62ba <updateMenu+0x2b6>
    6094:	84 30       	cpi	r24, 0x04	; 4
    6096:	09 f4       	brne	.+2      	; 0x609a <updateMenu+0x96>
    6098:	0c c1       	rjmp	.+536    	; 0x62b2 <updateMenu+0x2ae>
      default:
        break;
    }
  }

  if(menuState == MENU_VALUE_CHANGE){
    609a:	13 30       	cpi	r17, 0x03	; 3
    609c:	c9 f6       	brne	.-78     	; 0x6050 <updateMenu+0x4c>
    /* here we have a motor selected and want to change any of its values */
    rotEncVal = getRotaryEncoderEvent();
    609e:	0e 94 32 0a 	call	0x1464	; 0x1464 <getRotaryEncoderEvent>
    60a2:	18 2f       	mov	r17, r24
    if(rotEncVal != 0){
    60a4:	88 23       	and	r24, r24
    60a6:	a1 f2       	breq	.-88     	; 0x6050 <updateMenu+0x4c>
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
    60a8:	80 91 0e 03 	lds	r24, 0x030E
    60ac:	90 e0       	ldi	r25, 0x00	; 0
    60ae:	88 0f       	add	r24, r24
    60b0:	99 1f       	adc	r25, r25
    60b2:	86 5a       	subi	r24, 0xA6	; 166
    60b4:	9a 4f       	sbci	r25, 0xFA	; 250
    60b6:	fc 01       	movw	r30, r24
    60b8:	25 91       	lpm	r18, Z+
    60ba:	34 91       	lpm	r19, Z+
      state = (uint8_t)pgm_read_byte(&menuPtr->state);
    60bc:	2e 5f       	subi	r18, 0xFE	; 254
    60be:	3f 4f       	sbci	r19, 0xFF	; 255
    60c0:	f9 01       	movw	r30, r18
    60c2:	84 91       	lpm	r24, Z+

      switch(state){
    60c4:	88 30       	cpi	r24, 0x08	; 8
    60c6:	09 f4       	brne	.+2      	; 0x60ca <updateMenu+0xc6>
    60c8:	e9 c0       	rjmp	.+466    	; 0x629c <updateMenu+0x298>
    60ca:	89 30       	cpi	r24, 0x09	; 9
    60cc:	08 f0       	brcs	.+2      	; 0x60d0 <updateMenu+0xcc>
    60ce:	3a c1       	rjmp	.+628    	; 0x6344 <updateMenu+0x340>
    60d0:	84 30       	cpi	r24, 0x04	; 4
    60d2:	09 f4       	brne	.+2      	; 0x60d6 <updateMenu+0xd2>
    60d4:	5a c5       	rjmp	.+2740   	; 0x6b8a <updateMenu+0xb86>
    60d6:	85 30       	cpi	r24, 0x05	; 5
    60d8:	08 f0       	brcs	.+2      	; 0x60dc <updateMenu+0xd8>
    60da:	ee c1       	rjmp	.+988    	; 0x64b8 <updateMenu+0x4b4>
    60dc:	82 30       	cpi	r24, 0x02	; 2
    60de:	09 f4       	brne	.+2      	; 0x60e2 <updateMenu+0xde>
    60e0:	fd c6       	rjmp	.+3578   	; 0x6edc <updateMenu+0xed8>
    60e2:	83 30       	cpi	r24, 0x03	; 3
    60e4:	08 f0       	brcs	.+2      	; 0x60e8 <updateMenu+0xe4>
    60e6:	aa c4       	rjmp	.+2388   	; 0x6a3c <updateMenu+0xa38>
    60e8:	81 30       	cpi	r24, 0x01	; 1
    60ea:	09 f0       	breq	.+2      	; 0x60ee <updateMenu+0xea>
    60ec:	b1 cf       	rjmp	.-158    	; 0x6050 <updateMenu+0x4c>
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              switch(motor[i].stepUnit){
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
    60ee:	81 2e       	mov	r8, r17
    60f0:	99 24       	eor	r9, r9
    60f2:	87 fc       	sbrc	r8, 7
    60f4:	90 94       	com	r9
    60f6:	84 e6       	ldi	r24, 0x64	; 100
    60f8:	90 e0       	ldi	r25, 0x00	; 0
    60fa:	88 9e       	mul	r8, r24
    60fc:	30 01       	movw	r6, r0
    60fe:	89 9e       	mul	r8, r25
    6100:	70 0c       	add	r7, r0
    6102:	98 9e       	mul	r9, r24
    6104:	70 0c       	add	r7, r0
    6106:	11 24       	eor	r1, r1
    6108:	c0 e0       	ldi	r28, 0x00	; 0
    610a:	d0 e0       	ldi	r29, 0x00	; 0
                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
                  }
                  else{
                    degreeToSteps(i, rotEncVal, motor[i].stepMultiplier);
    610c:	a1 2e       	mov	r10, r17
    610e:	bb 24       	eor	r11, r11
    6110:	a7 fc       	sbrc	r10, 7
    6112:	b0 94       	com	r11
    6114:	cb 2c       	mov	r12, r11
    6116:	db 2c       	mov	r13, r11
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6118:	80 91 13 03 	lds	r24, 0x0313
    611c:	90 e0       	ldi	r25, 0x00	; 0
    611e:	0c 2e       	mov	r0, r28
    6120:	02 c0       	rjmp	.+4      	; 0x6126 <updateMenu+0x122>
    6122:	95 95       	asr	r25
    6124:	87 95       	ror	r24
    6126:	0a 94       	dec	r0
    6128:	e2 f7       	brpl	.-8      	; 0x6122 <updateMenu+0x11e>
    612a:	80 ff       	sbrs	r24, 0
    612c:	45 c0       	rjmp	.+138    	; 0x61b8 <updateMenu+0x1b4>
              switch(motor[i].stepUnit){
    612e:	fe 01       	movw	r30, r28
    6130:	ee 0f       	add	r30, r30
    6132:	ff 1f       	adc	r31, r31
    6134:	ee 0f       	add	r30, r30
    6136:	ff 1f       	adc	r31, r31
    6138:	ee 0f       	add	r30, r30
    613a:	ff 1f       	adc	r31, r31
    613c:	cf 01       	movw	r24, r30
    613e:	88 0f       	add	r24, r24
    6140:	99 1f       	adc	r25, r25
    6142:	88 0f       	add	r24, r24
    6144:	99 1f       	adc	r25, r25
    6146:	e8 0f       	add	r30, r24
    6148:	f9 1f       	adc	r31, r25
    614a:	e2 5e       	subi	r30, 0xE2	; 226
    614c:	fb 4f       	sbci	r31, 0xFB	; 251
    614e:	81 8d       	ldd	r24, Z+25	; 0x19
    6150:	81 30       	cpi	r24, 0x01	; 1
    6152:	09 f4       	brne	.+2      	; 0x6156 <updateMenu+0x152>
    6154:	a6 c7       	rjmp	.+3916   	; 0x70a2 <updateMenu+0x109e>
    6156:	82 30       	cpi	r24, 0x02	; 2
    6158:	09 f4       	brne	.+2      	; 0x615c <updateMenu+0x158>
    615a:	7d c7       	rjmp	.+3834   	; 0x7056 <updateMenu+0x1052>
    615c:	88 23       	and	r24, r24
    615e:	61 f5       	brne	.+88     	; 0x61b8 <updateMenu+0x1b4>
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
    6160:	80 91 10 03 	lds	r24, 0x0310
    6164:	88 23       	and	r24, r24
    6166:	11 f4       	brne	.+4      	; 0x616c <updateMenu+0x168>
    6168:	0c 94 fa 38 	jmp	0x71f4	; 0x71f4 <updateMenu+0x11f0>
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
    616c:	fe 01       	movw	r30, r28
    616e:	ee 0f       	add	r30, r30
    6170:	ff 1f       	adc	r31, r31
    6172:	ee 0f       	add	r30, r30
    6174:	ff 1f       	adc	r31, r31
    6176:	cf 01       	movw	r24, r30
    6178:	88 0f       	add	r24, r24
    617a:	99 1f       	adc	r25, r25
    617c:	88 0f       	add	r24, r24
    617e:	99 1f       	adc	r25, r25
    6180:	e8 0f       	add	r30, r24
    6182:	f9 1f       	adc	r31, r25
    6184:	ee 0f       	add	r30, r30
    6186:	ff 1f       	adc	r31, r31
    6188:	e0 5e       	subi	r30, 0xE0	; 224
    618a:	fb 4f       	sbci	r31, 0xFB	; 251
    618c:	20 81       	ld	r18, Z
    618e:	31 81       	ldd	r19, Z+1	; 0x01
    6190:	26 0d       	add	r18, r6
    6192:	37 1d       	adc	r19, r7
                  }
                  else{
                    motor[i].desiredPosition += (int16_t)rotEncVal;
    6194:	fe 01       	movw	r30, r28
    6196:	ee 0f       	add	r30, r30
    6198:	ff 1f       	adc	r31, r31
    619a:	ee 0f       	add	r30, r30
    619c:	ff 1f       	adc	r31, r31
    619e:	cf 01       	movw	r24, r30
    61a0:	88 0f       	add	r24, r24
    61a2:	99 1f       	adc	r25, r25
    61a4:	88 0f       	add	r24, r24
    61a6:	99 1f       	adc	r25, r25
    61a8:	e8 0f       	add	r30, r24
    61aa:	f9 1f       	adc	r31, r25
    61ac:	ee 0f       	add	r30, r30
    61ae:	ff 1f       	adc	r31, r31
    61b0:	e0 5e       	subi	r30, 0xE0	; 224
    61b2:	fb 4f       	sbci	r31, 0xFB	; 251
    61b4:	31 83       	std	Z+1, r19	; 0x01
    61b6:	20 83       	st	Z, r18
                  break;

                case MOTOR_STEP_UNIT_RADIAN:
                  /* default step is pi/8 */
                  /* pi/8 is far enough, so no fast moving mode here */
                  radiansToSteps(i, (rotEncVal)*0.125, motor[i].stepMultiplier);
    61b8:	21 96       	adiw	r28, 0x01	; 1
      switch(state){
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    61ba:	c4 30       	cpi	r28, 0x04	; 4
    61bc:	d1 05       	cpc	r29, r1
    61be:	09 f0       	breq	.+2      	; 0x61c2 <updateMenu+0x1be>
    61c0:	ab cf       	rjmp	.-170    	; 0x6118 <updateMenu+0x114>
    61c2:	46 cf       	rjmp	.-372    	; 0x6050 <updateMenu+0x4c>
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    switch(buttonVal){
    61c4:	87 30       	cpi	r24, 0x07	; 7
    61c6:	09 f4       	brne	.+2      	; 0x61ca <updateMenu+0x1c6>
    61c8:	89 c0       	rjmp	.+274    	; 0x62dc <updateMenu+0x2d8>
    61ca:	87 30       	cpi	r24, 0x07	; 7
    61cc:	08 f0       	brcs	.+2      	; 0x61d0 <updateMenu+0x1cc>
    61ce:	5c c0       	rjmp	.+184    	; 0x6288 <updateMenu+0x284>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR1:
        menu.selectedMotor ^= (1 << MOTOR1);
    61d0:	80 91 13 03 	lds	r24, 0x0313
    61d4:	92 e0       	ldi	r25, 0x02	; 2
    61d6:	89 27       	eor	r24, r25
    61d8:	80 93 13 03 	sts	0x0313, r24
        menu.newMenuMode = MENU_VALUE_CHANGE;
    61dc:	83 e0       	ldi	r24, 0x03	; 3
    61de:	80 93 0f 03 	sts	0x030F, r24
        updateMotorButtonLEDs();
    61e2:	0e 94 bc 07 	call	0xf78	; 0xf78 <updateMotorButtonLEDs>
    61e6:	59 cf       	rjmp	.-334    	; 0x609a <updateMenu+0x96>
  menuState  = menu.currentMenuMode;

  if(menuState == MENU_SCROLL_MODE){
    /* so here we want to scroll through the menu */

    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    61e8:	0e 94 32 0a 	call	0x1464	; 0x1464 <getRotaryEncoderEvent>
    menuPrompt = (menuPrompt+(int8_t)rotEncVal) % NUMBER_OF_DISPLAY_MENUS;
    61ec:	99 27       	eor	r25, r25
    61ee:	87 fd       	sbrc	r24, 7
    61f0:	90 95       	com	r25
    61f2:	20 2f       	mov	r18, r16
    61f4:	33 27       	eor	r19, r19
    61f6:	27 fd       	sbrc	r18, 7
    61f8:	30 95       	com	r19
    61fa:	82 0f       	add	r24, r18
    61fc:	93 1f       	adc	r25, r19
    61fe:	69 e0       	ldi	r22, 0x09	; 9
    6200:	70 e0       	ldi	r23, 0x00	; 0
    6202:	0e 94 c8 45 	call	0x8b90	; 0x8b90 <__divmodhi4>
    6206:	18 2f       	mov	r17, r24
    if(menuPrompt < 0){
    6208:	87 fd       	sbrc	r24, 7
    620a:	90 c0       	rjmp	.+288    	; 0x632c <updateMenu+0x328>
      menuPrompt = NUMBER_OF_DISPLAY_MENUS - 1;
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    620c:	80 93 0d 03 	sts	0x030D, r24
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    6210:	0e 94 10 0a 	call	0x1420	; 0x1420 <getButtonEvent>
    6214:	88 30       	cpi	r24, 0x08	; 8
    6216:	09 f4       	brne	.+2      	; 0x621a <updateMenu+0x216>
    6218:	80 c0       	rjmp	.+256    	; 0x631a <updateMenu+0x316>
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    621a:	0e 94 10 0a 	call	0x1420	; 0x1420 <getButtonEvent>
    621e:	88 30       	cpi	r24, 0x08	; 8
    6220:	09 f4       	brne	.+2      	; 0x6224 <updateMenu+0x220>
    6222:	72 c0       	rjmp	.+228    	; 0x6308 <updateMenu+0x304>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    }
    
    //or enter MENU_SETTINGS_MODE
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menuPrompt == MENU_SETTINGS){
    6224:	0e 94 10 0a 	call	0x1420	; 0x1420 <getButtonEvent>
    6228:	88 30       	cpi	r24, 0x08	; 8
    622a:	09 f0       	breq	.+2      	; 0x622e <updateMenu+0x22a>
    622c:	11 cf       	rjmp	.-478    	; 0x6050 <updateMenu+0x4c>
    622e:	18 30       	cpi	r17, 0x08	; 8
    6230:	09 f0       	breq	.+2      	; 0x6234 <updateMenu+0x230>
    6232:	0e cf       	rjmp	.-484    	; 0x6050 <updateMenu+0x4c>
      menu.newMenuMode = MENU_SETTINGS_MODE;
    6234:	85 e0       	ldi	r24, 0x05	; 5
    6236:	80 93 0f 03 	sts	0x030F, r24
      menu.newDisplayedMenu = MENU_SET_GEAR_RATIO; //first submenu, that should be displayed
    623a:	8a e0       	ldi	r24, 0x0A	; 10
    623c:	80 93 0d 03 	sts	0x030D, r24
    6240:	07 cf       	rjmp	.-498    	; 0x6050 <updateMenu+0x4c>
  }
  
  if(menuState == MENU_SETTINGS_MODE){
    /* so here we want to scroll through the settings menu */
          
    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    6242:	0e 94 32 0a 	call	0x1464	; 0x1464 <getRotaryEncoderEvent>
    menuPrompt = (menuPrompt + (int8_t)rotEncVal);
    6246:	28 2f       	mov	r18, r24
    6248:	20 0f       	add	r18, r16
    if(menuPrompt > 9 + NUMBER_OF_SETTINGS_MENUS){
    624a:	22 31       	cpi	r18, 0x12	; 18
    624c:	cc f0       	brlt	.+50     	; 0x6280 <updateMenu+0x27c>
    624e:	2a e0       	ldi	r18, 0x0A	; 10
    }
    if(menuPrompt < 10){
      menuPrompt = 9 + NUMBER_OF_SETTINGS_MENUS;
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    6250:	20 93 0d 03 	sts	0x030D, r18

    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    6254:	0e 94 10 0a 	call	0x1420	; 0x1420 <getButtonEvent>
    6258:	88 30       	cpi	r24, 0x08	; 8
    625a:	09 f4       	brne	.+2      	; 0x625e <updateMenu+0x25a>
    625c:	43 c0       	rjmp	.+134    	; 0x62e4 <updateMenu+0x2e0>
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    625e:	0e 94 10 0a 	call	0x1420	; 0x1420 <getButtonEvent>
    6262:	88 30       	cpi	r24, 0x08	; 8
    6264:	09 f4       	brne	.+2      	; 0x6268 <updateMenu+0x264>
    6266:	47 c0       	rjmp	.+142    	; 0x62f6 <updateMenu+0x2f2>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    }
    
    buttonVal = getButtonEvent();
    6268:	0e 94 10 0a 	call	0x1420	; 0x1420 <getButtonEvent>
    if(buttonVal == BUTTON_MENUESCAPE){
    626c:	83 30       	cpi	r24, 0x03	; 3
    626e:	09 f0       	breq	.+2      	; 0x6272 <updateMenu+0x26e>
    6270:	ef ce       	rjmp	.-546    	; 0x6050 <updateMenu+0x4c>
      /* get back to the MENU_SCROLL_MODE */
      menu.newMenuMode = MENU_SCROLL_MODE;
    6272:	82 e0       	ldi	r24, 0x02	; 2
    6274:	80 93 0f 03 	sts	0x030F, r24
      menu.newDisplayedMenu = MENU_SETTINGS;
    6278:	88 e0       	ldi	r24, 0x08	; 8
    627a:	80 93 0d 03 	sts	0x030D, r24
    627e:	e8 ce       	rjmp	.-560    	; 0x6050 <updateMenu+0x4c>
    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    menuPrompt = (menuPrompt + (int8_t)rotEncVal);
    if(menuPrompt > 9 + NUMBER_OF_SETTINGS_MENUS){
      menuPrompt = 10;
    }
    if(menuPrompt < 10){
    6280:	2a 30       	cpi	r18, 0x0A	; 10
    6282:	34 f7       	brge	.-52     	; 0x6250 <updateMenu+0x24c>
    6284:	21 e1       	ldi	r18, 0x11	; 17
    6286:	e4 cf       	rjmp	.-56     	; 0x6250 <updateMenu+0x24c>
  

  if((menuState == MENU_CHANGE_MODE) || (menuState == MENU_VALUE_CHANGE)){
    /* Well, we want to select a motor to change its above selected value */
    buttonVal = getButtonEvent();
    switch(buttonVal){
    6288:	88 30       	cpi	r24, 0x08	; 8
    628a:	09 f0       	breq	.+2      	; 0x628e <updateMenu+0x28a>
    628c:	06 cf       	rjmp	.-500    	; 0x609a <updateMenu+0x96>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_ROT_ENC_PRESS:
        menu.fastMovingMode ^= 1;
    628e:	80 91 10 03 	lds	r24, 0x0310
    6292:	91 e0       	ldi	r25, 0x01	; 1
    6294:	89 27       	eor	r24, r25
    6296:	80 93 10 03 	sts	0x0310, r24
    629a:	ff ce       	rjmp	.-514    	; 0x609a <updateMenu+0x96>
            }
          }
          break;
          
        case MENU_SETTINGS:        
          OLEDclear();
    629c:	0e 94 f4 3d 	call	0x7be8	; 0x7be8 <OLEDclear>
          OLEDsetCursor(0, 0);
    62a0:	80 e0       	ldi	r24, 0x00	; 0
    62a2:	60 e0       	ldi	r22, 0x00	; 0
    62a4:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
          OLEDprintCC("hello"); //should never show up
    62a8:	88 ef       	ldi	r24, 0xF8	; 248
    62aa:	92 e0       	ldi	r25, 0x02	; 2
    62ac:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
    62b0:	cf ce       	rjmp	.-610    	; 0x6050 <updateMenu+0x4c>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR3:
        menu.selectedMotor ^= (1 << MOTOR3);
    62b2:	80 91 13 03 	lds	r24, 0x0313
    62b6:	98 e0       	ldi	r25, 0x08	; 8
    62b8:	8e cf       	rjmp	.-228    	; 0x61d6 <updateMenu+0x1d2>
      case BUTTON_ROT_ENC_PRESS:
        menu.fastMovingMode ^= 1;
        break;

      case BUTTON_MENUESCAPE:
        if(menu.currentDisplayedMenu < 10){
    62ba:	80 91 0e 03 	lds	r24, 0x030E
    62be:	8a 30       	cpi	r24, 0x0A	; 10
    62c0:	c0 f5       	brcc	.+112    	; 0x6332 <updateMenu+0x32e>
          /* get back to the MENU_SCROLL_MODE */
          menu.newMenuMode = MENU_SCROLL_MODE;
    62c2:	82 e0       	ldi	r24, 0x02	; 2
    62c4:	80 93 0f 03 	sts	0x030F, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    62c8:	89 e0       	ldi	r24, 0x09	; 9
    62ca:	80 93 0e 03 	sts	0x030E, r24
          menu.fastMovingMode = OFF;
    62ce:	10 92 10 03 	sts	0x0310, r1
    62d2:	e3 ce       	rjmp	.-570    	; 0x609a <updateMenu+0x96>
        menu.newMenuMode = MENU_VALUE_CHANGE;
        updateMotorButtonLEDs();
        break;

      case BUTTON_MOTOR2:
        menu.selectedMotor ^= (1 << MOTOR2);
    62d4:	80 91 13 03 	lds	r24, 0x0313
    62d8:	94 e0       	ldi	r25, 0x04	; 4
    62da:	7d cf       	rjmp	.-262    	; 0x61d6 <updateMenu+0x1d2>
    switch(buttonVal){
      case NO_BUTTON:
        break;

      case BUTTON_MOTOR0:
        menu.selectedMotor ^= (1 << MOTOR0);
    62dc:	80 91 13 03 	lds	r24, 0x0313
    62e0:	91 e0       	ldi	r25, 0x01	; 1
    62e2:	79 cf       	rjmp	.-270    	; 0x61d6 <updateMenu+0x1d2>
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;

    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    62e4:	80 91 13 03 	lds	r24, 0x0313
    62e8:	88 23       	and	r24, r24
    62ea:	09 f0       	breq	.+2      	; 0x62ee <updateMenu+0x2ea>
    62ec:	b8 cf       	rjmp	.-144    	; 0x625e <updateMenu+0x25a>
      menu.newMenuMode = MENU_CHANGE_MODE;
    62ee:	81 e0       	ldi	r24, 0x01	; 1
    62f0:	80 93 0f 03 	sts	0x030F, r24
    62f4:	b4 cf       	rjmp	.-152    	; 0x625e <updateMenu+0x25a>
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    62f6:	80 91 13 03 	lds	r24, 0x0313
    62fa:	88 23       	and	r24, r24
    62fc:	09 f4       	brne	.+2      	; 0x6300 <updateMenu+0x2fc>
    62fe:	b4 cf       	rjmp	.-152    	; 0x6268 <updateMenu+0x264>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    6300:	83 e0       	ldi	r24, 0x03	; 3
    6302:	80 93 0f 03 	sts	0x030F, r24
    6306:	b0 cf       	rjmp	.-160    	; 0x6268 <updateMenu+0x264>
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
      menu.newMenuMode = MENU_CHANGE_MODE;
    }
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor != 0){
    6308:	80 91 13 03 	lds	r24, 0x0313
    630c:	88 23       	and	r24, r24
    630e:	09 f4       	brne	.+2      	; 0x6312 <updateMenu+0x30e>
    6310:	89 cf       	rjmp	.-238    	; 0x6224 <updateMenu+0x220>
      menu.newMenuMode = MENU_VALUE_CHANGE;
    6312:	83 e0       	ldi	r24, 0x03	; 3
    6314:	80 93 0f 03 	sts	0x030F, r24
    6318:	85 cf       	rjmp	.-246    	; 0x6224 <updateMenu+0x220>
    }

    menu.newDisplayedMenu = (uint8_t)menuPrompt;
    
    /* or enter the MENU_CHANGE_MODE */
    if(getButtonEvent() == BUTTON_ROT_ENC_PRESS && menu.selectedMotor == 0){
    631a:	80 91 13 03 	lds	r24, 0x0313
    631e:	88 23       	and	r24, r24
    6320:	09 f0       	breq	.+2      	; 0x6324 <updateMenu+0x320>
    6322:	7b cf       	rjmp	.-266    	; 0x621a <updateMenu+0x216>
      menu.newMenuMode = MENU_CHANGE_MODE;
    6324:	81 e0       	ldi	r24, 0x01	; 1
    6326:	80 93 0f 03 	sts	0x030F, r24
    632a:	77 cf       	rjmp	.-274    	; 0x621a <updateMenu+0x216>
  if(menuState == MENU_SCROLL_MODE){
    /* so here we want to scroll through the menu */

    rotEncVal = getRotaryEncoderEvent();  /* get wanted menu prompt */
    menuPrompt = (menuPrompt+(int8_t)rotEncVal) % NUMBER_OF_DISPLAY_MENUS;
    if(menuPrompt < 0){
    632c:	18 e0       	ldi	r17, 0x08	; 8
    632e:	88 e0       	ldi	r24, 0x08	; 8
    6330:	6d cf       	rjmp	.-294    	; 0x620c <updateMenu+0x208>
          menu.currentDisplayedMenu = MENU_DUMMY;
          menu.fastMovingMode = OFF;
        }
        else{
          /* get back to the MENU_SETTINGS_MODE */
          menu.newMenuMode = MENU_SETTINGS_MODE;
    6332:	85 e0       	ldi	r24, 0x05	; 5
    6334:	80 93 0f 03 	sts	0x030F, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    6338:	89 e0       	ldi	r24, 0x09	; 9
    633a:	80 93 0e 03 	sts	0x030E, r24
          menu.fastMovingMode = OFF;
    633e:	10 92 10 03 	sts	0x0310, r1
    6342:	ab ce       	rjmp	.-682    	; 0x609a <updateMenu+0x96>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    6344:	8d 30       	cpi	r24, 0x0D	; 13
    6346:	09 f4       	brne	.+2      	; 0x634a <updateMenu+0x346>
    6348:	c4 c1       	rjmp	.+904    	; 0x66d2 <updateMenu+0x6ce>
    634a:	8e 30       	cpi	r24, 0x0E	; 14
    634c:	08 f0       	brcs	.+2      	; 0x6350 <updateMenu+0x34c>
    634e:	99 c0       	rjmp	.+306    	; 0x6482 <updateMenu+0x47e>
    6350:	8b 30       	cpi	r24, 0x0B	; 11
    6352:	09 f4       	brne	.+2      	; 0x6356 <updateMenu+0x352>
    6354:	fa c2       	rjmp	.+1524   	; 0x694a <updateMenu+0x946>
    6356:	8c 30       	cpi	r24, 0x0C	; 12
    6358:	08 f0       	brcs	.+2      	; 0x635c <updateMenu+0x358>
    635a:	7a c2       	rjmp	.+1268   	; 0x6850 <updateMenu+0x84c>
    635c:	8a 30       	cpi	r24, 0x0A	; 10
    635e:	09 f0       	breq	.+2      	; 0x6362 <updateMenu+0x35e>
    6360:	77 ce       	rjmp	.-786    	; 0x6050 <updateMenu+0x4c>
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    6362:	c0 e0       	ldi	r28, 0x00	; 0
    6364:	d0 e0       	ldi	r29, 0x00	; 0
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                motor[i].gearRatio += (rotEncVal)/10.0;
              }
              else{
                motor[i].gearRatio += (rotEncVal)/1000.0;
    6366:	81 2e       	mov	r8, r17
    6368:	99 24       	eor	r9, r9
    636a:	87 fc       	sbrc	r8, 7
    636c:	90 94       	com	r9
    636e:	a9 2c       	mov	r10, r9
    6370:	b9 2c       	mov	r11, r9
          }
          break;
          
        case MENU_SET_GEAR_RATIO:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6372:	80 91 13 03 	lds	r24, 0x0313
    6376:	dc 2e       	mov	r13, r28
    6378:	cd 2e       	mov	r12, r29
    637a:	90 e0       	ldi	r25, 0x00	; 0
    637c:	0c 2e       	mov	r0, r28
    637e:	02 c0       	rjmp	.+4      	; 0x6384 <updateMenu+0x380>
    6380:	95 95       	asr	r25
    6382:	87 95       	ror	r24
    6384:	0a 94       	dec	r0
    6386:	e2 f7       	brpl	.-8      	; 0x6380 <updateMenu+0x37c>
    6388:	80 ff       	sbrs	r24, 0
    638a:	75 c0       	rjmp	.+234    	; 0x6476 <updateMenu+0x472>
              if(menu.fastMovingMode){
    638c:	80 91 10 03 	lds	r24, 0x0310
    6390:	88 23       	and	r24, r24
    6392:	09 f4       	brne	.+2      	; 0x6396 <updateMenu+0x392>
    6394:	c6 c3       	rjmp	.+1932   	; 0x6b22 <updateMenu+0xb1e>
                motor[i].gearRatio += (rotEncVal)/10.0;
    6396:	fe 01       	movw	r30, r28
    6398:	ee 0f       	add	r30, r30
    639a:	ff 1f       	adc	r31, r31
    639c:	ee 0f       	add	r30, r30
    639e:	ff 1f       	adc	r31, r31
    63a0:	ee 0f       	add	r30, r30
    63a2:	ff 1f       	adc	r31, r31
    63a4:	cf 01       	movw	r24, r30
    63a6:	88 0f       	add	r24, r24
    63a8:	99 1f       	adc	r25, r25
    63aa:	88 0f       	add	r24, r24
    63ac:	99 1f       	adc	r25, r25
    63ae:	e8 0f       	add	r30, r24
    63b0:	f9 1f       	adc	r31, r25
    63b2:	e2 5e       	subi	r30, 0xE2	; 226
    63b4:	fb 4f       	sbci	r31, 0xFB	; 251
    63b6:	e5 84       	ldd	r14, Z+13	; 0x0d
    63b8:	f6 84       	ldd	r15, Z+14	; 0x0e
    63ba:	07 85       	ldd	r16, Z+15	; 0x0f
    63bc:	10 89       	ldd	r17, Z+16	; 0x10
    63be:	c5 01       	movw	r24, r10
    63c0:	b4 01       	movw	r22, r8
    63c2:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    63c6:	20 e0       	ldi	r18, 0x00	; 0
    63c8:	30 e0       	ldi	r19, 0x00	; 0
    63ca:	40 e2       	ldi	r20, 0x20	; 32
    63cc:	51 e4       	ldi	r21, 0x41	; 65
              }
              else{
                motor[i].gearRatio += (rotEncVal)/1000.0;
    63ce:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    63d2:	9b 01       	movw	r18, r22
    63d4:	ac 01       	movw	r20, r24
    63d6:	c8 01       	movw	r24, r16
    63d8:	b7 01       	movw	r22, r14
    63da:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    63de:	fe 01       	movw	r30, r28
    63e0:	ee 0f       	add	r30, r30
    63e2:	ff 1f       	adc	r31, r31
    63e4:	ee 0f       	add	r30, r30
    63e6:	ff 1f       	adc	r31, r31
    63e8:	ee 0f       	add	r30, r30
    63ea:	ff 1f       	adc	r31, r31
    63ec:	9f 01       	movw	r18, r30
    63ee:	22 0f       	add	r18, r18
    63f0:	33 1f       	adc	r19, r19
    63f2:	22 0f       	add	r18, r18
    63f4:	33 1f       	adc	r19, r19
    63f6:	e2 0f       	add	r30, r18
    63f8:	f3 1f       	adc	r31, r19
    63fa:	e2 5e       	subi	r30, 0xE2	; 226
    63fc:	fb 4f       	sbci	r31, 0xFB	; 251
    63fe:	65 87       	std	Z+13, r22	; 0x0d
    6400:	76 87       	std	Z+14, r23	; 0x0e
    6402:	87 87       	std	Z+15, r24	; 0x0f
    6404:	90 8b       	std	Z+16, r25	; 0x10
              }
              motor[i].gearRatio = roundf(motor[i].gearRatio * 1000) / 1000;
    6406:	ed 2d       	mov	r30, r13
    6408:	fc 2d       	mov	r31, r12
    640a:	ee 0f       	add	r30, r30
    640c:	ff 1f       	adc	r31, r31
    640e:	ee 0f       	add	r30, r30
    6410:	ff 1f       	adc	r31, r31
    6412:	ee 0f       	add	r30, r30
    6414:	ff 1f       	adc	r31, r31
    6416:	cf 01       	movw	r24, r30
    6418:	88 0f       	add	r24, r24
    641a:	99 1f       	adc	r25, r25
    641c:	88 0f       	add	r24, r24
    641e:	99 1f       	adc	r25, r25
    6420:	e8 0f       	add	r30, r24
    6422:	f9 1f       	adc	r31, r25
    6424:	e2 5e       	subi	r30, 0xE2	; 226
    6426:	fb 4f       	sbci	r31, 0xFB	; 251
    6428:	65 85       	ldd	r22, Z+13	; 0x0d
    642a:	76 85       	ldd	r23, Z+14	; 0x0e
    642c:	87 85       	ldd	r24, Z+15	; 0x0f
    642e:	90 89       	ldd	r25, Z+16	; 0x10
    6430:	20 e0       	ldi	r18, 0x00	; 0
    6432:	30 e0       	ldi	r19, 0x00	; 0
    6434:	4a e7       	ldi	r20, 0x7A	; 122
    6436:	54 e4       	ldi	r21, 0x44	; 68
    6438:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    643c:	0e 94 94 45 	call	0x8b28	; 0x8b28 <round>
    6440:	20 e0       	ldi	r18, 0x00	; 0
    6442:	30 e0       	ldi	r19, 0x00	; 0
    6444:	4a e7       	ldi	r20, 0x7A	; 122
    6446:	54 e4       	ldi	r21, 0x44	; 68
    6448:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    644c:	ed 2d       	mov	r30, r13
    644e:	fc 2d       	mov	r31, r12
    6450:	ee 0f       	add	r30, r30
    6452:	ff 1f       	adc	r31, r31
    6454:	ee 0f       	add	r30, r30
    6456:	ff 1f       	adc	r31, r31
    6458:	ee 0f       	add	r30, r30
    645a:	ff 1f       	adc	r31, r31
    645c:	9f 01       	movw	r18, r30
    645e:	22 0f       	add	r18, r18
    6460:	33 1f       	adc	r19, r19
    6462:	22 0f       	add	r18, r18
    6464:	33 1f       	adc	r19, r19
    6466:	e2 0f       	add	r30, r18
    6468:	f3 1f       	adc	r31, r19
    646a:	e2 5e       	subi	r30, 0xE2	; 226
    646c:	fb 4f       	sbci	r31, 0xFB	; 251
    646e:	65 87       	std	Z+13, r22	; 0x0d
    6470:	76 87       	std	Z+14, r23	; 0x0e
    6472:	87 87       	std	Z+15, r24	; 0x0f
    6474:	90 8b       	std	Z+16, r25	; 0x10
    6476:	21 96       	adiw	r28, 0x01	; 1
            ;
          }
          break;
          
        case MENU_SET_GEAR_RATIO:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6478:	c4 30       	cpi	r28, 0x04	; 4
    647a:	d1 05       	cpc	r29, r1
    647c:	09 f0       	breq	.+2      	; 0x6480 <updateMenu+0x47c>
    647e:	79 cf       	rjmp	.-270    	; 0x6372 <updateMenu+0x36e>
    6480:	e7 cd       	rjmp	.-1074   	; 0x6050 <updateMenu+0x4c>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    6482:	8f 30       	cpi	r24, 0x0F	; 15
    6484:	09 f4       	brne	.+2      	; 0x6488 <updateMenu+0x484>
    6486:	9b c4       	rjmp	.+2358   	; 0x6dbe <updateMenu+0xdba>
    6488:	8f 30       	cpi	r24, 0x0F	; 15
    648a:	08 f4       	brcc	.+2      	; 0x648e <updateMenu+0x48a>
    648c:	25 c4       	rjmp	.+2122   	; 0x6cd8 <updateMenu+0xcd4>
    648e:	80 31       	cpi	r24, 0x10	; 16
    6490:	09 f4       	brne	.+2      	; 0x6494 <updateMenu+0x490>
    6492:	15 c4       	rjmp	.+2090   	; 0x6cbe <updateMenu+0xcba>
    6494:	81 31       	cpi	r24, 0x11	; 17
    6496:	09 f0       	breq	.+2      	; 0x649a <updateMenu+0x496>
    6498:	db cd       	rjmp	.-1098   	; 0x6050 <updateMenu+0x4c>
          OLEDsetCursor(0, 0);
          OLEDprintCC("saved");
          break;

        case MENU_LOAD_CONFIG:   /* load last configuration */
          loadConfigFromEEPROM();
    649a:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <loadConfigFromEEPROM>
          updateIICvalues();
    649e:	0e 94 1d 2e 	call	0x5c3a	; 0x5c3a <updateIICvalues>
          //lcd_clear();
          //lcd_string("loaded");
          OLEDclear();
    64a2:	0e 94 f4 3d 	call	0x7be8	; 0x7be8 <OLEDclear>
          OLEDsetCursor(0, 0);
    64a6:	80 e0       	ldi	r24, 0x00	; 0
    64a8:	60 e0       	ldi	r22, 0x00	; 0
    64aa:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
          OLEDprintCC("loaded");
    64ae:	81 ef       	ldi	r24, 0xF1	; 241
    64b0:	92 e0       	ldi	r25, 0x02	; 2
    64b2:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
    64b6:	cc cd       	rjmp	.-1128   	; 0x6050 <updateMenu+0x4c>
    rotEncVal = getRotaryEncoderEvent();
    if(rotEncVal != 0){
      menuPtr = (menuItem*)pgm_read_word(&menuList[menu.currentDisplayedMenu]);
      state = (uint8_t)pgm_read_byte(&menuPtr->state);

      switch(state){
    64b8:	86 30       	cpi	r24, 0x06	; 6
    64ba:	09 f4       	brne	.+2      	; 0x64be <updateMenu+0x4ba>
    64bc:	83 c0       	rjmp	.+262    	; 0x65c4 <updateMenu+0x5c0>
    64be:	87 30       	cpi	r24, 0x07	; 7
    64c0:	78 f1       	brcs	.+94     	; 0x6520 <updateMenu+0x51c>
            }
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    64c2:	c0 e0       	ldi	r28, 0x00	; 0
    64c4:	d0 e0       	ldi	r29, 0x00	; 0

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motorZeroRun(i);
              menu.selectedMotor ^= (1 << i);
    64c6:	e1 e0       	ldi	r30, 0x01	; 1
    64c8:	ce 2e       	mov	r12, r30
    64ca:	d1 2c       	mov	r13, r1
          }
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    64cc:	80 91 13 03 	lds	r24, 0x0313
    64d0:	90 e0       	ldi	r25, 0x00	; 0
    64d2:	0c 2e       	mov	r0, r28
    64d4:	02 c0       	rjmp	.+4      	; 0x64da <updateMenu+0x4d6>
    64d6:	95 95       	asr	r25
    64d8:	87 95       	ror	r24
    64da:	0a 94       	dec	r0
    64dc:	e2 f7       	brpl	.-8      	; 0x64d6 <updateMenu+0x4d2>
    64de:	80 fd       	sbrc	r24, 0
    64e0:	0b c0       	rjmp	.+22     	; 0x64f8 <updateMenu+0x4f4>
              motorZeroRun(i);
              menu.selectedMotor ^= (1 << i);
              updateDisplay();
              updateMotorButtonLEDs();
    64e2:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    64e4:	c4 30       	cpi	r28, 0x04	; 4
    64e6:	d1 05       	cpc	r29, r1
    64e8:	89 f7       	brne	.-30     	; 0x64cc <updateMenu+0x4c8>
              updateDisplay();
              updateMotorButtonLEDs();
            }
          }
          /* get back to the MENU_SCROLL_MODE when finished calibration*/
          menu.newMenuMode = MENU_SCROLL_MODE;
    64ea:	82 e0       	ldi	r24, 0x02	; 2
    64ec:	80 93 0f 03 	sts	0x030F, r24
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
    64f0:	89 e0       	ldi	r24, 0x09	; 9
    64f2:	80 93 0e 03 	sts	0x030E, r24
    64f6:	ac cd       	rjmp	.-1192   	; 0x6050 <updateMenu+0x4c>
          break;

        case MENU_RUN_ZERO_CALIBRATION:   /* run ZERO calibration */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motorZeroRun(i);
    64f8:	8c 2f       	mov	r24, r28
    64fa:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <motorZeroRun>
              menu.selectedMotor ^= (1 << i);
    64fe:	20 91 13 03 	lds	r18, 0x0313
    6502:	c6 01       	movw	r24, r12
    6504:	0c 2e       	mov	r0, r28
    6506:	02 c0       	rjmp	.+4      	; 0x650c <updateMenu+0x508>
    6508:	88 0f       	add	r24, r24
    650a:	99 1f       	adc	r25, r25
    650c:	0a 94       	dec	r0
    650e:	e2 f7       	brpl	.-8      	; 0x6508 <updateMenu+0x504>
    6510:	28 27       	eor	r18, r24
    6512:	20 93 13 03 	sts	0x0313, r18
              updateDisplay();
    6516:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <updateDisplay>
              updateMotorButtonLEDs();
    651a:	0e 94 bc 07 	call	0xf78	; 0xf78 <updateMotorButtonLEDs>
    651e:	e1 cf       	rjmp	.-62     	; 0x64e2 <updateMenu+0x4de>
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6520:	c0 e0       	ldi	r28, 0x00	; 0
    6522:	d0 e0       	ldi	r29, 0x00	; 0
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
              if(motor[i].angularVelocity < 0){
                motor[i].angularVelocity = 2;
    6524:	02 e0       	ldi	r16, 0x02	; 2
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6526:	4c 2f       	mov	r20, r28
          }
          break;

        case MENU_CONST_ANGULAR_SPEED:  /* enter constant moving mode */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6528:	80 91 13 03 	lds	r24, 0x0313
    652c:	90 e0       	ldi	r25, 0x00	; 0
    652e:	0c 2e       	mov	r0, r28
    6530:	02 c0       	rjmp	.+4      	; 0x6536 <updateMenu+0x532>
    6532:	95 95       	asr	r25
    6534:	87 95       	ror	r24
    6536:	0a 94       	dec	r0
    6538:	e2 f7       	brpl	.-8      	; 0x6532 <updateMenu+0x52e>
    653a:	80 ff       	sbrs	r24, 0
    653c:	3d c0       	rjmp	.+122    	; 0x65b8 <updateMenu+0x5b4>
              if(forbiddenZone[i].active){
    653e:	fe 01       	movw	r30, r28
    6540:	ee 0f       	add	r30, r30
    6542:	ff 1f       	adc	r31, r31
    6544:	ee 0f       	add	r30, r30
    6546:	ff 1f       	adc	r31, r31
    6548:	ec 0f       	add	r30, r28
    654a:	fd 1f       	adc	r31, r29
    654c:	ef 5f       	subi	r30, 0xFF	; 255
    654e:	fb 4f       	sbci	r31, 0xFB	; 251
    6550:	84 81       	ldd	r24, Z+4	; 0x04
    6552:	88 23       	and	r24, r24
    6554:	09 f0       	breq	.+2      	; 0x6558 <updateMenu+0x554>
    6556:	7c cd       	rjmp	.-1288   	; 0x6050 <updateMenu+0x4c>
                /* const angular speed not allowed if
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
    6558:	9e 01       	movw	r18, r28
    655a:	22 0f       	add	r18, r18
    655c:	33 1f       	adc	r19, r19
    655e:	22 0f       	add	r18, r18
    6560:	33 1f       	adc	r19, r19
    6562:	22 0f       	add	r18, r18
    6564:	33 1f       	adc	r19, r19
    6566:	f9 01       	movw	r30, r18
    6568:	ee 0f       	add	r30, r30
    656a:	ff 1f       	adc	r31, r31
    656c:	ee 0f       	add	r30, r30
    656e:	ff 1f       	adc	r31, r31
    6570:	e2 0f       	add	r30, r18
    6572:	f3 1f       	adc	r31, r19
    6574:	e2 5e       	subi	r30, 0xE2	; 226
    6576:	fb 4f       	sbci	r31, 0xFB	; 251
    6578:	82 a1       	ldd	r24, Z+34	; 0x22
    657a:	81 0f       	add	r24, r17
    657c:	82 a3       	std	Z+34, r24	; 0x22
              if(motor[i].angularVelocity < 0){
    657e:	82 a1       	ldd	r24, Z+34	; 0x22
    6580:	87 fd       	sbrc	r24, 7
    6582:	67 c5       	rjmp	.+2766   	; 0x7052 <updateMenu+0x104e>
                motor[i].angularVelocity = 2;
              }
              if(motor[i].angularVelocity > 2){
    6584:	f9 01       	movw	r30, r18
    6586:	ee 0f       	add	r30, r30
    6588:	ff 1f       	adc	r31, r31
    658a:	ee 0f       	add	r30, r30
    658c:	ff 1f       	adc	r31, r31
    658e:	e2 0f       	add	r30, r18
    6590:	f3 1f       	adc	r31, r19
    6592:	e2 5e       	subi	r30, 0xE2	; 226
    6594:	fb 4f       	sbci	r31, 0xFB	; 251
    6596:	82 a1       	ldd	r24, Z+34	; 0x22
    6598:	83 30       	cpi	r24, 0x03	; 3
    659a:	0c f0       	brlt	.+2      	; 0x659e <updateMenu+0x59a>
                motor[i].angularVelocity = 0;
    659c:	12 a2       	std	Z+34, r1	; 0x22
              }
              setConstSpeed(i, motor[i].angularVelocity);
    659e:	f9 01       	movw	r30, r18
    65a0:	ee 0f       	add	r30, r30
    65a2:	ff 1f       	adc	r31, r31
    65a4:	ee 0f       	add	r30, r30
    65a6:	ff 1f       	adc	r31, r31
    65a8:	e2 0f       	add	r30, r18
    65aa:	f3 1f       	adc	r31, r19
    65ac:	e2 5e       	subi	r30, 0xE2	; 226
    65ae:	fb 4f       	sbci	r31, 0xFB	; 251
    65b0:	62 a1       	ldd	r22, Z+34	; 0x22
    65b2:	84 2f       	mov	r24, r20
    65b4:	0e 94 e7 08 	call	0x11ce	; 0x11ce <setConstSpeed>
    65b8:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_CONST_ANGULAR_SPEED:  /* enter constant moving mode */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    65ba:	c4 30       	cpi	r28, 0x04	; 4
    65bc:	d1 05       	cpc	r29, r1
    65be:	09 f0       	breq	.+2      	; 0x65c2 <updateMenu+0x5be>
    65c0:	b2 cf       	rjmp	.-156    	; 0x6526 <updateMenu+0x522>
    65c2:	46 cd       	rjmp	.-1396   	; 0x6050 <updateMenu+0x4c>

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                defineOpticalZeroPosition(i, rotEncVal*100);
    65c4:	61 2f       	mov	r22, r17
    65c6:	77 27       	eor	r23, r23
    65c8:	67 fd       	sbrc	r22, 7
    65ca:	70 95       	com	r23
    65cc:	84 e6       	ldi	r24, 0x64	; 100
    65ce:	90 e0       	ldi	r25, 0x00	; 0
    65d0:	68 9f       	mul	r22, r24
    65d2:	d0 01       	movw	r26, r0
    65d4:	69 9f       	mul	r22, r25
    65d6:	b0 0d       	add	r27, r0
    65d8:	78 9f       	mul	r23, r24
    65da:	b0 0d       	add	r27, r0
    65dc:	11 24       	eor	r1, r1
    65de:	40 e0       	ldi	r20, 0x00	; 0
    65e0:	50 e0       	ldi	r21, 0x00	; 0
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    65e2:	80 91 13 03 	lds	r24, 0x0313
    65e6:	90 e0       	ldi	r25, 0x00	; 0
    65e8:	04 2e       	mov	r0, r20
    65ea:	02 c0       	rjmp	.+4      	; 0x65f0 <updateMenu+0x5ec>
    65ec:	95 95       	asr	r25
    65ee:	87 95       	ror	r24
    65f0:	0a 94       	dec	r0
    65f2:	e2 f7       	brpl	.-8      	; 0x65ec <updateMenu+0x5e8>
    65f4:	80 ff       	sbrs	r24, 0
    65f6:	51 c0       	rjmp	.+162    	; 0x669a <updateMenu+0x696>
              if(menu.fastMovingMode){
    65f8:	80 91 10 03 	lds	r24, 0x0310
    65fc:	88 23       	and	r24, r24
    65fe:	09 f4       	brne	.+2      	; 0x6602 <updateMenu+0x5fe>
    6600:	53 c0       	rjmp	.+166    	; 0x66a8 <updateMenu+0x6a4>
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
    6602:	fa 01       	movw	r30, r20
    6604:	ee 0f       	add	r30, r30
    6606:	ff 1f       	adc	r31, r31
    6608:	ee 0f       	add	r30, r30
    660a:	ff 1f       	adc	r31, r31
    660c:	ee 0f       	add	r30, r30
    660e:	ff 1f       	adc	r31, r31
    6610:	cf 01       	movw	r24, r30
    6612:	88 0f       	add	r24, r24
    6614:	99 1f       	adc	r25, r25
    6616:	88 0f       	add	r24, r24
    6618:	99 1f       	adc	r25, r25
    661a:	e8 0f       	add	r30, r24
    661c:	f9 1f       	adc	r31, r25
    661e:	e2 5e       	subi	r30, 0xE2	; 226
    6620:	fb 4f       	sbci	r31, 0xFB	; 251
    6622:	20 81       	ld	r18, Z
    6624:	31 81       	ldd	r19, Z+1	; 0x01
    6626:	2a 0f       	add	r18, r26
    6628:	3b 1f       	adc	r19, r27
    662a:	fa 01       	movw	r30, r20
    662c:	ee 0f       	add	r30, r30
    662e:	ff 1f       	adc	r31, r31
    6630:	ee 0f       	add	r30, r30
    6632:	ff 1f       	adc	r31, r31
    6634:	cf 01       	movw	r24, r30
    6636:	88 0f       	add	r24, r24
    6638:	99 1f       	adc	r25, r25
    663a:	88 0f       	add	r24, r24
    663c:	99 1f       	adc	r25, r25
    663e:	e8 0f       	add	r30, r24
    6640:	f9 1f       	adc	r31, r25
    6642:	ee 0f       	add	r30, r30
    6644:	ff 1f       	adc	r31, r31
    6646:	e0 5e       	subi	r30, 0xE0	; 224
    6648:	fb 4f       	sbci	r31, 0xFB	; 251
    664a:	31 83       	std	Z+1, r19	; 0x01
    664c:	20 83       	st	Z, r18
  motor[i].opticalZeroPosition = motor[i].desiredPosition;
    664e:	fa 01       	movw	r30, r20
    6650:	ee 0f       	add	r30, r30
    6652:	ff 1f       	adc	r31, r31
    6654:	ee 0f       	add	r30, r30
    6656:	ff 1f       	adc	r31, r31
    6658:	cf 01       	movw	r24, r30
    665a:	88 0f       	add	r24, r24
    665c:	99 1f       	adc	r25, r25
    665e:	88 0f       	add	r24, r24
    6660:	99 1f       	adc	r25, r25
    6662:	e8 0f       	add	r30, r24
    6664:	f9 1f       	adc	r31, r25
    6666:	ee 0f       	add	r30, r30
    6668:	ff 1f       	adc	r31, r31
    666a:	e0 5e       	subi	r30, 0xE0	; 224
    666c:	fb 4f       	sbci	r31, 0xFB	; 251
    666e:	20 81       	ld	r18, Z
    6670:	31 81       	ldd	r19, Z+1	; 0x01
    6672:	ca 01       	movw	r24, r20
    6674:	fa 01       	movw	r30, r20
    6676:	ee 0f       	add	r30, r30
    6678:	ff 1f       	adc	r31, r31
    667a:	ee 0f       	add	r30, r30
    667c:	ff 1f       	adc	r31, r31
    667e:	ee 0f       	add	r30, r30
    6680:	ff 1f       	adc	r31, r31
    6682:	88 0f       	add	r24, r24
    6684:	99 1f       	adc	r25, r25
    6686:	e8 0f       	add	r30, r24
    6688:	f9 1f       	adc	r31, r25
    668a:	ee 0f       	add	r30, r30
    668c:	ff 1f       	adc	r31, r31
    668e:	ee 0f       	add	r30, r30
    6690:	ff 1f       	adc	r31, r31
    6692:	ee 5d       	subi	r30, 0xDE	; 222
    6694:	fb 4f       	sbci	r31, 0xFB	; 251
    6696:	31 83       	std	Z+1, r19	; 0x01
    6698:	20 83       	st	Z, r18
    669a:	4f 5f       	subi	r20, 0xFF	; 255
    669c:	5f 4f       	sbci	r21, 0xFF	; 255
          OLEDsetCursor(0, 0);
          OLEDprintCC("loaded");
          break;

        case MENU_OPTICAL_ZERO_POS: /* define the optical zero position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    669e:	44 30       	cpi	r20, 0x04	; 4
    66a0:	51 05       	cpc	r21, r1
    66a2:	09 f0       	breq	.+2      	; 0x66a6 <updateMenu+0x6a2>
    66a4:	9e cf       	rjmp	.-196    	; 0x65e2 <updateMenu+0x5de>
    66a6:	d4 cc       	rjmp	.-1624   	; 0x6050 <updateMenu+0x4c>
/* ---------------------------------------------------------------------
   setting the optical zero position
 --------------------------------------------------------------------- */
void defineOpticalZeroPosition(uint8_t i, int16_t step){

  motor[i].desiredPosition = motor[i].actualPosition + step;
    66a8:	fa 01       	movw	r30, r20
    66aa:	ee 0f       	add	r30, r30
    66ac:	ff 1f       	adc	r31, r31
    66ae:	ee 0f       	add	r30, r30
    66b0:	ff 1f       	adc	r31, r31
    66b2:	ee 0f       	add	r30, r30
    66b4:	ff 1f       	adc	r31, r31
    66b6:	cf 01       	movw	r24, r30
    66b8:	88 0f       	add	r24, r24
    66ba:	99 1f       	adc	r25, r25
    66bc:	88 0f       	add	r24, r24
    66be:	99 1f       	adc	r25, r25
    66c0:	e8 0f       	add	r30, r24
    66c2:	f9 1f       	adc	r31, r25
    66c4:	e2 5e       	subi	r30, 0xE2	; 226
    66c6:	fb 4f       	sbci	r31, 0xFB	; 251
    66c8:	20 81       	ld	r18, Z
    66ca:	31 81       	ldd	r19, Z+1	; 0x01
    66cc:	26 0f       	add	r18, r22
    66ce:	37 1f       	adc	r19, r23
    66d0:	ac cf       	rjmp	.-168    	; 0x662a <updateMenu+0x626>
            }
          }
          break;
          
        case MENU_SET_FULL_ROTATION:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    66d2:	c0 e0       	ldi	r28, 0x00	; 0
    66d4:	d0 e0       	ldi	r29, 0x00	; 0
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].current += (rotEncVal)/10.0;
    66d6:	61 2e       	mov	r6, r17
    66d8:	77 24       	eor	r7, r7
    66da:	67 fc       	sbrc	r6, 7
    66dc:	70 94       	com	r7
    66de:	87 2c       	mov	r8, r7
    66e0:	97 2c       	mov	r9, r7
            }
          }
          break;
          
        case MENU_SET_FULL_ROTATION:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    66e2:	bc 2e       	mov	r11, r28
          }
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    66e4:	80 91 13 03 	lds	r24, 0x0313
    66e8:	dc 2e       	mov	r13, r28
    66ea:	cd 2e       	mov	r12, r29
    66ec:	90 e0       	ldi	r25, 0x00	; 0
    66ee:	0c 2e       	mov	r0, r28
    66f0:	02 c0       	rjmp	.+4      	; 0x66f6 <updateMenu+0x6f2>
    66f2:	95 95       	asr	r25
    66f4:	87 95       	ror	r24
    66f6:	0a 94       	dec	r0
    66f8:	e2 f7       	brpl	.-8      	; 0x66f2 <updateMenu+0x6ee>
    66fa:	80 ff       	sbrs	r24, 0
    66fc:	a3 c0       	rjmp	.+326    	; 0x6844 <updateMenu+0x840>
              motor[i].current += (rotEncVal)/10.0;
    66fe:	fe 01       	movw	r30, r28
    6700:	ee 0f       	add	r30, r30
    6702:	ff 1f       	adc	r31, r31
    6704:	ee 0f       	add	r30, r30
    6706:	ff 1f       	adc	r31, r31
    6708:	ee 0f       	add	r30, r30
    670a:	ff 1f       	adc	r31, r31
    670c:	cf 01       	movw	r24, r30
    670e:	88 0f       	add	r24, r24
    6710:	99 1f       	adc	r25, r25
    6712:	88 0f       	add	r24, r24
    6714:	99 1f       	adc	r25, r25
    6716:	e8 0f       	add	r30, r24
    6718:	f9 1f       	adc	r31, r25
    671a:	e2 5e       	subi	r30, 0xE2	; 226
    671c:	fb 4f       	sbci	r31, 0xFB	; 251
    671e:	e3 a0       	ldd	r14, Z+35	; 0x23
    6720:	f4 a0       	ldd	r15, Z+36	; 0x24
    6722:	05 a1       	ldd	r16, Z+37	; 0x25
    6724:	16 a1       	ldd	r17, Z+38	; 0x26
    6726:	c4 01       	movw	r24, r8
    6728:	b3 01       	movw	r22, r6
    672a:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    672e:	20 e0       	ldi	r18, 0x00	; 0
    6730:	30 e0       	ldi	r19, 0x00	; 0
    6732:	40 e2       	ldi	r20, 0x20	; 32
    6734:	51 e4       	ldi	r21, 0x41	; 65
    6736:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    673a:	9b 01       	movw	r18, r22
    673c:	ac 01       	movw	r20, r24
    673e:	c8 01       	movw	r24, r16
    6740:	b7 01       	movw	r22, r14
    6742:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    6746:	fe 01       	movw	r30, r28
    6748:	ee 0f       	add	r30, r30
    674a:	ff 1f       	adc	r31, r31
    674c:	ee 0f       	add	r30, r30
    674e:	ff 1f       	adc	r31, r31
    6750:	ee 0f       	add	r30, r30
    6752:	ff 1f       	adc	r31, r31
    6754:	9f 01       	movw	r18, r30
    6756:	22 0f       	add	r18, r18
    6758:	33 1f       	adc	r19, r19
    675a:	22 0f       	add	r18, r18
    675c:	33 1f       	adc	r19, r19
    675e:	e2 0f       	add	r30, r18
    6760:	f3 1f       	adc	r31, r19
    6762:	e2 5e       	subi	r30, 0xE2	; 226
    6764:	fb 4f       	sbci	r31, 0xFB	; 251
    6766:	63 a3       	std	Z+35, r22	; 0x23
    6768:	74 a3       	std	Z+36, r23	; 0x24
    676a:	85 a3       	std	Z+37, r24	; 0x25
    676c:	96 a3       	std	Z+38, r25	; 0x26
              if(motor[i].current < 0){
    676e:	fe 01       	movw	r30, r28
    6770:	ee 0f       	add	r30, r30
    6772:	ff 1f       	adc	r31, r31
    6774:	ee 0f       	add	r30, r30
    6776:	ff 1f       	adc	r31, r31
    6778:	ee 0f       	add	r30, r30
    677a:	ff 1f       	adc	r31, r31
    677c:	cf 01       	movw	r24, r30
    677e:	88 0f       	add	r24, r24
    6780:	99 1f       	adc	r25, r25
    6782:	88 0f       	add	r24, r24
    6784:	99 1f       	adc	r25, r25
    6786:	e8 0f       	add	r30, r24
    6788:	f9 1f       	adc	r31, r25
    678a:	e2 5e       	subi	r30, 0xE2	; 226
    678c:	fb 4f       	sbci	r31, 0xFB	; 251
    678e:	63 a1       	ldd	r22, Z+35	; 0x23
    6790:	74 a1       	ldd	r23, Z+36	; 0x24
    6792:	85 a1       	ldd	r24, Z+37	; 0x25
    6794:	96 a1       	ldd	r25, Z+38	; 0x26
    6796:	20 e0       	ldi	r18, 0x00	; 0
    6798:	30 e0       	ldi	r19, 0x00	; 0
    679a:	40 e0       	ldi	r20, 0x00	; 0
    679c:	50 e0       	ldi	r21, 0x00	; 0
    679e:	0e 94 8b 43 	call	0x8716	; 0x8716 <__cmpsf2>
    67a2:	88 23       	and	r24, r24
    67a4:	0c f4       	brge	.+2      	; 0x67a8 <updateMenu+0x7a4>
    67a6:	3c c4       	rjmp	.+2168   	; 0x7020 <updateMenu+0x101c>
                motor[i].current = 0;
              }
              if(motor[i].current > 2.5){
    67a8:	ed 2d       	mov	r30, r13
    67aa:	fc 2d       	mov	r31, r12
    67ac:	ee 0f       	add	r30, r30
    67ae:	ff 1f       	adc	r31, r31
    67b0:	ee 0f       	add	r30, r30
    67b2:	ff 1f       	adc	r31, r31
    67b4:	ee 0f       	add	r30, r30
    67b6:	ff 1f       	adc	r31, r31
    67b8:	cf 01       	movw	r24, r30
    67ba:	88 0f       	add	r24, r24
    67bc:	99 1f       	adc	r25, r25
    67be:	88 0f       	add	r24, r24
    67c0:	99 1f       	adc	r25, r25
    67c2:	e8 0f       	add	r30, r24
    67c4:	f9 1f       	adc	r31, r25
    67c6:	e2 5e       	subi	r30, 0xE2	; 226
    67c8:	fb 4f       	sbci	r31, 0xFB	; 251
    67ca:	63 a1       	ldd	r22, Z+35	; 0x23
    67cc:	74 a1       	ldd	r23, Z+36	; 0x24
    67ce:	85 a1       	ldd	r24, Z+37	; 0x25
    67d0:	96 a1       	ldd	r25, Z+38	; 0x26
    67d2:	20 e0       	ldi	r18, 0x00	; 0
    67d4:	30 e0       	ldi	r19, 0x00	; 0
    67d6:	40 e2       	ldi	r20, 0x20	; 32
    67d8:	50 e4       	ldi	r21, 0x40	; 64
    67da:	0e 94 2d 45 	call	0x8a5a	; 0x8a5a <__gesf2>
    67de:	18 16       	cp	r1, r24
    67e0:	cc f4       	brge	.+50     	; 0x6814 <updateMenu+0x810>
                motor[i].current = 2.5;
    67e2:	ed 2d       	mov	r30, r13
    67e4:	fc 2d       	mov	r31, r12
    67e6:	ee 0f       	add	r30, r30
    67e8:	ff 1f       	adc	r31, r31
    67ea:	ee 0f       	add	r30, r30
    67ec:	ff 1f       	adc	r31, r31
    67ee:	ee 0f       	add	r30, r30
    67f0:	ff 1f       	adc	r31, r31
    67f2:	cf 01       	movw	r24, r30
    67f4:	88 0f       	add	r24, r24
    67f6:	99 1f       	adc	r25, r25
    67f8:	88 0f       	add	r24, r24
    67fa:	99 1f       	adc	r25, r25
    67fc:	e8 0f       	add	r30, r24
    67fe:	f9 1f       	adc	r31, r25
    6800:	e2 5e       	subi	r30, 0xE2	; 226
    6802:	fb 4f       	sbci	r31, 0xFB	; 251
    6804:	80 e0       	ldi	r24, 0x00	; 0
    6806:	90 e0       	ldi	r25, 0x00	; 0
    6808:	a0 e2       	ldi	r26, 0x20	; 32
    680a:	b0 e4       	ldi	r27, 0x40	; 64
    680c:	83 a3       	std	Z+35, r24	; 0x23
    680e:	94 a3       	std	Z+36, r25	; 0x24
    6810:	a5 a3       	std	Z+37, r26	; 0x25
    6812:	b6 a3       	std	Z+38, r27	; 0x26
              }
              setMotorCurrent(i, motor[i].current);
    6814:	ed 2d       	mov	r30, r13
    6816:	fc 2d       	mov	r31, r12
    6818:	ee 0f       	add	r30, r30
    681a:	ff 1f       	adc	r31, r31
    681c:	ee 0f       	add	r30, r30
    681e:	ff 1f       	adc	r31, r31
    6820:	ee 0f       	add	r30, r30
    6822:	ff 1f       	adc	r31, r31
    6824:	cf 01       	movw	r24, r30
    6826:	88 0f       	add	r24, r24
    6828:	99 1f       	adc	r25, r25
    682a:	88 0f       	add	r24, r24
    682c:	99 1f       	adc	r25, r25
    682e:	e8 0f       	add	r30, r24
    6830:	f9 1f       	adc	r31, r25
    6832:	e2 5e       	subi	r30, 0xE2	; 226
    6834:	fb 4f       	sbci	r31, 0xFB	; 251
    6836:	43 a1       	ldd	r20, Z+35	; 0x23
    6838:	54 a1       	ldd	r21, Z+36	; 0x24
    683a:	65 a1       	ldd	r22, Z+37	; 0x25
    683c:	76 a1       	ldd	r23, Z+38	; 0x26
    683e:	8b 2d       	mov	r24, r11
    6840:	0e 94 a1 28 	call	0x5142	; 0x5142 <setMotorCurrent>
    6844:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6846:	c4 30       	cpi	r28, 0x04	; 4
    6848:	d1 05       	cpc	r29, r1
    684a:	09 f0       	breq	.+2      	; 0x684e <updateMenu+0x84a>
    684c:	4a cf       	rjmp	.-364    	; 0x66e2 <updateMenu+0x6de>
    684e:	00 cc       	rjmp	.-2048   	; 0x6050 <updateMenu+0x4c>
          }
          /* get back to the MENU_SCROLL_MODE when finished calibration*/
          menu.newMenuMode = MENU_SCROLL_MODE;
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
          break;
    6850:	c0 e0       	ldi	r28, 0x00	; 0
    6852:	d0 e0       	ldi	r29, 0x00	; 0
    6854:	ec 2e       	mov	r14, r28

        case MENU_CHANGE_SUBSTEPS:   /* change motor substeps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6856:	80 91 13 03 	lds	r24, 0x0313
    685a:	dc 2e       	mov	r13, r28
    685c:	cd 2e       	mov	r12, r29
    685e:	90 e0       	ldi	r25, 0x00	; 0
    6860:	0c 2e       	mov	r0, r28
    6862:	02 c0       	rjmp	.+4      	; 0x6868 <updateMenu+0x864>
    6864:	95 95       	asr	r25
    6866:	87 95       	ror	r24
    6868:	0a 94       	dec	r0
    686a:	e2 f7       	brpl	.-8      	; 0x6864 <updateMenu+0x860>
    686c:	80 ff       	sbrs	r24, 0
    686e:	67 c0       	rjmp	.+206    	; 0x693e <updateMenu+0x93a>
              tmp = motor[i].subSteps;
    6870:	fe 01       	movw	r30, r28
    6872:	ee 0f       	add	r30, r30
    6874:	ff 1f       	adc	r31, r31
    6876:	ee 0f       	add	r30, r30
    6878:	ff 1f       	adc	r31, r31
    687a:	ee 0f       	add	r30, r30
    687c:	ff 1f       	adc	r31, r31
    687e:	cf 01       	movw	r24, r30
    6880:	88 0f       	add	r24, r24
    6882:	99 1f       	adc	r25, r25
    6884:	88 0f       	add	r24, r24
    6886:	99 1f       	adc	r25, r25
    6888:	e8 0f       	add	r30, r24
    688a:	f9 1f       	adc	r31, r25
    688c:	e2 5e       	subi	r30, 0xE2	; 226
    688e:	fb 4f       	sbci	r31, 0xFB	; 251
    6890:	65 89       	ldd	r22, Z+21	; 0x15
    6892:	76 89       	ldd	r23, Z+22	; 0x16
    6894:	87 89       	ldd	r24, Z+23	; 0x17
    6896:	90 8d       	ldd	r25, Z+24	; 0x18
    6898:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
              if(rotEncVal > 0){
    689c:	11 16       	cp	r1, r17
    689e:	0c f0       	brlt	.+2      	; 0x68a2 <updateMenu+0x89e>
    68a0:	8a c3       	rjmp	.+1812   	; 0x6fb6 <updateMenu+0xfb2>
                //motor[i].subSteps *= 2.0;
                tmp *= 2.0;
    68a2:	70 e0       	ldi	r23, 0x00	; 0
    68a4:	88 27       	eor	r24, r24
    68a6:	77 fd       	sbrc	r23, 7
    68a8:	80 95       	com	r24
    68aa:	98 2f       	mov	r25, r24
    68ac:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    68b0:	9b 01       	movw	r18, r22
    68b2:	ac 01       	movw	r20, r24
    68b4:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    68b8:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
    68bc:	06 2f       	mov	r16, r22
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
              }
              if(motor[i].subSteps < 1){
    68be:	ed 2d       	mov	r30, r13
    68c0:	fc 2d       	mov	r31, r12
    68c2:	ee 0f       	add	r30, r30
    68c4:	ff 1f       	adc	r31, r31
    68c6:	ee 0f       	add	r30, r30
    68c8:	ff 1f       	adc	r31, r31
    68ca:	ee 0f       	add	r30, r30
    68cc:	ff 1f       	adc	r31, r31
    68ce:	cf 01       	movw	r24, r30
    68d0:	88 0f       	add	r24, r24
    68d2:	99 1f       	adc	r25, r25
    68d4:	88 0f       	add	r24, r24
    68d6:	99 1f       	adc	r25, r25
    68d8:	e8 0f       	add	r30, r24
    68da:	f9 1f       	adc	r31, r25
    68dc:	e2 5e       	subi	r30, 0xE2	; 226
    68de:	fb 4f       	sbci	r31, 0xFB	; 251
    68e0:	65 89       	ldd	r22, Z+21	; 0x15
    68e2:	76 89       	ldd	r23, Z+22	; 0x16
    68e4:	87 89       	ldd	r24, Z+23	; 0x17
    68e6:	90 8d       	ldd	r25, Z+24	; 0x18
    68e8:	20 e0       	ldi	r18, 0x00	; 0
    68ea:	30 e0       	ldi	r19, 0x00	; 0
    68ec:	40 e8       	ldi	r20, 0x80	; 128
    68ee:	5f e3       	ldi	r21, 0x3F	; 63
    68f0:	0e 94 8b 43 	call	0x8716	; 0x8716 <__cmpsf2>
    68f4:	88 23       	and	r24, r24
    68f6:	0c f4       	brge	.+2      	; 0x68fa <updateMenu+0x8f6>
    68f8:	5c c3       	rjmp	.+1720   	; 0x6fb2 <updateMenu+0xfae>
                //motor[i].subSteps = 1;
                tmp = 1;
              }
              if(motor[i].subSteps > 32){
    68fa:	ed 2d       	mov	r30, r13
    68fc:	fc 2d       	mov	r31, r12
    68fe:	ee 0f       	add	r30, r30
    6900:	ff 1f       	adc	r31, r31
    6902:	ee 0f       	add	r30, r30
    6904:	ff 1f       	adc	r31, r31
    6906:	ee 0f       	add	r30, r30
    6908:	ff 1f       	adc	r31, r31
    690a:	cf 01       	movw	r24, r30
    690c:	88 0f       	add	r24, r24
    690e:	99 1f       	adc	r25, r25
    6910:	88 0f       	add	r24, r24
    6912:	99 1f       	adc	r25, r25
    6914:	e8 0f       	add	r30, r24
    6916:	f9 1f       	adc	r31, r25
    6918:	e2 5e       	subi	r30, 0xE2	; 226
    691a:	fb 4f       	sbci	r31, 0xFB	; 251
    691c:	65 89       	ldd	r22, Z+21	; 0x15
    691e:	76 89       	ldd	r23, Z+22	; 0x16
    6920:	87 89       	ldd	r24, Z+23	; 0x17
    6922:	90 8d       	ldd	r25, Z+24	; 0x18
    6924:	20 e0       	ldi	r18, 0x00	; 0
    6926:	30 e0       	ldi	r19, 0x00	; 0
    6928:	40 e0       	ldi	r20, 0x00	; 0
    692a:	52 e4       	ldi	r21, 0x42	; 66
    692c:	0e 94 2d 45 	call	0x8a5a	; 0x8a5a <__gesf2>
    6930:	18 16       	cp	r1, r24
    6932:	0c f4       	brge	.+2      	; 0x6936 <updateMenu+0x932>
    6934:	00 e2       	ldi	r16, 0x20	; 32
                //motor[i].subSteps = 32;
                tmp = 32;
              }
              setSubSteps(i,tmp);
    6936:	8e 2d       	mov	r24, r14
    6938:	60 2f       	mov	r22, r16
    693a:	0e 94 6b 2d 	call	0x5ad6	; 0x5ad6 <setSubSteps>
    693e:	21 96       	adiw	r28, 0x01	; 1
          //menu.currentDisplayedMenu += 1;
          menu.currentDisplayedMenu = MENU_DUMMY;
          break;

        case MENU_CHANGE_SUBSTEPS:   /* change motor substeps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6940:	c4 30       	cpi	r28, 0x04	; 4
    6942:	d1 05       	cpc	r29, r1
    6944:	09 f0       	breq	.+2      	; 0x6948 <updateMenu+0x944>
    6946:	86 cf       	rjmp	.-244    	; 0x6854 <updateMenu+0x850>
    6948:	83 cb       	rjmp	.-2298   	; 0x6050 <updateMenu+0x4c>
          
        case MENU_SET_FULL_ROTATION:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                motor[i].stepsPerFullRotation += ((int16_t)rotEncVal)*100;
    694a:	84 e6       	ldi	r24, 0x64	; 100
    694c:	18 02       	muls	r17, r24
    694e:	c0 01       	movw	r24, r0
    6950:	11 24       	eor	r1, r1
    6952:	c0 e0       	ldi	r28, 0x00	; 0
    6954:	d0 e0       	ldi	r29, 0x00	; 0
              }
              else{
                motor[i].stepsPerFullRotation += (int16_t)rotEncVal;
    6956:	81 2e       	mov	r8, r17
    6958:	99 24       	eor	r9, r9
    695a:	87 fc       	sbrc	r8, 7
    695c:	90 94       	com	r9
    695e:	a9 2c       	mov	r10, r9
    6960:	b9 2c       	mov	r11, r9
          
        case MENU_SET_FULL_ROTATION:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                motor[i].stepsPerFullRotation += ((int16_t)rotEncVal)*100;
    6962:	2c 01       	movw	r4, r24
    6964:	66 24       	eor	r6, r6
    6966:	57 fc       	sbrc	r5, 7
    6968:	60 94       	com	r6
    696a:	76 2c       	mov	r7, r6
          }
          break;
          
        case MENU_SET_FULL_ROTATION:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    696c:	80 91 13 03 	lds	r24, 0x0313
    6970:	dc 2e       	mov	r13, r28
    6972:	cd 2e       	mov	r12, r29
    6974:	90 e0       	ldi	r25, 0x00	; 0
    6976:	0c 2e       	mov	r0, r28
    6978:	02 c0       	rjmp	.+4      	; 0x697e <updateMenu+0x97a>
    697a:	95 95       	asr	r25
    697c:	87 95       	ror	r24
    697e:	0a 94       	dec	r0
    6980:	e2 f7       	brpl	.-8      	; 0x697a <updateMenu+0x976>
    6982:	80 ff       	sbrs	r24, 0
    6984:	55 c0       	rjmp	.+170    	; 0x6a30 <updateMenu+0xa2c>
              if(menu.fastMovingMode){
    6986:	80 91 10 03 	lds	r24, 0x0310
    698a:	88 23       	and	r24, r24
    698c:	09 f4       	brne	.+2      	; 0x6990 <updateMenu+0x98c>
    698e:	e6 c0       	rjmp	.+460    	; 0x6b5c <updateMenu+0xb58>
                motor[i].stepsPerFullRotation += ((int16_t)rotEncVal)*100;
    6990:	fe 01       	movw	r30, r28
    6992:	ee 0f       	add	r30, r30
    6994:	ff 1f       	adc	r31, r31
    6996:	ee 0f       	add	r30, r30
    6998:	ff 1f       	adc	r31, r31
    699a:	ee 0f       	add	r30, r30
    699c:	ff 1f       	adc	r31, r31
    699e:	cf 01       	movw	r24, r30
    69a0:	88 0f       	add	r24, r24
    69a2:	99 1f       	adc	r25, r25
    69a4:	88 0f       	add	r24, r24
    69a6:	99 1f       	adc	r25, r25
    69a8:	e8 0f       	add	r30, r24
    69aa:	f9 1f       	adc	r31, r25
    69ac:	e2 5e       	subi	r30, 0xE2	; 226
    69ae:	fb 4f       	sbci	r31, 0xFB	; 251
    69b0:	e1 88       	ldd	r14, Z+17	; 0x11
    69b2:	f2 88       	ldd	r15, Z+18	; 0x12
    69b4:	03 89       	ldd	r16, Z+19	; 0x13
    69b6:	14 89       	ldd	r17, Z+20	; 0x14
    69b8:	c3 01       	movw	r24, r6
    69ba:	b2 01       	movw	r22, r4
              }
              else{
                motor[i].stepsPerFullRotation += (int16_t)rotEncVal;
    69bc:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    69c0:	9b 01       	movw	r18, r22
    69c2:	ac 01       	movw	r20, r24
    69c4:	c8 01       	movw	r24, r16
    69c6:	b7 01       	movw	r22, r14
    69c8:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    69cc:	fe 01       	movw	r30, r28
    69ce:	ee 0f       	add	r30, r30
    69d0:	ff 1f       	adc	r31, r31
    69d2:	ee 0f       	add	r30, r30
    69d4:	ff 1f       	adc	r31, r31
    69d6:	ee 0f       	add	r30, r30
    69d8:	ff 1f       	adc	r31, r31
    69da:	9f 01       	movw	r18, r30
    69dc:	22 0f       	add	r18, r18
    69de:	33 1f       	adc	r19, r19
    69e0:	22 0f       	add	r18, r18
    69e2:	33 1f       	adc	r19, r19
    69e4:	e2 0f       	add	r30, r18
    69e6:	f3 1f       	adc	r31, r19
    69e8:	e2 5e       	subi	r30, 0xE2	; 226
    69ea:	fb 4f       	sbci	r31, 0xFB	; 251
    69ec:	61 8b       	std	Z+17, r22	; 0x11
    69ee:	72 8b       	std	Z+18, r23	; 0x12
    69f0:	83 8b       	std	Z+19, r24	; 0x13
    69f2:	94 8b       	std	Z+20, r25	; 0x14
              }
              if(motor[i].stepsPerFullRotation < 1){
    69f4:	ed 2d       	mov	r30, r13
    69f6:	fc 2d       	mov	r31, r12
    69f8:	ee 0f       	add	r30, r30
    69fa:	ff 1f       	adc	r31, r31
    69fc:	ee 0f       	add	r30, r30
    69fe:	ff 1f       	adc	r31, r31
    6a00:	ee 0f       	add	r30, r30
    6a02:	ff 1f       	adc	r31, r31
    6a04:	cf 01       	movw	r24, r30
    6a06:	88 0f       	add	r24, r24
    6a08:	99 1f       	adc	r25, r25
    6a0a:	88 0f       	add	r24, r24
    6a0c:	99 1f       	adc	r25, r25
    6a0e:	e8 0f       	add	r30, r24
    6a10:	f9 1f       	adc	r31, r25
    6a12:	e2 5e       	subi	r30, 0xE2	; 226
    6a14:	fb 4f       	sbci	r31, 0xFB	; 251
    6a16:	61 89       	ldd	r22, Z+17	; 0x11
    6a18:	72 89       	ldd	r23, Z+18	; 0x12
    6a1a:	83 89       	ldd	r24, Z+19	; 0x13
    6a1c:	94 89       	ldd	r25, Z+20	; 0x14
    6a1e:	20 e0       	ldi	r18, 0x00	; 0
    6a20:	30 e0       	ldi	r19, 0x00	; 0
    6a22:	40 e8       	ldi	r20, 0x80	; 128
    6a24:	5f e3       	ldi	r21, 0x3F	; 63
    6a26:	0e 94 8b 43 	call	0x8716	; 0x8716 <__cmpsf2>
    6a2a:	88 23       	and	r24, r24
    6a2c:	0c f4       	brge	.+2      	; 0x6a30 <updateMenu+0xa2c>
    6a2e:	a7 c2       	rjmp	.+1358   	; 0x6f7e <updateMenu+0xf7a>
                motor[i].stepsPerFullRotation = 1;
    6a30:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;
          
        case MENU_SET_FULL_ROTATION:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6a32:	c4 30       	cpi	r28, 0x04	; 4
    6a34:	d1 05       	cpc	r29, r1
    6a36:	09 f0       	breq	.+2      	; 0x6a3a <updateMenu+0xa36>
    6a38:	99 cf       	rjmp	.-206    	; 0x696c <updateMenu+0x968>
    6a3a:	0a cb       	rjmp	.-2540   	; 0x6050 <updateMenu+0x4c>
      switch(state){
        case MENU_MAIN:   /* main menu point, no values here to change */
          break;

        case MENU_CHANGE_POSITION:   /* change motor position */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6a3c:	40 e0       	ldi	r20, 0x00	; 0
    6a3e:	50 e0       	ldi	r21, 0x00	; 0
        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepUnit += rotEncVal;
              if(motor[i].stepUnit < 0){
                motor[i].stepUnit = 2;
    6a40:	72 e0       	ldi	r23, 0x02	; 2
          }
          break;

        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6a42:	80 91 13 03 	lds	r24, 0x0313
    6a46:	34 2f       	mov	r19, r20
    6a48:	65 2f       	mov	r22, r21
    6a4a:	90 e0       	ldi	r25, 0x00	; 0
    6a4c:	04 2e       	mov	r0, r20
    6a4e:	02 c0       	rjmp	.+4      	; 0x6a54 <updateMenu+0xa50>
    6a50:	95 95       	asr	r25
    6a52:	87 95       	ror	r24
    6a54:	0a 94       	dec	r0
    6a56:	e2 f7       	brpl	.-8      	; 0x6a50 <updateMenu+0xa4c>
    6a58:	80 ff       	sbrs	r24, 0
    6a5a:	5c c0       	rjmp	.+184    	; 0x6b14 <updateMenu+0xb10>
              motor[i].stepUnit += rotEncVal;
    6a5c:	fa 01       	movw	r30, r20
    6a5e:	ee 0f       	add	r30, r30
    6a60:	ff 1f       	adc	r31, r31
    6a62:	ee 0f       	add	r30, r30
    6a64:	ff 1f       	adc	r31, r31
    6a66:	ee 0f       	add	r30, r30
    6a68:	ff 1f       	adc	r31, r31
    6a6a:	cf 01       	movw	r24, r30
    6a6c:	88 0f       	add	r24, r24
    6a6e:	99 1f       	adc	r25, r25
    6a70:	88 0f       	add	r24, r24
    6a72:	99 1f       	adc	r25, r25
    6a74:	e8 0f       	add	r30, r24
    6a76:	f9 1f       	adc	r31, r25
    6a78:	e2 5e       	subi	r30, 0xE2	; 226
    6a7a:	fb 4f       	sbci	r31, 0xFB	; 251
    6a7c:	21 8d       	ldd	r18, Z+25	; 0x19
    6a7e:	21 0f       	add	r18, r17
    6a80:	fa 01       	movw	r30, r20
    6a82:	ee 0f       	add	r30, r30
    6a84:	ff 1f       	adc	r31, r31
    6a86:	ee 0f       	add	r30, r30
    6a88:	ff 1f       	adc	r31, r31
    6a8a:	ee 0f       	add	r30, r30
    6a8c:	ff 1f       	adc	r31, r31
    6a8e:	cf 01       	movw	r24, r30
    6a90:	88 0f       	add	r24, r24
    6a92:	99 1f       	adc	r25, r25
    6a94:	88 0f       	add	r24, r24
    6a96:	99 1f       	adc	r25, r25
    6a98:	e8 0f       	add	r30, r24
    6a9a:	f9 1f       	adc	r31, r25
    6a9c:	e2 5e       	subi	r30, 0xE2	; 226
    6a9e:	fb 4f       	sbci	r31, 0xFB	; 251
    6aa0:	21 8f       	std	Z+25, r18	; 0x19
              if(motor[i].stepUnit < 0){
    6aa2:	fa 01       	movw	r30, r20
    6aa4:	ee 0f       	add	r30, r30
    6aa6:	ff 1f       	adc	r31, r31
    6aa8:	ee 0f       	add	r30, r30
    6aaa:	ff 1f       	adc	r31, r31
    6aac:	ee 0f       	add	r30, r30
    6aae:	ff 1f       	adc	r31, r31
    6ab0:	cf 01       	movw	r24, r30
    6ab2:	88 0f       	add	r24, r24
    6ab4:	99 1f       	adc	r25, r25
    6ab6:	88 0f       	add	r24, r24
    6ab8:	99 1f       	adc	r25, r25
    6aba:	e8 0f       	add	r30, r24
    6abc:	f9 1f       	adc	r31, r25
    6abe:	e2 5e       	subi	r30, 0xE2	; 226
    6ac0:	fb 4f       	sbci	r31, 0xFB	; 251
    6ac2:	81 8d       	ldd	r24, Z+25	; 0x19
    6ac4:	87 fd       	sbrc	r24, 7
    6ac6:	9a c2       	rjmp	.+1332   	; 0x6ffc <updateMenu+0xff8>
                motor[i].stepUnit = 2;
              }
              if(motor[i].stepUnit > 2){
    6ac8:	e3 2f       	mov	r30, r19
    6aca:	f6 2f       	mov	r31, r22
    6acc:	ee 0f       	add	r30, r30
    6ace:	ff 1f       	adc	r31, r31
    6ad0:	ee 0f       	add	r30, r30
    6ad2:	ff 1f       	adc	r31, r31
    6ad4:	ee 0f       	add	r30, r30
    6ad6:	ff 1f       	adc	r31, r31
    6ad8:	cf 01       	movw	r24, r30
    6ada:	88 0f       	add	r24, r24
    6adc:	99 1f       	adc	r25, r25
    6ade:	88 0f       	add	r24, r24
    6ae0:	99 1f       	adc	r25, r25
    6ae2:	e8 0f       	add	r30, r24
    6ae4:	f9 1f       	adc	r31, r25
    6ae6:	e2 5e       	subi	r30, 0xE2	; 226
    6ae8:	fb 4f       	sbci	r31, 0xFB	; 251
    6aea:	81 8d       	ldd	r24, Z+25	; 0x19
    6aec:	83 30       	cpi	r24, 0x03	; 3
    6aee:	94 f0       	brlt	.+36     	; 0x6b14 <updateMenu+0xb10>
                motor[i].stepUnit = 0;
    6af0:	e3 2f       	mov	r30, r19
    6af2:	f6 2f       	mov	r31, r22
    6af4:	ee 0f       	add	r30, r30
    6af6:	ff 1f       	adc	r31, r31
    6af8:	ee 0f       	add	r30, r30
    6afa:	ff 1f       	adc	r31, r31
    6afc:	ee 0f       	add	r30, r30
    6afe:	ff 1f       	adc	r31, r31
    6b00:	cf 01       	movw	r24, r30
    6b02:	88 0f       	add	r24, r24
    6b04:	99 1f       	adc	r25, r25
    6b06:	88 0f       	add	r24, r24
    6b08:	99 1f       	adc	r25, r25
    6b0a:	e8 0f       	add	r30, r24
    6b0c:	f9 1f       	adc	r31, r25
    6b0e:	e2 5e       	subi	r30, 0xE2	; 226
    6b10:	fb 4f       	sbci	r31, 0xFB	; 251
    6b12:	11 8e       	std	Z+25, r1	; 0x19
    6b14:	4f 5f       	subi	r20, 0xFF	; 255
    6b16:	5f 4f       	sbci	r21, 0xFF	; 255
            }
          }
          break;

        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6b18:	44 30       	cpi	r20, 0x04	; 4
    6b1a:	51 05       	cpc	r21, r1
    6b1c:	09 f0       	breq	.+2      	; 0x6b20 <updateMenu+0xb1c>
    6b1e:	91 cf       	rjmp	.-222    	; 0x6a42 <updateMenu+0xa3e>
    6b20:	97 ca       	rjmp	.-2770   	; 0x6050 <updateMenu+0x4c>
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                motor[i].gearRatio += (rotEncVal)/10.0;
              }
              else{
                motor[i].gearRatio += (rotEncVal)/1000.0;
    6b22:	fe 01       	movw	r30, r28
    6b24:	ee 0f       	add	r30, r30
    6b26:	ff 1f       	adc	r31, r31
    6b28:	ee 0f       	add	r30, r30
    6b2a:	ff 1f       	adc	r31, r31
    6b2c:	ee 0f       	add	r30, r30
    6b2e:	ff 1f       	adc	r31, r31
    6b30:	cf 01       	movw	r24, r30
    6b32:	88 0f       	add	r24, r24
    6b34:	99 1f       	adc	r25, r25
    6b36:	88 0f       	add	r24, r24
    6b38:	99 1f       	adc	r25, r25
    6b3a:	e8 0f       	add	r30, r24
    6b3c:	f9 1f       	adc	r31, r25
    6b3e:	e2 5e       	subi	r30, 0xE2	; 226
    6b40:	fb 4f       	sbci	r31, 0xFB	; 251
    6b42:	e5 84       	ldd	r14, Z+13	; 0x0d
    6b44:	f6 84       	ldd	r15, Z+14	; 0x0e
    6b46:	07 85       	ldd	r16, Z+15	; 0x0f
    6b48:	10 89       	ldd	r17, Z+16	; 0x10
    6b4a:	c5 01       	movw	r24, r10
    6b4c:	b4 01       	movw	r22, r8
    6b4e:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    6b52:	20 e0       	ldi	r18, 0x00	; 0
    6b54:	30 e0       	ldi	r19, 0x00	; 0
    6b56:	4a e7       	ldi	r20, 0x7A	; 122
    6b58:	54 e4       	ldi	r21, 0x44	; 68
    6b5a:	39 cc       	rjmp	.-1934   	; 0x63ce <updateMenu+0x3ca>
            if(menu.selectedMotor & (1 << i)){
              if(menu.fastMovingMode){
                motor[i].stepsPerFullRotation += ((int16_t)rotEncVal)*100;
              }
              else{
                motor[i].stepsPerFullRotation += (int16_t)rotEncVal;
    6b5c:	fe 01       	movw	r30, r28
    6b5e:	ee 0f       	add	r30, r30
    6b60:	ff 1f       	adc	r31, r31
    6b62:	ee 0f       	add	r30, r30
    6b64:	ff 1f       	adc	r31, r31
    6b66:	ee 0f       	add	r30, r30
    6b68:	ff 1f       	adc	r31, r31
    6b6a:	cf 01       	movw	r24, r30
    6b6c:	88 0f       	add	r24, r24
    6b6e:	99 1f       	adc	r25, r25
    6b70:	88 0f       	add	r24, r24
    6b72:	99 1f       	adc	r25, r25
    6b74:	e8 0f       	add	r30, r24
    6b76:	f9 1f       	adc	r31, r25
    6b78:	e2 5e       	subi	r30, 0xE2	; 226
    6b7a:	fb 4f       	sbci	r31, 0xFB	; 251
    6b7c:	e1 88       	ldd	r14, Z+17	; 0x11
    6b7e:	f2 88       	ldd	r15, Z+18	; 0x12
    6b80:	03 89       	ldd	r16, Z+19	; 0x13
    6b82:	14 89       	ldd	r17, Z+20	; 0x14
    6b84:	c5 01       	movw	r24, r10
    6b86:	b4 01       	movw	r22, r8
    6b88:	19 cf       	rjmp	.-462    	; 0x69bc <updateMenu+0x9b8>
            }
          }
          break;

        case MENU_RUN_PROGRAM:  /* run an internal program defined by CLI */
          if(rotEncVal > 0){
    6b8a:	11 16       	cp	r1, r17
    6b8c:	0c f0       	brlt	.+2      	; 0x6b90 <updateMenu+0xb8c>
    6b8e:	0e c3       	rjmp	.+1564   	; 0x71ac <updateMenu+0x11a8>
            do{
              /* find the next active program step */
              menu.currentProgramStep += 1;
    6b90:	80 91 11 03 	lds	r24, 0x0311
    6b94:	8f 5f       	subi	r24, 0xFF	; 255
    6b96:	80 93 11 03 	sts	0x0311, r24
              if(menu.currentProgramStep >= MAX_PROGRAM_STEPS){
    6b9a:	80 91 11 03 	lds	r24, 0x0311
    6b9e:	80 31       	cpi	r24, 0x10	; 16
    6ba0:	14 f0       	brlt	.+4      	; 0x6ba6 <updateMenu+0xba2>
                menu.currentProgramStep = 0;
    6ba2:	10 92 11 03 	sts	0x0311, r1
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
    6ba6:	80 91 11 03 	lds	r24, 0x0311
    6baa:	99 27       	eor	r25, r25
    6bac:	87 fd       	sbrc	r24, 7
    6bae:	90 95       	com	r25
    6bb0:	fc 01       	movw	r30, r24
    6bb2:	ee 0f       	add	r30, r30
    6bb4:	ff 1f       	adc	r31, r31
    6bb6:	ee 0f       	add	r30, r30
    6bb8:	ff 1f       	adc	r31, r31
    6bba:	ee 0f       	add	r30, r30
    6bbc:	ff 1f       	adc	r31, r31
    6bbe:	88 0f       	add	r24, r24
    6bc0:	99 1f       	adc	r25, r25
    6bc2:	e8 0f       	add	r30, r24
    6bc4:	f9 1f       	adc	r31, r25
    6bc6:	ef 5d       	subi	r30, 0xDF	; 223
    6bc8:	fc 4f       	sbci	r31, 0xFC	; 252
    6bca:	80 81       	ld	r24, Z
    6bcc:	88 23       	and	r24, r24
    6bce:	01 f3       	breq	.-64     	; 0x6b90 <updateMenu+0xb8c>
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
          }

          if(programList[menu.currentProgramStep].absRel == PROG_ABSOLUTE_MOVEMENT){
    6bd0:	80 91 11 03 	lds	r24, 0x0311
    6bd4:	99 27       	eor	r25, r25
    6bd6:	87 fd       	sbrc	r24, 7
    6bd8:	90 95       	com	r25
    6bda:	fc 01       	movw	r30, r24
    6bdc:	ee 0f       	add	r30, r30
    6bde:	ff 1f       	adc	r31, r31
    6be0:	ee 0f       	add	r30, r30
    6be2:	ff 1f       	adc	r31, r31
    6be4:	ee 0f       	add	r30, r30
    6be6:	ff 1f       	adc	r31, r31
    6be8:	88 0f       	add	r24, r24
    6bea:	99 1f       	adc	r25, r25
    6bec:	e8 0f       	add	r30, r24
    6bee:	f9 1f       	adc	r31, r25
    6bf0:	ef 5d       	subi	r30, 0xDF	; 223
    6bf2:	fc 4f       	sbci	r31, 0xFC	; 252
    6bf4:	81 85       	ldd	r24, Z+9	; 0x09
    6bf6:	88 23       	and	r24, r24
    6bf8:	09 f0       	breq	.+2      	; 0x6bfc <updateMenu+0xbf8>
    6bfa:	7e c2       	rjmp	.+1276   	; 0x70f8 <updateMenu+0x10f4>
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
    6bfc:	80 91 11 03 	lds	r24, 0x0311
    6c00:	99 27       	eor	r25, r25
    6c02:	87 fd       	sbrc	r24, 7
    6c04:	90 95       	com	r25
    6c06:	fc 01       	movw	r30, r24
    6c08:	ee 0f       	add	r30, r30
    6c0a:	ff 1f       	adc	r31, r31
    6c0c:	ee 0f       	add	r30, r30
    6c0e:	ff 1f       	adc	r31, r31
    6c10:	ee 0f       	add	r30, r30
    6c12:	ff 1f       	adc	r31, r31
    6c14:	88 0f       	add	r24, r24
    6c16:	99 1f       	adc	r25, r25
    6c18:	e8 0f       	add	r30, r24
    6c1a:	f9 1f       	adc	r31, r25
    6c1c:	ef 5d       	subi	r30, 0xDF	; 223
    6c1e:	fc 4f       	sbci	r31, 0xFC	; 252
    6c20:	81 81       	ldd	r24, Z+1	; 0x01
    6c22:	92 81       	ldd	r25, Z+2	; 0x02
    6c24:	90 93 21 04 	sts	0x0421, r25
    6c28:	80 93 20 04 	sts	0x0420, r24
    6c2c:	80 91 11 03 	lds	r24, 0x0311
    6c30:	99 27       	eor	r25, r25
    6c32:	87 fd       	sbrc	r24, 7
    6c34:	90 95       	com	r25
    6c36:	fc 01       	movw	r30, r24
    6c38:	ee 0f       	add	r30, r30
    6c3a:	ff 1f       	adc	r31, r31
    6c3c:	ee 0f       	add	r30, r30
    6c3e:	ff 1f       	adc	r31, r31
    6c40:	ee 0f       	add	r30, r30
    6c42:	ff 1f       	adc	r31, r31
    6c44:	88 0f       	add	r24, r24
    6c46:	99 1f       	adc	r25, r25
    6c48:	e8 0f       	add	r30, r24
    6c4a:	f9 1f       	adc	r31, r25
    6c4c:	ef 5d       	subi	r30, 0xDF	; 223
    6c4e:	fc 4f       	sbci	r31, 0xFC	; 252
    6c50:	83 81       	ldd	r24, Z+3	; 0x03
    6c52:	94 81       	ldd	r25, Z+4	; 0x04
    6c54:	90 93 49 04 	sts	0x0449, r25
    6c58:	80 93 48 04 	sts	0x0448, r24
    6c5c:	80 91 11 03 	lds	r24, 0x0311
    6c60:	99 27       	eor	r25, r25
    6c62:	87 fd       	sbrc	r24, 7
    6c64:	90 95       	com	r25
    6c66:	fc 01       	movw	r30, r24
    6c68:	ee 0f       	add	r30, r30
    6c6a:	ff 1f       	adc	r31, r31
    6c6c:	ee 0f       	add	r30, r30
    6c6e:	ff 1f       	adc	r31, r31
    6c70:	ee 0f       	add	r30, r30
    6c72:	ff 1f       	adc	r31, r31
    6c74:	88 0f       	add	r24, r24
    6c76:	99 1f       	adc	r25, r25
    6c78:	e8 0f       	add	r30, r24
    6c7a:	f9 1f       	adc	r31, r25
    6c7c:	ef 5d       	subi	r30, 0xDF	; 223
    6c7e:	fc 4f       	sbci	r31, 0xFC	; 252
    6c80:	85 81       	ldd	r24, Z+5	; 0x05
    6c82:	96 81       	ldd	r25, Z+6	; 0x06
    6c84:	90 93 71 04 	sts	0x0471, r25
    6c88:	80 93 70 04 	sts	0x0470, r24
    6c8c:	80 91 11 03 	lds	r24, 0x0311
    6c90:	99 27       	eor	r25, r25
    6c92:	87 fd       	sbrc	r24, 7
    6c94:	90 95       	com	r25
    6c96:	fc 01       	movw	r30, r24
    6c98:	ee 0f       	add	r30, r30
    6c9a:	ff 1f       	adc	r31, r31
    6c9c:	ee 0f       	add	r30, r30
    6c9e:	ff 1f       	adc	r31, r31
    6ca0:	ee 0f       	add	r30, r30
    6ca2:	ff 1f       	adc	r31, r31
    6ca4:	88 0f       	add	r24, r24
    6ca6:	99 1f       	adc	r25, r25
    6ca8:	e8 0f       	add	r30, r24
    6caa:	f9 1f       	adc	r31, r25
    6cac:	ef 5d       	subi	r30, 0xDF	; 223
    6cae:	fc 4f       	sbci	r31, 0xFC	; 252
    6cb0:	87 81       	ldd	r24, Z+7	; 0x07
    6cb2:	90 85       	ldd	r25, Z+8	; 0x08
    6cb4:	90 93 99 04 	sts	0x0499, r25
    6cb8:	80 93 98 04 	sts	0x0498, r24
    6cbc:	c9 c9       	rjmp	.-3182   	; 0x6050 <updateMenu+0x4c>
            }
          }
          break;

        case MENU_SAVE_CONFIG:   /* save current configuration */
          saveConfigToEEPROM();
    6cbe:	0e 94 bb 0b 	call	0x1776	; 0x1776 <saveConfigToEEPROM>
          //lcd_clear();
          //lcd_string("saved");
          OLEDclear();
    6cc2:	0e 94 f4 3d 	call	0x7be8	; 0x7be8 <OLEDclear>
          OLEDsetCursor(0, 0);
    6cc6:	80 e0       	ldi	r24, 0x00	; 0
    6cc8:	60 e0       	ldi	r22, 0x00	; 0
    6cca:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
          OLEDprintCC("saved");
    6cce:	8b ee       	ldi	r24, 0xEB	; 235
    6cd0:	92 e0       	ldi	r25, 0x02	; 2
    6cd2:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <OLEDprintCC>
    6cd6:	bc c9       	rjmp	.-3208   	; 0x6050 <updateMenu+0x4c>
            }
          }
          break;
		  
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6cd8:	40 e0       	ldi	r20, 0x00	; 0
    6cda:	50 e0       	ldi	r21, 0x00	; 0
        case MENU_SET_DECAY_MODE:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].decay += rotEncVal;
              if(motor[i].decay < 0){
                motor[i].decay = 2;
    6cdc:	72 e0       	ldi	r23, 0x02	; 2
          }
          break;
          
        case MENU_SET_DECAY_MODE:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6cde:	80 91 13 03 	lds	r24, 0x0313
    6ce2:	34 2f       	mov	r19, r20
    6ce4:	65 2f       	mov	r22, r21
    6ce6:	90 e0       	ldi	r25, 0x00	; 0
    6ce8:	04 2e       	mov	r0, r20
    6cea:	02 c0       	rjmp	.+4      	; 0x6cf0 <updateMenu+0xcec>
    6cec:	95 95       	asr	r25
    6cee:	87 95       	ror	r24
    6cf0:	0a 94       	dec	r0
    6cf2:	e2 f7       	brpl	.-8      	; 0x6cec <updateMenu+0xce8>
    6cf4:	80 ff       	sbrs	r24, 0
    6cf6:	5c c0       	rjmp	.+184    	; 0x6db0 <updateMenu+0xdac>
              motor[i].decay += rotEncVal;
    6cf8:	fa 01       	movw	r30, r20
    6cfa:	ee 0f       	add	r30, r30
    6cfc:	ff 1f       	adc	r31, r31
    6cfe:	ee 0f       	add	r30, r30
    6d00:	ff 1f       	adc	r31, r31
    6d02:	ee 0f       	add	r30, r30
    6d04:	ff 1f       	adc	r31, r31
    6d06:	cf 01       	movw	r24, r30
    6d08:	88 0f       	add	r24, r24
    6d0a:	99 1f       	adc	r25, r25
    6d0c:	88 0f       	add	r24, r24
    6d0e:	99 1f       	adc	r25, r25
    6d10:	e8 0f       	add	r30, r24
    6d12:	f9 1f       	adc	r31, r25
    6d14:	e2 5e       	subi	r30, 0xE2	; 226
    6d16:	fb 4f       	sbci	r31, 0xFB	; 251
    6d18:	27 a1       	ldd	r18, Z+39	; 0x27
    6d1a:	21 0f       	add	r18, r17
    6d1c:	fa 01       	movw	r30, r20
    6d1e:	ee 0f       	add	r30, r30
    6d20:	ff 1f       	adc	r31, r31
    6d22:	ee 0f       	add	r30, r30
    6d24:	ff 1f       	adc	r31, r31
    6d26:	ee 0f       	add	r30, r30
    6d28:	ff 1f       	adc	r31, r31
    6d2a:	cf 01       	movw	r24, r30
    6d2c:	88 0f       	add	r24, r24
    6d2e:	99 1f       	adc	r25, r25
    6d30:	88 0f       	add	r24, r24
    6d32:	99 1f       	adc	r25, r25
    6d34:	e8 0f       	add	r30, r24
    6d36:	f9 1f       	adc	r31, r25
    6d38:	e2 5e       	subi	r30, 0xE2	; 226
    6d3a:	fb 4f       	sbci	r31, 0xFB	; 251
    6d3c:	27 a3       	std	Z+39, r18	; 0x27
              if(motor[i].decay < 0){
    6d3e:	fa 01       	movw	r30, r20
    6d40:	ee 0f       	add	r30, r30
    6d42:	ff 1f       	adc	r31, r31
    6d44:	ee 0f       	add	r30, r30
    6d46:	ff 1f       	adc	r31, r31
    6d48:	ee 0f       	add	r30, r30
    6d4a:	ff 1f       	adc	r31, r31
    6d4c:	cf 01       	movw	r24, r30
    6d4e:	88 0f       	add	r24, r24
    6d50:	99 1f       	adc	r25, r25
    6d52:	88 0f       	add	r24, r24
    6d54:	99 1f       	adc	r25, r25
    6d56:	e8 0f       	add	r30, r24
    6d58:	f9 1f       	adc	r31, r25
    6d5a:	e2 5e       	subi	r30, 0xE2	; 226
    6d5c:	fb 4f       	sbci	r31, 0xFB	; 251
    6d5e:	87 a1       	ldd	r24, Z+39	; 0x27
    6d60:	87 fd       	sbrc	r24, 7
    6d62:	3a c1       	rjmp	.+628    	; 0x6fd8 <updateMenu+0xfd4>
                motor[i].decay = 2;
              }
              if(motor[i].decay > 2){
    6d64:	e3 2f       	mov	r30, r19
    6d66:	f6 2f       	mov	r31, r22
    6d68:	ee 0f       	add	r30, r30
    6d6a:	ff 1f       	adc	r31, r31
    6d6c:	ee 0f       	add	r30, r30
    6d6e:	ff 1f       	adc	r31, r31
    6d70:	ee 0f       	add	r30, r30
    6d72:	ff 1f       	adc	r31, r31
    6d74:	cf 01       	movw	r24, r30
    6d76:	88 0f       	add	r24, r24
    6d78:	99 1f       	adc	r25, r25
    6d7a:	88 0f       	add	r24, r24
    6d7c:	99 1f       	adc	r25, r25
    6d7e:	e8 0f       	add	r30, r24
    6d80:	f9 1f       	adc	r31, r25
    6d82:	e2 5e       	subi	r30, 0xE2	; 226
    6d84:	fb 4f       	sbci	r31, 0xFB	; 251
    6d86:	87 a1       	ldd	r24, Z+39	; 0x27
    6d88:	83 30       	cpi	r24, 0x03	; 3
    6d8a:	94 f0       	brlt	.+36     	; 0x6db0 <updateMenu+0xdac>
                motor[i].decay = 0;
    6d8c:	e3 2f       	mov	r30, r19
    6d8e:	f6 2f       	mov	r31, r22
    6d90:	ee 0f       	add	r30, r30
    6d92:	ff 1f       	adc	r31, r31
    6d94:	ee 0f       	add	r30, r30
    6d96:	ff 1f       	adc	r31, r31
    6d98:	ee 0f       	add	r30, r30
    6d9a:	ff 1f       	adc	r31, r31
    6d9c:	cf 01       	movw	r24, r30
    6d9e:	88 0f       	add	r24, r24
    6da0:	99 1f       	adc	r25, r25
    6da2:	88 0f       	add	r24, r24
    6da4:	99 1f       	adc	r25, r25
    6da6:	e8 0f       	add	r30, r24
    6da8:	f9 1f       	adc	r31, r25
    6daa:	e2 5e       	subi	r30, 0xE2	; 226
    6dac:	fb 4f       	sbci	r31, 0xFB	; 251
    6dae:	17 a2       	std	Z+39, r1	; 0x27
    6db0:	4f 5f       	subi	r20, 0xFF	; 255
    6db2:	5f 4f       	sbci	r21, 0xFF	; 255
            }
          }
          break;
          
        case MENU_SET_DECAY_MODE:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6db4:	44 30       	cpi	r20, 0x04	; 4
    6db6:	51 05       	cpc	r21, r1
    6db8:	09 f0       	breq	.+2      	; 0x6dbc <updateMenu+0xdb8>
    6dba:	91 cf       	rjmp	.-222    	; 0x6cde <updateMenu+0xcda>
    6dbc:	49 c9       	rjmp	.-3438   	; 0x6050 <updateMenu+0x4c>
            }
          }
          break;

        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6dbe:	40 e0       	ldi	r20, 0x00	; 0
    6dc0:	50 e0       	ldi	r21, 0x00	; 0
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].waitBetweenSteps += rotEncVal;
    6dc2:	61 2f       	mov	r22, r17
    6dc4:	77 27       	eor	r23, r23
    6dc6:	67 fd       	sbrc	r22, 7
    6dc8:	70 95       	com	r23
              if(motor[i].waitBetweenSteps < 1){
                /* wait time is at least 1 ms */
                motor[i].waitBetweenSteps = 1;
    6dca:	c1 e0       	ldi	r28, 0x01	; 1
    6dcc:	d0 e0       	ldi	r29, 0x00	; 0
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6dce:	80 91 13 03 	lds	r24, 0x0313
    6dd2:	da 01       	movw	r26, r20
    6dd4:	90 e0       	ldi	r25, 0x00	; 0
    6dd6:	04 2e       	mov	r0, r20
    6dd8:	02 c0       	rjmp	.+4      	; 0x6dde <updateMenu+0xdda>
    6dda:	95 95       	asr	r25
    6ddc:	87 95       	ror	r24
    6dde:	0a 94       	dec	r0
    6de0:	e2 f7       	brpl	.-8      	; 0x6dda <updateMenu+0xdd6>
    6de2:	80 ff       	sbrs	r24, 0
    6de4:	74 c0       	rjmp	.+232    	; 0x6ece <updateMenu+0xeca>
              motor[i].waitBetweenSteps += rotEncVal;
    6de6:	fa 01       	movw	r30, r20
    6de8:	ee 0f       	add	r30, r30
    6dea:	ff 1f       	adc	r31, r31
    6dec:	ee 0f       	add	r30, r30
    6dee:	ff 1f       	adc	r31, r31
    6df0:	ee 0f       	add	r30, r30
    6df2:	ff 1f       	adc	r31, r31
    6df4:	cf 01       	movw	r24, r30
    6df6:	88 0f       	add	r24, r24
    6df8:	99 1f       	adc	r25, r25
    6dfa:	88 0f       	add	r24, r24
    6dfc:	99 1f       	adc	r25, r25
    6dfe:	e8 0f       	add	r30, r24
    6e00:	f9 1f       	adc	r31, r25
    6e02:	e2 5e       	subi	r30, 0xE2	; 226
    6e04:	fb 4f       	sbci	r31, 0xFB	; 251
    6e06:	26 8d       	ldd	r18, Z+30	; 0x1e
    6e08:	37 8d       	ldd	r19, Z+31	; 0x1f
    6e0a:	26 0f       	add	r18, r22
    6e0c:	37 1f       	adc	r19, r23
    6e0e:	fa 01       	movw	r30, r20
    6e10:	ee 0f       	add	r30, r30
    6e12:	ff 1f       	adc	r31, r31
    6e14:	ee 0f       	add	r30, r30
    6e16:	ff 1f       	adc	r31, r31
    6e18:	ee 0f       	add	r30, r30
    6e1a:	ff 1f       	adc	r31, r31
    6e1c:	cf 01       	movw	r24, r30
    6e1e:	88 0f       	add	r24, r24
    6e20:	99 1f       	adc	r25, r25
    6e22:	88 0f       	add	r24, r24
    6e24:	99 1f       	adc	r25, r25
    6e26:	e8 0f       	add	r30, r24
    6e28:	f9 1f       	adc	r31, r25
    6e2a:	e2 5e       	subi	r30, 0xE2	; 226
    6e2c:	fb 4f       	sbci	r31, 0xFB	; 251
    6e2e:	37 8f       	std	Z+31, r19	; 0x1f
    6e30:	26 8f       	std	Z+30, r18	; 0x1e
              if(motor[i].waitBetweenSteps < 1){
    6e32:	fa 01       	movw	r30, r20
    6e34:	ee 0f       	add	r30, r30
    6e36:	ff 1f       	adc	r31, r31
    6e38:	ee 0f       	add	r30, r30
    6e3a:	ff 1f       	adc	r31, r31
    6e3c:	ee 0f       	add	r30, r30
    6e3e:	ff 1f       	adc	r31, r31
    6e40:	cf 01       	movw	r24, r30
    6e42:	88 0f       	add	r24, r24
    6e44:	99 1f       	adc	r25, r25
    6e46:	88 0f       	add	r24, r24
    6e48:	99 1f       	adc	r25, r25
    6e4a:	e8 0f       	add	r30, r24
    6e4c:	f9 1f       	adc	r31, r25
    6e4e:	e2 5e       	subi	r30, 0xE2	; 226
    6e50:	fb 4f       	sbci	r31, 0xFB	; 251
    6e52:	86 8d       	ldd	r24, Z+30	; 0x1e
    6e54:	97 8d       	ldd	r25, Z+31	; 0x1f
    6e56:	89 2b       	or	r24, r25
    6e58:	91 f4       	brne	.+36     	; 0x6e7e <updateMenu+0xe7a>
                /* wait time is at least 1 ms */
                motor[i].waitBetweenSteps = 1;
    6e5a:	fa 01       	movw	r30, r20
    6e5c:	ee 0f       	add	r30, r30
    6e5e:	ff 1f       	adc	r31, r31
    6e60:	ee 0f       	add	r30, r30
    6e62:	ff 1f       	adc	r31, r31
    6e64:	ee 0f       	add	r30, r30
    6e66:	ff 1f       	adc	r31, r31
    6e68:	cf 01       	movw	r24, r30
    6e6a:	88 0f       	add	r24, r24
    6e6c:	99 1f       	adc	r25, r25
    6e6e:	88 0f       	add	r24, r24
    6e70:	99 1f       	adc	r25, r25
    6e72:	e8 0f       	add	r30, r24
    6e74:	f9 1f       	adc	r31, r25
    6e76:	e2 5e       	subi	r30, 0xE2	; 226
    6e78:	fb 4f       	sbci	r31, 0xFB	; 251
    6e7a:	d7 8f       	std	Z+31, r29	; 0x1f
    6e7c:	c6 8f       	std	Z+30, r28	; 0x1e
              }
              motor[i].delayCounter = 2*motor[i].waitBetweenSteps-1;
    6e7e:	fd 01       	movw	r30, r26
    6e80:	ee 0f       	add	r30, r30
    6e82:	ff 1f       	adc	r31, r31
    6e84:	ee 0f       	add	r30, r30
    6e86:	ff 1f       	adc	r31, r31
    6e88:	ee 0f       	add	r30, r30
    6e8a:	ff 1f       	adc	r31, r31
    6e8c:	cf 01       	movw	r24, r30
    6e8e:	88 0f       	add	r24, r24
    6e90:	99 1f       	adc	r25, r25
    6e92:	88 0f       	add	r24, r24
    6e94:	99 1f       	adc	r25, r25
    6e96:	e8 0f       	add	r30, r24
    6e98:	f9 1f       	adc	r31, r25
    6e9a:	e2 5e       	subi	r30, 0xE2	; 226
    6e9c:	fb 4f       	sbci	r31, 0xFB	; 251
    6e9e:	26 8d       	ldd	r18, Z+30	; 0x1e
    6ea0:	37 8d       	ldd	r19, Z+31	; 0x1f
    6ea2:	22 0f       	add	r18, r18
    6ea4:	33 1f       	adc	r19, r19
    6ea6:	21 50       	subi	r18, 0x01	; 1
    6ea8:	30 40       	sbci	r19, 0x00	; 0
    6eaa:	fd 01       	movw	r30, r26
    6eac:	ee 0f       	add	r30, r30
    6eae:	ff 1f       	adc	r31, r31
    6eb0:	ee 0f       	add	r30, r30
    6eb2:	ff 1f       	adc	r31, r31
    6eb4:	ee 0f       	add	r30, r30
    6eb6:	ff 1f       	adc	r31, r31
    6eb8:	cf 01       	movw	r24, r30
    6eba:	88 0f       	add	r24, r24
    6ebc:	99 1f       	adc	r25, r25
    6ebe:	88 0f       	add	r24, r24
    6ec0:	99 1f       	adc	r25, r25
    6ec2:	e8 0f       	add	r30, r24
    6ec4:	f9 1f       	adc	r31, r25
    6ec6:	e2 5e       	subi	r30, 0xE2	; 226
    6ec8:	fb 4f       	sbci	r31, 0xFB	; 251
    6eca:	31 a3       	std	Z+33, r19	; 0x21
    6ecc:	20 a3       	std	Z+32, r18	; 0x20
    6ece:	4f 5f       	subi	r20, 0xFF	; 255
    6ed0:	5f 4f       	sbci	r21, 0xFF	; 255
            }
          }
          break;

        case MENU_CHANGE_WAIT_TIME:   /* change wait time between steps */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6ed2:	44 30       	cpi	r20, 0x04	; 4
    6ed4:	51 05       	cpc	r21, r1
    6ed6:	09 f0       	breq	.+2      	; 0x6eda <updateMenu+0xed6>
    6ed8:	7a cf       	rjmp	.-268    	; 0x6dce <updateMenu+0xdca>
    6eda:	ba c8       	rjmp	.-3724   	; 0x6050 <updateMenu+0x4c>
    6edc:	c0 e0       	ldi	r28, 0x00	; 0
    6ede:	d0 e0       	ldi	r29, 0x00	; 0
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepMultiplier += (rotEncVal)/10.0;
    6ee0:	a1 2e       	mov	r10, r17
    6ee2:	bb 24       	eor	r11, r11
    6ee4:	a7 fc       	sbrc	r10, 7
    6ee6:	b0 94       	com	r11
    6ee8:	cb 2c       	mov	r12, r11
    6eea:	db 2c       	mov	r13, r11
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
    6eec:	80 91 13 03 	lds	r24, 0x0313
    6ef0:	90 e0       	ldi	r25, 0x00	; 0
    6ef2:	0c 2e       	mov	r0, r28
    6ef4:	02 c0       	rjmp	.+4      	; 0x6efa <updateMenu+0xef6>
    6ef6:	95 95       	asr	r25
    6ef8:	87 95       	ror	r24
    6efa:	0a 94       	dec	r0
    6efc:	e2 f7       	brpl	.-8      	; 0x6ef6 <updateMenu+0xef2>
    6efe:	80 ff       	sbrs	r24, 0
    6f00:	38 c0       	rjmp	.+112    	; 0x6f72 <updateMenu+0xf6e>
              motor[i].stepMultiplier += (rotEncVal)/10.0;
    6f02:	fe 01       	movw	r30, r28
    6f04:	ee 0f       	add	r30, r30
    6f06:	ff 1f       	adc	r31, r31
    6f08:	ee 0f       	add	r30, r30
    6f0a:	ff 1f       	adc	r31, r31
    6f0c:	ee 0f       	add	r30, r30
    6f0e:	ff 1f       	adc	r31, r31
    6f10:	cf 01       	movw	r24, r30
    6f12:	88 0f       	add	r24, r24
    6f14:	99 1f       	adc	r25, r25
    6f16:	88 0f       	add	r24, r24
    6f18:	99 1f       	adc	r25, r25
    6f1a:	e8 0f       	add	r30, r24
    6f1c:	f9 1f       	adc	r31, r25
    6f1e:	e2 5e       	subi	r30, 0xE2	; 226
    6f20:	fb 4f       	sbci	r31, 0xFB	; 251
    6f22:	e2 8c       	ldd	r14, Z+26	; 0x1a
    6f24:	f3 8c       	ldd	r15, Z+27	; 0x1b
    6f26:	04 8d       	ldd	r16, Z+28	; 0x1c
    6f28:	15 8d       	ldd	r17, Z+29	; 0x1d
    6f2a:	c6 01       	movw	r24, r12
    6f2c:	b5 01       	movw	r22, r10
    6f2e:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    6f32:	20 e0       	ldi	r18, 0x00	; 0
    6f34:	30 e0       	ldi	r19, 0x00	; 0
    6f36:	40 e2       	ldi	r20, 0x20	; 32
    6f38:	51 e4       	ldi	r21, 0x41	; 65
    6f3a:	0e 94 8f 43 	call	0x871e	; 0x871e <__divsf3>
    6f3e:	9b 01       	movw	r18, r22
    6f40:	ac 01       	movw	r20, r24
    6f42:	c8 01       	movw	r24, r16
    6f44:	b7 01       	movw	r22, r14
    6f46:	0e 94 27 43 	call	0x864e	; 0x864e <__addsf3>
    6f4a:	fe 01       	movw	r30, r28
    6f4c:	ee 0f       	add	r30, r30
    6f4e:	ff 1f       	adc	r31, r31
    6f50:	ee 0f       	add	r30, r30
    6f52:	ff 1f       	adc	r31, r31
    6f54:	ee 0f       	add	r30, r30
    6f56:	ff 1f       	adc	r31, r31
    6f58:	9f 01       	movw	r18, r30
    6f5a:	22 0f       	add	r18, r18
    6f5c:	33 1f       	adc	r19, r19
    6f5e:	22 0f       	add	r18, r18
    6f60:	33 1f       	adc	r19, r19
    6f62:	e2 0f       	add	r30, r18
    6f64:	f3 1f       	adc	r31, r19
    6f66:	e2 5e       	subi	r30, 0xE2	; 226
    6f68:	fb 4f       	sbci	r31, 0xFB	; 251
    6f6a:	62 8f       	std	Z+26, r22	; 0x1a
    6f6c:	73 8f       	std	Z+27, r23	; 0x1b
    6f6e:	84 8f       	std	Z+28, r24	; 0x1c
    6f70:	95 8f       	std	Z+29, r25	; 0x1d
    6f72:	21 96       	adiw	r28, 0x01	; 1
            }
          }
          break;

        case MENU_SET_STEP_MULTIPL:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
    6f74:	c4 30       	cpi	r28, 0x04	; 4
    6f76:	d1 05       	cpc	r29, r1
    6f78:	09 f0       	breq	.+2      	; 0x6f7c <updateMenu+0xf78>
    6f7a:	b8 cf       	rjmp	.-144    	; 0x6eec <updateMenu+0xee8>
    6f7c:	69 c8       	rjmp	.-3886   	; 0x6050 <updateMenu+0x4c>
              }
              else{
                motor[i].stepsPerFullRotation += (int16_t)rotEncVal;
              }
              if(motor[i].stepsPerFullRotation < 1){
                motor[i].stepsPerFullRotation = 1;
    6f7e:	ed 2d       	mov	r30, r13
    6f80:	fc 2d       	mov	r31, r12
    6f82:	ee 0f       	add	r30, r30
    6f84:	ff 1f       	adc	r31, r31
    6f86:	ee 0f       	add	r30, r30
    6f88:	ff 1f       	adc	r31, r31
    6f8a:	ee 0f       	add	r30, r30
    6f8c:	ff 1f       	adc	r31, r31
    6f8e:	cf 01       	movw	r24, r30
    6f90:	88 0f       	add	r24, r24
    6f92:	99 1f       	adc	r25, r25
    6f94:	88 0f       	add	r24, r24
    6f96:	99 1f       	adc	r25, r25
    6f98:	e8 0f       	add	r30, r24
    6f9a:	f9 1f       	adc	r31, r25
    6f9c:	e2 5e       	subi	r30, 0xE2	; 226
    6f9e:	fb 4f       	sbci	r31, 0xFB	; 251
    6fa0:	80 e0       	ldi	r24, 0x00	; 0
    6fa2:	90 e0       	ldi	r25, 0x00	; 0
    6fa4:	a0 e8       	ldi	r26, 0x80	; 128
    6fa6:	bf e3       	ldi	r27, 0x3F	; 63
    6fa8:	81 8b       	std	Z+17, r24	; 0x11
    6faa:	92 8b       	std	Z+18, r25	; 0x12
    6fac:	a3 8b       	std	Z+19, r26	; 0x13
    6fae:	b4 8b       	std	Z+20, r27	; 0x14
    6fb0:	3f cd       	rjmp	.-1410   	; 0x6a30 <updateMenu+0xa2c>
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
              }
              if(motor[i].subSteps < 1){
    6fb2:	01 e0       	ldi	r16, 0x01	; 1
    6fb4:	a2 cc       	rjmp	.-1724   	; 0x68fa <updateMenu+0x8f6>
                //motor[i].subSteps *= 2.0;
                tmp *= 2.0;
              }
              if(rotEncVal < 0){
                //motor[i].subSteps /= 2.0;
                tmp /= 2.0;
    6fb6:	70 e0       	ldi	r23, 0x00	; 0
    6fb8:	88 27       	eor	r24, r24
    6fba:	77 fd       	sbrc	r23, 7
    6fbc:	80 95       	com	r24
    6fbe:	98 2f       	mov	r25, r24
    6fc0:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    6fc4:	20 e0       	ldi	r18, 0x00	; 0
    6fc6:	30 e0       	ldi	r19, 0x00	; 0
    6fc8:	40 e0       	ldi	r20, 0x00	; 0
    6fca:	5f e3       	ldi	r21, 0x3F	; 63
    6fcc:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    6fd0:	0e 94 fc 43 	call	0x87f8	; 0x87f8 <__fixunssfsi>
    6fd4:	06 2f       	mov	r16, r22
    6fd6:	73 cc       	rjmp	.-1818   	; 0x68be <updateMenu+0x8ba>
        case MENU_SET_DECAY_MODE:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].decay += rotEncVal;
              if(motor[i].decay < 0){
                motor[i].decay = 2;
    6fd8:	fa 01       	movw	r30, r20
    6fda:	ee 0f       	add	r30, r30
    6fdc:	ff 1f       	adc	r31, r31
    6fde:	ee 0f       	add	r30, r30
    6fe0:	ff 1f       	adc	r31, r31
    6fe2:	ee 0f       	add	r30, r30
    6fe4:	ff 1f       	adc	r31, r31
    6fe6:	cf 01       	movw	r24, r30
    6fe8:	88 0f       	add	r24, r24
    6fea:	99 1f       	adc	r25, r25
    6fec:	88 0f       	add	r24, r24
    6fee:	99 1f       	adc	r25, r25
    6ff0:	e8 0f       	add	r30, r24
    6ff2:	f9 1f       	adc	r31, r25
    6ff4:	e2 5e       	subi	r30, 0xE2	; 226
    6ff6:	fb 4f       	sbci	r31, 0xFB	; 251
    6ff8:	77 a3       	std	Z+39, r23	; 0x27
    6ffa:	b4 ce       	rjmp	.-664    	; 0x6d64 <updateMenu+0xd60>
        case MENU_CHANGE_STEP_UNIT:   /* change step units */
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].stepUnit += rotEncVal;
              if(motor[i].stepUnit < 0){
                motor[i].stepUnit = 2;
    6ffc:	fa 01       	movw	r30, r20
    6ffe:	ee 0f       	add	r30, r30
    7000:	ff 1f       	adc	r31, r31
    7002:	ee 0f       	add	r30, r30
    7004:	ff 1f       	adc	r31, r31
    7006:	ee 0f       	add	r30, r30
    7008:	ff 1f       	adc	r31, r31
    700a:	cf 01       	movw	r24, r30
    700c:	88 0f       	add	r24, r24
    700e:	99 1f       	adc	r25, r25
    7010:	88 0f       	add	r24, r24
    7012:	99 1f       	adc	r25, r25
    7014:	e8 0f       	add	r30, r24
    7016:	f9 1f       	adc	r31, r25
    7018:	e2 5e       	subi	r30, 0xE2	; 226
    701a:	fb 4f       	sbci	r31, 0xFB	; 251
    701c:	71 8f       	std	Z+25, r23	; 0x19
    701e:	54 cd       	rjmp	.-1368   	; 0x6ac8 <updateMenu+0xac4>
        case MENU_CHANGE_CURR:
          for(i = MOTOR0; i <= MAX_MOTOR; i++){
            if(menu.selectedMotor & (1 << i)){
              motor[i].current += (rotEncVal)/10.0;
              if(motor[i].current < 0){
                motor[i].current = 0;
    7020:	fe 01       	movw	r30, r28
    7022:	ee 0f       	add	r30, r30
    7024:	ff 1f       	adc	r31, r31
    7026:	ee 0f       	add	r30, r30
    7028:	ff 1f       	adc	r31, r31
    702a:	ee 0f       	add	r30, r30
    702c:	ff 1f       	adc	r31, r31
    702e:	cf 01       	movw	r24, r30
    7030:	88 0f       	add	r24, r24
    7032:	99 1f       	adc	r25, r25
    7034:	88 0f       	add	r24, r24
    7036:	99 1f       	adc	r25, r25
    7038:	e8 0f       	add	r30, r24
    703a:	f9 1f       	adc	r31, r25
    703c:	e2 5e       	subi	r30, 0xE2	; 226
    703e:	fb 4f       	sbci	r31, 0xFB	; 251
    7040:	80 e0       	ldi	r24, 0x00	; 0
    7042:	90 e0       	ldi	r25, 0x00	; 0
    7044:	a0 e0       	ldi	r26, 0x00	; 0
    7046:	b0 e0       	ldi	r27, 0x00	; 0
    7048:	83 a3       	std	Z+35, r24	; 0x23
    704a:	94 a3       	std	Z+36, r25	; 0x24
    704c:	a5 a3       	std	Z+37, r26	; 0x25
    704e:	b6 a3       	std	Z+38, r27	; 0x26
    7050:	ab cb       	rjmp	.-2218   	; 0x67a8 <updateMenu+0x7a4>
                 * fobidden zone is set */
                break;
              }
              motor[i].angularVelocity += rotEncVal;
              if(motor[i].angularVelocity < 0){
                motor[i].angularVelocity = 2;
    7052:	02 a3       	std	Z+34, r16	; 0x22
    7054:	97 ca       	rjmp	.-2770   	; 0x6584 <updateMenu+0x580>
                  break;

                case MOTOR_STEP_UNIT_RADIAN:
                  /* default step is pi/8 */
                  /* pi/8 is far enough, so no fast moving mode here */
                  radiansToSteps(i, (rotEncVal)*0.125, motor[i].stepMultiplier);
    7056:	fe 01       	movw	r30, r28
    7058:	ee 0f       	add	r30, r30
    705a:	ff 1f       	adc	r31, r31
    705c:	ee 0f       	add	r30, r30
    705e:	ff 1f       	adc	r31, r31
    7060:	ee 0f       	add	r30, r30
    7062:	ff 1f       	adc	r31, r31
    7064:	cf 01       	movw	r24, r30
    7066:	88 0f       	add	r24, r24
    7068:	99 1f       	adc	r25, r25
    706a:	88 0f       	add	r24, r24
    706c:	99 1f       	adc	r25, r25
    706e:	e8 0f       	add	r30, r24
    7070:	f9 1f       	adc	r31, r25
    7072:	e2 5e       	subi	r30, 0xE2	; 226
    7074:	fb 4f       	sbci	r31, 0xFB	; 251
    7076:	e2 8c       	ldd	r14, Z+26	; 0x1a
    7078:	f3 8c       	ldd	r15, Z+27	; 0x1b
    707a:	04 8d       	ldd	r16, Z+28	; 0x1c
    707c:	15 8d       	ldd	r17, Z+29	; 0x1d
    707e:	c6 01       	movw	r24, r12
    7080:	b5 01       	movw	r22, r10
    7082:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    7086:	20 e0       	ldi	r18, 0x00	; 0
    7088:	30 e0       	ldi	r19, 0x00	; 0
    708a:	40 e0       	ldi	r20, 0x00	; 0
    708c:	5e e3       	ldi	r21, 0x3E	; 62
    708e:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    7092:	ab 01       	movw	r20, r22
    7094:	bc 01       	movw	r22, r24
    7096:	8c 2f       	mov	r24, r28
    7098:	98 01       	movw	r18, r16
    709a:	87 01       	movw	r16, r14
    709c:	0e 94 0b 10 	call	0x2016	; 0x2016 <radiansToSteps>
    70a0:	8b c8       	rjmp	.-3818   	; 0x61b8 <updateMenu+0x1b4>
                    motor[i].desiredPosition += (int16_t)rotEncVal;
                  }
                  break;

                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
    70a2:	80 91 10 03 	lds	r24, 0x0310
    70a6:	88 23       	and	r24, r24
    70a8:	09 f4       	brne	.+2      	; 0x70ac <updateMenu+0x10a8>
    70aa:	ba c0       	rjmp	.+372    	; 0x7220 <updateMenu+0x121c>
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
    70ac:	fe 01       	movw	r30, r28
    70ae:	ee 0f       	add	r30, r30
    70b0:	ff 1f       	adc	r31, r31
    70b2:	ee 0f       	add	r30, r30
    70b4:	ff 1f       	adc	r31, r31
    70b6:	ee 0f       	add	r30, r30
    70b8:	ff 1f       	adc	r31, r31
    70ba:	cf 01       	movw	r24, r30
    70bc:	88 0f       	add	r24, r24
    70be:	99 1f       	adc	r25, r25
    70c0:	88 0f       	add	r24, r24
    70c2:	99 1f       	adc	r25, r25
    70c4:	e8 0f       	add	r30, r24
    70c6:	f9 1f       	adc	r31, r25
    70c8:	e2 5e       	subi	r30, 0xE2	; 226
    70ca:	fb 4f       	sbci	r31, 0xFB	; 251
    70cc:	e2 8c       	ldd	r14, Z+26	; 0x1a
    70ce:	f3 8c       	ldd	r15, Z+27	; 0x1b
    70d0:	04 8d       	ldd	r16, Z+28	; 0x1c
    70d2:	15 8d       	ldd	r17, Z+29	; 0x1d
    70d4:	c6 01       	movw	r24, r12
    70d6:	b5 01       	movw	r22, r10
    70d8:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    70dc:	20 e0       	ldi	r18, 0x00	; 0
    70de:	30 e0       	ldi	r19, 0x00	; 0
    70e0:	40 e2       	ldi	r20, 0x20	; 32
    70e2:	51 e4       	ldi	r21, 0x41	; 65
    70e4:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    70e8:	ab 01       	movw	r20, r22
    70ea:	bc 01       	movw	r22, r24
    70ec:	8c 2f       	mov	r24, r28
    70ee:	98 01       	movw	r18, r16
    70f0:	87 01       	movw	r16, r14
    70f2:	0e 94 52 11 	call	0x22a4	; 0x22a4 <degreeToSteps>
    70f6:	60 c8       	rjmp	.-3904   	; 0x61b8 <updateMenu+0x1b4>
          if(programList[menu.currentProgramStep].absRel == PROG_ABSOLUTE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
    70f8:	80 91 11 03 	lds	r24, 0x0311
    70fc:	99 27       	eor	r25, r25
    70fe:	87 fd       	sbrc	r24, 7
    7100:	90 95       	com	r25
    7102:	fc 01       	movw	r30, r24
    7104:	ee 0f       	add	r30, r30
    7106:	ff 1f       	adc	r31, r31
    7108:	ee 0f       	add	r30, r30
    710a:	ff 1f       	adc	r31, r31
    710c:	ee 0f       	add	r30, r30
    710e:	ff 1f       	adc	r31, r31
    7110:	88 0f       	add	r24, r24
    7112:	99 1f       	adc	r25, r25
    7114:	e8 0f       	add	r30, r24
    7116:	f9 1f       	adc	r31, r25
    7118:	ef 5d       	subi	r30, 0xDF	; 223
    711a:	fc 4f       	sbci	r31, 0xFC	; 252
    711c:	81 85       	ldd	r24, Z+9	; 0x09
    711e:	81 30       	cpi	r24, 0x01	; 1
    7120:	11 f0       	breq	.+4      	; 0x7126 <updateMenu+0x1122>
    7122:	0c 94 28 30 	jmp	0x6050	; 0x6050 <updateMenu+0x4c>
    7126:	60 e0       	ldi	r22, 0x00	; 0
    7128:	70 e0       	ldi	r23, 0x00	; 0
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = motor[i].actualPosition
    712a:	fb 01       	movw	r30, r22
    712c:	ee 0f       	add	r30, r30
    712e:	ff 1f       	adc	r31, r31
    7130:	ee 0f       	add	r30, r30
    7132:	ff 1f       	adc	r31, r31
    7134:	ee 0f       	add	r30, r30
    7136:	ff 1f       	adc	r31, r31
    7138:	cf 01       	movw	r24, r30
    713a:	88 0f       	add	r24, r24
    713c:	99 1f       	adc	r25, r25
    713e:	88 0f       	add	r24, r24
    7140:	99 1f       	adc	r25, r25
    7142:	e8 0f       	add	r30, r24
    7144:	f9 1f       	adc	r31, r25
    7146:	e2 5e       	subi	r30, 0xE2	; 226
    7148:	fb 4f       	sbci	r31, 0xFB	; 251
    714a:	40 81       	ld	r20, Z
    714c:	51 81       	ldd	r21, Z+1	; 0x01
    714e:	80 91 11 03 	lds	r24, 0x0311
    7152:	99 27       	eor	r25, r25
    7154:	87 fd       	sbrc	r24, 7
    7156:	90 95       	com	r25
    7158:	fc 01       	movw	r30, r24
    715a:	ee 0f       	add	r30, r30
    715c:	ff 1f       	adc	r31, r31
    715e:	ee 0f       	add	r30, r30
    7160:	ff 1f       	adc	r31, r31
    7162:	e8 0f       	add	r30, r24
    7164:	f9 1f       	adc	r31, r25
    7166:	e6 0f       	add	r30, r22
    7168:	f7 1f       	adc	r31, r23
    716a:	ee 0f       	add	r30, r30
    716c:	ff 1f       	adc	r31, r31
    716e:	ef 5d       	subi	r30, 0xDF	; 223
    7170:	fc 4f       	sbci	r31, 0xFC	; 252
    7172:	21 81       	ldd	r18, Z+1	; 0x01
    7174:	32 81       	ldd	r19, Z+2	; 0x02
    7176:	24 0f       	add	r18, r20
    7178:	35 1f       	adc	r19, r21
    717a:	fb 01       	movw	r30, r22
    717c:	ee 0f       	add	r30, r30
    717e:	ff 1f       	adc	r31, r31
    7180:	ee 0f       	add	r30, r30
    7182:	ff 1f       	adc	r31, r31
    7184:	cf 01       	movw	r24, r30
    7186:	88 0f       	add	r24, r24
    7188:	99 1f       	adc	r25, r25
    718a:	88 0f       	add	r24, r24
    718c:	99 1f       	adc	r25, r25
    718e:	e8 0f       	add	r30, r24
    7190:	f9 1f       	adc	r31, r25
    7192:	ee 0f       	add	r30, r30
    7194:	ff 1f       	adc	r31, r31
    7196:	e0 5e       	subi	r30, 0xE0	; 224
    7198:	fb 4f       	sbci	r31, 0xFB	; 251
    719a:	31 83       	std	Z+1, r19	; 0x01
    719c:	20 83       	st	Z, r18
    719e:	6f 5f       	subi	r22, 0xFF	; 255
    71a0:	7f 4f       	sbci	r23, 0xFF	; 255
            for(i = 0; i <= MAX_MOTOR; i++){
              motor[i].desiredPosition = programList[menu.currentProgramStep].position[i];
            }
          }
          else if(programList[menu.currentProgramStep].absRel == PROG_RELATIVE_MOVEMENT){
            for(i = 0; i <= MAX_MOTOR; i++){
    71a2:	64 30       	cpi	r22, 0x04	; 4
    71a4:	71 05       	cpc	r23, r1
    71a6:	09 f6       	brne	.-126    	; 0x712a <updateMenu+0x1126>
    71a8:	0c 94 28 30 	jmp	0x6050	; 0x6050 <updateMenu+0x4c>
          if(rotEncVal < 0){
            do{
              /* find the next active program step */
              menu.currentProgramStep += -1;
              if(menu.currentProgramStep < 0){
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
    71ac:	2f e0       	ldi	r18, 0x0F	; 15
    71ae:	16 c0       	rjmp	.+44     	; 0x71dc <updateMenu+0x11d8>
              }
            }while(programList[menu.currentProgramStep].isActive == 0);
    71b0:	80 91 11 03 	lds	r24, 0x0311
    71b4:	99 27       	eor	r25, r25
    71b6:	87 fd       	sbrc	r24, 7
    71b8:	90 95       	com	r25
    71ba:	fc 01       	movw	r30, r24
    71bc:	ee 0f       	add	r30, r30
    71be:	ff 1f       	adc	r31, r31
    71c0:	ee 0f       	add	r30, r30
    71c2:	ff 1f       	adc	r31, r31
    71c4:	ee 0f       	add	r30, r30
    71c6:	ff 1f       	adc	r31, r31
    71c8:	88 0f       	add	r24, r24
    71ca:	99 1f       	adc	r25, r25
    71cc:	e8 0f       	add	r30, r24
    71ce:	f9 1f       	adc	r31, r25
    71d0:	ef 5d       	subi	r30, 0xDF	; 223
    71d2:	fc 4f       	sbci	r31, 0xFC	; 252
    71d4:	80 81       	ld	r24, Z
    71d6:	88 23       	and	r24, r24
    71d8:	09 f0       	breq	.+2      	; 0x71dc <updateMenu+0x11d8>
    71da:	fa cc       	rjmp	.-1548   	; 0x6bd0 <updateMenu+0xbcc>
          }

          if(rotEncVal < 0){
            do{
              /* find the next active program step */
              menu.currentProgramStep += -1;
    71dc:	80 91 11 03 	lds	r24, 0x0311
    71e0:	81 50       	subi	r24, 0x01	; 1
    71e2:	80 93 11 03 	sts	0x0311, r24
              if(menu.currentProgramStep < 0){
    71e6:	80 91 11 03 	lds	r24, 0x0311
    71ea:	87 ff       	sbrs	r24, 7
    71ec:	e1 cf       	rjmp	.-62     	; 0x71b0 <updateMenu+0x11ac>
                menu.currentProgramStep = MAX_PROGRAM_STEPS - 1;
    71ee:	20 93 11 03 	sts	0x0311, r18
    71f2:	de cf       	rjmp	.-68     	; 0x71b0 <updateMenu+0x11ac>
                case MOTOR_STEP_UNIT_STEP:
                  if(menu.fastMovingMode){
                    motor[i].desiredPosition += ((int16_t)rotEncVal)*100;
                  }
                  else{
                    motor[i].desiredPosition += (int16_t)rotEncVal;
    71f4:	fe 01       	movw	r30, r28
    71f6:	ee 0f       	add	r30, r30
    71f8:	ff 1f       	adc	r31, r31
    71fa:	ee 0f       	add	r30, r30
    71fc:	ff 1f       	adc	r31, r31
    71fe:	cf 01       	movw	r24, r30
    7200:	88 0f       	add	r24, r24
    7202:	99 1f       	adc	r25, r25
    7204:	88 0f       	add	r24, r24
    7206:	99 1f       	adc	r25, r25
    7208:	e8 0f       	add	r30, r24
    720a:	f9 1f       	adc	r31, r25
    720c:	ee 0f       	add	r30, r30
    720e:	ff 1f       	adc	r31, r31
    7210:	e0 5e       	subi	r30, 0xE0	; 224
    7212:	fb 4f       	sbci	r31, 0xFB	; 251
    7214:	20 81       	ld	r18, Z
    7216:	31 81       	ldd	r19, Z+1	; 0x01
    7218:	28 0d       	add	r18, r8
    721a:	39 1d       	adc	r19, r9
    721c:	0c 94 ca 30 	jmp	0x6194	; 0x6194 <updateMenu+0x190>
                case MOTOR_STEP_UNIT_DEGREE:
                  if(menu.fastMovingMode){
                    degreeToSteps(i, (rotEncVal)*10.0, motor[i].stepMultiplier);
                  }
                  else{
                    degreeToSteps(i, rotEncVal, motor[i].stepMultiplier);
    7220:	fe 01       	movw	r30, r28
    7222:	ee 0f       	add	r30, r30
    7224:	ff 1f       	adc	r31, r31
    7226:	ee 0f       	add	r30, r30
    7228:	ff 1f       	adc	r31, r31
    722a:	ee 0f       	add	r30, r30
    722c:	ff 1f       	adc	r31, r31
    722e:	cf 01       	movw	r24, r30
    7230:	88 0f       	add	r24, r24
    7232:	99 1f       	adc	r25, r25
    7234:	88 0f       	add	r24, r24
    7236:	99 1f       	adc	r25, r25
    7238:	e8 0f       	add	r30, r24
    723a:	f9 1f       	adc	r31, r25
    723c:	e2 5e       	subi	r30, 0xE2	; 226
    723e:	fb 4f       	sbci	r31, 0xFB	; 251
    7240:	e2 8c       	ldd	r14, Z+26	; 0x1a
    7242:	f3 8c       	ldd	r15, Z+27	; 0x1b
    7244:	04 8d       	ldd	r16, Z+28	; 0x1c
    7246:	15 8d       	ldd	r17, Z+29	; 0x1d
    7248:	c6 01       	movw	r24, r12
    724a:	b5 01       	movw	r22, r10
    724c:	0e 94 2a 44 	call	0x8854	; 0x8854 <__floatsisf>
    7250:	ab 01       	movw	r20, r22
    7252:	bc 01       	movw	r22, r24
    7254:	8c 2f       	mov	r24, r28
    7256:	98 01       	movw	r18, r16
    7258:	87 01       	movw	r16, r14
    725a:	0e 94 52 11 	call	0x22a4	; 0x22a4 <degreeToSteps>
    725e:	0c 94 dc 30 	jmp	0x61b8	; 0x61b8 <updateMenu+0x1b4>

00007262 <main>:


/* =====================================================================
    main loop
====================================================================== */
int main(void){
    7262:	ef 92       	push	r14
    7264:	ff 92       	push	r15
    7266:	0f 93       	push	r16
    7268:	1f 93       	push	r17
    726a:	cf 93       	push	r28
    726c:	df 93       	push	r29

  uint8_t i;
  uint8_t commandCode;

  /* initialize command parameter list */
  commandParam = (char**)malloc(NUMBER_OF_PARAMETERS * sizeof(char*));
    726e:	84 e1       	ldi	r24, 0x14	; 20
    7270:	90 e0       	ldi	r25, 0x00	; 0
    7272:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    7276:	80 93 04 03 	sts	0x0304, r24
    727a:	90 93 05 03 	sts	0x0305, r25
    727e:	c0 e0       	ldi	r28, 0x00	; 0
    7280:	d0 e0       	ldi	r29, 0x00	; 0
  for(i = 0; i < NUMBER_OF_PARAMETERS; i++){
    commandParam[i] = (char*)malloc(PARAMETER_LENGTH * sizeof(char));
    7282:	00 91 04 03 	lds	r16, 0x0304
    7286:	10 91 05 03 	lds	r17, 0x0305
    728a:	0c 0f       	add	r16, r28
    728c:	1d 1f       	adc	r17, r29
    728e:	84 e1       	ldi	r24, 0x14	; 20
    7290:	90 e0       	ldi	r25, 0x00	; 0
    7292:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    7296:	f8 01       	movw	r30, r16
    7298:	80 83       	st	Z, r24
    729a:	91 83       	std	Z+1, r25	; 0x01
    729c:	22 96       	adiw	r28, 0x02	; 2
  uint8_t i;
  uint8_t commandCode;

  /* initialize command parameter list */
  commandParam = (char**)malloc(NUMBER_OF_PARAMETERS * sizeof(char*));
  for(i = 0; i < NUMBER_OF_PARAMETERS; i++){
    729e:	c4 31       	cpi	r28, 0x14	; 20
    72a0:	d1 05       	cpc	r29, r1
    72a2:	79 f7       	brne	.-34     	; 0x7282 <main+0x20>
    commandParam[i] = (char*)malloc(PARAMETER_LENGTH * sizeof(char));
  }

  /* initialize menu strings */
  menu.currentDisplayValue = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
    72a4:	88 e0       	ldi	r24, 0x08	; 8
    72a6:	90 e0       	ldi	r25, 0x00	; 0
    72a8:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    72ac:	90 93 15 03 	sts	0x0315, r25
    72b0:	80 93 14 03 	sts	0x0314, r24
  menu.newDisplayValue     = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
    72b4:	88 e0       	ldi	r24, 0x08	; 8
    72b6:	90 e0       	ldi	r25, 0x00	; 0
    72b8:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    72bc:	90 93 17 03 	sts	0x0317, r25
    72c0:	80 93 16 03 	sts	0x0316, r24
    72c4:	c0 e0       	ldi	r28, 0x00	; 0
    72c6:	d0 e0       	ldi	r29, 0x00	; 0
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    menu.currentDisplayValue[i] = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    72c8:	00 91 14 03 	lds	r16, 0x0314
    72cc:	10 91 15 03 	lds	r17, 0x0315
    72d0:	89 e0       	ldi	r24, 0x09	; 9
    72d2:	90 e0       	ldi	r25, 0x00	; 0
    72d4:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    72d8:	0c 0f       	add	r16, r28
    72da:	1d 1f       	adc	r17, r29
    72dc:	f8 01       	movw	r30, r16
    72de:	80 83       	st	Z, r24
    72e0:	91 83       	std	Z+1, r25	; 0x01
    menu.newDisplayValue[i]     = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    72e2:	00 91 16 03 	lds	r16, 0x0316
    72e6:	10 91 17 03 	lds	r17, 0x0317
    72ea:	89 e0       	ldi	r24, 0x09	; 9
    72ec:	90 e0       	ldi	r25, 0x00	; 0
    72ee:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    72f2:	0c 0f       	add	r16, r28
    72f4:	1d 1f       	adc	r17, r29
    72f6:	f8 01       	movw	r30, r16
    72f8:	80 83       	st	Z, r24
    72fa:	91 83       	std	Z+1, r25	; 0x01
    72fc:	22 96       	adiw	r28, 0x02	; 2
  }

  /* initialize menu strings */
  menu.currentDisplayValue = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
  menu.newDisplayValue     = (char**)malloc(NUMBER_DISPLAY_VALUE_STRINGS * sizeof(char*));
  for(i = 0; i < NUMBER_DISPLAY_VALUE_STRINGS; i++){
    72fe:	c8 30       	cpi	r28, 0x08	; 8
    7300:	d1 05       	cpc	r29, r1
    7302:	11 f7       	brne	.-60     	; 0x72c8 <main+0x66>
    menu.currentDisplayValue[i] = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
    menu.newDisplayValue[i]     = (char*)malloc(DISPLAY_VALUE_STRING_LENGTH * sizeof(char));
  }

  menu.currentMenuText     = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
    7304:	84 e0       	ldi	r24, 0x04	; 4
    7306:	90 e0       	ldi	r25, 0x00	; 0
    7308:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    730c:	90 93 19 03 	sts	0x0319, r25
    7310:	80 93 18 03 	sts	0x0318, r24
  menu.newMenuText         = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
    7314:	84 e0       	ldi	r24, 0x04	; 4
    7316:	90 e0       	ldi	r25, 0x00	; 0
    7318:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    731c:	90 93 1b 03 	sts	0x031B, r25
    7320:	80 93 1a 03 	sts	0x031A, r24
  for(i = 0; i < NUMBER_DISPLAY_MENU_STRINGS; i++){
    menu.currentMenuText[i] = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    7324:	00 91 18 03 	lds	r16, 0x0318
    7328:	10 91 19 03 	lds	r17, 0x0319
    732c:	81 e1       	ldi	r24, 0x11	; 17
    732e:	90 e0       	ldi	r25, 0x00	; 0
    7330:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    7334:	f8 01       	movw	r30, r16
    7336:	80 83       	st	Z, r24
    7338:	91 83       	std	Z+1, r25	; 0x01
    menu.newMenuText[i]     = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    733a:	00 91 1a 03 	lds	r16, 0x031A
    733e:	10 91 1b 03 	lds	r17, 0x031B
    7342:	81 e1       	ldi	r24, 0x11	; 17
    7344:	90 e0       	ldi	r25, 0x00	; 0
    7346:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    734a:	f8 01       	movw	r30, r16
    734c:	80 83       	st	Z, r24
    734e:	91 83       	std	Z+1, r25	; 0x01
  }

  menu.currentMenuText     = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
  menu.newMenuText         = (char**)malloc(NUMBER_DISPLAY_MENU_STRINGS * sizeof(char*));
  for(i = 0; i < NUMBER_DISPLAY_MENU_STRINGS; i++){
    menu.currentMenuText[i] = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    7350:	00 91 18 03 	lds	r16, 0x0318
    7354:	10 91 19 03 	lds	r17, 0x0319
    7358:	81 e1       	ldi	r24, 0x11	; 17
    735a:	90 e0       	ldi	r25, 0x00	; 0
    735c:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    7360:	f8 01       	movw	r30, r16
    7362:	82 83       	std	Z+2, r24	; 0x02
    7364:	93 83       	std	Z+3, r25	; 0x03
    menu.newMenuText[i]     = (char*)malloc(DISPLAY_MENU_STRING_LENGTH * sizeof(char));
    7366:	00 91 1a 03 	lds	r16, 0x031A
    736a:	10 91 1b 03 	lds	r17, 0x031B
    736e:	81 e1       	ldi	r24, 0x11	; 17
    7370:	90 e0       	ldi	r25, 0x00	; 0
    7372:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    7376:	f8 01       	movw	r30, r16
    7378:	82 83       	std	Z+2, r24	; 0x02
    737a:	93 83       	std	Z+3, r25	; 0x03
  }

  /* initialize TX and RX buffers for USART serial interface */
  rxString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    737c:	80 e4       	ldi	r24, 0x40	; 64
    737e:	90 e0       	ldi	r25, 0x00	; 0
    7380:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    7384:	90 93 1d 03 	sts	0x031D, r25
    7388:	80 93 1c 03 	sts	0x031C, r24
  txString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    738c:	80 e4       	ldi	r24, 0x40	; 64
    738e:	90 e0       	ldi	r25, 0x00	; 0
    7390:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    7394:	90 93 16 04 	sts	0x0416, r25
    7398:	80 93 15 04 	sts	0x0415, r24
  commandString.buffer = (char*)malloc(SERIAL_BUFFERSIZE * sizeof(char));
    739c:	80 e4       	ldi	r24, 0x40	; 64
    739e:	90 e0       	ldi	r25, 0x00	; 0
    73a0:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    73a4:	90 93 bf 04 	sts	0x04BF, r25
    73a8:	80 93 be 04 	sts	0x04BE, r24

  /* initialize IIC data buffer */
  IIC.data = (char*)malloc(21 * sizeof(char));
    73ac:	85 e1       	ldi	r24, 0x15	; 21
    73ae:	90 e0       	ldi	r25, 0x00	; 0
    73b0:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    73b4:	90 93 1c 04 	sts	0x041C, r25
    73b8:	80 93 1b 04 	sts	0x041B, r24

  /* initialize displayBuffer */
  displayBuffer = (char*)malloc(DISPLAY_BUFFER_SIZE * sizeof(char));
    73bc:	88 e2       	ldi	r24, 0x28	; 40
    73be:	90 e0       	ldi	r25, 0x00	; 0
    73c0:	0e 94 db 45 	call	0x8bb6	; 0x8bb6 <malloc>
    73c4:	80 93 19 04 	sts	0x0419, r24
    73c8:	90 93 1a 04 	sts	0x041A, r25
    73cc:	80 e0       	ldi	r24, 0x00	; 0
    73ce:	90 e0       	ldi	r25, 0x00	; 0

  /* initialize data for LEDs and WS2803 output pins */
  for(i = 0; i < BUTT_LED_CHANNELS; i++){
    buttLedData[i] = 0;
    73d0:	fc 01       	movw	r30, r24
    73d2:	ed 53       	subi	r30, 0x3D	; 61
    73d4:	fc 4f       	sbci	r31, 0xFC	; 252
    73d6:	10 82       	st	Z, r1
    73d8:	01 96       	adiw	r24, 0x01	; 1

  /* initialize displayBuffer */
  displayBuffer = (char*)malloc(DISPLAY_BUFFER_SIZE * sizeof(char));

  /* initialize data for LEDs and WS2803 output pins */
  for(i = 0; i < BUTT_LED_CHANNELS; i++){
    73da:	80 33       	cpi	r24, 0x30	; 48
    73dc:	91 05       	cpc	r25, r1
    73de:	c1 f7       	brne	.-16     	; 0x73d0 <main+0x16e>
    buttLedData[i] = 0;
  }
  DDRC |= (1 << WS2803_CKI) | (1 << WS2803_SDI);
    73e0:	87 b1       	in	r24, 0x07	; 7
    73e2:	80 6c       	ori	r24, 0xC0	; 192
    73e4:	87 b9       	out	0x07, r24	; 7
  PORTC |= (1 << WS2803_CKI) | (1 << WS2803_SDI);
    73e6:	88 b1       	in	r24, 0x08	; 8
    73e8:	80 6c       	ori	r24, 0xC0	; 192
    73ea:	88 b9       	out	0x08, r24	; 8

  /* initialize PORTA as output for motor Step/Direction */
  DDRA  = 0xFF;
    73ec:	8f ef       	ldi	r24, 0xFF	; 255
    73ee:	81 b9       	out	0x01, r24	; 1
  PORTA = 0;
    73f0:	12 b8       	out	0x02, r1	; 2

  //lcd_init();
  //lcd_home();

  /* OLED setup */
  OLEDinit(OLED_V2);
    73f2:	82 e0       	ldi	r24, 0x02	; 2
    73f4:	0e 94 a6 3e 	call	0x7d4c	; 0x7d4c <OLEDinit>
    73f8:	28 e8       	ldi	r18, 0x88	; 136
    73fa:	33 e1       	ldi	r19, 0x13	; 19
    73fc:	44 ef       	ldi	r20, 0xF4	; 244
    73fe:	51 e0       	ldi	r21, 0x01	; 1
    7400:	ca 01       	movw	r24, r20
    7402:	01 97       	sbiw	r24, 0x01	; 1
    7404:	f1 f7       	brne	.-4      	; 0x7402 <main+0x1a0>
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7406:	21 50       	subi	r18, 0x01	; 1
    7408:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    740a:	d1 f7       	brne	.-12     	; 0x7400 <main+0x19e>
  _delay_ms(500);
  OLEDclear();
    740c:	0e 94 f4 3d 	call	0x7be8	; 0x7be8 <OLEDclear>
  OLEDsetCursor(0, 0);
    7410:	80 e0       	ldi	r24, 0x00	; 0
    7412:	60 e0       	ldi	r22, 0x00	; 0
    7414:	0e 94 93 3d 	call	0x7b26	; 0x7b26 <OLEDsetCursor>
   - 8 bit character size
   - no flow control
  */

  /* set baud rate registers */
  UBRR0H = (uint8_t)(UBRR_VALUE >> 8);
    7418:	10 92 c5 00 	sts	0x00C5, r1
  UBRR0L = (uint8_t)(UBRR_VALUE & 0xFF);
    741c:	85 e1       	ldi	r24, 0x15	; 21
    741e:	80 93 c4 00 	sts	0x00C4, r24

  UCSR0B |= (1<<TXEN0) | (1<<RXEN0)        /* enable RX and TX */
    7422:	80 91 c1 00 	lds	r24, 0x00C1
    7426:	88 69       	ori	r24, 0x98	; 152
    7428:	80 93 c1 00 	sts	0x00C1, r24
  OLEDclear();
  OLEDsetCursor(0, 0);

  initUSART();

  initDataStructs();  /* must be the first function after reset! */
    742c:	0e 94 7f 03 	call	0x6fe	; 0x6fe <initDataStructs>
  initBuffers();
    7430:	0e 94 84 27 	call	0x4f08	; 0x4f08 <initBuffers>
  //initADC();
  initIIC();
    7434:	0e 94 ce 3e 	call	0x7d9c	; 0x7d9c <initIIC>
  
RESET:
  initDataStructs();  /* must be the first function after reset! */ 
    7438:	0e 94 7f 03 	call	0x6fe	; 0x6fe <initDataStructs>
  initMotorDelayTimer();
    743c:	0e 94 02 06 	call	0xc04	; 0xc04 <initMotorDelayTimer>
  initManualOperatingButtons();
    7440:	0e 94 71 2a 	call	0x54e2	; 0x54e2 <initManualOperatingButtons>
  
  /* TODO: detect motors if connected */
  
  loadConfigFromEEPROM();
    7444:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <loadConfigFromEEPROM>
    7448:	10 e0       	ldi	r17, 0x00	; 0

  /* init all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    initPortExpander(getPortExpanderAddress(i));
    744a:	81 2f       	mov	r24, r17
    744c:	0e 94 c8 09 	call	0x1390	; 0x1390 <getPortExpanderAddress>
    7450:	0e 94 83 29 	call	0x5306	; 0x5306 <initPortExpander>
    initDAC(i);
    7454:	81 2f       	mov	r24, r17
    7456:	0e 94 5b 29 	call	0x52b6	; 0x52b6 <initDAC>
  /* TODO: detect motors if connected */
  
  loadConfigFromEEPROM();

  /* init all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    745a:	1f 5f       	subi	r17, 0xFF	; 255
    745c:	14 30       	cpi	r17, 0x04	; 4
    745e:	a9 f7       	brne	.-22     	; 0x744a <main+0x1e8>
    initPortExpander(getPortExpanderAddress(i));
    initDAC(i);
  }
  
  updateIICvalues();
    7460:	0e 94 1d 2e 	call	0x5c3a	; 0x5c3a <updateIICvalues>
  
  /* turn on all available motors */
  for(i = 0; i <= MAX_MOTOR; i++){
    setMotorState(i, ON);
    7464:	80 e0       	ldi	r24, 0x00	; 0
    7466:	61 e0       	ldi	r22, 0x01	; 1
    7468:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
    746c:	81 e0       	ldi	r24, 0x01	; 1
    746e:	61 e0       	ldi	r22, 0x01	; 1
    7470:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
    7474:	82 e0       	ldi	r24, 0x02	; 2
    7476:	61 e0       	ldi	r22, 0x01	; 1
    7478:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
    747c:	83 e0       	ldi	r24, 0x03	; 3
    747e:	61 e0       	ldi	r22, 0x01	; 1
    7480:	0e 94 fc 2c 	call	0x59f8	; 0x59f8 <setMotorState>
  }

  updateMenu();
    7484:	0e 94 02 30 	call	0x6004	; 0x6004 <updateMenu>
  
  updateDisplay();
    7488:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <updateDisplay>
  /*
  for(i = 0; i < 4; i++){
    changeButtonLED(i, GREEN, 0x0F);
  }
  */
  changeButtonLED(LED_MESC, RED, 0x0F);
    748c:	84 e0       	ldi	r24, 0x04	; 4
    748e:	62 e0       	ldi	r22, 0x02	; 2
    7490:	4f e0       	ldi	r20, 0x0F	; 15
    7492:	0e 94 24 07 	call	0xe48	; 0xe48 <changeButtonLED>
  //updateLEDs();
  updateMotorButtonLEDs();
    7496:	0e 94 bc 07 	call	0xf78	; 0xf78 <updateMotorButtonLEDs>
  
  commandCode = 0x80;

  sei();  /* turn on interrupts */
    749a:	78 94       	sei

  /* start the never ending story */
  for(;;){

    /* check for manual done changes */
    updateMenu();
    749c:	0e 94 02 30 	call	0x6004	; 0x6004 <updateMenu>

    /* check for changed values and update them on the display */
    updateDisplay();
    74a0:	0e 94 72 2e 	call	0x5ce4	; 0x5ce4 <updateDisplay>
    
    //updateMotorButtonLEDs();

    /* check for new received command */
    if(rxString.readyToProcess){
    74a4:	80 91 1e 03 	lds	r24, 0x031E
    74a8:	88 23       	and	r24, r24
    74aa:	c1 f3       	breq	.-16     	; 0x749c <main+0x23a>
      copyRXstring();
    74ac:	0e 94 f7 27 	call	0x4fee	; 0x4fee <copyRXstring>
      commandCode = parseCommand();
    74b0:	0e 94 3d 21 	call	0x427a	; 0x427a <parseCommand>
    }

    switch(commandCode){
    74b4:	90 e0       	ldi	r25, 0x00	; 0
    74b6:	fc 01       	movw	r30, r24
    74b8:	e1 58       	subi	r30, 0x81	; 129
    74ba:	f0 40       	sbci	r31, 0x00	; 0
    74bc:	e4 32       	cpi	r30, 0x24	; 36
    74be:	f1 05       	cpc	r31, r1
    74c0:	68 f7       	brcc	.-38     	; 0x749c <main+0x23a>
    74c2:	e8 5a       	subi	r30, 0xA8	; 168
    74c4:	ff 4f       	sbci	r31, 0xFF	; 255
    74c6:	ee 0f       	add	r30, r30
    74c8:	ff 1f       	adc	r31, r31
    74ca:	05 90       	lpm	r0, Z+
    74cc:	f4 91       	lpm	r31, Z+
    74ce:	e0 2d       	mov	r30, r0
    74d0:	09 94       	ijmp
      case 0xA2:    /* GETDECAY */
        sendText(commandGetMotorDecay(commandParam[1]));
        break;

      case 0xA3:    /* SETDECAY */
        commandSetMotorDecay(commandParam[1], commandParam[2]);
    74d2:	e0 91 04 03 	lds	r30, 0x0304
    74d6:	f0 91 05 03 	lds	r31, 0x0305
    74da:	64 81       	ldd	r22, Z+4	; 0x04
    74dc:	75 81       	ldd	r23, Z+5	; 0x05
    74de:	82 81       	ldd	r24, Z+2	; 0x02
    74e0:	93 81       	ldd	r25, Z+3	; 0x03
    74e2:	0e 94 7e 2c 	call	0x58fc	; 0x58fc <commandSetMotorDecay>
    74e6:	da cf       	rjmp	.-76     	; 0x749c <main+0x23a>
      case 0xA1:    /* SETCURR */
        commandSetMotorCurrent(commandParam[1], commandParam[2]);
        break;
        
      case 0xA2:    /* GETDECAY */
        sendText(commandGetMotorDecay(commandParam[1]));
    74e8:	e0 91 04 03 	lds	r30, 0x0304
    74ec:	f0 91 05 03 	lds	r31, 0x0305
    74f0:	82 81       	ldd	r24, Z+2	; 0x02
    74f2:	93 81       	ldd	r25, Z+3	; 0x03
    74f4:	0e 94 99 12 	call	0x2532	; 0x2532 <commandGetMotorDecay>
    74f8:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    74fc:	cf cf       	rjmp	.-98     	; 0x749c <main+0x23a>
      case 0xA0:    /* GETCURR */
        sendText(commandGetMotorCurrent(commandParam[1]));
        break;

      case 0xA1:    /* SETCURR */
        commandSetMotorCurrent(commandParam[1], commandParam[2]);
    74fe:	e0 91 04 03 	lds	r30, 0x0304
    7502:	f0 91 05 03 	lds	r31, 0x0305
    7506:	64 81       	ldd	r22, Z+4	; 0x04
    7508:	75 81       	ldd	r23, Z+5	; 0x05
    750a:	82 81       	ldd	r24, Z+2	; 0x02
    750c:	93 81       	ldd	r25, Z+3	; 0x03
    750e:	0e 94 ef 28 	call	0x51de	; 0x51de <commandSetMotorCurrent>
    7512:	c4 cf       	rjmp	.-120    	; 0x749c <main+0x23a>
      case 0x9F:    /* LED */
        commandLED(commandParam[1], commandParam[2], commandParam[3]);
        break;
		
      case 0xA0:    /* GETCURR */
        sendText(commandGetMotorCurrent(commandParam[1]));
    7514:	e0 91 04 03 	lds	r30, 0x0304
    7518:	f0 91 05 03 	lds	r31, 0x0305
    751c:	82 81       	ldd	r24, Z+2	; 0x02
    751e:	93 81       	ldd	r25, Z+3	; 0x03
    7520:	0e 94 43 28 	call	0x5086	; 0x5086 <commandGetMotorCurrent>
    7524:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7528:	b9 cf       	rjmp	.-142    	; 0x749c <main+0x23a>
      case 0x9E:
        commandDebugReadout();
        break;

      case 0x9F:    /* LED */
        commandLED(commandParam[1], commandParam[2], commandParam[3]);
    752a:	e0 91 04 03 	lds	r30, 0x0304
    752e:	f0 91 05 03 	lds	r31, 0x0305
    7532:	64 81       	ldd	r22, Z+4	; 0x04
    7534:	75 81       	ldd	r23, Z+5	; 0x05
    7536:	46 81       	ldd	r20, Z+6	; 0x06
    7538:	57 81       	ldd	r21, Z+7	; 0x07
    753a:	82 81       	ldd	r24, Z+2	; 0x02
    753c:	93 81       	ldd	r25, Z+3	; 0x03
    753e:	0e 94 d8 21 	call	0x43b0	; 0x43b0 <commandLED>
    7542:	ac cf       	rjmp	.-168    	; 0x749c <main+0x23a>
      case 0x9D:    /* GETMOTSTATE */
        commandGetMotorState(commandParam[1]);
        break;

      case 0x9E:
        commandDebugReadout();
    7544:	0e 94 34 22 	call	0x4468	; 0x4468 <commandDebugReadout>
    7548:	a9 cf       	rjmp	.-174    	; 0x749c <main+0x23a>
        commandSetProgStep(commandParam[1], commandParam[2], commandParam[3],
                           commandParam[4], commandParam[5], commandParam[6]);
        break;

      case 0x9D:    /* GETMOTSTATE */
        commandGetMotorState(commandParam[1]);
    754a:	e0 91 04 03 	lds	r30, 0x0304
    754e:	f0 91 05 03 	lds	r31, 0x0305
    7552:	82 81       	ldd	r24, Z+2	; 0x02
    7554:	93 81       	ldd	r25, Z+3	; 0x03
    7556:	0e 94 e5 22 	call	0x45ca	; 0x45ca <commandGetMotorState>
    755a:	a0 cf       	rjmp	.-192    	; 0x749c <main+0x23a>
      case 0x9B:    /* ENABFORBZONE */
        commandEnableForbiddenZone(commandParam[1], commandParam[2]);
        break;

      case 0x9C:    /* SETPROGSTEP */
        commandSetProgStep(commandParam[1], commandParam[2], commandParam[3],
    755c:	e0 91 04 03 	lds	r30, 0x0304
    7560:	f0 91 05 03 	lds	r31, 0x0305
    7564:	64 81       	ldd	r22, Z+4	; 0x04
    7566:	75 81       	ldd	r23, Z+5	; 0x05
    7568:	46 81       	ldd	r20, Z+6	; 0x06
    756a:	57 81       	ldd	r21, Z+7	; 0x07
    756c:	20 85       	ldd	r18, Z+8	; 0x08
    756e:	31 85       	ldd	r19, Z+9	; 0x09
    7570:	02 85       	ldd	r16, Z+10	; 0x0a
    7572:	13 85       	ldd	r17, Z+11	; 0x0b
    7574:	e4 84       	ldd	r14, Z+12	; 0x0c
    7576:	f5 84       	ldd	r15, Z+13	; 0x0d
    7578:	82 81       	ldd	r24, Z+2	; 0x02
    757a:	93 81       	ldd	r25, Z+3	; 0x03
    757c:	0e 94 bd 1e 	call	0x3d7a	; 0x3d7a <commandSetProgStep>
    7580:	8d cf       	rjmp	.-230    	; 0x749c <main+0x23a>
      case 0x9A:    /* SETFORBZONE */
        commandSetForbiddenZone(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x9B:    /* ENABFORBZONE */
        commandEnableForbiddenZone(commandParam[1], commandParam[2]);
    7582:	e0 91 04 03 	lds	r30, 0x0304
    7586:	f0 91 05 03 	lds	r31, 0x0305
    758a:	64 81       	ldd	r22, Z+4	; 0x04
    758c:	75 81       	ldd	r23, Z+5	; 0x05
    758e:	82 81       	ldd	r24, Z+2	; 0x02
    7590:	93 81       	ldd	r25, Z+3	; 0x03
    7592:	0e 94 2b 23 	call	0x4656	; 0x4656 <commandEnableForbiddenZone>
    7596:	82 cf       	rjmp	.-252    	; 0x749c <main+0x23a>
          }
        }
        break;

      case 0x9A:    /* SETFORBZONE */
        commandSetForbiddenZone(commandParam[1], commandParam[2], commandParam[3]);
    7598:	e0 91 04 03 	lds	r30, 0x0304
    759c:	f0 91 05 03 	lds	r31, 0x0305
    75a0:	64 81       	ldd	r22, Z+4	; 0x04
    75a2:	75 81       	ldd	r23, Z+5	; 0x05
    75a4:	46 81       	ldd	r20, Z+6	; 0x06
    75a6:	57 81       	ldd	r21, Z+7	; 0x07
    75a8:	82 81       	ldd	r24, Z+2	; 0x02
    75aa:	93 81       	ldd	r25, Z+3	; 0x03
    75ac:	0e 94 61 23 	call	0x46c2	; 0x46c2 <commandSetForbiddenZone>
    75b0:	75 cf       	rjmp	.-278    	; 0x749c <main+0x23a>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    75b2:	f8 94       	cli
    75b4:	40 e0       	ldi	r20, 0x00	; 0
    75b6:	50 e0       	ldi	r21, 0x00	; 0
        break;

      case 0x99:    /* STOPALL */
        ATOMIC_BLOCK(ATOMIC_FORCEON){
          for(i = 0; i <= MAX_MOTOR; i++){
            motor[i].desiredPosition = motor[i].actualPosition;
    75b8:	fa 01       	movw	r30, r20
    75ba:	ee 0f       	add	r30, r30
    75bc:	ff 1f       	adc	r31, r31
    75be:	ee 0f       	add	r30, r30
    75c0:	ff 1f       	adc	r31, r31
    75c2:	ee 0f       	add	r30, r30
    75c4:	ff 1f       	adc	r31, r31
    75c6:	cf 01       	movw	r24, r30
    75c8:	88 0f       	add	r24, r24
    75ca:	99 1f       	adc	r25, r25
    75cc:	88 0f       	add	r24, r24
    75ce:	99 1f       	adc	r25, r25
    75d0:	e8 0f       	add	r30, r24
    75d2:	f9 1f       	adc	r31, r25
    75d4:	e2 5e       	subi	r30, 0xE2	; 226
    75d6:	fb 4f       	sbci	r31, 0xFB	; 251
    75d8:	20 81       	ld	r18, Z
    75da:	31 81       	ldd	r19, Z+1	; 0x01
    75dc:	fa 01       	movw	r30, r20
    75de:	ee 0f       	add	r30, r30
    75e0:	ff 1f       	adc	r31, r31
    75e2:	ee 0f       	add	r30, r30
    75e4:	ff 1f       	adc	r31, r31
    75e6:	cf 01       	movw	r24, r30
    75e8:	88 0f       	add	r24, r24
    75ea:	99 1f       	adc	r25, r25
    75ec:	88 0f       	add	r24, r24
    75ee:	99 1f       	adc	r25, r25
    75f0:	e8 0f       	add	r30, r24
    75f2:	f9 1f       	adc	r31, r25
    75f4:	ee 0f       	add	r30, r30
    75f6:	ff 1f       	adc	r31, r31
    75f8:	e0 5e       	subi	r30, 0xE0	; 224
    75fa:	fb 4f       	sbci	r31, 0xFB	; 251
    75fc:	31 83       	std	Z+1, r19	; 0x01
    75fe:	20 83       	st	Z, r18
            motor[i].isMovingInfinite = MOTOR_MOVE_INFINITE_STOP;
    7600:	fa 01       	movw	r30, r20
    7602:	ee 0f       	add	r30, r30
    7604:	ff 1f       	adc	r31, r31
    7606:	ee 0f       	add	r30, r30
    7608:	ff 1f       	adc	r31, r31
    760a:	ee 0f       	add	r30, r30
    760c:	ff 1f       	adc	r31, r31
    760e:	cf 01       	movw	r24, r30
    7610:	88 0f       	add	r24, r24
    7612:	99 1f       	adc	r25, r25
    7614:	88 0f       	add	r24, r24
    7616:	99 1f       	adc	r25, r25
    7618:	e8 0f       	add	r30, r24
    761a:	f9 1f       	adc	r31, r25
    761c:	e2 5e       	subi	r30, 0xE2	; 226
    761e:	fb 4f       	sbci	r31, 0xFB	; 251
    7620:	14 86       	std	Z+12, r1	; 0x0c
    7622:	4f 5f       	subi	r20, 0xFF	; 255
    7624:	5f 4f       	sbci	r21, 0xFF	; 255
        goto RESET;
        break;

      case 0x99:    /* STOPALL */
        ATOMIC_BLOCK(ATOMIC_FORCEON){
          for(i = 0; i <= MAX_MOTOR; i++){
    7626:	44 30       	cpi	r20, 0x04	; 4
    7628:	51 05       	cpc	r21, r1
    762a:	31 f6       	brne	.-116    	; 0x75b8 <main+0x356>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    762c:	78 94       	sei
    __asm__ volatile ("" ::: "memory");
    762e:	36 cf       	rjmp	.-404    	; 0x749c <main+0x23a>
      case 0x97:    /* SETCONSTSPEED */
        commandSetConstSpeed(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x98:    /* FACTORYRESET */
        commandFactoryReset();
    7630:	0e 94 80 0c 	call	0x1900	; 0x1900 <commandFactoryReset>
        cli();
    7634:	f8 94       	cli
        prepareReset();
    7636:	0e 94 57 2d 	call	0x5aae	; 0x5aae <prepareReset>
    763a:	fe ce       	rjmp	.-516    	; 0x7438 <main+0x1d6>
      case 0x96:    /* SETWAITTIME */
        commandSetWaitTime(commandParam[1], commandParam[2]);
        break;

      case 0x97:    /* SETCONSTSPEED */
        commandSetConstSpeed(commandParam[1], commandParam[2], commandParam[3]);
    763c:	e0 91 04 03 	lds	r30, 0x0304
    7640:	f0 91 05 03 	lds	r31, 0x0305
    7644:	64 81       	ldd	r22, Z+4	; 0x04
    7646:	75 81       	ldd	r23, Z+5	; 0x05
    7648:	46 81       	ldd	r20, Z+6	; 0x06
    764a:	57 81       	ldd	r21, Z+7	; 0x07
    764c:	82 81       	ldd	r24, Z+2	; 0x02
    764e:	93 81       	ldd	r25, Z+3	; 0x03
    7650:	0e 94 c2 23 	call	0x4784	; 0x4784 <commandSetConstSpeed>
    7654:	23 cf       	rjmp	.-442    	; 0x749c <main+0x23a>
      case 0x95:    /* GETWAITTIME */
        sendText(commandGetWaitTime(commandParam[1]));
        break;

      case 0x96:    /* SETWAITTIME */
        commandSetWaitTime(commandParam[1], commandParam[2]);
    7656:	e0 91 04 03 	lds	r30, 0x0304
    765a:	f0 91 05 03 	lds	r31, 0x0305
    765e:	64 81       	ldd	r22, Z+4	; 0x04
    7660:	75 81       	ldd	r23, Z+5	; 0x05
    7662:	82 81       	ldd	r24, Z+2	; 0x02
    7664:	93 81       	ldd	r25, Z+3	; 0x03
    7666:	0e 94 1e 25 	call	0x4a3c	; 0x4a3c <commandSetWaitTime>
    766a:	18 cf       	rjmp	.-464    	; 0x749c <main+0x23a>
      case 0x94:    /* SETSUBSTEPS */
        commandSetSubSteps(commandParam[1], commandParam[2]);
        break;

      case 0x95:    /* GETWAITTIME */
        sendText(commandGetWaitTime(commandParam[1]));
    766c:	e0 91 04 03 	lds	r30, 0x0304
    7670:	f0 91 05 03 	lds	r31, 0x0305
    7674:	82 81       	ldd	r24, Z+2	; 0x02
    7676:	93 81       	ldd	r25, Z+3	; 0x03
    7678:	0e 94 02 13 	call	0x2604	; 0x2604 <commandGetWaitTime>
    767c:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7680:	0d cf       	rjmp	.-486    	; 0x749c <main+0x23a>
      case 0x93:    /* GETSUBSTEPS */
        sendText(commandGetSubSteps(commandParam[1]));
        break;

      case 0x94:    /* SETSUBSTEPS */
        commandSetSubSteps(commandParam[1], commandParam[2]);
    7682:	e0 91 04 03 	lds	r30, 0x0304
    7686:	f0 91 05 03 	lds	r31, 0x0305
    768a:	64 81       	ldd	r22, Z+4	; 0x04
    768c:	75 81       	ldd	r23, Z+5	; 0x05
    768e:	82 81       	ldd	r24, Z+2	; 0x02
    7690:	93 81       	ldd	r25, Z+3	; 0x03
    7692:	0e 94 d4 2d 	call	0x5ba8	; 0x5ba8 <commandSetSubSteps>
    7696:	02 cf       	rjmp	.-508    	; 0x749c <main+0x23a>
      case 0x92:    /* SETFULLROT */
        commandSetFullRotation(commandParam[1], commandParam[2]);
        break;

      case 0x93:    /* GETSUBSTEPS */
        sendText(commandGetSubSteps(commandParam[1]));
    7698:	e0 91 04 03 	lds	r30, 0x0304
    769c:	f0 91 05 03 	lds	r31, 0x0305
    76a0:	82 81       	ldd	r24, Z+2	; 0x02
    76a2:	93 81       	ldd	r25, Z+3	; 0x03
    76a4:	0e 94 69 13 	call	0x26d2	; 0x26d2 <commandGetSubSteps>
    76a8:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    76ac:	f7 ce       	rjmp	.-530    	; 0x749c <main+0x23a>
      case 0x91:    /* GETFULLROT */
        sendText(commandGetFullRotation(commandParam[1]));
        break;

      case 0x92:    /* SETFULLROT */
        commandSetFullRotation(commandParam[1], commandParam[2]);
    76ae:	e0 91 04 03 	lds	r30, 0x0304
    76b2:	f0 91 05 03 	lds	r31, 0x0305
    76b6:	64 81       	ldd	r22, Z+4	; 0x04
    76b8:	75 81       	ldd	r23, Z+5	; 0x05
    76ba:	82 81       	ldd	r24, Z+2	; 0x02
    76bc:	93 81       	ldd	r25, Z+3	; 0x03
    76be:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <commandSetFullRotation>
    76c2:	ec ce       	rjmp	.-552    	; 0x749c <main+0x23a>
      case 0x90:    /* SETGEARRATIO */
        commandSetGearRatio(commandParam[1], commandParam[2]);
        break;

      case 0x91:    /* GETFULLROT */
        sendText(commandGetFullRotation(commandParam[1]));
    76c4:	e0 91 04 03 	lds	r30, 0x0304
    76c8:	f0 91 05 03 	lds	r31, 0x0305
    76cc:	82 81       	ldd	r24, Z+2	; 0x02
    76ce:	93 81       	ldd	r25, Z+3	; 0x03
    76d0:	0e 94 d9 13 	call	0x27b2	; 0x27b2 <commandGetFullRotation>
    76d4:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    76d8:	e1 ce       	rjmp	.-574    	; 0x749c <main+0x23a>
      case 0x8F:    /* GETGEARRATIO */
        sendText(commandGetGearRatio(commandParam[1]));
        break;

      case 0x90:    /* SETGEARRATIO */
        commandSetGearRatio(commandParam[1], commandParam[2]);
    76da:	e0 91 04 03 	lds	r30, 0x0304
    76de:	f0 91 05 03 	lds	r31, 0x0305
    76e2:	64 81       	ldd	r22, Z+4	; 0x04
    76e4:	75 81       	ldd	r23, Z+5	; 0x05
    76e6:	82 81       	ldd	r24, Z+2	; 0x02
    76e8:	93 81       	ldd	r25, Z+3	; 0x03
    76ea:	0e 94 ac 25 	call	0x4b58	; 0x4b58 <commandSetGearRatio>
    76ee:	d6 ce       	rjmp	.-596    	; 0x749c <main+0x23a>
      case 0x8E:    /* SETZEROPOS */
        commandSetOptZeroPos(commandParam[1], commandParam[2]);
        break;

      case 0x8F:    /* GETGEARRATIO */
        sendText(commandGetGearRatio(commandParam[1]));
    76f0:	e0 91 04 03 	lds	r30, 0x0304
    76f4:	f0 91 05 03 	lds	r31, 0x0305
    76f8:	82 81       	ldd	r24, Z+2	; 0x02
    76fa:	93 81       	ldd	r25, Z+3	; 0x03
    76fc:	0e 94 49 14 	call	0x2892	; 0x2892 <commandGetGearRatio>
    7700:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7704:	cb ce       	rjmp	.-618    	; 0x749c <main+0x23a>
      case 0x8D:    /* GETZEROPOS */
        sendText(commandGetOptZeroPos(commandParam[1]));
        break;

      case 0x8E:    /* SETZEROPOS */
        commandSetOptZeroPos(commandParam[1], commandParam[2]);
    7706:	e0 91 04 03 	lds	r30, 0x0304
    770a:	f0 91 05 03 	lds	r31, 0x0305
    770e:	64 81       	ldd	r22, Z+4	; 0x04
    7710:	75 81       	ldd	r23, Z+5	; 0x05
    7712:	82 81       	ldd	r24, Z+2	; 0x02
    7714:	93 81       	ldd	r25, Z+3	; 0x03
    7716:	0e 94 00 26 	call	0x4c00	; 0x4c00 <commandSetOptZeroPos>
    771a:	c0 ce       	rjmp	.-640    	; 0x749c <main+0x23a>
      case 0x8C:    /* GETANALOG */
        sendText(commandGetAnalog(commandParam[1]));
        break;

      case 0x8D:    /* GETZEROPOS */
        sendText(commandGetOptZeroPos(commandParam[1]));
    771c:	e0 91 04 03 	lds	r30, 0x0304
    7720:	f0 91 05 03 	lds	r31, 0x0305
    7724:	82 81       	ldd	r24, Z+2	; 0x02
    7726:	93 81       	ldd	r25, Z+3	; 0x03
    7728:	0e 94 b9 14 	call	0x2972	; 0x2972 <commandGetOptZeroPos>
    772c:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7730:	b5 ce       	rjmp	.-662    	; 0x749c <main+0x23a>
      case 0x8B:    /* ISMOVING */
        sendText(commandIsMoving(commandParam[1]));
        break;

      case 0x8C:    /* GETANALOG */
        sendText(commandGetAnalog(commandParam[1]));
    7732:	e0 91 04 03 	lds	r30, 0x0304
    7736:	f0 91 05 03 	lds	r31, 0x0305
    773a:	82 81       	ldd	r24, Z+2	; 0x02
    773c:	93 81       	ldd	r25, Z+3	; 0x03
    773e:	0e 94 22 15 	call	0x2a44	; 0x2a44 <commandGetAnalog>
    7742:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7746:	aa ce       	rjmp	.-684    	; 0x749c <main+0x23a>
        loadConfigFromEEPROM();
        updateIICvalues();
        break;

      case 0x8B:    /* ISMOVING */
        sendText(commandIsMoving(commandParam[1]));
    7748:	e0 91 04 03 	lds	r30, 0x0304
    774c:	f0 91 05 03 	lds	r31, 0x0305
    7750:	82 81       	ldd	r24, Z+2	; 0x02
    7752:	93 81       	ldd	r25, Z+3	; 0x03
    7754:	0e 94 79 15 	call	0x2af2	; 0x2af2 <commandIsMoving>
    7758:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    775c:	9f ce       	rjmp	.-706    	; 0x749c <main+0x23a>
      case 0x89:    /* SAVECONF: save current machine configuration */
        saveConfigToEEPROM();
        break;

      case 0x8A:    /* LOADCONF: load last saved machine configuration */
        loadConfigFromEEPROM();
    775e:	0e 94 e2 0a 	call	0x15c4	; 0x15c4 <loadConfigFromEEPROM>
        updateIICvalues();
    7762:	0e 94 1d 2e 	call	0x5c3a	; 0x5c3a <updateIICvalues>
    7766:	9a ce       	rjmp	.-716    	; 0x749c <main+0x23a>
      case 0x88:    /* GETPOS --> get position in [unit] */
        sendText(commandGetMotorPosition(commandParam[1], commandParam[2]));
        break;

      case 0x89:    /* SAVECONF: save current machine configuration */
        saveConfigToEEPROM();
    7768:	0e 94 bb 0b 	call	0x1776	; 0x1776 <saveConfigToEEPROM>
    776c:	97 ce       	rjmp	.-722    	; 0x749c <main+0x23a>
      case 0x87:    /* ENABLE */
        commandEnable(commandParam[1], commandParam[2]);
        break;

      case 0x88:    /* GETPOS --> get position in [unit] */
        sendText(commandGetMotorPosition(commandParam[1], commandParam[2]));
    776e:	e0 91 04 03 	lds	r30, 0x0304
    7772:	f0 91 05 03 	lds	r31, 0x0305
    7776:	64 81       	ldd	r22, Z+4	; 0x04
    7778:	75 81       	ldd	r23, Z+5	; 0x05
    777a:	82 81       	ldd	r24, Z+2	; 0x02
    777c:	93 81       	ldd	r25, Z+3	; 0x03
    777e:	0e 94 f3 1f 	call	0x3fe6	; 0x3fe6 <commandGetMotorPosition>
    7782:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7786:	8a ce       	rjmp	.-748    	; 0x749c <main+0x23a>
      case 0x86:    /* ZERORUN */
        motorZeroRun((uint8_t)atoi(commandParam[1]));
        break;

      case 0x87:    /* ENABLE */
        commandEnable(commandParam[1], commandParam[2]);
    7788:	e0 91 04 03 	lds	r30, 0x0304
    778c:	f0 91 05 03 	lds	r31, 0x0305
    7790:	64 81       	ldd	r22, Z+4	; 0x04
    7792:	75 81       	ldd	r23, Z+5	; 0x05
    7794:	82 81       	ldd	r24, Z+2	; 0x02
    7796:	93 81       	ldd	r25, Z+3	; 0x03
    7798:	0e 94 28 2d 	call	0x5a50	; 0x5a50 <commandEnable>
    779c:	7f ce       	rjmp	.-770    	; 0x749c <main+0x23a>
      case 0x85:    /* MOVEREL */
        commandMoveRel(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x86:    /* ZERORUN */
        motorZeroRun((uint8_t)atoi(commandParam[1]));
    779e:	e0 91 04 03 	lds	r30, 0x0304
    77a2:	f0 91 05 03 	lds	r31, 0x0305
    77a6:	82 81       	ldd	r24, Z+2	; 0x02
    77a8:	93 81       	ldd	r25, Z+3	; 0x03
    77aa:	0e 94 13 48 	call	0x9026	; 0x9026 <atoi>
    77ae:	0e 94 52 2b 	call	0x56a4	; 0x56a4 <motorZeroRun>
    77b2:	74 ce       	rjmp	.-792    	; 0x749c <main+0x23a>
      case 0x84:    /* MOVEABS */
        commandMoveAbs(commandParam[1], commandParam[2], commandParam[3]);
        break;

      case 0x85:    /* MOVEREL */
        commandMoveRel(commandParam[1], commandParam[2], commandParam[3]);
    77b4:	e0 91 04 03 	lds	r30, 0x0304
    77b8:	f0 91 05 03 	lds	r31, 0x0305
    77bc:	64 81       	ldd	r22, Z+4	; 0x04
    77be:	75 81       	ldd	r23, Z+5	; 0x05
    77c0:	46 81       	ldd	r20, Z+6	; 0x06
    77c2:	57 81       	ldd	r21, Z+7	; 0x07
    77c4:	82 81       	ldd	r24, Z+2	; 0x02
    77c6:	93 81       	ldd	r25, Z+3	; 0x03
    77c8:	0e 94 58 26 	call	0x4cb0	; 0x4cb0 <commandMoveRel>
    77cc:	67 ce       	rjmp	.-818    	; 0x749c <main+0x23a>
        }
        eeprom_update_block((const void*)commandParam[1], (void*)IDNtext, IDN_STRING_LENGTH + 1);
        break;

      case 0x84:    /* MOVEABS */
        commandMoveAbs(commandParam[1], commandParam[2], commandParam[3]);
    77ce:	e0 91 04 03 	lds	r30, 0x0304
    77d2:	f0 91 05 03 	lds	r31, 0x0305
    77d6:	64 81       	ldd	r22, Z+4	; 0x04
    77d8:	75 81       	ldd	r23, Z+5	; 0x05
    77da:	46 81       	ldd	r20, Z+6	; 0x06
    77dc:	57 81       	ldd	r21, Z+7	; 0x07
    77de:	82 81       	ldd	r24, Z+2	; 0x02
    77e0:	93 81       	ldd	r25, Z+3	; 0x03
    77e2:	0e 94 da 26 	call	0x4db4	; 0x4db4 <commandMoveAbs>
    77e6:	5a ce       	rjmp	.-844    	; 0x749c <main+0x23a>
        eeprom_read_block((void*)txString.buffer, (const void*)IDNtext, IDN_STRING_LENGTH + 1);
        sendText(txString.buffer);
        break;

      case 0x83:    /* set IDN */
        if(strlen(commandParam[1]) > IDN_STRING_LENGTH){
    77e8:	e0 91 04 03 	lds	r30, 0x0304
    77ec:	f0 91 05 03 	lds	r31, 0x0305
    77f0:	82 81       	ldd	r24, Z+2	; 0x02
    77f2:	93 81       	ldd	r25, Z+3	; 0x03
    77f4:	dc 01       	movw	r26, r24
    77f6:	fd 01       	movw	r30, r26
    77f8:	01 90       	ld	r0, Z+
    77fa:	00 20       	and	r0, r0
    77fc:	e9 f7       	brne	.-6      	; 0x77f8 <main+0x596>
    77fe:	31 97       	sbiw	r30, 0x01	; 1
    7800:	ea 1b       	sub	r30, r26
    7802:	fb 0b       	sbc	r31, r27
    7804:	f3 97       	sbiw	r30, 0x33	; 51
    7806:	08 f0       	brcs	.+2      	; 0x780a <main+0x5a8>
    7808:	49 ce       	rjmp	.-878    	; 0x749c <main+0x23a>
          break;
        }
        eeprom_update_block((const void*)commandParam[1], (void*)IDNtext, IDN_STRING_LENGTH + 1);
    780a:	60 e0       	ldi	r22, 0x00	; 0
    780c:	70 e0       	ldi	r23, 0x00	; 0
    780e:	43 e3       	ldi	r20, 0x33	; 51
    7810:	50 e0       	ldi	r21, 0x00	; 0
    7812:	0e 94 3d 4a 	call	0x947a	; 0x947a <__eeupd_block_m1284p>
    7816:	42 ce       	rjmp	.-892    	; 0x749c <main+0x23a>
        prepareReset();
        goto RESET;
        break;

      case 0x82:    /* *IDN? */
        eeprom_read_block((void*)txString.buffer, (const void*)IDNtext, IDN_STRING_LENGTH + 1);
    7818:	80 91 15 04 	lds	r24, 0x0415
    781c:	90 91 16 04 	lds	r25, 0x0416
    7820:	60 e0       	ldi	r22, 0x00	; 0
    7822:	70 e0       	ldi	r23, 0x00	; 0
    7824:	43 e3       	ldi	r20, 0x33	; 51
    7826:	50 e0       	ldi	r21, 0x00	; 0
    7828:	0e 94 2d 4a 	call	0x945a	; 0x945a <__eerd_block_m1284p>
        sendText(txString.buffer);
    782c:	80 91 15 04 	lds	r24, 0x0415
    7830:	90 91 16 04 	lds	r25, 0x0416
    7834:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7838:	31 ce       	rjmp	.-926    	; 0x749c <main+0x23a>
      case 0x80:    /* no or unknown command, ignore it */
        break;

      case 0x81:    /* *RST */
        //sendText("reset\0");
        cli();
    783a:	f8 94       	cli
        prepareReset();
    783c:	0e 94 57 2d 	call	0x5aae	; 0x5aae <prepareReset>
    7840:	fb cd       	rjmp	.-1034   	; 0x7438 <main+0x1d6>
      case 0xA3:    /* SETDECAY */
        commandSetMotorDecay(commandParam[1], commandParam[2]);
        break;
        
      case 0xA4:    /* ISCON */
        sendText(commandIsConnected(commandParam[1]));
    7842:	e0 91 04 03 	lds	r30, 0x0304
    7846:	f0 91 05 03 	lds	r31, 0x0305
    784a:	82 81       	ldd	r24, Z+2	; 0x02
    784c:	93 81       	ldd	r25, Z+3	; 0x03
    784e:	0e 94 c3 2a 	call	0x5586	; 0x5586 <commandIsConnected>
    7852:	0e 94 b9 21 	call	0x4372	; 0x4372 <sendText>
    7856:	22 ce       	rjmp	.-956    	; 0x749c <main+0x23a>

00007858 <OLEDpinMode>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDpinMode(uint8_t pin, uint8_t mode){
    7858:	38 2f       	mov	r19, r24

  if (mode) {
    785a:	66 23       	and	r22, r22
    785c:	61 f4       	brne	.+24     	; 0x7876 <OLEDpinMode+0x1e>
    LCD_DDR |= (1 << pin);
  } //output
  else {
    LCD_DDR &= ~(1 << pin);
    785e:	24 b1       	in	r18, 0x04	; 4
    7860:	81 e0       	ldi	r24, 0x01	; 1
    7862:	90 e0       	ldi	r25, 0x00	; 0
    7864:	02 c0       	rjmp	.+4      	; 0x786a <OLEDpinMode+0x12>
    7866:	88 0f       	add	r24, r24
    7868:	99 1f       	adc	r25, r25
    786a:	3a 95       	dec	r19
    786c:	e2 f7       	brpl	.-8      	; 0x7866 <OLEDpinMode+0xe>
    786e:	80 95       	com	r24
    7870:	82 23       	and	r24, r18
    7872:	84 b9       	out	0x04, r24	; 4
    7874:	08 95       	ret
    unknown
 --------------------------------------------------------------------- */
void OLEDpinMode(uint8_t pin, uint8_t mode){

  if (mode) {
    LCD_DDR |= (1 << pin);
    7876:	24 b1       	in	r18, 0x04	; 4
    7878:	81 e0       	ldi	r24, 0x01	; 1
    787a:	90 e0       	ldi	r25, 0x00	; 0
    787c:	02 c0       	rjmp	.+4      	; 0x7882 <OLEDpinMode+0x2a>
    787e:	88 0f       	add	r24, r24
    7880:	99 1f       	adc	r25, r25
    7882:	3a 95       	dec	r19
    7884:	e2 f7       	brpl	.-8      	; 0x787e <OLEDpinMode+0x26>
    7886:	28 2b       	or	r18, r24
    7888:	24 b9       	out	0x04, r18	; 4
    788a:	08 95       	ret

0000788c <OLEDdigitalWrite>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDdigitalWrite(uint8_t pin,uint8_t value){
    788c:	38 2f       	mov	r19, r24

  if (value == LOW) {
    788e:	66 23       	and	r22, r22
    7890:	59 f0       	breq	.+22     	; 0x78a8 <OLEDdigitalWrite+0x1c>
    LCD_PORT &= ~(1 << pin);
  } //If low, write 0
  else {
    LCD_PORT |= (1 << pin);
    7892:	25 b1       	in	r18, 0x05	; 5
    7894:	81 e0       	ldi	r24, 0x01	; 1
    7896:	90 e0       	ldi	r25, 0x00	; 0
    7898:	02 c0       	rjmp	.+4      	; 0x789e <OLEDdigitalWrite+0x12>
    789a:	88 0f       	add	r24, r24
    789c:	99 1f       	adc	r25, r25
    789e:	3a 95       	dec	r19
    78a0:	e2 f7       	brpl	.-8      	; 0x789a <OLEDdigitalWrite+0xe>
    78a2:	28 2b       	or	r18, r24
    78a4:	25 b9       	out	0x05, r18	; 5
    78a6:	08 95       	ret
    unknown
 --------------------------------------------------------------------- */
void OLEDdigitalWrite(uint8_t pin,uint8_t value){

  if (value == LOW) {
    LCD_PORT &= ~(1 << pin);
    78a8:	25 b1       	in	r18, 0x05	; 5
    78aa:	81 e0       	ldi	r24, 0x01	; 1
    78ac:	90 e0       	ldi	r25, 0x00	; 0
    78ae:	02 c0       	rjmp	.+4      	; 0x78b4 <OLEDdigitalWrite+0x28>
    78b0:	88 0f       	add	r24, r24
    78b2:	99 1f       	adc	r25, r25
    78b4:	3a 95       	dec	r19
    78b6:	e2 f7       	brpl	.-8      	; 0x78b0 <OLEDdigitalWrite+0x24>
    78b8:	80 95       	com	r24
    78ba:	82 23       	and	r24, r18
    78bc:	85 b9       	out	0x05, r24	; 5
    78be:	08 95       	ret

000078c0 <OLEDdigitalRead>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
uint8_t OLEDdigitalRead(uint8_t pin){

  return (LCD_PIN & (1 << pin));
    78c0:	93 b1       	in	r25, 0x03	; 3
    78c2:	21 e0       	ldi	r18, 0x01	; 1
    78c4:	30 e0       	ldi	r19, 0x00	; 0
    78c6:	02 c0       	rjmp	.+4      	; 0x78cc <OLEDdigitalRead+0xc>
    78c8:	22 0f       	add	r18, r18
    78ca:	33 1f       	adc	r19, r19
    78cc:	8a 95       	dec	r24
    78ce:	e2 f7       	brpl	.-8      	; 0x78c8 <OLEDdigitalRead+0x8>
}
    78d0:	89 2f       	mov	r24, r25
    78d2:	82 23       	and	r24, r18
    78d4:	08 95       	ret

000078d6 <OLEDpulseEnable>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDpulseEnable(void){

  OLEDdigitalWrite(_enable_pin, HIGH);
    78d6:	83 e0       	ldi	r24, 0x03	; 3
    78d8:	61 e0       	ldi	r22, 0x01	; 1
    78da:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
    78de:	8a ef       	ldi	r24, 0xFA	; 250
    78e0:	90 e0       	ldi	r25, 0x00	; 0
    78e2:	01 97       	sbiw	r24, 0x01	; 1
    78e4:	f1 f7       	brne	.-4      	; 0x78e2 <OLEDpulseEnable+0xc>
  _delay_us(50);    // TODO: Timing Spec?
  OLEDdigitalWrite(_enable_pin, LOW);
    78e6:	83 e0       	ldi	r24, 0x03	; 3
    78e8:	60 e0       	ldi	r22, 0x00	; 0
    78ea:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
}
    78ee:	08 95       	ret

000078f0 <OLEDwrite4bits>:

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDwrite4bits(uint8_t value){
    78f0:	ef 92       	push	r14
    78f2:	ff 92       	push	r15
    78f4:	0f 93       	push	r16
    78f6:	1f 93       	push	r17
    78f8:	cf 93       	push	r28
    78fa:	df 93       	push	r29
    78fc:	e8 2e       	mov	r14, r24
    78fe:	ff 24       	eor	r15, r15
    7900:	03 ef       	ldi	r16, 0xF3	; 243
    7902:	13 e0       	ldi	r17, 0x03	; 3
    7904:	c0 e0       	ldi	r28, 0x00	; 0
    7906:	d0 e0       	ldi	r29, 0x00	; 0

  for(int i = 0; i < 4; i++){
    OLEDpinMode(_data_pins[i], OUTPUT);
    7908:	f8 01       	movw	r30, r16
    790a:	80 81       	ld	r24, Z
    790c:	61 e0       	ldi	r22, 0x01	; 1
    790e:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
    OLEDdigitalWrite(_data_pins[i], (value >> i) & 0x01);
    7912:	b7 01       	movw	r22, r14
    7914:	0c 2e       	mov	r0, r28
    7916:	02 c0       	rjmp	.+4      	; 0x791c <OLEDwrite4bits+0x2c>
    7918:	75 95       	asr	r23
    791a:	67 95       	ror	r22
    791c:	0a 94       	dec	r0
    791e:	e2 f7       	brpl	.-8      	; 0x7918 <OLEDwrite4bits+0x28>
    7920:	61 70       	andi	r22, 0x01	; 1
    7922:	f8 01       	movw	r30, r16
    7924:	81 91       	ld	r24, Z+
    7926:	8f 01       	movw	r16, r30
    7928:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDwrite4bits(uint8_t value){

  for(int i = 0; i < 4; i++){
    792c:	21 96       	adiw	r28, 0x01	; 1
    792e:	c4 30       	cpi	r28, 0x04	; 4
    7930:	d1 05       	cpc	r29, r1
    7932:	51 f7       	brne	.-44     	; 0x7908 <OLEDwrite4bits+0x18>
    7934:	8a ef       	ldi	r24, 0xFA	; 250
    7936:	90 e0       	ldi	r25, 0x00	; 0
    7938:	01 97       	sbiw	r24, 0x01	; 1
    793a:	f1 f7       	brne	.-4      	; 0x7938 <OLEDwrite4bits+0x48>
    OLEDpinMode(_data_pins[i], OUTPUT);
    OLEDdigitalWrite(_data_pins[i], (value >> i) & 0x01);
  }

  _delay_us(50); // Timing spec?
  OLEDpulseEnable();
    793c:	0e 94 6b 3c 	call	0x78d6	; 0x78d6 <OLEDpulseEnable>
}
    7940:	df 91       	pop	r29
    7942:	cf 91       	pop	r28
    7944:	1f 91       	pop	r17
    7946:	0f 91       	pop	r16
    7948:	ff 90       	pop	r15
    794a:	ef 90       	pop	r14
    794c:	08 95       	ret

0000794e <OLEDsend>:
}

/* ---------------------------------------------------------------------
    write either command or data
 --------------------------------------------------------------------- */
void OLEDsend(uint8_t value, uint8_t mode){
    794e:	1f 93       	push	r17
    7950:	18 2f       	mov	r17, r24

  OLEDdigitalWrite(rs_pin, mode);
    7952:	81 e0       	ldi	r24, 0x01	; 1
    7954:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
  OLEDpinMode(_rw_pin, OUTPUT);
    7958:	82 e0       	ldi	r24, 0x02	; 2
    795a:	61 e0       	ldi	r22, 0x01	; 1
    795c:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
  OLEDdigitalWrite(_rw_pin, LOW);
    7960:	82 e0       	ldi	r24, 0x02	; 2
    7962:	60 e0       	ldi	r22, 0x00	; 0
    7964:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>

  OLEDwrite4bits(value >> 4);
    7968:	81 2f       	mov	r24, r17
    796a:	82 95       	swap	r24
    796c:	8f 70       	andi	r24, 0x0F	; 15
    796e:	0e 94 78 3c 	call	0x78f0	; 0x78f0 <OLEDwrite4bits>
  OLEDwrite4bits(value);
    7972:	81 2f       	mov	r24, r17
    7974:	0e 94 78 3c 	call	0x78f0	; 0x78f0 <OLEDwrite4bits>
}
    7978:	1f 91       	pop	r17
    797a:	08 95       	ret

0000797c <OLEDwaitForReady>:
}

/* ---------------------------------------------------------------------
    Poll the busy bit until it goes LOW
 --------------------------------------------------------------------- */
void OLEDwaitForReady(void){
    797c:	0f 93       	push	r16
    797e:	1f 93       	push	r17

  unsigned char busy = 1;
  OLEDpinMode(_busy_pin, INPUT);
    7980:	87 e0       	ldi	r24, 0x07	; 7
    7982:	60 e0       	ldi	r22, 0x00	; 0
    7984:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
  OLEDdigitalWrite(rs_pin, LOW);
    7988:	81 e0       	ldi	r24, 0x01	; 1
    798a:	60 e0       	ldi	r22, 0x00	; 0
    798c:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, HIGH);
    7990:	82 e0       	ldi	r24, 0x02	; 2
    7992:	61 e0       	ldi	r22, 0x01	; 1
    7994:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    7998:	02 e4       	ldi	r16, 0x42	; 66

  do{
    OLEDdigitalWrite(_enable_pin, LOW);
    799a:	83 e0       	ldi	r24, 0x03	; 3
    799c:	60 e0       	ldi	r22, 0x00	; 0
    799e:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
    OLEDdigitalWrite(_enable_pin, HIGH);
    79a2:	83 e0       	ldi	r24, 0x03	; 3
    79a4:	61 e0       	ldi	r22, 0x01	; 1
    79a6:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
    79aa:	80 2f       	mov	r24, r16
    79ac:	8a 95       	dec	r24
    79ae:	f1 f7       	brne	.-4      	; 0x79ac <OLEDwaitForReady+0x30>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
uint8_t OLEDdigitalRead(uint8_t pin){

  return (LCD_PIN & (1 << pin));
    79b0:	13 b1       	in	r17, 0x03	; 3
    OLEDdigitalWrite(_enable_pin, LOW);
    OLEDdigitalWrite(_enable_pin, HIGH);

    _delay_us(10);
    busy = OLEDdigitalRead(_busy_pin);
    OLEDdigitalWrite(_enable_pin, LOW);
    79b2:	83 e0       	ldi	r24, 0x03	; 3
    79b4:	60 e0       	ldi	r22, 0x00	; 0
    79b6:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>

    OLEDpulseEnable();    // get remaining 4 bits, which are not used.
    79ba:	0e 94 6b 3c 	call	0x78d6	; 0x78d6 <OLEDpulseEnable>
  } while(busy);
    79be:	17 fd       	sbrc	r17, 7
    79c0:	ec cf       	rjmp	.-40     	; 0x799a <OLEDwaitForReady+0x1e>

  OLEDpinMode(_busy_pin, OUTPUT);
    79c2:	87 e0       	ldi	r24, 0x07	; 7
    79c4:	61 e0       	ldi	r22, 0x01	; 1
    79c6:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
  OLEDdigitalWrite(_rw_pin, LOW);
    79ca:	82 e0       	ldi	r24, 0x02	; 2
    79cc:	60 e0       	ldi	r22, 0x00	; 0
    79ce:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
}
    79d2:	1f 91       	pop	r17
    79d4:	0f 91       	pop	r16
    79d6:	08 95       	ret

000079d8 <OLEDwriteC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    79d8:	61 e0       	ldi	r22, 0x01	; 1
    79da:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    79de:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
}
    79e2:	08 95       	ret

000079e4 <OLEDcommand>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    79e4:	60 e0       	ldi	r22, 0x00	; 0
    79e6:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    79ea:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
}
    79ee:	08 95       	ret

000079f0 <OLEDwriteCCC>:
}

/* ---------------------------------------------------------------------
    send a string with length to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCCC(const uint8_t *buffer, size_t size){
    79f0:	0f 93       	push	r16
    79f2:	1f 93       	push	r17
    79f4:	cf 93       	push	r28
    79f6:	df 93       	push	r29
    79f8:	8c 01       	movw	r16, r24
    79fa:	eb 01       	movw	r28, r22

  size_t n = 0;
  while(size--){
    79fc:	61 15       	cp	r22, r1
    79fe:	71 05       	cpc	r23, r1
    7a00:	51 f0       	breq	.+20     	; 0x7a16 <OLEDwriteCCC+0x26>
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    7a02:	f8 01       	movw	r30, r16
    7a04:	81 91       	ld	r24, Z+
    7a06:	8f 01       	movw	r16, r30
    7a08:	61 e0       	ldi	r22, 0x01	; 1
    7a0a:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7a0e:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    7a12:	21 97       	sbiw	r28, 0x01	; 1
    send a string with length to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCCC(const uint8_t *buffer, size_t size){

  size_t n = 0;
  while(size--){
    7a14:	b1 f7       	brne	.-20     	; 0x7a02 <OLEDwriteCCC+0x12>
    n += OLEDwriteC(*buffer++);
  }

  return n;
}
    7a16:	80 e0       	ldi	r24, 0x00	; 0
    7a18:	90 e0       	ldi	r25, 0x00	; 0
    7a1a:	df 91       	pop	r29
    7a1c:	cf 91       	pop	r28
    7a1e:	1f 91       	pop	r17
    7a20:	0f 91       	pop	r16
    7a22:	08 95       	ret

00007a24 <OLEDwriteCC>:
/* ---------------------------------------------------------------------
    send a string to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCC(const char *str){

  if(str == NULL){
    7a24:	00 97       	sbiw	r24, 0x00	; 0
    7a26:	69 f0       	breq	.+26     	; 0x7a42 <OLEDwriteCC+0x1e>
    return 0;
  }

  return OLEDwriteCCC((const uint8_t *)str, strlen(str));
    7a28:	fc 01       	movw	r30, r24
    7a2a:	01 90       	ld	r0, Z+
    7a2c:	00 20       	and	r0, r0
    7a2e:	e9 f7       	brne	.-6      	; 0x7a2a <OLEDwriteCC+0x6>
    7a30:	31 97       	sbiw	r30, 0x01	; 1
    7a32:	e8 1b       	sub	r30, r24
    7a34:	f9 0b       	sbc	r31, r25
    7a36:	bf 01       	movw	r22, r30
    7a38:	0e 94 f8 3c 	call	0x79f0	; 0x79f0 <OLEDwriteCCC>
    7a3c:	9c 01       	movw	r18, r24
}
    7a3e:	c9 01       	movw	r24, r18
    7a40:	08 95       	ret
/* ---------------------------------------------------------------------
    send a string to the display
 --------------------------------------------------------------------- */
size_t OLEDwriteCC(const char *str){

  if(str == NULL){
    7a42:	20 e0       	ldi	r18, 0x00	; 0
    7a44:	30 e0       	ldi	r19, 0x00	; 0
    return 0;
  }

  return OLEDwriteCCC((const uint8_t *)str, strlen(str));
}
    7a46:	c9 01       	movw	r24, r18
    7a48:	08 95       	ret

00007a4a <OLEDprintCC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
size_t OLEDprintCC(const char str[]){

  return OLEDwriteCC(str);
    7a4a:	0e 94 12 3d 	call	0x7a24	; 0x7a24 <OLEDwriteCC>
}
    7a4e:	08 95       	ret

00007a50 <OLEDprintC>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    7a50:	61 e0       	ldi	r22, 0x01	; 1
    7a52:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7a56:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    unknown
 --------------------------------------------------------------------- */
size_t OLEDprintC(char c){

  return OLEDwriteC(c);
}
    7a5a:	80 e0       	ldi	r24, 0x00	; 0
    7a5c:	90 e0       	ldi	r25, 0x00	; 0
    7a5e:	08 95       	ret

00007a60 <OLEDcreateChar>:

/* ---------------------------------------------------------------------
    Allows us to fill the first 8 CGRAM locations
    with custom characters
 --------------------------------------------------------------------- */
void OLEDcreateChar(uint8_t location, uint8_t charmap[]){
    7a60:	0f 93       	push	r16
    7a62:	1f 93       	push	r17
    7a64:	cf 93       	push	r28
    7a66:	df 93       	push	r29
    7a68:	8b 01       	movw	r16, r22
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7a6a:	87 70       	andi	r24, 0x07	; 7
    7a6c:	88 0f       	add	r24, r24
    7a6e:	88 0f       	add	r24, r24
    7a70:	88 0f       	add	r24, r24
    7a72:	80 64       	ori	r24, 0x40	; 64
    7a74:	60 e0       	ldi	r22, 0x00	; 0
    7a76:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7a7a:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    7a7e:	c0 e0       	ldi	r28, 0x00	; 0
    7a80:	d0 e0       	ldi	r29, 0x00	; 0
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
inline size_t OLEDwriteC(uint8_t value){

  OLEDsend(value, HIGH);
    7a82:	f8 01       	movw	r30, r16
    7a84:	ec 0f       	add	r30, r28
    7a86:	fd 1f       	adc	r31, r29
    7a88:	80 81       	ld	r24, Z
    7a8a:	61 e0       	ldi	r22, 0x01	; 1
    7a8c:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7a90:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDcreateChar(uint8_t location, uint8_t charmap[]){

  location &= 0x7; // we only have 8 locations 0-7
  OLEDcommand(LCD_SETCGRAMADDR | (location << 3));
  for (int i=0; i<8; i++){
    7a94:	21 96       	adiw	r28, 0x01	; 1
    7a96:	c8 30       	cpi	r28, 0x08	; 8
    7a98:	d1 05       	cpc	r29, r1
    7a9a:	99 f7       	brne	.-26     	; 0x7a82 <OLEDcreateChar+0x22>
    OLEDwriteC(charmap[i]);
  }
}
    7a9c:	df 91       	pop	r29
    7a9e:	cf 91       	pop	r28
    7aa0:	1f 91       	pop	r17
    7aa2:	0f 91       	pop	r16
    7aa4:	08 95       	ret

00007aa6 <OLEDnoAutoscroll>:
/* ---------------------------------------------------------------------
    This will 'left justify' text from the cursor
 --------------------------------------------------------------------- */
void OLEDnoAutoscroll(void){

  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
    7aa6:	80 91 f7 03 	lds	r24, 0x03F7
    7aaa:	8e 7f       	andi	r24, 0xFE	; 254
    7aac:	80 93 f7 03 	sts	0x03F7, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7ab0:	84 60       	ori	r24, 0x04	; 4
    7ab2:	60 e0       	ldi	r22, 0x00	; 0
    7ab4:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7ab8:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoAutoscroll(void){

  _displaymode &= ~LCD_ENTRYSHIFTINCREMENT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    7abc:	08 95       	ret

00007abe <OLEDautoscroll>:
/* ---------------------------------------------------------------------
    This will 'right justify' text from the cursor
 --------------------------------------------------------------------- */
void OLEDautoscroll(void){

  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
    7abe:	80 91 f7 03 	lds	r24, 0x03F7
    7ac2:	98 2f       	mov	r25, r24
    7ac4:	91 60       	ori	r25, 0x01	; 1
    7ac6:	90 93 f7 03 	sts	0x03F7, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7aca:	85 60       	ori	r24, 0x05	; 5
    7acc:	60 e0       	ldi	r22, 0x00	; 0
    7ace:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7ad2:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDautoscroll(void){

  _displaymode |= LCD_ENTRYSHIFTINCREMENT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    7ad6:	08 95       	ret

00007ad8 <OLEDscrollDisplayRight>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7ad8:	8c e1       	ldi	r24, 0x1C	; 28
    7ada:	60 e0       	ldi	r22, 0x00	; 0
    7adc:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7ae0:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    unknown
 --------------------------------------------------------------------- */
void OLEDscrollDisplayRight(void){

  OLEDcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVERIGHT);
}
    7ae4:	08 95       	ret

00007ae6 <OLEDscrollDisplayLeft>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7ae6:	88 e1       	ldi	r24, 0x18	; 24
    7ae8:	60 e0       	ldi	r22, 0x00	; 0
    7aea:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7aee:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    These commands scroll the display without changing the RAM
 --------------------------------------------------------------------- */
void OLEDscrollDisplayLeft(void){

  OLEDcommand(LCD_CURSORSHIFT | LCD_DISPLAYMOVE | LCD_MOVELEFT);
}
    7af2:	08 95       	ret

00007af4 <OLEDrightToLeft>:
/* ---------------------------------------------------------------------
    This is for text that flows Right to Left
 --------------------------------------------------------------------- */
void OLEDrightToLeft(void){

  _displaymode &= ~LCD_ENTRYLEFT;
    7af4:	80 91 f7 03 	lds	r24, 0x03F7
    7af8:	8d 7f       	andi	r24, 0xFD	; 253
    7afa:	80 93 f7 03 	sts	0x03F7, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7afe:	84 60       	ori	r24, 0x04	; 4
    7b00:	60 e0       	ldi	r22, 0x00	; 0
    7b02:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7b06:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDrightToLeft(void){

  _displaymode &= ~LCD_ENTRYLEFT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    7b0a:	08 95       	ret

00007b0c <OLEDleftToRight>:
/* ---------------------------------------------------------------------
    This is for text that flows Left to Right
 --------------------------------------------------------------------- */
void OLEDleftToRight(void){

  _displaymode |= LCD_ENTRYLEFT;
    7b0c:	80 91 f7 03 	lds	r24, 0x03F7
    7b10:	98 2f       	mov	r25, r24
    7b12:	92 60       	ori	r25, 0x02	; 2
    7b14:	90 93 f7 03 	sts	0x03F7, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7b18:	86 60       	ori	r24, 0x06	; 6
    7b1a:	60 e0       	ldi	r22, 0x00	; 0
    7b1c:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7b20:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDleftToRight(void){

  _displaymode |= LCD_ENTRYLEFT;
  OLEDcommand(LCD_ENTRYMODESET | _displaymode);
}
    7b24:	08 95       	ret

00007b26 <OLEDsetCursor>:
}

/* ---------------------------------------------------------------------
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){
    7b26:	df 93       	push	r29
    7b28:	cf 93       	push	r28
    7b2a:	00 d0       	rcall	.+0      	; 0x7b2c <OLEDsetCursor+0x6>
    7b2c:	00 d0       	rcall	.+0      	; 0x7b2e <OLEDsetCursor+0x8>
    7b2e:	cd b7       	in	r28, 0x3d	; 61
    7b30:	de b7       	in	r29, 0x3e	; 62
    7b32:	98 2f       	mov	r25, r24

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
  if (row >= _numlines){
    7b34:	80 91 c2 03 	lds	r24, 0x03C2
    7b38:	68 17       	cp	r22, r24
    7b3a:	d0 f0       	brcs	.+52     	; 0x7b70 <OLEDsetCursor+0x4a>
    7b3c:	e0 e0       	ldi	r30, 0x00	; 0
    7b3e:	f0 e0       	ldi	r31, 0x00	; 0
/* ---------------------------------------------------------------------
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
    7b40:	19 82       	std	Y+1, r1	; 0x01
    7b42:	80 e4       	ldi	r24, 0x40	; 64
    7b44:	8a 83       	std	Y+2, r24	; 0x02
    7b46:	84 e1       	ldi	r24, 0x14	; 20
    7b48:	8b 83       	std	Y+3, r24	; 0x03
    7b4a:	84 e5       	ldi	r24, 0x54	; 84
    7b4c:	8c 83       	std	Y+4, r24	; 0x04
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7b4e:	ec 0f       	add	r30, r28
    7b50:	fd 1f       	adc	r31, r29
    7b52:	81 81       	ldd	r24, Z+1	; 0x01
    7b54:	89 0f       	add	r24, r25
    7b56:	80 68       	ori	r24, 0x80	; 128
    7b58:	60 e0       	ldi	r22, 0x00	; 0
    7b5a:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7b5e:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
  if (row >= _numlines){
    row = 0;  //write to first line if out off bounds
  }

  OLEDcommand(LCD_SETDDRAMADDR | (col + row_offsets[row]));
}
    7b62:	0f 90       	pop	r0
    7b64:	0f 90       	pop	r0
    7b66:	0f 90       	pop	r0
    7b68:	0f 90       	pop	r0
    7b6a:	cf 91       	pop	r28
    7b6c:	df 91       	pop	r29
    7b6e:	08 95       	ret
    set cursor to x-y-position (home = 0,0)
 --------------------------------------------------------------------- */
void OLEDsetCursor(uint8_t col, uint8_t row){

  uint8_t row_offsets[] = {0x00, 0x40, 0x14, 0x54};
  if (row >= _numlines){
    7b70:	e6 2f       	mov	r30, r22
    7b72:	f0 e0       	ldi	r31, 0x00	; 0
    7b74:	e5 cf       	rjmp	.-54     	; 0x7b40 <OLEDsetCursor+0x1a>

00007b76 <OLEDhome>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7b76:	82 e0       	ldi	r24, 0x02	; 2
    7b78:	60 e0       	ldi	r22, 0x00	; 0
    7b7a:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7b7e:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    set cursor to home position
 --------------------------------------------------------------------- */
void OLEDhome(void){
  OLEDcommand(LCD_RETURNHOME);  // set cursor position to zero
  //  _delay_us(2000);  // this command takes a long time!
}
    7b82:	08 95       	ret

00007b84 <OLEDcursor>:
/* ---------------------------------------------------------------------
    Turns the underline cursor on
 --------------------------------------------------------------------- */
void OLEDcursor(void){

  _displaycontrol |= LCD_CURSORON;
    7b84:	80 91 c1 03 	lds	r24, 0x03C1
    7b88:	98 2f       	mov	r25, r24
    7b8a:	92 60       	ori	r25, 0x02	; 2
    7b8c:	90 93 c1 03 	sts	0x03C1, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7b90:	8a 60       	ori	r24, 0x0A	; 10
    7b92:	60 e0       	ldi	r22, 0x00	; 0
    7b94:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7b98:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDcursor(void){

  _displaycontrol |= LCD_CURSORON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7b9c:	08 95       	ret

00007b9e <OLEDnoCursor>:
/* ---------------------------------------------------------------------
    Turns the underline cursor off
 --------------------------------------------------------------------- */
void OLEDnoCursor(void){

  _displaycontrol &= ~LCD_CURSORON;
    7b9e:	80 91 c1 03 	lds	r24, 0x03C1
    7ba2:	8d 7f       	andi	r24, 0xFD	; 253
    7ba4:	80 93 c1 03 	sts	0x03C1, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7ba8:	88 60       	ori	r24, 0x08	; 8
    7baa:	60 e0       	ldi	r22, 0x00	; 0
    7bac:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7bb0:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoCursor(void){

  _displaycontrol &= ~LCD_CURSORON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7bb4:	08 95       	ret

00007bb6 <OLEDblink>:
/* ---------------------------------------------------------------------
    Turn on the blinking cursor
 --------------------------------------------------------------------- */
void OLEDblink(void){

  _displaycontrol |= LCD_BLINKON;
    7bb6:	80 91 c1 03 	lds	r24, 0x03C1
    7bba:	98 2f       	mov	r25, r24
    7bbc:	91 60       	ori	r25, 0x01	; 1
    7bbe:	90 93 c1 03 	sts	0x03C1, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7bc2:	89 60       	ori	r24, 0x09	; 9
    7bc4:	60 e0       	ldi	r22, 0x00	; 0
    7bc6:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7bca:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDblink(void){

  _displaycontrol |= LCD_BLINKON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7bce:	08 95       	ret

00007bd0 <OLEDnoBlink>:
/* ---------------------------------------------------------------------
    Turn off the blinking cursor
 --------------------------------------------------------------------- */
void OLEDnoBlink(void){

  _displaycontrol &= ~LCD_BLINKON;
    7bd0:	80 91 c1 03 	lds	r24, 0x03C1
    7bd4:	8e 7f       	andi	r24, 0xFE	; 254
    7bd6:	80 93 c1 03 	sts	0x03C1, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7bda:	88 60       	ori	r24, 0x08	; 8
    7bdc:	60 e0       	ldi	r22, 0x00	; 0
    7bde:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7be2:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoBlink(void){

  _displaycontrol &= ~LCD_BLINKON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7be6:	08 95       	ret

00007be8 <OLEDclear>:
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7be8:	81 e0       	ldi	r24, 0x01	; 1
    7bea:	60 e0       	ldi	r22, 0x00	; 0
    7bec:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7bf0:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDclear(void){

  OLEDcommand(LCD_CLEARDISPLAY);  // clear display, set cursor position to zero
  //  _delay_us(2000);  // this command takes a long time!
}
    7bf4:	08 95       	ret

00007bf6 <OLEDdisplay>:
/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDdisplay(void){

  _displaycontrol |= LCD_DISPLAYON;
    7bf6:	80 91 c1 03 	lds	r24, 0x03C1
    7bfa:	98 2f       	mov	r25, r24
    7bfc:	94 60       	ori	r25, 0x04	; 4
    7bfe:	90 93 c1 03 	sts	0x03C1, r25
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7c02:	8c 60       	ori	r24, 0x0C	; 12
    7c04:	60 e0       	ldi	r22, 0x00	; 0
    7c06:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7c0a:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDdisplay(void){

  _displaycontrol |= LCD_DISPLAYON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7c0e:	08 95       	ret

00007c10 <OLEDnoDisplay>:
/* ---------------------------------------------------------------------
    Turn the display on/off (quickly)
 --------------------------------------------------------------------- */
void OLEDnoDisplay(void){

  _displaycontrol &= ~LCD_DISPLAYON;
    7c10:	80 91 c1 03 	lds	r24, 0x03C1
    7c14:	8b 7f       	andi	r24, 0xFB	; 251
    7c16:	80 93 c1 03 	sts	0x03C1, r24
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7c1a:	88 60       	ori	r24, 0x08	; 8
    7c1c:	60 e0       	ldi	r22, 0x00	; 0
    7c1e:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7c22:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
 --------------------------------------------------------------------- */
void OLEDnoDisplay(void){

  _displaycontrol &= ~LCD_DISPLAYON;
  OLEDcommand(LCD_DISPLAYCONTROL | _displaycontrol);
}
    7c26:	08 95       	ret

00007c28 <OLEDbegin>:
}

/* ---------------------------------------------------------------------
    unknown
 --------------------------------------------------------------------- */
void OLEDbegin(uint8_t cols, uint8_t lines){
    7c28:	0f 93       	push	r16
    7c2a:	1f 93       	push	r17
    7c2c:	cf 93       	push	r28
    7c2e:	df 93       	push	r29

  _numlines = lines;
    7c30:	60 93 c2 03 	sts	0x03C2, r22
  _currline = 0;
    7c34:	10 92 20 03 	sts	0x0320, r1

  OLEDpinMode(rs_pin, OUTPUT);
    7c38:	81 e0       	ldi	r24, 0x01	; 1
    7c3a:	61 e0       	ldi	r22, 0x01	; 1
    7c3c:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
  OLEDpinMode(_rw_pin, OUTPUT);
    7c40:	82 e0       	ldi	r24, 0x02	; 2
    7c42:	61 e0       	ldi	r22, 0x01	; 1
    7c44:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
  OLEDpinMode(_enable_pin, OUTPUT);
    7c48:	83 e0       	ldi	r24, 0x03	; 3
    7c4a:	61 e0       	ldi	r22, 0x01	; 1
    7c4c:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>

  OLEDdigitalWrite(rs_pin, LOW);
    7c50:	81 e0       	ldi	r24, 0x01	; 1
    7c52:	60 e0       	ldi	r22, 0x00	; 0
    7c54:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
  OLEDdigitalWrite(_enable_pin, LOW);
    7c58:	83 e0       	ldi	r24, 0x03	; 3
    7c5a:	60 e0       	ldi	r22, 0x00	; 0
    7c5c:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, LOW);
    7c60:	82 e0       	ldi	r24, 0x02	; 2
    7c62:	60 e0       	ldi	r22, 0x00	; 0
    7c64:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
    7c68:	24 ef       	ldi	r18, 0xF4	; 244
    7c6a:	31 e0       	ldi	r19, 0x01	; 1
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    7c6c:	44 ef       	ldi	r20, 0xF4	; 244
    7c6e:	51 e0       	ldi	r21, 0x01	; 1
    7c70:	ca 01       	movw	r24, r20
    7c72:	01 97       	sbiw	r24, 0x01	; 1
    7c74:	f1 f7       	brne	.-4      	; 0x7c72 <OLEDbegin+0x4a>
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    7c76:	21 50       	subi	r18, 0x01	; 1
    7c78:	30 40       	sbci	r19, 0x00	; 0
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    7c7a:	d1 f7       	brne	.-12     	; 0x7c70 <OLEDbegin+0x48>
    7c7c:	c3 ef       	ldi	r28, 0xF3	; 243
    7c7e:	d3 e0       	ldi	r29, 0x03	; 3

  _delay_us(50000); // give it some time to power up

  // Now we pull both RS and R/W low to begin commands
  for(int i = 0; i < 4; i++){
    OLEDpinMode(_data_pins[i], OUTPUT);
    7c80:	88 81       	ld	r24, Y
    7c82:	61 e0       	ldi	r22, 0x01	; 1
    7c84:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
    OLEDdigitalWrite(_data_pins[i], LOW);
    7c88:	89 91       	ld	r24, Y+
    7c8a:	60 e0       	ldi	r22, 0x00	; 0
    7c8c:	0e 94 46 3c 	call	0x788c	; 0x788c <OLEDdigitalWrite>
  OLEDdigitalWrite(_rw_pin, LOW);

  _delay_us(50000); // give it some time to power up

  // Now we pull both RS and R/W low to begin commands
  for(int i = 0; i < 4; i++){
    7c90:	83 e0       	ldi	r24, 0x03	; 3
    7c92:	c7 3f       	cpi	r28, 0xF7	; 247
    7c94:	d8 07       	cpc	r29, r24
    7c96:	a1 f7       	brne	.-24     	; 0x7c80 <OLEDbegin+0x58>
  //
  // In the data sheet, the timing specs are all zeros(!).  These have been tested to
  // reliably handle both warm & cold starts.

  // 4-Bit initialization sequence from Technobly
  OLEDwrite4bits(0x03); // Put back into 8-bit mode
    7c98:	83 e0       	ldi	r24, 0x03	; 3
    7c9a:	0e 94 78 3c 	call	0x78f0	; 0x78f0 <OLEDwrite4bits>
    7c9e:	c8 ea       	ldi	r28, 0xA8	; 168
    7ca0:	d1 e6       	ldi	r29, 0x61	; 97
    7ca2:	ce 01       	movw	r24, r28
    7ca4:	01 97       	sbiw	r24, 0x01	; 1
    7ca6:	f1 f7       	brne	.-4      	; 0x7ca4 <OLEDbegin+0x7c>
  _delay_us(5000);
  if(_oled_ver == OLED_V2){  // only run extra command for newer displays
    7ca8:	80 91 c5 04 	lds	r24, 0x04C5
    7cac:	82 30       	cpi	r24, 0x02	; 2
    7cae:	09 f4       	brne	.+2      	; 0x7cb2 <OLEDbegin+0x8a>
    7cb0:	46 c0       	rjmp	.+140    	; 0x7d3e <OLEDbegin+0x116>
    OLEDwrite4bits(0x08);
    _delay_us(5000);
  }

  OLEDwrite4bits(0x02); // Put into 4-bit mode
    7cb2:	82 e0       	ldi	r24, 0x02	; 2
    7cb4:	0e 94 78 3c 	call	0x78f0	; 0x78f0 <OLEDwrite4bits>
    7cb8:	08 ea       	ldi	r16, 0xA8	; 168
    7cba:	11 e6       	ldi	r17, 0x61	; 97
    7cbc:	c8 01       	movw	r24, r16
    7cbe:	01 97       	sbiw	r24, 0x01	; 1
    7cc0:	f1 f7       	brne	.-4      	; 0x7cbe <OLEDbegin+0x96>
  _delay_us(5000);
  OLEDwrite4bits(0x02);
    7cc2:	82 e0       	ldi	r24, 0x02	; 2
    7cc4:	0e 94 78 3c 	call	0x78f0	; 0x78f0 <OLEDwrite4bits>
    7cc8:	c8 01       	movw	r24, r16
    7cca:	01 97       	sbiw	r24, 0x01	; 1
    7ccc:	f1 f7       	brne	.-4      	; 0x7cca <OLEDbegin+0xa2>
  _delay_us(5000);
  OLEDwrite4bits(0x08);
    7cce:	88 e0       	ldi	r24, 0x08	; 8
    7cd0:	0e 94 78 3c 	call	0x78f0	; 0x78f0 <OLEDwrite4bits>
    7cd4:	c8 01       	movw	r24, r16
    7cd6:	01 97       	sbiw	r24, 0x01	; 1
    7cd8:	f1 f7       	brne	.-4      	; 0x7cd6 <OLEDbegin+0xae>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7cda:	88 e0       	ldi	r24, 0x08	; 8
    7cdc:	60 e0       	ldi	r22, 0x00	; 0
    7cde:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7ce2:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    7ce6:	c8 01       	movw	r24, r16
    7ce8:	01 97       	sbiw	r24, 0x01	; 1
    7cea:	f1 f7       	brne	.-4      	; 0x7ce8 <OLEDbegin+0xc0>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7cec:	81 e0       	ldi	r24, 0x01	; 1
    7cee:	60 e0       	ldi	r22, 0x00	; 0
    7cf0:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7cf4:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    7cf8:	c8 01       	movw	r24, r16
    7cfa:	01 97       	sbiw	r24, 0x01	; 1
    7cfc:	f1 f7       	brne	.-4      	; 0x7cfa <OLEDbegin+0xd2>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7cfe:	86 e0       	ldi	r24, 0x06	; 6
    7d00:	60 e0       	ldi	r22, 0x00	; 0
    7d02:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7d06:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    7d0a:	c8 01       	movw	r24, r16
    7d0c:	01 97       	sbiw	r24, 0x01	; 1
    7d0e:	f1 f7       	brne	.-4      	; 0x7d0c <OLEDbegin+0xe4>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7d10:	82 e0       	ldi	r24, 0x02	; 2
    7d12:	60 e0       	ldi	r22, 0x00	; 0
    7d14:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7d18:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    7d1c:	c8 01       	movw	r24, r16
    7d1e:	01 97       	sbiw	r24, 0x01	; 1
    7d20:	f1 f7       	brne	.-4      	; 0x7d1e <OLEDbegin+0xf6>
/* ---------------------------------------------------------------------
    send a command to the display
 --------------------------------------------------------------------- */
inline void OLEDcommand(uint8_t value){

  OLEDsend(value, LOW);
    7d22:	8c e0       	ldi	r24, 0x0C	; 12
    7d24:	60 e0       	ldi	r22, 0x00	; 0
    7d26:	0e 94 a7 3c 	call	0x794e	; 0x794e <OLEDsend>
  OLEDwaitForReady();
    7d2a:	0e 94 be 3c 	call	0x797c	; 0x797c <OLEDwaitForReady>
    7d2e:	c8 01       	movw	r24, r16
    7d30:	01 97       	sbiw	r24, 0x01	; 1
    7d32:	f1 f7       	brne	.-4      	; 0x7d30 <OLEDbegin+0x108>
  _delay_us(5000);
  OLEDcommand(0x02);  // Home Cursor
  _delay_us(5000);
  OLEDcommand(0x0C);  // Turn On - enable cursor & blink
  _delay_us(5000);
}
    7d34:	df 91       	pop	r29
    7d36:	cf 91       	pop	r28
    7d38:	1f 91       	pop	r17
    7d3a:	0f 91       	pop	r16
    7d3c:	08 95       	ret

  // 4-Bit initialization sequence from Technobly
  OLEDwrite4bits(0x03); // Put back into 8-bit mode
  _delay_us(5000);
  if(_oled_ver == OLED_V2){  // only run extra command for newer displays
    OLEDwrite4bits(0x08);
    7d3e:	88 e0       	ldi	r24, 0x08	; 8
    7d40:	0e 94 78 3c 	call	0x78f0	; 0x78f0 <OLEDwrite4bits>
    7d44:	ce 01       	movw	r24, r28
    7d46:	01 97       	sbiw	r24, 0x01	; 1
    7d48:	f1 f7       	brne	.-4      	; 0x7d46 <OLEDbegin+0x11e>
    7d4a:	b3 cf       	rjmp	.-154    	; 0x7cb2 <OLEDbegin+0x8a>

00007d4c <OLEDinit>:
/* ---------------------------------------------------------------------
    initialize OLED display
 --------------------------------------------------------------------- */
void OLEDinit(uint8_t ver){

  _oled_ver = ver;
    7d4c:	80 93 c5 04 	sts	0x04C5, r24
  if(_oled_ver != OLED_V1 && _oled_ver != OLED_V2){
    7d50:	81 50       	subi	r24, 0x01	; 1
    7d52:	82 30       	cpi	r24, 0x02	; 2
    7d54:	18 f0       	brcs	.+6      	; 0x7d5c <OLEDinit+0x10>
    _oled_ver = OLED_V2; // if error, default to newer version
    7d56:	82 e0       	ldi	r24, 0x02	; 2
    7d58:	80 93 c5 04 	sts	0x04C5, r24
  }

  _data_pins[0] = data4;
    7d5c:	84 e0       	ldi	r24, 0x04	; 4
    7d5e:	80 93 f3 03 	sts	0x03F3, r24
  _data_pins[1] = data5;
    7d62:	85 e0       	ldi	r24, 0x05	; 5
    7d64:	80 93 f4 03 	sts	0x03F4, r24
  _data_pins[2] = data6;
    7d68:	86 e0       	ldi	r24, 0x06	; 6
    7d6a:	80 93 f5 03 	sts	0x03F5, r24
  _data_pins[3] = data7;
    7d6e:	87 e0       	ldi	r24, 0x07	; 7
    7d70:	80 93 f6 03 	sts	0x03F6, r24

  OLEDpinMode(rs_pin, OUTPUT);
    7d74:	81 e0       	ldi	r24, 0x01	; 1
    7d76:	61 e0       	ldi	r22, 0x01	; 1
    7d78:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
  OLEDpinMode(_rw_pin, OUTPUT);
    7d7c:	82 e0       	ldi	r24, 0x02	; 2
    7d7e:	61 e0       	ldi	r22, 0x01	; 1
    7d80:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>
  OLEDpinMode(_enable_pin, OUTPUT);
    7d84:	83 e0       	ldi	r24, 0x03	; 3
    7d86:	61 e0       	ldi	r22, 0x01	; 1
    7d88:	0e 94 2c 3c 	call	0x7858	; 0x7858 <OLEDpinMode>

  _displayfunction = LCD_FUNCTIONSET | LCD_4BITMODE;
    7d8c:	88 e2       	ldi	r24, 0x28	; 40
    7d8e:	80 93 f8 03 	sts	0x03F8, r24

  OLEDbegin(16, 2);
    7d92:	80 e1       	ldi	r24, 0x10	; 16
    7d94:	62 e0       	ldi	r22, 0x02	; 2
    7d96:	0e 94 14 3e 	call	0x7c28	; 0x7c28 <OLEDbegin>
}
    7d9a:	08 95       	ret

00007d9c <initIIC>:
/* ---------------------------------------------------------------------
   initialize I2C system
 --------------------------------------------------------------------- */
void initIIC(void){

  TWBR = TWBR_VALUE;    /* see macro in libiic.h */
    7d9c:	81 e1       	ldi	r24, 0x11	; 17
    7d9e:	80 93 b8 00 	sts	0x00B8, r24
  TWSR &= ~((1<<TWPS0) | (1<<TWPS1));
    7da2:	e9 eb       	ldi	r30, 0xB9	; 185
    7da4:	f0 e0       	ldi	r31, 0x00	; 0
    7da6:	80 81       	ld	r24, Z
    7da8:	8c 7f       	andi	r24, 0xFC	; 252
    7daa:	80 83       	st	Z, r24
  TWCR = (1<<TWEN);
    7dac:	84 e0       	ldi	r24, 0x04	; 4
    7dae:	80 93 bc 00 	sts	0x00BC, r24

  return;
}
    7db2:	08 95       	ret

00007db4 <IICstart>:
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    7db4:	84 ea       	ldi	r24, 0xA4	; 164
    7db6:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7dba:	80 91 bc 00 	lds	r24, 0x00BC
    7dbe:	87 ff       	sbrs	r24, 7
    7dc0:	fc cf       	rjmp	.-8      	; 0x7dba <IICstart+0x6>

  return;
}
    7dc2:	08 95       	ret

00007dc4 <IICstop>:
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    7dc4:	84 e9       	ldi	r24, 0x94	; 148
    7dc6:	80 93 bc 00 	sts	0x00BC, r24

  return;
}
    7dca:	08 95       	ret

00007dcc <IICsendByte>:
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    7dcc:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);
    7dd0:	84 e8       	ldi	r24, 0x84	; 132
    7dd2:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7dd6:	80 91 bc 00 	lds	r24, 0x00BC
    7dda:	87 ff       	sbrs	r24, 7
    7ddc:	fc cf       	rjmp	.-8      	; 0x7dd6 <IICsendByte+0xa>

  return;
}
    7dde:	08 95       	ret

00007de0 <IICreadACK>:
/* ---------------------------------------------------------------------
   read a single byte with ACK
 --------------------------------------------------------------------- */
uint8_t IICreadACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    7de0:	84 ec       	ldi	r24, 0xC4	; 196
    7de2:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7de6:	80 91 bc 00 	lds	r24, 0x00BC
    7dea:	87 ff       	sbrs	r24, 7
    7dec:	fc cf       	rjmp	.-8      	; 0x7de6 <IICreadACK+0x6>

  return TWDR;
    7dee:	80 91 bb 00 	lds	r24, 0x00BB
}
    7df2:	08 95       	ret

00007df4 <IICreadNACK>:
/* ---------------------------------------------------------------------
   read a single byte with NACK
 --------------------------------------------------------------------- */
uint8_t IICreadNACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN);
    7df4:	84 e8       	ldi	r24, 0x84	; 132
    7df6:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));
    7dfa:	80 91 bc 00 	lds	r24, 0x00BC
    7dfe:	87 ff       	sbrs	r24, 7
    7e00:	fc cf       	rjmp	.-8      	; 0x7dfa <IICreadNACK+0x6>

  return TWDR;
    7e02:	80 91 bb 00 	lds	r24, 0x00BB
}
    7e06:	08 95       	ret

00007e08 <IICgetStatus>:
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7e08:	80 91 b9 00 	lds	r24, 0x00B9

  return status;
}
    7e0c:	88 7f       	andi	r24, 0xF8	; 248
    7e0e:	08 95       	ret

00007e10 <IICwrite>:

/* ---------------------------------------------------------------------
   send a number of bytes to I2C slave
 --------------------------------------------------------------------- */
void IICwrite(uint8_t addr, uint8_t* data, uint8_t numDat){
    7e10:	98 2f       	mov	r25, r24
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    7e12:	84 ea       	ldi	r24, 0xA4	; 164
    7e14:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7e18:	80 91 bc 00 	lds	r24, 0x00BC
    7e1c:	87 ff       	sbrs	r24, 7
    7e1e:	fc cf       	rjmp	.-8      	; 0x7e18 <IICwrite+0x8>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7e20:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    7e24:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    7e28:	84 e8       	ldi	r24, 0x84	; 132
    7e2a:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7e2e:	80 91 bc 00 	lds	r24, 0x00BC
    7e32:	87 ff       	sbrs	r24, 7
    7e34:	fc cf       	rjmp	.-8      	; 0x7e2e <IICwrite+0x1e>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7e36:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_WRITE);
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    7e3a:	44 23       	and	r20, r20
    7e3c:	91 f0       	breq	.+36     	; 0x7e62 <IICwrite+0x52>
    7e3e:	fb 01       	movw	r30, r22
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
  TWCR = (1<<TWINT) | (1<<TWEN);
    7e40:	94 e8       	ldi	r25, 0x84	; 132
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    IICsendByte(*data);
    7e42:	80 81       	ld	r24, Z
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    7e44:	80 93 bb 00 	sts	0x00BB, r24
  TWCR = (1<<TWINT) | (1<<TWEN);
    7e48:	90 93 bc 00 	sts	0x00BC, r25
  while(!(TWCR & (1<<TWINT)));
    7e4c:	80 91 bc 00 	lds	r24, 0x00BC
    7e50:	87 ff       	sbrs	r24, 7
    7e52:	fc cf       	rjmp	.-8      	; 0x7e4c <IICwrite+0x3c>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7e54:	80 91 b9 00 	lds	r24, 0x00B9
    7e58:	31 96       	adiw	r30, 0x01	; 1
  IICsendByte(addr | TW_WRITE);
  if(IICgetStatus() !=  TW_MT_SLA_ACK){
    /* error handling */
  }

  for(i = 0; i < numDat; i++){
    7e5a:	8e 2f       	mov	r24, r30
    7e5c:	86 1b       	sub	r24, r22
    7e5e:	84 17       	cp	r24, r20
    7e60:	80 f3       	brcs	.-32     	; 0x7e42 <IICwrite+0x32>
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    7e62:	84 e9       	ldi	r24, 0x94	; 148
    7e64:	80 93 bc 00 	sts	0x00BC, r24
  }

  IICstop();

  return;
}
    7e68:	08 95       	ret

00007e6a <IICread>:

/* ---------------------------------------------------------------------
   read a number of bytes from an I2C slave
 --------------------------------------------------------------------- */
void IICread(uint8_t addr, uint8_t* data, uint8_t numDat){
    7e6a:	98 2f       	mov	r25, r24
    7e6c:	db 01       	movw	r26, r22
/* ---------------------------------------------------------------------
   send IIC start
 --------------------------------------------------------------------- */
void IICstart(void){

  TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN);
    7e6e:	84 ea       	ldi	r24, 0xA4	; 164
    7e70:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7e74:	80 91 bc 00 	lds	r24, 0x00BC
    7e78:	87 ff       	sbrs	r24, 7
    7e7a:	fc cf       	rjmp	.-8      	; 0x7e74 <IICread+0xa>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7e7c:	80 91 b9 00 	lds	r24, 0x00B9
  IICstart();
  if(IICgetStatus() != TW_START){
    /* error handling */
  }

  IICsendByte(addr | TW_READ);
    7e80:	91 60       	ori	r25, 0x01	; 1
/* ---------------------------------------------------------------------
   write a single byte to the bus
 --------------------------------------------------------------------- */
void IICsendByte(uint8_t data){

  TWDR = data;
    7e82:	90 93 bb 00 	sts	0x00BB, r25
  TWCR = (1<<TWINT) | (1<<TWEN);
    7e86:	84 e8       	ldi	r24, 0x84	; 132
    7e88:	80 93 bc 00 	sts	0x00BC, r24
  while(!(TWCR & (1<<TWINT)));
    7e8c:	80 91 bc 00 	lds	r24, 0x00BC
    7e90:	87 ff       	sbrs	r24, 7
    7e92:	fc cf       	rjmp	.-8      	; 0x7e8c <IICread+0x22>
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7e94:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_READ);
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    7e98:	50 e0       	ldi	r21, 0x00	; 0
    7e9a:	41 50       	subi	r20, 0x01	; 1
    7e9c:	50 40       	sbci	r21, 0x00	; 0
    7e9e:	14 16       	cp	r1, r20
    7ea0:	15 06       	cpc	r1, r21
    7ea2:	a4 f4       	brge	.+40     	; 0x7ecc <IICread+0x62>
    7ea4:	fd 01       	movw	r30, r26
/* ---------------------------------------------------------------------
   read a single byte with ACK
 --------------------------------------------------------------------- */
uint8_t IICreadACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWEA);
    7ea6:	24 ec       	ldi	r18, 0xC4	; 196
    7ea8:	20 93 bc 00 	sts	0x00BC, r18
  while(!(TWCR & (1<<TWINT)));
    7eac:	80 91 bc 00 	lds	r24, 0x00BC
    7eb0:	87 ff       	sbrs	r24, 7
    7eb2:	fc cf       	rjmp	.-8      	; 0x7eac <IICread+0x42>

  return TWDR;
    7eb4:	80 91 bb 00 	lds	r24, 0x00BB
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    *data = IICreadACK();
    7eb8:	81 93       	st	Z+, r24
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7eba:	80 91 b9 00 	lds	r24, 0x00B9
  IICsendByte(addr | TW_READ);
  if(IICgetStatus() !=  TW_MR_SLA_ACK){
    /* error handling */
  }

  for(i=0; i < numDat - 1; i++){
    7ebe:	8e 2f       	mov	r24, r30
    7ec0:	8a 1b       	sub	r24, r26
    7ec2:	90 e0       	ldi	r25, 0x00	; 0
    7ec4:	84 17       	cp	r24, r20
    7ec6:	95 07       	cpc	r25, r21
    7ec8:	7c f3       	brlt	.-34     	; 0x7ea8 <IICread+0x3e>
    7eca:	df 01       	movw	r26, r30
/* ---------------------------------------------------------------------
   read a single byte with NACK
 --------------------------------------------------------------------- */
uint8_t IICreadNACK(void){

  TWCR = (1<<TWINT) | (1<<TWEN);
    7ecc:	84 e8       	ldi	r24, 0x84	; 132
    7ece:	80 93 bc 00 	sts	0x00BC, r24
  while (!(TWCR & (1<<TWINT)));
    7ed2:	80 91 bc 00 	lds	r24, 0x00BC
    7ed6:	87 ff       	sbrs	r24, 7
    7ed8:	fc cf       	rjmp	.-8      	; 0x7ed2 <IICread+0x68>

  return TWDR;
    7eda:	80 91 bb 00 	lds	r24, 0x00BB
      /* error handling */
    }
    data++;
  }

  *data = IICreadNACK();
    7ede:	8c 93       	st	X, r24
 --------------------------------------------------------------------- */
uint8_t IICgetStatus(void){

  uint8_t status = 0;

  status = TWSR & 0xF8;
    7ee0:	80 91 b9 00 	lds	r24, 0x00B9
/* ---------------------------------------------------------------------
   send IIC stop
 --------------------------------------------------------------------- */
void IICstop(void){

  TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    7ee4:	84 e9       	ldi	r24, 0x94	; 148
    7ee6:	80 93 bc 00 	sts	0x00BC, r24
  }

  IICstop();

  return;
}
    7eea:	08 95       	ret

00007eec <vfprintf>:
    7eec:	2f 92       	push	r2
    7eee:	3f 92       	push	r3
    7ef0:	4f 92       	push	r4
    7ef2:	5f 92       	push	r5
    7ef4:	6f 92       	push	r6
    7ef6:	7f 92       	push	r7
    7ef8:	8f 92       	push	r8
    7efa:	9f 92       	push	r9
    7efc:	af 92       	push	r10
    7efe:	bf 92       	push	r11
    7f00:	cf 92       	push	r12
    7f02:	df 92       	push	r13
    7f04:	ef 92       	push	r14
    7f06:	ff 92       	push	r15
    7f08:	0f 93       	push	r16
    7f0a:	1f 93       	push	r17
    7f0c:	df 93       	push	r29
    7f0e:	cf 93       	push	r28
    7f10:	cd b7       	in	r28, 0x3d	; 61
    7f12:	de b7       	in	r29, 0x3e	; 62
    7f14:	61 97       	sbiw	r28, 0x11	; 17
    7f16:	0f b6       	in	r0, 0x3f	; 63
    7f18:	f8 94       	cli
    7f1a:	de bf       	out	0x3e, r29	; 62
    7f1c:	0f be       	out	0x3f, r0	; 63
    7f1e:	cd bf       	out	0x3d, r28	; 61
    7f20:	3c 01       	movw	r6, r24
    7f22:	7f 87       	std	Y+15, r23	; 0x0f
    7f24:	6e 87       	std	Y+14, r22	; 0x0e
    7f26:	6a 01       	movw	r12, r20
    7f28:	fc 01       	movw	r30, r24
    7f2a:	17 82       	std	Z+7, r1	; 0x07
    7f2c:	16 82       	std	Z+6, r1	; 0x06
    7f2e:	83 81       	ldd	r24, Z+3	; 0x03
    7f30:	81 fd       	sbrc	r24, 1
    7f32:	03 c0       	rjmp	.+6      	; 0x7f3a <vfprintf+0x4e>
    7f34:	6f ef       	ldi	r22, 0xFF	; 255
    7f36:	7f ef       	ldi	r23, 0xFF	; 255
    7f38:	6f c3       	rjmp	.+1758   	; 0x8618 <vfprintf+0x72c>
    7f3a:	9e 01       	movw	r18, r28
    7f3c:	2f 5f       	subi	r18, 0xFF	; 255
    7f3e:	3f 4f       	sbci	r19, 0xFF	; 255
    7f40:	39 8b       	std	Y+17, r19	; 0x11
    7f42:	28 8b       	std	Y+16, r18	; 0x10
    7f44:	f3 01       	movw	r30, r6
    7f46:	23 81       	ldd	r18, Z+3	; 0x03
    7f48:	ee 85       	ldd	r30, Y+14	; 0x0e
    7f4a:	ff 85       	ldd	r31, Y+15	; 0x0f
    7f4c:	23 fd       	sbrc	r18, 3
    7f4e:	85 91       	lpm	r24, Z+
    7f50:	23 ff       	sbrs	r18, 3
    7f52:	81 91       	ld	r24, Z+
    7f54:	ff 87       	std	Y+15, r31	; 0x0f
    7f56:	ee 87       	std	Y+14, r30	; 0x0e
    7f58:	88 23       	and	r24, r24
    7f5a:	09 f4       	brne	.+2      	; 0x7f5e <vfprintf+0x72>
    7f5c:	5a c3       	rjmp	.+1716   	; 0x8612 <vfprintf+0x726>
    7f5e:	85 32       	cpi	r24, 0x25	; 37
    7f60:	51 f4       	brne	.+20     	; 0x7f76 <vfprintf+0x8a>
    7f62:	ee 85       	ldd	r30, Y+14	; 0x0e
    7f64:	ff 85       	ldd	r31, Y+15	; 0x0f
    7f66:	23 fd       	sbrc	r18, 3
    7f68:	85 91       	lpm	r24, Z+
    7f6a:	23 ff       	sbrs	r18, 3
    7f6c:	81 91       	ld	r24, Z+
    7f6e:	ff 87       	std	Y+15, r31	; 0x0f
    7f70:	ee 87       	std	Y+14, r30	; 0x0e
    7f72:	85 32       	cpi	r24, 0x25	; 37
    7f74:	29 f4       	brne	.+10     	; 0x7f80 <vfprintf+0x94>
    7f76:	90 e0       	ldi	r25, 0x00	; 0
    7f78:	b3 01       	movw	r22, r6
    7f7a:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    7f7e:	e2 cf       	rjmp	.-60     	; 0x7f44 <vfprintf+0x58>
    7f80:	98 2f       	mov	r25, r24
    7f82:	10 e0       	ldi	r17, 0x00	; 0
    7f84:	88 24       	eor	r8, r8
    7f86:	99 24       	eor	r9, r9
    7f88:	10 32       	cpi	r17, 0x20	; 32
    7f8a:	b0 f4       	brcc	.+44     	; 0x7fb8 <vfprintf+0xcc>
    7f8c:	9b 32       	cpi	r25, 0x2B	; 43
    7f8e:	69 f0       	breq	.+26     	; 0x7faa <vfprintf+0xbe>
    7f90:	9c 32       	cpi	r25, 0x2C	; 44
    7f92:	28 f4       	brcc	.+10     	; 0x7f9e <vfprintf+0xb2>
    7f94:	90 32       	cpi	r25, 0x20	; 32
    7f96:	51 f0       	breq	.+20     	; 0x7fac <vfprintf+0xc0>
    7f98:	93 32       	cpi	r25, 0x23	; 35
    7f9a:	71 f4       	brne	.+28     	; 0x7fb8 <vfprintf+0xcc>
    7f9c:	0b c0       	rjmp	.+22     	; 0x7fb4 <vfprintf+0xc8>
    7f9e:	9d 32       	cpi	r25, 0x2D	; 45
    7fa0:	39 f0       	breq	.+14     	; 0x7fb0 <vfprintf+0xc4>
    7fa2:	90 33       	cpi	r25, 0x30	; 48
    7fa4:	49 f4       	brne	.+18     	; 0x7fb8 <vfprintf+0xcc>
    7fa6:	11 60       	ori	r17, 0x01	; 1
    7fa8:	28 c0       	rjmp	.+80     	; 0x7ffa <vfprintf+0x10e>
    7faa:	12 60       	ori	r17, 0x02	; 2
    7fac:	14 60       	ori	r17, 0x04	; 4
    7fae:	25 c0       	rjmp	.+74     	; 0x7ffa <vfprintf+0x10e>
    7fb0:	18 60       	ori	r17, 0x08	; 8
    7fb2:	23 c0       	rjmp	.+70     	; 0x7ffa <vfprintf+0x10e>
    7fb4:	10 61       	ori	r17, 0x10	; 16
    7fb6:	21 c0       	rjmp	.+66     	; 0x7ffa <vfprintf+0x10e>
    7fb8:	17 fd       	sbrc	r17, 7
    7fba:	2a c0       	rjmp	.+84     	; 0x8010 <vfprintf+0x124>
    7fbc:	89 2f       	mov	r24, r25
    7fbe:	80 53       	subi	r24, 0x30	; 48
    7fc0:	8a 30       	cpi	r24, 0x0A	; 10
    7fc2:	78 f4       	brcc	.+30     	; 0x7fe2 <vfprintf+0xf6>
    7fc4:	16 ff       	sbrs	r17, 6
    7fc6:	06 c0       	rjmp	.+12     	; 0x7fd4 <vfprintf+0xe8>
    7fc8:	fa e0       	ldi	r31, 0x0A	; 10
    7fca:	9f 9e       	mul	r9, r31
    7fcc:	90 2c       	mov	r9, r0
    7fce:	11 24       	eor	r1, r1
    7fd0:	98 0e       	add	r9, r24
    7fd2:	13 c0       	rjmp	.+38     	; 0x7ffa <vfprintf+0x10e>
    7fd4:	3a e0       	ldi	r19, 0x0A	; 10
    7fd6:	83 9e       	mul	r8, r19
    7fd8:	80 2c       	mov	r8, r0
    7fda:	11 24       	eor	r1, r1
    7fdc:	88 0e       	add	r8, r24
    7fde:	10 62       	ori	r17, 0x20	; 32
    7fe0:	0c c0       	rjmp	.+24     	; 0x7ffa <vfprintf+0x10e>
    7fe2:	9e 32       	cpi	r25, 0x2E	; 46
    7fe4:	21 f4       	brne	.+8      	; 0x7fee <vfprintf+0x102>
    7fe6:	16 fd       	sbrc	r17, 6
    7fe8:	14 c3       	rjmp	.+1576   	; 0x8612 <vfprintf+0x726>
    7fea:	10 64       	ori	r17, 0x40	; 64
    7fec:	06 c0       	rjmp	.+12     	; 0x7ffa <vfprintf+0x10e>
    7fee:	9c 36       	cpi	r25, 0x6C	; 108
    7ff0:	11 f4       	brne	.+4      	; 0x7ff6 <vfprintf+0x10a>
    7ff2:	10 68       	ori	r17, 0x80	; 128
    7ff4:	02 c0       	rjmp	.+4      	; 0x7ffa <vfprintf+0x10e>
    7ff6:	98 36       	cpi	r25, 0x68	; 104
    7ff8:	59 f4       	brne	.+22     	; 0x8010 <vfprintf+0x124>
    7ffa:	ee 85       	ldd	r30, Y+14	; 0x0e
    7ffc:	ff 85       	ldd	r31, Y+15	; 0x0f
    7ffe:	23 fd       	sbrc	r18, 3
    8000:	95 91       	lpm	r25, Z+
    8002:	23 ff       	sbrs	r18, 3
    8004:	91 91       	ld	r25, Z+
    8006:	ff 87       	std	Y+15, r31	; 0x0f
    8008:	ee 87       	std	Y+14, r30	; 0x0e
    800a:	99 23       	and	r25, r25
    800c:	09 f0       	breq	.+2      	; 0x8010 <vfprintf+0x124>
    800e:	bc cf       	rjmp	.-136    	; 0x7f88 <vfprintf+0x9c>
    8010:	89 2f       	mov	r24, r25
    8012:	85 54       	subi	r24, 0x45	; 69
    8014:	83 30       	cpi	r24, 0x03	; 3
    8016:	20 f4       	brcc	.+8      	; 0x8020 <vfprintf+0x134>
    8018:	81 2f       	mov	r24, r17
    801a:	80 61       	ori	r24, 0x10	; 16
    801c:	90 5e       	subi	r25, 0xE0	; 224
    801e:	07 c0       	rjmp	.+14     	; 0x802e <vfprintf+0x142>
    8020:	89 2f       	mov	r24, r25
    8022:	85 56       	subi	r24, 0x65	; 101
    8024:	83 30       	cpi	r24, 0x03	; 3
    8026:	08 f0       	brcs	.+2      	; 0x802a <vfprintf+0x13e>
    8028:	9f c1       	rjmp	.+830    	; 0x8368 <vfprintf+0x47c>
    802a:	81 2f       	mov	r24, r17
    802c:	8f 7e       	andi	r24, 0xEF	; 239
    802e:	86 fd       	sbrc	r24, 6
    8030:	02 c0       	rjmp	.+4      	; 0x8036 <vfprintf+0x14a>
    8032:	76 e0       	ldi	r23, 0x06	; 6
    8034:	97 2e       	mov	r9, r23
    8036:	6f e3       	ldi	r22, 0x3F	; 63
    8038:	f6 2e       	mov	r15, r22
    803a:	f8 22       	and	r15, r24
    803c:	95 36       	cpi	r25, 0x65	; 101
    803e:	19 f4       	brne	.+6      	; 0x8046 <vfprintf+0x15a>
    8040:	f0 e4       	ldi	r31, 0x40	; 64
    8042:	ff 2a       	or	r15, r31
    8044:	07 c0       	rjmp	.+14     	; 0x8054 <vfprintf+0x168>
    8046:	96 36       	cpi	r25, 0x66	; 102
    8048:	19 f4       	brne	.+6      	; 0x8050 <vfprintf+0x164>
    804a:	20 e8       	ldi	r18, 0x80	; 128
    804c:	f2 2a       	or	r15, r18
    804e:	02 c0       	rjmp	.+4      	; 0x8054 <vfprintf+0x168>
    8050:	91 10       	cpse	r9, r1
    8052:	9a 94       	dec	r9
    8054:	f7 fe       	sbrs	r15, 7
    8056:	0a c0       	rjmp	.+20     	; 0x806c <vfprintf+0x180>
    8058:	3b e3       	ldi	r19, 0x3B	; 59
    805a:	39 15       	cp	r19, r9
    805c:	18 f4       	brcc	.+6      	; 0x8064 <vfprintf+0x178>
    805e:	5c e3       	ldi	r21, 0x3C	; 60
    8060:	b5 2e       	mov	r11, r21
    8062:	02 c0       	rjmp	.+4      	; 0x8068 <vfprintf+0x17c>
    8064:	b9 2c       	mov	r11, r9
    8066:	b3 94       	inc	r11
    8068:	27 e0       	ldi	r18, 0x07	; 7
    806a:	09 c0       	rjmp	.+18     	; 0x807e <vfprintf+0x192>
    806c:	47 e0       	ldi	r20, 0x07	; 7
    806e:	49 15       	cp	r20, r9
    8070:	20 f4       	brcc	.+8      	; 0x807a <vfprintf+0x18e>
    8072:	bb 24       	eor	r11, r11
    8074:	47 e0       	ldi	r20, 0x07	; 7
    8076:	94 2e       	mov	r9, r20
    8078:	f7 cf       	rjmp	.-18     	; 0x8068 <vfprintf+0x17c>
    807a:	29 2d       	mov	r18, r9
    807c:	bb 24       	eor	r11, r11
    807e:	c6 01       	movw	r24, r12
    8080:	04 96       	adiw	r24, 0x04	; 4
    8082:	9d 87       	std	Y+13, r25	; 0x0d
    8084:	8c 87       	std	Y+12, r24	; 0x0c
    8086:	f6 01       	movw	r30, r12
    8088:	60 81       	ld	r22, Z
    808a:	71 81       	ldd	r23, Z+1	; 0x01
    808c:	82 81       	ldd	r24, Z+2	; 0x02
    808e:	93 81       	ldd	r25, Z+3	; 0x03
    8090:	ae 01       	movw	r20, r28
    8092:	4f 5f       	subi	r20, 0xFF	; 255
    8094:	5f 4f       	sbci	r21, 0xFF	; 255
    8096:	0b 2d       	mov	r16, r11
    8098:	0e 94 31 48 	call	0x9062	; 0x9062 <__ftoa_engine>
    809c:	6c 01       	movw	r12, r24
    809e:	09 81       	ldd	r16, Y+1	; 0x01
    80a0:	20 2e       	mov	r2, r16
    80a2:	33 24       	eor	r3, r3
    80a4:	00 ff       	sbrs	r16, 0
    80a6:	04 c0       	rjmp	.+8      	; 0x80b0 <vfprintf+0x1c4>
    80a8:	03 fd       	sbrc	r16, 3
    80aa:	02 c0       	rjmp	.+4      	; 0x80b0 <vfprintf+0x1c4>
    80ac:	1d e2       	ldi	r17, 0x2D	; 45
    80ae:	09 c0       	rjmp	.+18     	; 0x80c2 <vfprintf+0x1d6>
    80b0:	f1 fe       	sbrs	r15, 1
    80b2:	02 c0       	rjmp	.+4      	; 0x80b8 <vfprintf+0x1cc>
    80b4:	1b e2       	ldi	r17, 0x2B	; 43
    80b6:	05 c0       	rjmp	.+10     	; 0x80c2 <vfprintf+0x1d6>
    80b8:	f2 fc       	sbrc	r15, 2
    80ba:	02 c0       	rjmp	.+4      	; 0x80c0 <vfprintf+0x1d4>
    80bc:	10 e0       	ldi	r17, 0x00	; 0
    80be:	01 c0       	rjmp	.+2      	; 0x80c2 <vfprintf+0x1d6>
    80c0:	10 e2       	ldi	r17, 0x20	; 32
    80c2:	c1 01       	movw	r24, r2
    80c4:	8c 70       	andi	r24, 0x0C	; 12
    80c6:	90 70       	andi	r25, 0x00	; 0
    80c8:	89 2b       	or	r24, r25
    80ca:	b9 f1       	breq	.+110    	; 0x813a <vfprintf+0x24e>
    80cc:	11 23       	and	r17, r17
    80ce:	11 f4       	brne	.+4      	; 0x80d4 <vfprintf+0x1e8>
    80d0:	83 e0       	ldi	r24, 0x03	; 3
    80d2:	01 c0       	rjmp	.+2      	; 0x80d6 <vfprintf+0x1ea>
    80d4:	84 e0       	ldi	r24, 0x04	; 4
    80d6:	88 15       	cp	r24, r8
    80d8:	10 f0       	brcs	.+4      	; 0x80de <vfprintf+0x1f2>
    80da:	88 24       	eor	r8, r8
    80dc:	0a c0       	rjmp	.+20     	; 0x80f2 <vfprintf+0x206>
    80de:	88 1a       	sub	r8, r24
    80e0:	f3 fc       	sbrc	r15, 3
    80e2:	07 c0       	rjmp	.+14     	; 0x80f2 <vfprintf+0x206>
    80e4:	80 e2       	ldi	r24, 0x20	; 32
    80e6:	90 e0       	ldi	r25, 0x00	; 0
    80e8:	b3 01       	movw	r22, r6
    80ea:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    80ee:	8a 94       	dec	r8
    80f0:	c9 f7       	brne	.-14     	; 0x80e4 <vfprintf+0x1f8>
    80f2:	11 23       	and	r17, r17
    80f4:	29 f0       	breq	.+10     	; 0x8100 <vfprintf+0x214>
    80f6:	81 2f       	mov	r24, r17
    80f8:	90 e0       	ldi	r25, 0x00	; 0
    80fa:	b3 01       	movw	r22, r6
    80fc:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8100:	23 fe       	sbrs	r2, 3
    8102:	03 c0       	rjmp	.+6      	; 0x810a <vfprintf+0x21e>
    8104:	0e e7       	ldi	r16, 0x7E	; 126
    8106:	15 e0       	ldi	r17, 0x05	; 5
    8108:	0e c0       	rjmp	.+28     	; 0x8126 <vfprintf+0x23a>
    810a:	02 e8       	ldi	r16, 0x82	; 130
    810c:	15 e0       	ldi	r17, 0x05	; 5
    810e:	0b c0       	rjmp	.+22     	; 0x8126 <vfprintf+0x23a>
    8110:	e1 14       	cp	r14, r1
    8112:	f1 04       	cpc	r15, r1
    8114:	09 f0       	breq	.+2      	; 0x8118 <vfprintf+0x22c>
    8116:	80 52       	subi	r24, 0x20	; 32
    8118:	90 e0       	ldi	r25, 0x00	; 0
    811a:	b3 01       	movw	r22, r6
    811c:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8120:	0f 5f       	subi	r16, 0xFF	; 255
    8122:	1f 4f       	sbci	r17, 0xFF	; 255
    8124:	05 c0       	rjmp	.+10     	; 0x8130 <vfprintf+0x244>
    8126:	ef 2c       	mov	r14, r15
    8128:	ff 24       	eor	r15, r15
    812a:	f0 e1       	ldi	r31, 0x10	; 16
    812c:	ef 22       	and	r14, r31
    812e:	ff 24       	eor	r15, r15
    8130:	f8 01       	movw	r30, r16
    8132:	84 91       	lpm	r24, Z+
    8134:	88 23       	and	r24, r24
    8136:	61 f7       	brne	.-40     	; 0x8110 <vfprintf+0x224>
    8138:	14 c1       	rjmp	.+552    	; 0x8362 <vfprintf+0x476>
    813a:	f7 fe       	sbrs	r15, 7
    813c:	12 c0       	rjmp	.+36     	; 0x8162 <vfprintf+0x276>
    813e:	bc 0c       	add	r11, r12
    8140:	24 fe       	sbrs	r2, 4
    8142:	04 c0       	rjmp	.+8      	; 0x814c <vfprintf+0x260>
    8144:	8a 81       	ldd	r24, Y+2	; 0x02
    8146:	81 33       	cpi	r24, 0x31	; 49
    8148:	09 f4       	brne	.+2      	; 0x814c <vfprintf+0x260>
    814a:	ba 94       	dec	r11
    814c:	1b 14       	cp	r1, r11
    814e:	1c f0       	brlt	.+6      	; 0x8156 <vfprintf+0x26a>
    8150:	bb 24       	eor	r11, r11
    8152:	b3 94       	inc	r11
    8154:	2d c0       	rjmp	.+90     	; 0x81b0 <vfprintf+0x2c4>
    8156:	f8 e0       	ldi	r31, 0x08	; 8
    8158:	fb 15       	cp	r31, r11
    815a:	50 f5       	brcc	.+84     	; 0x81b0 <vfprintf+0x2c4>
    815c:	38 e0       	ldi	r19, 0x08	; 8
    815e:	b3 2e       	mov	r11, r19
    8160:	27 c0       	rjmp	.+78     	; 0x81b0 <vfprintf+0x2c4>
    8162:	f6 fc       	sbrc	r15, 6
    8164:	25 c0       	rjmp	.+74     	; 0x81b0 <vfprintf+0x2c4>
    8166:	89 2d       	mov	r24, r9
    8168:	90 e0       	ldi	r25, 0x00	; 0
    816a:	8c 15       	cp	r24, r12
    816c:	9d 05       	cpc	r25, r13
    816e:	4c f0       	brlt	.+18     	; 0x8182 <vfprintf+0x296>
    8170:	2c ef       	ldi	r18, 0xFC	; 252
    8172:	c2 16       	cp	r12, r18
    8174:	2f ef       	ldi	r18, 0xFF	; 255
    8176:	d2 06       	cpc	r13, r18
    8178:	24 f0       	brlt	.+8      	; 0x8182 <vfprintf+0x296>
    817a:	30 e8       	ldi	r19, 0x80	; 128
    817c:	f3 2a       	or	r15, r19
    817e:	01 c0       	rjmp	.+2      	; 0x8182 <vfprintf+0x296>
    8180:	9a 94       	dec	r9
    8182:	99 20       	and	r9, r9
    8184:	49 f0       	breq	.+18     	; 0x8198 <vfprintf+0x2ac>
    8186:	e2 e0       	ldi	r30, 0x02	; 2
    8188:	f0 e0       	ldi	r31, 0x00	; 0
    818a:	ec 0f       	add	r30, r28
    818c:	fd 1f       	adc	r31, r29
    818e:	e9 0d       	add	r30, r9
    8190:	f1 1d       	adc	r31, r1
    8192:	80 81       	ld	r24, Z
    8194:	80 33       	cpi	r24, 0x30	; 48
    8196:	a1 f3       	breq	.-24     	; 0x8180 <vfprintf+0x294>
    8198:	f7 fe       	sbrs	r15, 7
    819a:	0a c0       	rjmp	.+20     	; 0x81b0 <vfprintf+0x2c4>
    819c:	b9 2c       	mov	r11, r9
    819e:	b3 94       	inc	r11
    81a0:	89 2d       	mov	r24, r9
    81a2:	90 e0       	ldi	r25, 0x00	; 0
    81a4:	c8 16       	cp	r12, r24
    81a6:	d9 06       	cpc	r13, r25
    81a8:	14 f0       	brlt	.+4      	; 0x81ae <vfprintf+0x2c2>
    81aa:	99 24       	eor	r9, r9
    81ac:	01 c0       	rjmp	.+2      	; 0x81b0 <vfprintf+0x2c4>
    81ae:	9c 18       	sub	r9, r12
    81b0:	f7 fc       	sbrc	r15, 7
    81b2:	03 c0       	rjmp	.+6      	; 0x81ba <vfprintf+0x2ce>
    81b4:	25 e0       	ldi	r18, 0x05	; 5
    81b6:	30 e0       	ldi	r19, 0x00	; 0
    81b8:	09 c0       	rjmp	.+18     	; 0x81cc <vfprintf+0x2e0>
    81ba:	1c 14       	cp	r1, r12
    81bc:	1d 04       	cpc	r1, r13
    81be:	1c f0       	brlt	.+6      	; 0x81c6 <vfprintf+0x2da>
    81c0:	21 e0       	ldi	r18, 0x01	; 1
    81c2:	30 e0       	ldi	r19, 0x00	; 0
    81c4:	03 c0       	rjmp	.+6      	; 0x81cc <vfprintf+0x2e0>
    81c6:	96 01       	movw	r18, r12
    81c8:	2f 5f       	subi	r18, 0xFF	; 255
    81ca:	3f 4f       	sbci	r19, 0xFF	; 255
    81cc:	11 23       	and	r17, r17
    81ce:	11 f0       	breq	.+4      	; 0x81d4 <vfprintf+0x2e8>
    81d0:	2f 5f       	subi	r18, 0xFF	; 255
    81d2:	3f 4f       	sbci	r19, 0xFF	; 255
    81d4:	99 20       	and	r9, r9
    81d6:	29 f0       	breq	.+10     	; 0x81e2 <vfprintf+0x2f6>
    81d8:	89 2d       	mov	r24, r9
    81da:	90 e0       	ldi	r25, 0x00	; 0
    81dc:	01 96       	adiw	r24, 0x01	; 1
    81de:	28 0f       	add	r18, r24
    81e0:	39 1f       	adc	r19, r25
    81e2:	88 2d       	mov	r24, r8
    81e4:	90 e0       	ldi	r25, 0x00	; 0
    81e6:	28 17       	cp	r18, r24
    81e8:	39 07       	cpc	r19, r25
    81ea:	14 f0       	brlt	.+4      	; 0x81f0 <vfprintf+0x304>
    81ec:	88 24       	eor	r8, r8
    81ee:	01 c0       	rjmp	.+2      	; 0x81f2 <vfprintf+0x306>
    81f0:	82 1a       	sub	r8, r18
    81f2:	4f 2c       	mov	r4, r15
    81f4:	55 24       	eor	r5, r5
    81f6:	c2 01       	movw	r24, r4
    81f8:	89 70       	andi	r24, 0x09	; 9
    81fa:	90 70       	andi	r25, 0x00	; 0
    81fc:	89 2b       	or	r24, r25
    81fe:	39 f0       	breq	.+14     	; 0x820e <vfprintf+0x322>
    8200:	08 c0       	rjmp	.+16     	; 0x8212 <vfprintf+0x326>
    8202:	80 e2       	ldi	r24, 0x20	; 32
    8204:	90 e0       	ldi	r25, 0x00	; 0
    8206:	b3 01       	movw	r22, r6
    8208:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    820c:	8a 94       	dec	r8
    820e:	88 20       	and	r8, r8
    8210:	c1 f7       	brne	.-16     	; 0x8202 <vfprintf+0x316>
    8212:	11 23       	and	r17, r17
    8214:	29 f0       	breq	.+10     	; 0x8220 <vfprintf+0x334>
    8216:	81 2f       	mov	r24, r17
    8218:	90 e0       	ldi	r25, 0x00	; 0
    821a:	b3 01       	movw	r22, r6
    821c:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8220:	43 fe       	sbrs	r4, 3
    8222:	07 c0       	rjmp	.+14     	; 0x8232 <vfprintf+0x346>
    8224:	08 c0       	rjmp	.+16     	; 0x8236 <vfprintf+0x34a>
    8226:	80 e3       	ldi	r24, 0x30	; 48
    8228:	90 e0       	ldi	r25, 0x00	; 0
    822a:	b3 01       	movw	r22, r6
    822c:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8230:	8a 94       	dec	r8
    8232:	88 20       	and	r8, r8
    8234:	c1 f7       	brne	.-16     	; 0x8226 <vfprintf+0x33a>
    8236:	f7 fe       	sbrs	r15, 7
    8238:	46 c0       	rjmp	.+140    	; 0x82c6 <vfprintf+0x3da>
    823a:	86 01       	movw	r16, r12
    823c:	d7 fe       	sbrs	r13, 7
    823e:	02 c0       	rjmp	.+4      	; 0x8244 <vfprintf+0x358>
    8240:	00 e0       	ldi	r16, 0x00	; 0
    8242:	10 e0       	ldi	r17, 0x00	; 0
    8244:	76 01       	movw	r14, r12
    8246:	08 94       	sec
    8248:	e1 1c       	adc	r14, r1
    824a:	f1 1c       	adc	r15, r1
    824c:	e0 1a       	sub	r14, r16
    824e:	f1 0a       	sbc	r15, r17
    8250:	41 e0       	ldi	r20, 0x01	; 1
    8252:	50 e0       	ldi	r21, 0x00	; 0
    8254:	4c 0f       	add	r20, r28
    8256:	5d 1f       	adc	r21, r29
    8258:	e4 0e       	add	r14, r20
    825a:	f5 1e       	adc	r15, r21
    825c:	26 01       	movw	r4, r12
    825e:	4b 18       	sub	r4, r11
    8260:	51 08       	sbc	r5, r1
    8262:	89 2d       	mov	r24, r9
    8264:	90 e0       	ldi	r25, 0x00	; 0
    8266:	aa 24       	eor	r10, r10
    8268:	bb 24       	eor	r11, r11
    826a:	a8 1a       	sub	r10, r24
    826c:	b9 0a       	sbc	r11, r25
    826e:	5f ef       	ldi	r21, 0xFF	; 255
    8270:	0f 3f       	cpi	r16, 0xFF	; 255
    8272:	15 07       	cpc	r17, r21
    8274:	29 f4       	brne	.+10     	; 0x8280 <vfprintf+0x394>
    8276:	8e e2       	ldi	r24, 0x2E	; 46
    8278:	90 e0       	ldi	r25, 0x00	; 0
    827a:	b3 01       	movw	r22, r6
    827c:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8280:	c0 16       	cp	r12, r16
    8282:	d1 06       	cpc	r13, r17
    8284:	34 f0       	brlt	.+12     	; 0x8292 <vfprintf+0x3a6>
    8286:	40 16       	cp	r4, r16
    8288:	51 06       	cpc	r5, r17
    828a:	1c f4       	brge	.+6      	; 0x8292 <vfprintf+0x3a6>
    828c:	f7 01       	movw	r30, r14
    828e:	80 81       	ld	r24, Z
    8290:	01 c0       	rjmp	.+2      	; 0x8294 <vfprintf+0x3a8>
    8292:	80 e3       	ldi	r24, 0x30	; 48
    8294:	01 50       	subi	r16, 0x01	; 1
    8296:	10 40       	sbci	r17, 0x00	; 0
    8298:	08 94       	sec
    829a:	e1 1c       	adc	r14, r1
    829c:	f1 1c       	adc	r15, r1
    829e:	0a 15       	cp	r16, r10
    82a0:	1b 05       	cpc	r17, r11
    82a2:	2c f0       	brlt	.+10     	; 0x82ae <vfprintf+0x3c2>
    82a4:	90 e0       	ldi	r25, 0x00	; 0
    82a6:	b3 01       	movw	r22, r6
    82a8:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    82ac:	e0 cf       	rjmp	.-64     	; 0x826e <vfprintf+0x382>
    82ae:	0c 15       	cp	r16, r12
    82b0:	1d 05       	cpc	r17, r13
    82b2:	39 f4       	brne	.+14     	; 0x82c2 <vfprintf+0x3d6>
    82b4:	9a 81       	ldd	r25, Y+2	; 0x02
    82b6:	96 33       	cpi	r25, 0x36	; 54
    82b8:	18 f4       	brcc	.+6      	; 0x82c0 <vfprintf+0x3d4>
    82ba:	95 33       	cpi	r25, 0x35	; 53
    82bc:	11 f4       	brne	.+4      	; 0x82c2 <vfprintf+0x3d6>
    82be:	24 fe       	sbrs	r2, 4
    82c0:	81 e3       	ldi	r24, 0x31	; 49
    82c2:	90 e0       	ldi	r25, 0x00	; 0
    82c4:	4b c0       	rjmp	.+150    	; 0x835c <vfprintf+0x470>
    82c6:	8a 81       	ldd	r24, Y+2	; 0x02
    82c8:	81 33       	cpi	r24, 0x31	; 49
    82ca:	09 f0       	breq	.+2      	; 0x82ce <vfprintf+0x3e2>
    82cc:	0f 7e       	andi	r16, 0xEF	; 239
    82ce:	90 e0       	ldi	r25, 0x00	; 0
    82d0:	b3 01       	movw	r22, r6
    82d2:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    82d6:	99 20       	and	r9, r9
    82d8:	a1 f0       	breq	.+40     	; 0x8302 <vfprintf+0x416>
    82da:	8e e2       	ldi	r24, 0x2E	; 46
    82dc:	90 e0       	ldi	r25, 0x00	; 0
    82de:	b3 01       	movw	r22, r6
    82e0:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    82e4:	12 e0       	ldi	r17, 0x02	; 2
    82e6:	e1 e0       	ldi	r30, 0x01	; 1
    82e8:	f0 e0       	ldi	r31, 0x00	; 0
    82ea:	ec 0f       	add	r30, r28
    82ec:	fd 1f       	adc	r31, r29
    82ee:	e1 0f       	add	r30, r17
    82f0:	f1 1d       	adc	r31, r1
    82f2:	1f 5f       	subi	r17, 0xFF	; 255
    82f4:	80 81       	ld	r24, Z
    82f6:	90 e0       	ldi	r25, 0x00	; 0
    82f8:	b3 01       	movw	r22, r6
    82fa:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    82fe:	9a 94       	dec	r9
    8300:	91 f7       	brne	.-28     	; 0x82e6 <vfprintf+0x3fa>
    8302:	44 fc       	sbrc	r4, 4
    8304:	03 c0       	rjmp	.+6      	; 0x830c <vfprintf+0x420>
    8306:	85 e6       	ldi	r24, 0x65	; 101
    8308:	90 e0       	ldi	r25, 0x00	; 0
    830a:	02 c0       	rjmp	.+4      	; 0x8310 <vfprintf+0x424>
    830c:	85 e4       	ldi	r24, 0x45	; 69
    830e:	90 e0       	ldi	r25, 0x00	; 0
    8310:	b3 01       	movw	r22, r6
    8312:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8316:	d7 fc       	sbrc	r13, 7
    8318:	05 c0       	rjmp	.+10     	; 0x8324 <vfprintf+0x438>
    831a:	c1 14       	cp	r12, r1
    831c:	d1 04       	cpc	r13, r1
    831e:	41 f4       	brne	.+16     	; 0x8330 <vfprintf+0x444>
    8320:	04 ff       	sbrs	r16, 4
    8322:	06 c0       	rjmp	.+12     	; 0x8330 <vfprintf+0x444>
    8324:	d0 94       	com	r13
    8326:	c1 94       	neg	r12
    8328:	d1 08       	sbc	r13, r1
    832a:	d3 94       	inc	r13
    832c:	8d e2       	ldi	r24, 0x2D	; 45
    832e:	01 c0       	rjmp	.+2      	; 0x8332 <vfprintf+0x446>
    8330:	8b e2       	ldi	r24, 0x2B	; 43
    8332:	90 e0       	ldi	r25, 0x00	; 0
    8334:	b3 01       	movw	r22, r6
    8336:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    833a:	80 e3       	ldi	r24, 0x30	; 48
    833c:	05 c0       	rjmp	.+10     	; 0x8348 <vfprintf+0x45c>
    833e:	8f 5f       	subi	r24, 0xFF	; 255
    8340:	26 ef       	ldi	r18, 0xF6	; 246
    8342:	3f ef       	ldi	r19, 0xFF	; 255
    8344:	c2 0e       	add	r12, r18
    8346:	d3 1e       	adc	r13, r19
    8348:	3a e0       	ldi	r19, 0x0A	; 10
    834a:	c3 16       	cp	r12, r19
    834c:	d1 04       	cpc	r13, r1
    834e:	bc f7       	brge	.-18     	; 0x833e <vfprintf+0x452>
    8350:	90 e0       	ldi	r25, 0x00	; 0
    8352:	b3 01       	movw	r22, r6
    8354:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8358:	c6 01       	movw	r24, r12
    835a:	c0 96       	adiw	r24, 0x30	; 48
    835c:	b3 01       	movw	r22, r6
    835e:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8362:	cc 84       	ldd	r12, Y+12	; 0x0c
    8364:	dd 84       	ldd	r13, Y+13	; 0x0d
    8366:	52 c1       	rjmp	.+676    	; 0x860c <vfprintf+0x720>
    8368:	93 36       	cpi	r25, 0x63	; 99
    836a:	31 f0       	breq	.+12     	; 0x8378 <vfprintf+0x48c>
    836c:	93 37       	cpi	r25, 0x73	; 115
    836e:	99 f0       	breq	.+38     	; 0x8396 <vfprintf+0x4aa>
    8370:	93 35       	cpi	r25, 0x53	; 83
    8372:	09 f0       	breq	.+2      	; 0x8376 <vfprintf+0x48a>
    8374:	59 c0       	rjmp	.+178    	; 0x8428 <vfprintf+0x53c>
    8376:	23 c0       	rjmp	.+70     	; 0x83be <vfprintf+0x4d2>
    8378:	f6 01       	movw	r30, r12
    837a:	80 81       	ld	r24, Z
    837c:	89 83       	std	Y+1, r24	; 0x01
    837e:	5e 01       	movw	r10, r28
    8380:	08 94       	sec
    8382:	a1 1c       	adc	r10, r1
    8384:	b1 1c       	adc	r11, r1
    8386:	22 e0       	ldi	r18, 0x02	; 2
    8388:	30 e0       	ldi	r19, 0x00	; 0
    838a:	c2 0e       	add	r12, r18
    838c:	d3 1e       	adc	r13, r19
    838e:	21 e0       	ldi	r18, 0x01	; 1
    8390:	e2 2e       	mov	r14, r18
    8392:	f1 2c       	mov	r15, r1
    8394:	12 c0       	rjmp	.+36     	; 0x83ba <vfprintf+0x4ce>
    8396:	f6 01       	movw	r30, r12
    8398:	a0 80       	ld	r10, Z
    839a:	b1 80       	ldd	r11, Z+1	; 0x01
    839c:	16 fd       	sbrc	r17, 6
    839e:	03 c0       	rjmp	.+6      	; 0x83a6 <vfprintf+0x4ba>
    83a0:	6f ef       	ldi	r22, 0xFF	; 255
    83a2:	7f ef       	ldi	r23, 0xFF	; 255
    83a4:	02 c0       	rjmp	.+4      	; 0x83aa <vfprintf+0x4be>
    83a6:	69 2d       	mov	r22, r9
    83a8:	70 e0       	ldi	r23, 0x00	; 0
    83aa:	22 e0       	ldi	r18, 0x02	; 2
    83ac:	30 e0       	ldi	r19, 0x00	; 0
    83ae:	c2 0e       	add	r12, r18
    83b0:	d3 1e       	adc	r13, r19
    83b2:	c5 01       	movw	r24, r10
    83b4:	0e 94 38 49 	call	0x9270	; 0x9270 <strnlen>
    83b8:	7c 01       	movw	r14, r24
    83ba:	1f 77       	andi	r17, 0x7F	; 127
    83bc:	13 c0       	rjmp	.+38     	; 0x83e4 <vfprintf+0x4f8>
    83be:	f6 01       	movw	r30, r12
    83c0:	a0 80       	ld	r10, Z
    83c2:	b1 80       	ldd	r11, Z+1	; 0x01
    83c4:	16 fd       	sbrc	r17, 6
    83c6:	03 c0       	rjmp	.+6      	; 0x83ce <vfprintf+0x4e2>
    83c8:	6f ef       	ldi	r22, 0xFF	; 255
    83ca:	7f ef       	ldi	r23, 0xFF	; 255
    83cc:	02 c0       	rjmp	.+4      	; 0x83d2 <vfprintf+0x4e6>
    83ce:	69 2d       	mov	r22, r9
    83d0:	70 e0       	ldi	r23, 0x00	; 0
    83d2:	22 e0       	ldi	r18, 0x02	; 2
    83d4:	30 e0       	ldi	r19, 0x00	; 0
    83d6:	c2 0e       	add	r12, r18
    83d8:	d3 1e       	adc	r13, r19
    83da:	c5 01       	movw	r24, r10
    83dc:	0e 94 18 49 	call	0x9230	; 0x9230 <strnlen_P>
    83e0:	7c 01       	movw	r14, r24
    83e2:	10 68       	ori	r17, 0x80	; 128
    83e4:	13 ff       	sbrs	r17, 3
    83e6:	07 c0       	rjmp	.+14     	; 0x83f6 <vfprintf+0x50a>
    83e8:	1b c0       	rjmp	.+54     	; 0x8420 <vfprintf+0x534>
    83ea:	80 e2       	ldi	r24, 0x20	; 32
    83ec:	90 e0       	ldi	r25, 0x00	; 0
    83ee:	b3 01       	movw	r22, r6
    83f0:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    83f4:	8a 94       	dec	r8
    83f6:	88 2d       	mov	r24, r8
    83f8:	90 e0       	ldi	r25, 0x00	; 0
    83fa:	e8 16       	cp	r14, r24
    83fc:	f9 06       	cpc	r15, r25
    83fe:	a8 f3       	brcs	.-22     	; 0x83ea <vfprintf+0x4fe>
    8400:	0f c0       	rjmp	.+30     	; 0x8420 <vfprintf+0x534>
    8402:	f5 01       	movw	r30, r10
    8404:	17 fd       	sbrc	r17, 7
    8406:	85 91       	lpm	r24, Z+
    8408:	17 ff       	sbrs	r17, 7
    840a:	81 91       	ld	r24, Z+
    840c:	5f 01       	movw	r10, r30
    840e:	90 e0       	ldi	r25, 0x00	; 0
    8410:	b3 01       	movw	r22, r6
    8412:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8416:	81 10       	cpse	r8, r1
    8418:	8a 94       	dec	r8
    841a:	08 94       	sec
    841c:	e1 08       	sbc	r14, r1
    841e:	f1 08       	sbc	r15, r1
    8420:	e1 14       	cp	r14, r1
    8422:	f1 04       	cpc	r15, r1
    8424:	71 f7       	brne	.-36     	; 0x8402 <vfprintf+0x516>
    8426:	f2 c0       	rjmp	.+484    	; 0x860c <vfprintf+0x720>
    8428:	94 36       	cpi	r25, 0x64	; 100
    842a:	11 f0       	breq	.+4      	; 0x8430 <vfprintf+0x544>
    842c:	99 36       	cpi	r25, 0x69	; 105
    842e:	89 f5       	brne	.+98     	; 0x8492 <vfprintf+0x5a6>
    8430:	17 ff       	sbrs	r17, 7
    8432:	08 c0       	rjmp	.+16     	; 0x8444 <vfprintf+0x558>
    8434:	f6 01       	movw	r30, r12
    8436:	20 81       	ld	r18, Z
    8438:	31 81       	ldd	r19, Z+1	; 0x01
    843a:	42 81       	ldd	r20, Z+2	; 0x02
    843c:	53 81       	ldd	r21, Z+3	; 0x03
    843e:	84 e0       	ldi	r24, 0x04	; 4
    8440:	90 e0       	ldi	r25, 0x00	; 0
    8442:	0a c0       	rjmp	.+20     	; 0x8458 <vfprintf+0x56c>
    8444:	f6 01       	movw	r30, r12
    8446:	80 81       	ld	r24, Z
    8448:	91 81       	ldd	r25, Z+1	; 0x01
    844a:	9c 01       	movw	r18, r24
    844c:	44 27       	eor	r20, r20
    844e:	37 fd       	sbrc	r19, 7
    8450:	40 95       	com	r20
    8452:	54 2f       	mov	r21, r20
    8454:	82 e0       	ldi	r24, 0x02	; 2
    8456:	90 e0       	ldi	r25, 0x00	; 0
    8458:	c8 0e       	add	r12, r24
    845a:	d9 1e       	adc	r13, r25
    845c:	9f e6       	ldi	r25, 0x6F	; 111
    845e:	f9 2e       	mov	r15, r25
    8460:	f1 22       	and	r15, r17
    8462:	57 ff       	sbrs	r21, 7
    8464:	09 c0       	rjmp	.+18     	; 0x8478 <vfprintf+0x58c>
    8466:	50 95       	com	r21
    8468:	40 95       	com	r20
    846a:	30 95       	com	r19
    846c:	21 95       	neg	r18
    846e:	3f 4f       	sbci	r19, 0xFF	; 255
    8470:	4f 4f       	sbci	r20, 0xFF	; 255
    8472:	5f 4f       	sbci	r21, 0xFF	; 255
    8474:	90 e8       	ldi	r25, 0x80	; 128
    8476:	f9 2a       	or	r15, r25
    8478:	ca 01       	movw	r24, r20
    847a:	b9 01       	movw	r22, r18
    847c:	ae 01       	movw	r20, r28
    847e:	4f 5f       	subi	r20, 0xFF	; 255
    8480:	5f 4f       	sbci	r21, 0xFF	; 255
    8482:	2a e0       	ldi	r18, 0x0A	; 10
    8484:	30 e0       	ldi	r19, 0x00	; 0
    8486:	0e 94 cf 49 	call	0x939e	; 0x939e <__ultoa_invert>
    848a:	e8 2e       	mov	r14, r24
    848c:	e8 89       	ldd	r30, Y+16	; 0x10
    848e:	ee 1a       	sub	r14, r30
    8490:	41 c0       	rjmp	.+130    	; 0x8514 <vfprintf+0x628>
    8492:	95 37       	cpi	r25, 0x75	; 117
    8494:	21 f4       	brne	.+8      	; 0x849e <vfprintf+0x5b2>
    8496:	1f 7e       	andi	r17, 0xEF	; 239
    8498:	2a e0       	ldi	r18, 0x0A	; 10
    849a:	30 e0       	ldi	r19, 0x00	; 0
    849c:	1c c0       	rjmp	.+56     	; 0x84d6 <vfprintf+0x5ea>
    849e:	19 7f       	andi	r17, 0xF9	; 249
    84a0:	9f 36       	cpi	r25, 0x6F	; 111
    84a2:	61 f0       	breq	.+24     	; 0x84bc <vfprintf+0x5d0>
    84a4:	90 37       	cpi	r25, 0x70	; 112
    84a6:	20 f4       	brcc	.+8      	; 0x84b0 <vfprintf+0x5c4>
    84a8:	98 35       	cpi	r25, 0x58	; 88
    84aa:	09 f0       	breq	.+2      	; 0x84ae <vfprintf+0x5c2>
    84ac:	b2 c0       	rjmp	.+356    	; 0x8612 <vfprintf+0x726>
    84ae:	0f c0       	rjmp	.+30     	; 0x84ce <vfprintf+0x5e2>
    84b0:	90 37       	cpi	r25, 0x70	; 112
    84b2:	39 f0       	breq	.+14     	; 0x84c2 <vfprintf+0x5d6>
    84b4:	98 37       	cpi	r25, 0x78	; 120
    84b6:	09 f0       	breq	.+2      	; 0x84ba <vfprintf+0x5ce>
    84b8:	ac c0       	rjmp	.+344    	; 0x8612 <vfprintf+0x726>
    84ba:	04 c0       	rjmp	.+8      	; 0x84c4 <vfprintf+0x5d8>
    84bc:	28 e0       	ldi	r18, 0x08	; 8
    84be:	30 e0       	ldi	r19, 0x00	; 0
    84c0:	0a c0       	rjmp	.+20     	; 0x84d6 <vfprintf+0x5ea>
    84c2:	10 61       	ori	r17, 0x10	; 16
    84c4:	14 fd       	sbrc	r17, 4
    84c6:	14 60       	ori	r17, 0x04	; 4
    84c8:	20 e1       	ldi	r18, 0x10	; 16
    84ca:	30 e0       	ldi	r19, 0x00	; 0
    84cc:	04 c0       	rjmp	.+8      	; 0x84d6 <vfprintf+0x5ea>
    84ce:	14 fd       	sbrc	r17, 4
    84d0:	16 60       	ori	r17, 0x06	; 6
    84d2:	20 e1       	ldi	r18, 0x10	; 16
    84d4:	32 e0       	ldi	r19, 0x02	; 2
    84d6:	17 ff       	sbrs	r17, 7
    84d8:	08 c0       	rjmp	.+16     	; 0x84ea <vfprintf+0x5fe>
    84da:	f6 01       	movw	r30, r12
    84dc:	60 81       	ld	r22, Z
    84de:	71 81       	ldd	r23, Z+1	; 0x01
    84e0:	82 81       	ldd	r24, Z+2	; 0x02
    84e2:	93 81       	ldd	r25, Z+3	; 0x03
    84e4:	44 e0       	ldi	r20, 0x04	; 4
    84e6:	50 e0       	ldi	r21, 0x00	; 0
    84e8:	08 c0       	rjmp	.+16     	; 0x84fa <vfprintf+0x60e>
    84ea:	f6 01       	movw	r30, r12
    84ec:	80 81       	ld	r24, Z
    84ee:	91 81       	ldd	r25, Z+1	; 0x01
    84f0:	bc 01       	movw	r22, r24
    84f2:	80 e0       	ldi	r24, 0x00	; 0
    84f4:	90 e0       	ldi	r25, 0x00	; 0
    84f6:	42 e0       	ldi	r20, 0x02	; 2
    84f8:	50 e0       	ldi	r21, 0x00	; 0
    84fa:	c4 0e       	add	r12, r20
    84fc:	d5 1e       	adc	r13, r21
    84fe:	ae 01       	movw	r20, r28
    8500:	4f 5f       	subi	r20, 0xFF	; 255
    8502:	5f 4f       	sbci	r21, 0xFF	; 255
    8504:	0e 94 cf 49 	call	0x939e	; 0x939e <__ultoa_invert>
    8508:	e8 2e       	mov	r14, r24
    850a:	58 89       	ldd	r21, Y+16	; 0x10
    850c:	e5 1a       	sub	r14, r21
    850e:	8f e7       	ldi	r24, 0x7F	; 127
    8510:	f8 2e       	mov	r15, r24
    8512:	f1 22       	and	r15, r17
    8514:	f6 fe       	sbrs	r15, 6
    8516:	0b c0       	rjmp	.+22     	; 0x852e <vfprintf+0x642>
    8518:	8e ef       	ldi	r24, 0xFE	; 254
    851a:	f8 22       	and	r15, r24
    851c:	e9 14       	cp	r14, r9
    851e:	38 f4       	brcc	.+14     	; 0x852e <vfprintf+0x642>
    8520:	f4 fe       	sbrs	r15, 4
    8522:	07 c0       	rjmp	.+14     	; 0x8532 <vfprintf+0x646>
    8524:	f2 fc       	sbrc	r15, 2
    8526:	05 c0       	rjmp	.+10     	; 0x8532 <vfprintf+0x646>
    8528:	9f ee       	ldi	r25, 0xEF	; 239
    852a:	f9 22       	and	r15, r25
    852c:	02 c0       	rjmp	.+4      	; 0x8532 <vfprintf+0x646>
    852e:	1e 2d       	mov	r17, r14
    8530:	01 c0       	rjmp	.+2      	; 0x8534 <vfprintf+0x648>
    8532:	19 2d       	mov	r17, r9
    8534:	f4 fe       	sbrs	r15, 4
    8536:	0d c0       	rjmp	.+26     	; 0x8552 <vfprintf+0x666>
    8538:	fe 01       	movw	r30, r28
    853a:	ee 0d       	add	r30, r14
    853c:	f1 1d       	adc	r31, r1
    853e:	80 81       	ld	r24, Z
    8540:	80 33       	cpi	r24, 0x30	; 48
    8542:	19 f4       	brne	.+6      	; 0x854a <vfprintf+0x65e>
    8544:	e9 ee       	ldi	r30, 0xE9	; 233
    8546:	fe 22       	and	r15, r30
    8548:	08 c0       	rjmp	.+16     	; 0x855a <vfprintf+0x66e>
    854a:	1f 5f       	subi	r17, 0xFF	; 255
    854c:	f2 fe       	sbrs	r15, 2
    854e:	05 c0       	rjmp	.+10     	; 0x855a <vfprintf+0x66e>
    8550:	03 c0       	rjmp	.+6      	; 0x8558 <vfprintf+0x66c>
    8552:	8f 2d       	mov	r24, r15
    8554:	86 78       	andi	r24, 0x86	; 134
    8556:	09 f0       	breq	.+2      	; 0x855a <vfprintf+0x66e>
    8558:	1f 5f       	subi	r17, 0xFF	; 255
    855a:	0f 2d       	mov	r16, r15
    855c:	f3 fc       	sbrc	r15, 3
    855e:	14 c0       	rjmp	.+40     	; 0x8588 <vfprintf+0x69c>
    8560:	f0 fe       	sbrs	r15, 0
    8562:	0f c0       	rjmp	.+30     	; 0x8582 <vfprintf+0x696>
    8564:	18 15       	cp	r17, r8
    8566:	10 f0       	brcs	.+4      	; 0x856c <vfprintf+0x680>
    8568:	9e 2c       	mov	r9, r14
    856a:	0b c0       	rjmp	.+22     	; 0x8582 <vfprintf+0x696>
    856c:	9e 2c       	mov	r9, r14
    856e:	98 0c       	add	r9, r8
    8570:	91 1a       	sub	r9, r17
    8572:	18 2d       	mov	r17, r8
    8574:	06 c0       	rjmp	.+12     	; 0x8582 <vfprintf+0x696>
    8576:	80 e2       	ldi	r24, 0x20	; 32
    8578:	90 e0       	ldi	r25, 0x00	; 0
    857a:	b3 01       	movw	r22, r6
    857c:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    8580:	1f 5f       	subi	r17, 0xFF	; 255
    8582:	18 15       	cp	r17, r8
    8584:	c0 f3       	brcs	.-16     	; 0x8576 <vfprintf+0x68a>
    8586:	04 c0       	rjmp	.+8      	; 0x8590 <vfprintf+0x6a4>
    8588:	18 15       	cp	r17, r8
    858a:	10 f4       	brcc	.+4      	; 0x8590 <vfprintf+0x6a4>
    858c:	81 1a       	sub	r8, r17
    858e:	01 c0       	rjmp	.+2      	; 0x8592 <vfprintf+0x6a6>
    8590:	88 24       	eor	r8, r8
    8592:	04 ff       	sbrs	r16, 4
    8594:	0f c0       	rjmp	.+30     	; 0x85b4 <vfprintf+0x6c8>
    8596:	80 e3       	ldi	r24, 0x30	; 48
    8598:	90 e0       	ldi	r25, 0x00	; 0
    859a:	b3 01       	movw	r22, r6
    859c:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    85a0:	02 ff       	sbrs	r16, 2
    85a2:	1d c0       	rjmp	.+58     	; 0x85de <vfprintf+0x6f2>
    85a4:	01 fd       	sbrc	r16, 1
    85a6:	03 c0       	rjmp	.+6      	; 0x85ae <vfprintf+0x6c2>
    85a8:	88 e7       	ldi	r24, 0x78	; 120
    85aa:	90 e0       	ldi	r25, 0x00	; 0
    85ac:	0e c0       	rjmp	.+28     	; 0x85ca <vfprintf+0x6de>
    85ae:	88 e5       	ldi	r24, 0x58	; 88
    85b0:	90 e0       	ldi	r25, 0x00	; 0
    85b2:	0b c0       	rjmp	.+22     	; 0x85ca <vfprintf+0x6de>
    85b4:	80 2f       	mov	r24, r16
    85b6:	86 78       	andi	r24, 0x86	; 134
    85b8:	91 f0       	breq	.+36     	; 0x85de <vfprintf+0x6f2>
    85ba:	01 ff       	sbrs	r16, 1
    85bc:	02 c0       	rjmp	.+4      	; 0x85c2 <vfprintf+0x6d6>
    85be:	8b e2       	ldi	r24, 0x2B	; 43
    85c0:	01 c0       	rjmp	.+2      	; 0x85c4 <vfprintf+0x6d8>
    85c2:	80 e2       	ldi	r24, 0x20	; 32
    85c4:	f7 fc       	sbrc	r15, 7
    85c6:	8d e2       	ldi	r24, 0x2D	; 45
    85c8:	90 e0       	ldi	r25, 0x00	; 0
    85ca:	b3 01       	movw	r22, r6
    85cc:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    85d0:	06 c0       	rjmp	.+12     	; 0x85de <vfprintf+0x6f2>
    85d2:	80 e3       	ldi	r24, 0x30	; 48
    85d4:	90 e0       	ldi	r25, 0x00	; 0
    85d6:	b3 01       	movw	r22, r6
    85d8:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    85dc:	9a 94       	dec	r9
    85de:	e9 14       	cp	r14, r9
    85e0:	c0 f3       	brcs	.-16     	; 0x85d2 <vfprintf+0x6e6>
    85e2:	ea 94       	dec	r14
    85e4:	e1 e0       	ldi	r30, 0x01	; 1
    85e6:	f0 e0       	ldi	r31, 0x00	; 0
    85e8:	ec 0f       	add	r30, r28
    85ea:	fd 1f       	adc	r31, r29
    85ec:	ee 0d       	add	r30, r14
    85ee:	f1 1d       	adc	r31, r1
    85f0:	80 81       	ld	r24, Z
    85f2:	90 e0       	ldi	r25, 0x00	; 0
    85f4:	b3 01       	movw	r22, r6
    85f6:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    85fa:	ee 20       	and	r14, r14
    85fc:	91 f7       	brne	.-28     	; 0x85e2 <vfprintf+0x6f6>
    85fe:	06 c0       	rjmp	.+12     	; 0x860c <vfprintf+0x720>
    8600:	80 e2       	ldi	r24, 0x20	; 32
    8602:	90 e0       	ldi	r25, 0x00	; 0
    8604:	b3 01       	movw	r22, r6
    8606:	0e 94 72 49 	call	0x92e4	; 0x92e4 <fputc>
    860a:	8a 94       	dec	r8
    860c:	88 20       	and	r8, r8
    860e:	c1 f7       	brne	.-16     	; 0x8600 <vfprintf+0x714>
    8610:	99 cc       	rjmp	.-1742   	; 0x7f44 <vfprintf+0x58>
    8612:	f3 01       	movw	r30, r6
    8614:	66 81       	ldd	r22, Z+6	; 0x06
    8616:	77 81       	ldd	r23, Z+7	; 0x07
    8618:	cb 01       	movw	r24, r22
    861a:	61 96       	adiw	r28, 0x11	; 17
    861c:	0f b6       	in	r0, 0x3f	; 63
    861e:	f8 94       	cli
    8620:	de bf       	out	0x3e, r29	; 62
    8622:	0f be       	out	0x3f, r0	; 63
    8624:	cd bf       	out	0x3d, r28	; 61
    8626:	cf 91       	pop	r28
    8628:	df 91       	pop	r29
    862a:	1f 91       	pop	r17
    862c:	0f 91       	pop	r16
    862e:	ff 90       	pop	r15
    8630:	ef 90       	pop	r14
    8632:	df 90       	pop	r13
    8634:	cf 90       	pop	r12
    8636:	bf 90       	pop	r11
    8638:	af 90       	pop	r10
    863a:	9f 90       	pop	r9
    863c:	8f 90       	pop	r8
    863e:	7f 90       	pop	r7
    8640:	6f 90       	pop	r6
    8642:	5f 90       	pop	r5
    8644:	4f 90       	pop	r4
    8646:	3f 90       	pop	r3
    8648:	2f 90       	pop	r2
    864a:	08 95       	ret

0000864c <__subsf3>:
    864c:	50 58       	subi	r21, 0x80	; 128

0000864e <__addsf3>:
    864e:	bb 27       	eor	r27, r27
    8650:	aa 27       	eor	r26, r26
    8652:	0e d0       	rcall	.+28     	; 0x8670 <__addsf3x>
    8654:	b1 c1       	rjmp	.+866    	; 0x89b8 <__fp_round>
    8656:	a2 d1       	rcall	.+836    	; 0x899c <__fp_pscA>
    8658:	30 f0       	brcs	.+12     	; 0x8666 <__addsf3+0x18>
    865a:	a7 d1       	rcall	.+846    	; 0x89aa <__fp_pscB>
    865c:	20 f0       	brcs	.+8      	; 0x8666 <__addsf3+0x18>
    865e:	31 f4       	brne	.+12     	; 0x866c <__addsf3+0x1e>
    8660:	9f 3f       	cpi	r25, 0xFF	; 255
    8662:	11 f4       	brne	.+4      	; 0x8668 <__addsf3+0x1a>
    8664:	1e f4       	brtc	.+6      	; 0x866c <__addsf3+0x1e>
    8666:	97 c1       	rjmp	.+814    	; 0x8996 <__fp_nan>
    8668:	0e f4       	brtc	.+2      	; 0x866c <__addsf3+0x1e>
    866a:	e0 95       	com	r30
    866c:	e7 fb       	bst	r30, 7
    866e:	64 c1       	rjmp	.+712    	; 0x8938 <__fp_inf>

00008670 <__addsf3x>:
    8670:	e9 2f       	mov	r30, r25
    8672:	b3 d1       	rcall	.+870    	; 0x89da <__fp_split3>
    8674:	80 f3       	brcs	.-32     	; 0x8656 <__addsf3+0x8>
    8676:	ba 17       	cp	r27, r26
    8678:	62 07       	cpc	r22, r18
    867a:	73 07       	cpc	r23, r19
    867c:	84 07       	cpc	r24, r20
    867e:	95 07       	cpc	r25, r21
    8680:	18 f0       	brcs	.+6      	; 0x8688 <__addsf3x+0x18>
    8682:	71 f4       	brne	.+28     	; 0x86a0 <__addsf3x+0x30>
    8684:	9e f5       	brtc	.+102    	; 0x86ec <__addsf3x+0x7c>
    8686:	e2 c1       	rjmp	.+964    	; 0x8a4c <__fp_zero>
    8688:	0e f4       	brtc	.+2      	; 0x868c <__addsf3x+0x1c>
    868a:	e0 95       	com	r30
    868c:	0b 2e       	mov	r0, r27
    868e:	ba 2f       	mov	r27, r26
    8690:	a0 2d       	mov	r26, r0
    8692:	0b 01       	movw	r0, r22
    8694:	b9 01       	movw	r22, r18
    8696:	90 01       	movw	r18, r0
    8698:	0c 01       	movw	r0, r24
    869a:	ca 01       	movw	r24, r20
    869c:	a0 01       	movw	r20, r0
    869e:	11 24       	eor	r1, r1
    86a0:	ff 27       	eor	r31, r31
    86a2:	59 1b       	sub	r21, r25
    86a4:	99 f0       	breq	.+38     	; 0x86cc <__addsf3x+0x5c>
    86a6:	59 3f       	cpi	r21, 0xF9	; 249
    86a8:	50 f4       	brcc	.+20     	; 0x86be <__addsf3x+0x4e>
    86aa:	50 3e       	cpi	r21, 0xE0	; 224
    86ac:	68 f1       	brcs	.+90     	; 0x8708 <__addsf3x+0x98>
    86ae:	1a 16       	cp	r1, r26
    86b0:	f0 40       	sbci	r31, 0x00	; 0
    86b2:	a2 2f       	mov	r26, r18
    86b4:	23 2f       	mov	r18, r19
    86b6:	34 2f       	mov	r19, r20
    86b8:	44 27       	eor	r20, r20
    86ba:	58 5f       	subi	r21, 0xF8	; 248
    86bc:	f3 cf       	rjmp	.-26     	; 0x86a4 <__addsf3x+0x34>
    86be:	46 95       	lsr	r20
    86c0:	37 95       	ror	r19
    86c2:	27 95       	ror	r18
    86c4:	a7 95       	ror	r26
    86c6:	f0 40       	sbci	r31, 0x00	; 0
    86c8:	53 95       	inc	r21
    86ca:	c9 f7       	brne	.-14     	; 0x86be <__addsf3x+0x4e>
    86cc:	7e f4       	brtc	.+30     	; 0x86ec <__addsf3x+0x7c>
    86ce:	1f 16       	cp	r1, r31
    86d0:	ba 0b       	sbc	r27, r26
    86d2:	62 0b       	sbc	r22, r18
    86d4:	73 0b       	sbc	r23, r19
    86d6:	84 0b       	sbc	r24, r20
    86d8:	ba f0       	brmi	.+46     	; 0x8708 <__addsf3x+0x98>
    86da:	91 50       	subi	r25, 0x01	; 1
    86dc:	a1 f0       	breq	.+40     	; 0x8706 <__addsf3x+0x96>
    86de:	ff 0f       	add	r31, r31
    86e0:	bb 1f       	adc	r27, r27
    86e2:	66 1f       	adc	r22, r22
    86e4:	77 1f       	adc	r23, r23
    86e6:	88 1f       	adc	r24, r24
    86e8:	c2 f7       	brpl	.-16     	; 0x86da <__addsf3x+0x6a>
    86ea:	0e c0       	rjmp	.+28     	; 0x8708 <__addsf3x+0x98>
    86ec:	ba 0f       	add	r27, r26
    86ee:	62 1f       	adc	r22, r18
    86f0:	73 1f       	adc	r23, r19
    86f2:	84 1f       	adc	r24, r20
    86f4:	48 f4       	brcc	.+18     	; 0x8708 <__addsf3x+0x98>
    86f6:	87 95       	ror	r24
    86f8:	77 95       	ror	r23
    86fa:	67 95       	ror	r22
    86fc:	b7 95       	ror	r27
    86fe:	f7 95       	ror	r31
    8700:	9e 3f       	cpi	r25, 0xFE	; 254
    8702:	08 f0       	brcs	.+2      	; 0x8706 <__addsf3x+0x96>
    8704:	b3 cf       	rjmp	.-154    	; 0x866c <__addsf3+0x1e>
    8706:	93 95       	inc	r25
    8708:	88 0f       	add	r24, r24
    870a:	08 f0       	brcs	.+2      	; 0x870e <__addsf3x+0x9e>
    870c:	99 27       	eor	r25, r25
    870e:	ee 0f       	add	r30, r30
    8710:	97 95       	ror	r25
    8712:	87 95       	ror	r24
    8714:	08 95       	ret

00008716 <__cmpsf2>:
    8716:	ec d0       	rcall	.+472    	; 0x88f0 <__fp_cmp>
    8718:	08 f4       	brcc	.+2      	; 0x871c <__cmpsf2+0x6>
    871a:	81 e0       	ldi	r24, 0x01	; 1
    871c:	08 95       	ret

0000871e <__divsf3>:
    871e:	0c d0       	rcall	.+24     	; 0x8738 <__divsf3x>
    8720:	4b c1       	rjmp	.+662    	; 0x89b8 <__fp_round>
    8722:	43 d1       	rcall	.+646    	; 0x89aa <__fp_pscB>
    8724:	40 f0       	brcs	.+16     	; 0x8736 <__divsf3+0x18>
    8726:	3a d1       	rcall	.+628    	; 0x899c <__fp_pscA>
    8728:	30 f0       	brcs	.+12     	; 0x8736 <__divsf3+0x18>
    872a:	21 f4       	brne	.+8      	; 0x8734 <__divsf3+0x16>
    872c:	5f 3f       	cpi	r21, 0xFF	; 255
    872e:	19 f0       	breq	.+6      	; 0x8736 <__divsf3+0x18>
    8730:	03 c1       	rjmp	.+518    	; 0x8938 <__fp_inf>
    8732:	51 11       	cpse	r21, r1
    8734:	8c c1       	rjmp	.+792    	; 0x8a4e <__fp_szero>
    8736:	2f c1       	rjmp	.+606    	; 0x8996 <__fp_nan>

00008738 <__divsf3x>:
    8738:	50 d1       	rcall	.+672    	; 0x89da <__fp_split3>
    873a:	98 f3       	brcs	.-26     	; 0x8722 <__divsf3+0x4>

0000873c <__divsf3_pse>:
    873c:	99 23       	and	r25, r25
    873e:	c9 f3       	breq	.-14     	; 0x8732 <__divsf3+0x14>
    8740:	55 23       	and	r21, r21
    8742:	b1 f3       	breq	.-20     	; 0x8730 <__divsf3+0x12>
    8744:	95 1b       	sub	r25, r21
    8746:	55 0b       	sbc	r21, r21
    8748:	bb 27       	eor	r27, r27
    874a:	aa 27       	eor	r26, r26
    874c:	62 17       	cp	r22, r18
    874e:	73 07       	cpc	r23, r19
    8750:	84 07       	cpc	r24, r20
    8752:	38 f0       	brcs	.+14     	; 0x8762 <__divsf3_pse+0x26>
    8754:	9f 5f       	subi	r25, 0xFF	; 255
    8756:	5f 4f       	sbci	r21, 0xFF	; 255
    8758:	22 0f       	add	r18, r18
    875a:	33 1f       	adc	r19, r19
    875c:	44 1f       	adc	r20, r20
    875e:	aa 1f       	adc	r26, r26
    8760:	a9 f3       	breq	.-22     	; 0x874c <__divsf3_pse+0x10>
    8762:	33 d0       	rcall	.+102    	; 0x87ca <__divsf3_pse+0x8e>
    8764:	0e 2e       	mov	r0, r30
    8766:	3a f0       	brmi	.+14     	; 0x8776 <__divsf3_pse+0x3a>
    8768:	e0 e8       	ldi	r30, 0x80	; 128
    876a:	30 d0       	rcall	.+96     	; 0x87cc <__divsf3_pse+0x90>
    876c:	91 50       	subi	r25, 0x01	; 1
    876e:	50 40       	sbci	r21, 0x00	; 0
    8770:	e6 95       	lsr	r30
    8772:	00 1c       	adc	r0, r0
    8774:	ca f7       	brpl	.-14     	; 0x8768 <__divsf3_pse+0x2c>
    8776:	29 d0       	rcall	.+82     	; 0x87ca <__divsf3_pse+0x8e>
    8778:	fe 2f       	mov	r31, r30
    877a:	27 d0       	rcall	.+78     	; 0x87ca <__divsf3_pse+0x8e>
    877c:	66 0f       	add	r22, r22
    877e:	77 1f       	adc	r23, r23
    8780:	88 1f       	adc	r24, r24
    8782:	bb 1f       	adc	r27, r27
    8784:	26 17       	cp	r18, r22
    8786:	37 07       	cpc	r19, r23
    8788:	48 07       	cpc	r20, r24
    878a:	ab 07       	cpc	r26, r27
    878c:	b0 e8       	ldi	r27, 0x80	; 128
    878e:	09 f0       	breq	.+2      	; 0x8792 <__divsf3_pse+0x56>
    8790:	bb 0b       	sbc	r27, r27
    8792:	80 2d       	mov	r24, r0
    8794:	bf 01       	movw	r22, r30
    8796:	ff 27       	eor	r31, r31
    8798:	93 58       	subi	r25, 0x83	; 131
    879a:	5f 4f       	sbci	r21, 0xFF	; 255
    879c:	2a f0       	brmi	.+10     	; 0x87a8 <__divsf3_pse+0x6c>
    879e:	9e 3f       	cpi	r25, 0xFE	; 254
    87a0:	51 05       	cpc	r21, r1
    87a2:	68 f0       	brcs	.+26     	; 0x87be <__divsf3_pse+0x82>
    87a4:	c9 c0       	rjmp	.+402    	; 0x8938 <__fp_inf>
    87a6:	53 c1       	rjmp	.+678    	; 0x8a4e <__fp_szero>
    87a8:	5f 3f       	cpi	r21, 0xFF	; 255
    87aa:	ec f3       	brlt	.-6      	; 0x87a6 <__divsf3_pse+0x6a>
    87ac:	98 3e       	cpi	r25, 0xE8	; 232
    87ae:	dc f3       	brlt	.-10     	; 0x87a6 <__divsf3_pse+0x6a>
    87b0:	86 95       	lsr	r24
    87b2:	77 95       	ror	r23
    87b4:	67 95       	ror	r22
    87b6:	b7 95       	ror	r27
    87b8:	f7 95       	ror	r31
    87ba:	9f 5f       	subi	r25, 0xFF	; 255
    87bc:	c9 f7       	brne	.-14     	; 0x87b0 <__divsf3_pse+0x74>
    87be:	88 0f       	add	r24, r24
    87c0:	91 1d       	adc	r25, r1
    87c2:	96 95       	lsr	r25
    87c4:	87 95       	ror	r24
    87c6:	97 f9       	bld	r25, 7
    87c8:	08 95       	ret
    87ca:	e1 e0       	ldi	r30, 0x01	; 1
    87cc:	66 0f       	add	r22, r22
    87ce:	77 1f       	adc	r23, r23
    87d0:	88 1f       	adc	r24, r24
    87d2:	bb 1f       	adc	r27, r27
    87d4:	62 17       	cp	r22, r18
    87d6:	73 07       	cpc	r23, r19
    87d8:	84 07       	cpc	r24, r20
    87da:	ba 07       	cpc	r27, r26
    87dc:	20 f0       	brcs	.+8      	; 0x87e6 <__divsf3_pse+0xaa>
    87de:	62 1b       	sub	r22, r18
    87e0:	73 0b       	sbc	r23, r19
    87e2:	84 0b       	sbc	r24, r20
    87e4:	ba 0b       	sbc	r27, r26
    87e6:	ee 1f       	adc	r30, r30
    87e8:	88 f7       	brcc	.-30     	; 0x87cc <__divsf3_pse+0x90>
    87ea:	e0 95       	com	r30
    87ec:	08 95       	ret

000087ee <__fixsfsi>:
    87ee:	04 d0       	rcall	.+8      	; 0x87f8 <__fixunssfsi>
    87f0:	68 94       	set
    87f2:	b1 11       	cpse	r27, r1
    87f4:	2c c1       	rjmp	.+600    	; 0x8a4e <__fp_szero>
    87f6:	08 95       	ret

000087f8 <__fixunssfsi>:
    87f8:	f8 d0       	rcall	.+496    	; 0x89ea <__fp_splitA>
    87fa:	88 f0       	brcs	.+34     	; 0x881e <__fixunssfsi+0x26>
    87fc:	9f 57       	subi	r25, 0x7F	; 127
    87fe:	90 f0       	brcs	.+36     	; 0x8824 <__fixunssfsi+0x2c>
    8800:	b9 2f       	mov	r27, r25
    8802:	99 27       	eor	r25, r25
    8804:	b7 51       	subi	r27, 0x17	; 23
    8806:	a0 f0       	brcs	.+40     	; 0x8830 <__fixunssfsi+0x38>
    8808:	d1 f0       	breq	.+52     	; 0x883e <__fixunssfsi+0x46>
    880a:	66 0f       	add	r22, r22
    880c:	77 1f       	adc	r23, r23
    880e:	88 1f       	adc	r24, r24
    8810:	99 1f       	adc	r25, r25
    8812:	1a f0       	brmi	.+6      	; 0x881a <__fixunssfsi+0x22>
    8814:	ba 95       	dec	r27
    8816:	c9 f7       	brne	.-14     	; 0x880a <__fixunssfsi+0x12>
    8818:	12 c0       	rjmp	.+36     	; 0x883e <__fixunssfsi+0x46>
    881a:	b1 30       	cpi	r27, 0x01	; 1
    881c:	81 f0       	breq	.+32     	; 0x883e <__fixunssfsi+0x46>
    881e:	16 d1       	rcall	.+556    	; 0x8a4c <__fp_zero>
    8820:	b1 e0       	ldi	r27, 0x01	; 1
    8822:	08 95       	ret
    8824:	13 c1       	rjmp	.+550    	; 0x8a4c <__fp_zero>
    8826:	67 2f       	mov	r22, r23
    8828:	78 2f       	mov	r23, r24
    882a:	88 27       	eor	r24, r24
    882c:	b8 5f       	subi	r27, 0xF8	; 248
    882e:	39 f0       	breq	.+14     	; 0x883e <__fixunssfsi+0x46>
    8830:	b9 3f       	cpi	r27, 0xF9	; 249
    8832:	cc f3       	brlt	.-14     	; 0x8826 <__fixunssfsi+0x2e>
    8834:	86 95       	lsr	r24
    8836:	77 95       	ror	r23
    8838:	67 95       	ror	r22
    883a:	b3 95       	inc	r27
    883c:	d9 f7       	brne	.-10     	; 0x8834 <__fixunssfsi+0x3c>
    883e:	3e f4       	brtc	.+14     	; 0x884e <__fixunssfsi+0x56>
    8840:	90 95       	com	r25
    8842:	80 95       	com	r24
    8844:	70 95       	com	r23
    8846:	61 95       	neg	r22
    8848:	7f 4f       	sbci	r23, 0xFF	; 255
    884a:	8f 4f       	sbci	r24, 0xFF	; 255
    884c:	9f 4f       	sbci	r25, 0xFF	; 255
    884e:	08 95       	ret

00008850 <__floatunsisf>:
    8850:	e8 94       	clt
    8852:	09 c0       	rjmp	.+18     	; 0x8866 <__floatsisf+0x12>

00008854 <__floatsisf>:
    8854:	97 fb       	bst	r25, 7
    8856:	3e f4       	brtc	.+14     	; 0x8866 <__floatsisf+0x12>
    8858:	90 95       	com	r25
    885a:	80 95       	com	r24
    885c:	70 95       	com	r23
    885e:	61 95       	neg	r22
    8860:	7f 4f       	sbci	r23, 0xFF	; 255
    8862:	8f 4f       	sbci	r24, 0xFF	; 255
    8864:	9f 4f       	sbci	r25, 0xFF	; 255
    8866:	99 23       	and	r25, r25
    8868:	a9 f0       	breq	.+42     	; 0x8894 <__floatsisf+0x40>
    886a:	f9 2f       	mov	r31, r25
    886c:	96 e9       	ldi	r25, 0x96	; 150
    886e:	bb 27       	eor	r27, r27
    8870:	93 95       	inc	r25
    8872:	f6 95       	lsr	r31
    8874:	87 95       	ror	r24
    8876:	77 95       	ror	r23
    8878:	67 95       	ror	r22
    887a:	b7 95       	ror	r27
    887c:	f1 11       	cpse	r31, r1
    887e:	f8 cf       	rjmp	.-16     	; 0x8870 <__floatsisf+0x1c>
    8880:	fa f4       	brpl	.+62     	; 0x88c0 <__floatsisf+0x6c>
    8882:	bb 0f       	add	r27, r27
    8884:	11 f4       	brne	.+4      	; 0x888a <__floatsisf+0x36>
    8886:	60 ff       	sbrs	r22, 0
    8888:	1b c0       	rjmp	.+54     	; 0x88c0 <__floatsisf+0x6c>
    888a:	6f 5f       	subi	r22, 0xFF	; 255
    888c:	7f 4f       	sbci	r23, 0xFF	; 255
    888e:	8f 4f       	sbci	r24, 0xFF	; 255
    8890:	9f 4f       	sbci	r25, 0xFF	; 255
    8892:	16 c0       	rjmp	.+44     	; 0x88c0 <__floatsisf+0x6c>
    8894:	88 23       	and	r24, r24
    8896:	11 f0       	breq	.+4      	; 0x889c <__floatsisf+0x48>
    8898:	96 e9       	ldi	r25, 0x96	; 150
    889a:	11 c0       	rjmp	.+34     	; 0x88be <__floatsisf+0x6a>
    889c:	77 23       	and	r23, r23
    889e:	21 f0       	breq	.+8      	; 0x88a8 <__floatsisf+0x54>
    88a0:	9e e8       	ldi	r25, 0x8E	; 142
    88a2:	87 2f       	mov	r24, r23
    88a4:	76 2f       	mov	r23, r22
    88a6:	05 c0       	rjmp	.+10     	; 0x88b2 <__floatsisf+0x5e>
    88a8:	66 23       	and	r22, r22
    88aa:	71 f0       	breq	.+28     	; 0x88c8 <__floatsisf+0x74>
    88ac:	96 e8       	ldi	r25, 0x86	; 134
    88ae:	86 2f       	mov	r24, r22
    88b0:	70 e0       	ldi	r23, 0x00	; 0
    88b2:	60 e0       	ldi	r22, 0x00	; 0
    88b4:	2a f0       	brmi	.+10     	; 0x88c0 <__floatsisf+0x6c>
    88b6:	9a 95       	dec	r25
    88b8:	66 0f       	add	r22, r22
    88ba:	77 1f       	adc	r23, r23
    88bc:	88 1f       	adc	r24, r24
    88be:	da f7       	brpl	.-10     	; 0x88b6 <__floatsisf+0x62>
    88c0:	88 0f       	add	r24, r24
    88c2:	96 95       	lsr	r25
    88c4:	87 95       	ror	r24
    88c6:	97 f9       	bld	r25, 7
    88c8:	08 95       	ret

000088ca <floor>:
    88ca:	a9 d0       	rcall	.+338    	; 0x8a1e <__fp_trunc>
    88cc:	80 f0       	brcs	.+32     	; 0x88ee <floor+0x24>
    88ce:	9f 37       	cpi	r25, 0x7F	; 127
    88d0:	40 f4       	brcc	.+16     	; 0x88e2 <floor+0x18>
    88d2:	91 11       	cpse	r25, r1
    88d4:	0e f0       	brts	.+2      	; 0x88d8 <floor+0xe>
    88d6:	bb c0       	rjmp	.+374    	; 0x8a4e <__fp_szero>
    88d8:	60 e0       	ldi	r22, 0x00	; 0
    88da:	70 e0       	ldi	r23, 0x00	; 0
    88dc:	80 e8       	ldi	r24, 0x80	; 128
    88de:	9f eb       	ldi	r25, 0xBF	; 191
    88e0:	08 95       	ret
    88e2:	26 f4       	brtc	.+8      	; 0x88ec <floor+0x22>
    88e4:	1b 16       	cp	r1, r27
    88e6:	61 1d       	adc	r22, r1
    88e8:	71 1d       	adc	r23, r1
    88ea:	81 1d       	adc	r24, r1
    88ec:	2b c0       	rjmp	.+86     	; 0x8944 <__fp_mintl>
    88ee:	45 c0       	rjmp	.+138    	; 0x897a <__fp_mpack>

000088f0 <__fp_cmp>:
    88f0:	99 0f       	add	r25, r25
    88f2:	00 08       	sbc	r0, r0
    88f4:	55 0f       	add	r21, r21
    88f6:	aa 0b       	sbc	r26, r26
    88f8:	e0 e8       	ldi	r30, 0x80	; 128
    88fa:	fe ef       	ldi	r31, 0xFE	; 254
    88fc:	16 16       	cp	r1, r22
    88fe:	17 06       	cpc	r1, r23
    8900:	e8 07       	cpc	r30, r24
    8902:	f9 07       	cpc	r31, r25
    8904:	c0 f0       	brcs	.+48     	; 0x8936 <__fp_cmp+0x46>
    8906:	12 16       	cp	r1, r18
    8908:	13 06       	cpc	r1, r19
    890a:	e4 07       	cpc	r30, r20
    890c:	f5 07       	cpc	r31, r21
    890e:	98 f0       	brcs	.+38     	; 0x8936 <__fp_cmp+0x46>
    8910:	62 1b       	sub	r22, r18
    8912:	73 0b       	sbc	r23, r19
    8914:	84 0b       	sbc	r24, r20
    8916:	95 0b       	sbc	r25, r21
    8918:	39 f4       	brne	.+14     	; 0x8928 <__fp_cmp+0x38>
    891a:	0a 26       	eor	r0, r26
    891c:	61 f0       	breq	.+24     	; 0x8936 <__fp_cmp+0x46>
    891e:	23 2b       	or	r18, r19
    8920:	24 2b       	or	r18, r20
    8922:	25 2b       	or	r18, r21
    8924:	21 f4       	brne	.+8      	; 0x892e <__fp_cmp+0x3e>
    8926:	08 95       	ret
    8928:	0a 26       	eor	r0, r26
    892a:	09 f4       	brne	.+2      	; 0x892e <__fp_cmp+0x3e>
    892c:	a1 40       	sbci	r26, 0x01	; 1
    892e:	a6 95       	lsr	r26
    8930:	8f ef       	ldi	r24, 0xFF	; 255
    8932:	81 1d       	adc	r24, r1
    8934:	81 1d       	adc	r24, r1
    8936:	08 95       	ret

00008938 <__fp_inf>:
    8938:	97 f9       	bld	r25, 7
    893a:	9f 67       	ori	r25, 0x7F	; 127
    893c:	80 e8       	ldi	r24, 0x80	; 128
    893e:	70 e0       	ldi	r23, 0x00	; 0
    8940:	60 e0       	ldi	r22, 0x00	; 0
    8942:	08 95       	ret

00008944 <__fp_mintl>:
    8944:	88 23       	and	r24, r24
    8946:	71 f4       	brne	.+28     	; 0x8964 <__fp_mintl+0x20>
    8948:	77 23       	and	r23, r23
    894a:	21 f0       	breq	.+8      	; 0x8954 <__fp_mintl+0x10>
    894c:	98 50       	subi	r25, 0x08	; 8
    894e:	87 2b       	or	r24, r23
    8950:	76 2f       	mov	r23, r22
    8952:	07 c0       	rjmp	.+14     	; 0x8962 <__fp_mintl+0x1e>
    8954:	66 23       	and	r22, r22
    8956:	11 f4       	brne	.+4      	; 0x895c <__fp_mintl+0x18>
    8958:	99 27       	eor	r25, r25
    895a:	0d c0       	rjmp	.+26     	; 0x8976 <__fp_mintl+0x32>
    895c:	90 51       	subi	r25, 0x10	; 16
    895e:	86 2b       	or	r24, r22
    8960:	70 e0       	ldi	r23, 0x00	; 0
    8962:	60 e0       	ldi	r22, 0x00	; 0
    8964:	2a f0       	brmi	.+10     	; 0x8970 <__fp_mintl+0x2c>
    8966:	9a 95       	dec	r25
    8968:	66 0f       	add	r22, r22
    896a:	77 1f       	adc	r23, r23
    896c:	88 1f       	adc	r24, r24
    896e:	da f7       	brpl	.-10     	; 0x8966 <__fp_mintl+0x22>
    8970:	88 0f       	add	r24, r24
    8972:	96 95       	lsr	r25
    8974:	87 95       	ror	r24
    8976:	97 f9       	bld	r25, 7
    8978:	08 95       	ret

0000897a <__fp_mpack>:
    897a:	9f 3f       	cpi	r25, 0xFF	; 255
    897c:	31 f0       	breq	.+12     	; 0x898a <__fp_mpack_finite+0xc>

0000897e <__fp_mpack_finite>:
    897e:	91 50       	subi	r25, 0x01	; 1
    8980:	20 f4       	brcc	.+8      	; 0x898a <__fp_mpack_finite+0xc>
    8982:	87 95       	ror	r24
    8984:	77 95       	ror	r23
    8986:	67 95       	ror	r22
    8988:	b7 95       	ror	r27
    898a:	88 0f       	add	r24, r24
    898c:	91 1d       	adc	r25, r1
    898e:	96 95       	lsr	r25
    8990:	87 95       	ror	r24
    8992:	97 f9       	bld	r25, 7
    8994:	08 95       	ret

00008996 <__fp_nan>:
    8996:	9f ef       	ldi	r25, 0xFF	; 255
    8998:	80 ec       	ldi	r24, 0xC0	; 192
    899a:	08 95       	ret

0000899c <__fp_pscA>:
    899c:	00 24       	eor	r0, r0
    899e:	0a 94       	dec	r0
    89a0:	16 16       	cp	r1, r22
    89a2:	17 06       	cpc	r1, r23
    89a4:	18 06       	cpc	r1, r24
    89a6:	09 06       	cpc	r0, r25
    89a8:	08 95       	ret

000089aa <__fp_pscB>:
    89aa:	00 24       	eor	r0, r0
    89ac:	0a 94       	dec	r0
    89ae:	12 16       	cp	r1, r18
    89b0:	13 06       	cpc	r1, r19
    89b2:	14 06       	cpc	r1, r20
    89b4:	05 06       	cpc	r0, r21
    89b6:	08 95       	ret

000089b8 <__fp_round>:
    89b8:	09 2e       	mov	r0, r25
    89ba:	03 94       	inc	r0
    89bc:	00 0c       	add	r0, r0
    89be:	11 f4       	brne	.+4      	; 0x89c4 <__fp_round+0xc>
    89c0:	88 23       	and	r24, r24
    89c2:	52 f0       	brmi	.+20     	; 0x89d8 <__fp_round+0x20>
    89c4:	bb 0f       	add	r27, r27
    89c6:	40 f4       	brcc	.+16     	; 0x89d8 <__fp_round+0x20>
    89c8:	bf 2b       	or	r27, r31
    89ca:	11 f4       	brne	.+4      	; 0x89d0 <__fp_round+0x18>
    89cc:	60 ff       	sbrs	r22, 0
    89ce:	04 c0       	rjmp	.+8      	; 0x89d8 <__fp_round+0x20>
    89d0:	6f 5f       	subi	r22, 0xFF	; 255
    89d2:	7f 4f       	sbci	r23, 0xFF	; 255
    89d4:	8f 4f       	sbci	r24, 0xFF	; 255
    89d6:	9f 4f       	sbci	r25, 0xFF	; 255
    89d8:	08 95       	ret

000089da <__fp_split3>:
    89da:	57 fd       	sbrc	r21, 7
    89dc:	90 58       	subi	r25, 0x80	; 128
    89de:	44 0f       	add	r20, r20
    89e0:	55 1f       	adc	r21, r21
    89e2:	59 f0       	breq	.+22     	; 0x89fa <__fp_splitA+0x10>
    89e4:	5f 3f       	cpi	r21, 0xFF	; 255
    89e6:	71 f0       	breq	.+28     	; 0x8a04 <__fp_splitA+0x1a>
    89e8:	47 95       	ror	r20

000089ea <__fp_splitA>:
    89ea:	88 0f       	add	r24, r24
    89ec:	97 fb       	bst	r25, 7
    89ee:	99 1f       	adc	r25, r25
    89f0:	61 f0       	breq	.+24     	; 0x8a0a <__fp_splitA+0x20>
    89f2:	9f 3f       	cpi	r25, 0xFF	; 255
    89f4:	79 f0       	breq	.+30     	; 0x8a14 <__fp_splitA+0x2a>
    89f6:	87 95       	ror	r24
    89f8:	08 95       	ret
    89fa:	12 16       	cp	r1, r18
    89fc:	13 06       	cpc	r1, r19
    89fe:	14 06       	cpc	r1, r20
    8a00:	55 1f       	adc	r21, r21
    8a02:	f2 cf       	rjmp	.-28     	; 0x89e8 <__fp_split3+0xe>
    8a04:	46 95       	lsr	r20
    8a06:	f1 df       	rcall	.-30     	; 0x89ea <__fp_splitA>
    8a08:	08 c0       	rjmp	.+16     	; 0x8a1a <__fp_splitA+0x30>
    8a0a:	16 16       	cp	r1, r22
    8a0c:	17 06       	cpc	r1, r23
    8a0e:	18 06       	cpc	r1, r24
    8a10:	99 1f       	adc	r25, r25
    8a12:	f1 cf       	rjmp	.-30     	; 0x89f6 <__fp_splitA+0xc>
    8a14:	86 95       	lsr	r24
    8a16:	71 05       	cpc	r23, r1
    8a18:	61 05       	cpc	r22, r1
    8a1a:	08 94       	sec
    8a1c:	08 95       	ret

00008a1e <__fp_trunc>:
    8a1e:	e5 df       	rcall	.-54     	; 0x89ea <__fp_splitA>
    8a20:	a0 f0       	brcs	.+40     	; 0x8a4a <__fp_trunc+0x2c>
    8a22:	be e7       	ldi	r27, 0x7E	; 126
    8a24:	b9 17       	cp	r27, r25
    8a26:	88 f4       	brcc	.+34     	; 0x8a4a <__fp_trunc+0x2c>
    8a28:	bb 27       	eor	r27, r27
    8a2a:	9f 38       	cpi	r25, 0x8F	; 143
    8a2c:	60 f4       	brcc	.+24     	; 0x8a46 <__fp_trunc+0x28>
    8a2e:	16 16       	cp	r1, r22
    8a30:	b1 1d       	adc	r27, r1
    8a32:	67 2f       	mov	r22, r23
    8a34:	78 2f       	mov	r23, r24
    8a36:	88 27       	eor	r24, r24
    8a38:	98 5f       	subi	r25, 0xF8	; 248
    8a3a:	f7 cf       	rjmp	.-18     	; 0x8a2a <__fp_trunc+0xc>
    8a3c:	86 95       	lsr	r24
    8a3e:	77 95       	ror	r23
    8a40:	67 95       	ror	r22
    8a42:	b1 1d       	adc	r27, r1
    8a44:	93 95       	inc	r25
    8a46:	96 39       	cpi	r25, 0x96	; 150
    8a48:	c8 f3       	brcs	.-14     	; 0x8a3c <__fp_trunc+0x1e>
    8a4a:	08 95       	ret

00008a4c <__fp_zero>:
    8a4c:	e8 94       	clt

00008a4e <__fp_szero>:
    8a4e:	bb 27       	eor	r27, r27
    8a50:	66 27       	eor	r22, r22
    8a52:	77 27       	eor	r23, r23
    8a54:	cb 01       	movw	r24, r22
    8a56:	97 f9       	bld	r25, 7
    8a58:	08 95       	ret

00008a5a <__gesf2>:
    8a5a:	4a df       	rcall	.-364    	; 0x88f0 <__fp_cmp>
    8a5c:	08 f4       	brcc	.+2      	; 0x8a60 <__gesf2+0x6>
    8a5e:	8f ef       	ldi	r24, 0xFF	; 255
    8a60:	08 95       	ret

00008a62 <__mulsf3>:
    8a62:	0b d0       	rcall	.+22     	; 0x8a7a <__mulsf3x>
    8a64:	a9 cf       	rjmp	.-174    	; 0x89b8 <__fp_round>
    8a66:	9a df       	rcall	.-204    	; 0x899c <__fp_pscA>
    8a68:	28 f0       	brcs	.+10     	; 0x8a74 <__mulsf3+0x12>
    8a6a:	9f df       	rcall	.-194    	; 0x89aa <__fp_pscB>
    8a6c:	18 f0       	brcs	.+6      	; 0x8a74 <__mulsf3+0x12>
    8a6e:	95 23       	and	r25, r21
    8a70:	09 f0       	breq	.+2      	; 0x8a74 <__mulsf3+0x12>
    8a72:	62 cf       	rjmp	.-316    	; 0x8938 <__fp_inf>
    8a74:	90 cf       	rjmp	.-224    	; 0x8996 <__fp_nan>
    8a76:	11 24       	eor	r1, r1
    8a78:	ea cf       	rjmp	.-44     	; 0x8a4e <__fp_szero>

00008a7a <__mulsf3x>:
    8a7a:	af df       	rcall	.-162    	; 0x89da <__fp_split3>
    8a7c:	a0 f3       	brcs	.-24     	; 0x8a66 <__mulsf3+0x4>

00008a7e <__mulsf3_pse>:
    8a7e:	95 9f       	mul	r25, r21
    8a80:	d1 f3       	breq	.-12     	; 0x8a76 <__mulsf3+0x14>
    8a82:	95 0f       	add	r25, r21
    8a84:	50 e0       	ldi	r21, 0x00	; 0
    8a86:	55 1f       	adc	r21, r21
    8a88:	62 9f       	mul	r22, r18
    8a8a:	f0 01       	movw	r30, r0
    8a8c:	72 9f       	mul	r23, r18
    8a8e:	bb 27       	eor	r27, r27
    8a90:	f0 0d       	add	r31, r0
    8a92:	b1 1d       	adc	r27, r1
    8a94:	63 9f       	mul	r22, r19
    8a96:	aa 27       	eor	r26, r26
    8a98:	f0 0d       	add	r31, r0
    8a9a:	b1 1d       	adc	r27, r1
    8a9c:	aa 1f       	adc	r26, r26
    8a9e:	64 9f       	mul	r22, r20
    8aa0:	66 27       	eor	r22, r22
    8aa2:	b0 0d       	add	r27, r0
    8aa4:	a1 1d       	adc	r26, r1
    8aa6:	66 1f       	adc	r22, r22
    8aa8:	82 9f       	mul	r24, r18
    8aaa:	22 27       	eor	r18, r18
    8aac:	b0 0d       	add	r27, r0
    8aae:	a1 1d       	adc	r26, r1
    8ab0:	62 1f       	adc	r22, r18
    8ab2:	73 9f       	mul	r23, r19
    8ab4:	b0 0d       	add	r27, r0
    8ab6:	a1 1d       	adc	r26, r1
    8ab8:	62 1f       	adc	r22, r18
    8aba:	83 9f       	mul	r24, r19
    8abc:	a0 0d       	add	r26, r0
    8abe:	61 1d       	adc	r22, r1
    8ac0:	22 1f       	adc	r18, r18
    8ac2:	74 9f       	mul	r23, r20
    8ac4:	33 27       	eor	r19, r19
    8ac6:	a0 0d       	add	r26, r0
    8ac8:	61 1d       	adc	r22, r1
    8aca:	23 1f       	adc	r18, r19
    8acc:	84 9f       	mul	r24, r20
    8ace:	60 0d       	add	r22, r0
    8ad0:	21 1d       	adc	r18, r1
    8ad2:	82 2f       	mov	r24, r18
    8ad4:	76 2f       	mov	r23, r22
    8ad6:	6a 2f       	mov	r22, r26
    8ad8:	11 24       	eor	r1, r1
    8ada:	9f 57       	subi	r25, 0x7F	; 127
    8adc:	50 40       	sbci	r21, 0x00	; 0
    8ade:	8a f0       	brmi	.+34     	; 0x8b02 <__mulsf3_pse+0x84>
    8ae0:	e1 f0       	breq	.+56     	; 0x8b1a <__mulsf3_pse+0x9c>
    8ae2:	88 23       	and	r24, r24
    8ae4:	4a f0       	brmi	.+18     	; 0x8af8 <__mulsf3_pse+0x7a>
    8ae6:	ee 0f       	add	r30, r30
    8ae8:	ff 1f       	adc	r31, r31
    8aea:	bb 1f       	adc	r27, r27
    8aec:	66 1f       	adc	r22, r22
    8aee:	77 1f       	adc	r23, r23
    8af0:	88 1f       	adc	r24, r24
    8af2:	91 50       	subi	r25, 0x01	; 1
    8af4:	50 40       	sbci	r21, 0x00	; 0
    8af6:	a9 f7       	brne	.-22     	; 0x8ae2 <__mulsf3_pse+0x64>
    8af8:	9e 3f       	cpi	r25, 0xFE	; 254
    8afa:	51 05       	cpc	r21, r1
    8afc:	70 f0       	brcs	.+28     	; 0x8b1a <__mulsf3_pse+0x9c>
    8afe:	1c cf       	rjmp	.-456    	; 0x8938 <__fp_inf>
    8b00:	a6 cf       	rjmp	.-180    	; 0x8a4e <__fp_szero>
    8b02:	5f 3f       	cpi	r21, 0xFF	; 255
    8b04:	ec f3       	brlt	.-6      	; 0x8b00 <__mulsf3_pse+0x82>
    8b06:	98 3e       	cpi	r25, 0xE8	; 232
    8b08:	dc f3       	brlt	.-10     	; 0x8b00 <__mulsf3_pse+0x82>
    8b0a:	86 95       	lsr	r24
    8b0c:	77 95       	ror	r23
    8b0e:	67 95       	ror	r22
    8b10:	b7 95       	ror	r27
    8b12:	f7 95       	ror	r31
    8b14:	e7 95       	ror	r30
    8b16:	9f 5f       	subi	r25, 0xFF	; 255
    8b18:	c1 f7       	brne	.-16     	; 0x8b0a <__mulsf3_pse+0x8c>
    8b1a:	fe 2b       	or	r31, r30
    8b1c:	88 0f       	add	r24, r24
    8b1e:	91 1d       	adc	r25, r1
    8b20:	96 95       	lsr	r25
    8b22:	87 95       	ror	r24
    8b24:	97 f9       	bld	r25, 7
    8b26:	08 95       	ret

00008b28 <round>:
    8b28:	60 df       	rcall	.-320    	; 0x89ea <__fp_splitA>
    8b2a:	e0 f0       	brcs	.+56     	; 0x8b64 <round+0x3c>
    8b2c:	9e 37       	cpi	r25, 0x7E	; 126
    8b2e:	d8 f0       	brcs	.+54     	; 0x8b66 <round+0x3e>
    8b30:	96 39       	cpi	r25, 0x96	; 150
    8b32:	b8 f4       	brcc	.+46     	; 0x8b62 <round+0x3a>
    8b34:	9e 38       	cpi	r25, 0x8E	; 142
    8b36:	48 f4       	brcc	.+18     	; 0x8b4a <round+0x22>
    8b38:	67 2f       	mov	r22, r23
    8b3a:	78 2f       	mov	r23, r24
    8b3c:	88 27       	eor	r24, r24
    8b3e:	98 5f       	subi	r25, 0xF8	; 248
    8b40:	f9 cf       	rjmp	.-14     	; 0x8b34 <round+0xc>
    8b42:	86 95       	lsr	r24
    8b44:	77 95       	ror	r23
    8b46:	67 95       	ror	r22
    8b48:	93 95       	inc	r25
    8b4a:	95 39       	cpi	r25, 0x95	; 149
    8b4c:	d0 f3       	brcs	.-12     	; 0x8b42 <round+0x1a>
    8b4e:	b6 2f       	mov	r27, r22
    8b50:	b1 70       	andi	r27, 0x01	; 1
    8b52:	6b 0f       	add	r22, r27
    8b54:	71 1d       	adc	r23, r1
    8b56:	81 1d       	adc	r24, r1
    8b58:	20 f4       	brcc	.+8      	; 0x8b62 <round+0x3a>
    8b5a:	87 95       	ror	r24
    8b5c:	77 95       	ror	r23
    8b5e:	67 95       	ror	r22
    8b60:	93 95       	inc	r25
    8b62:	f0 ce       	rjmp	.-544    	; 0x8944 <__fp_mintl>
    8b64:	0a cf       	rjmp	.-492    	; 0x897a <__fp_mpack>
    8b66:	73 cf       	rjmp	.-282    	; 0x8a4e <__fp_szero>

00008b68 <__udivmodhi4>:
    8b68:	aa 1b       	sub	r26, r26
    8b6a:	bb 1b       	sub	r27, r27
    8b6c:	51 e1       	ldi	r21, 0x11	; 17
    8b6e:	07 c0       	rjmp	.+14     	; 0x8b7e <__udivmodhi4_ep>

00008b70 <__udivmodhi4_loop>:
    8b70:	aa 1f       	adc	r26, r26
    8b72:	bb 1f       	adc	r27, r27
    8b74:	a6 17       	cp	r26, r22
    8b76:	b7 07       	cpc	r27, r23
    8b78:	10 f0       	brcs	.+4      	; 0x8b7e <__udivmodhi4_ep>
    8b7a:	a6 1b       	sub	r26, r22
    8b7c:	b7 0b       	sbc	r27, r23

00008b7e <__udivmodhi4_ep>:
    8b7e:	88 1f       	adc	r24, r24
    8b80:	99 1f       	adc	r25, r25
    8b82:	5a 95       	dec	r21
    8b84:	a9 f7       	brne	.-22     	; 0x8b70 <__udivmodhi4_loop>
    8b86:	80 95       	com	r24
    8b88:	90 95       	com	r25
    8b8a:	bc 01       	movw	r22, r24
    8b8c:	cd 01       	movw	r24, r26
    8b8e:	08 95       	ret

00008b90 <__divmodhi4>:
    8b90:	97 fb       	bst	r25, 7
    8b92:	09 2e       	mov	r0, r25
    8b94:	07 26       	eor	r0, r23
    8b96:	0a d0       	rcall	.+20     	; 0x8bac <__divmodhi4_neg1>
    8b98:	77 fd       	sbrc	r23, 7
    8b9a:	04 d0       	rcall	.+8      	; 0x8ba4 <__divmodhi4_neg2>
    8b9c:	e5 df       	rcall	.-54     	; 0x8b68 <__udivmodhi4>
    8b9e:	06 d0       	rcall	.+12     	; 0x8bac <__divmodhi4_neg1>
    8ba0:	00 20       	and	r0, r0
    8ba2:	1a f4       	brpl	.+6      	; 0x8baa <__divmodhi4_exit>

00008ba4 <__divmodhi4_neg2>:
    8ba4:	70 95       	com	r23
    8ba6:	61 95       	neg	r22
    8ba8:	7f 4f       	sbci	r23, 0xFF	; 255

00008baa <__divmodhi4_exit>:
    8baa:	08 95       	ret

00008bac <__divmodhi4_neg1>:
    8bac:	f6 f7       	brtc	.-4      	; 0x8baa <__divmodhi4_exit>
    8bae:	90 95       	com	r25
    8bb0:	81 95       	neg	r24
    8bb2:	9f 4f       	sbci	r25, 0xFF	; 255
    8bb4:	08 95       	ret

00008bb6 <malloc>:
    8bb6:	cf 93       	push	r28
    8bb8:	df 93       	push	r29
    8bba:	bc 01       	movw	r22, r24
    8bbc:	82 30       	cpi	r24, 0x02	; 2
    8bbe:	91 05       	cpc	r25, r1
    8bc0:	10 f4       	brcc	.+4      	; 0x8bc6 <malloc+0x10>
    8bc2:	62 e0       	ldi	r22, 0x02	; 2
    8bc4:	70 e0       	ldi	r23, 0x00	; 0
    8bc6:	a0 91 c8 04 	lds	r26, 0x04C8
    8bca:	b0 91 c9 04 	lds	r27, 0x04C9
    8bce:	ed 01       	movw	r28, r26
    8bd0:	e0 e0       	ldi	r30, 0x00	; 0
    8bd2:	f0 e0       	ldi	r31, 0x00	; 0
    8bd4:	40 e0       	ldi	r20, 0x00	; 0
    8bd6:	50 e0       	ldi	r21, 0x00	; 0
    8bd8:	21 c0       	rjmp	.+66     	; 0x8c1c <malloc+0x66>
    8bda:	88 81       	ld	r24, Y
    8bdc:	99 81       	ldd	r25, Y+1	; 0x01
    8bde:	86 17       	cp	r24, r22
    8be0:	97 07       	cpc	r25, r23
    8be2:	69 f4       	brne	.+26     	; 0x8bfe <malloc+0x48>
    8be4:	8a 81       	ldd	r24, Y+2	; 0x02
    8be6:	9b 81       	ldd	r25, Y+3	; 0x03
    8be8:	30 97       	sbiw	r30, 0x00	; 0
    8bea:	19 f0       	breq	.+6      	; 0x8bf2 <malloc+0x3c>
    8bec:	93 83       	std	Z+3, r25	; 0x03
    8bee:	82 83       	std	Z+2, r24	; 0x02
    8bf0:	04 c0       	rjmp	.+8      	; 0x8bfa <malloc+0x44>
    8bf2:	90 93 c9 04 	sts	0x04C9, r25
    8bf6:	80 93 c8 04 	sts	0x04C8, r24
    8bfa:	fe 01       	movw	r30, r28
    8bfc:	34 c0       	rjmp	.+104    	; 0x8c66 <malloc+0xb0>
    8bfe:	68 17       	cp	r22, r24
    8c00:	79 07       	cpc	r23, r25
    8c02:	38 f4       	brcc	.+14     	; 0x8c12 <malloc+0x5c>
    8c04:	41 15       	cp	r20, r1
    8c06:	51 05       	cpc	r21, r1
    8c08:	19 f0       	breq	.+6      	; 0x8c10 <malloc+0x5a>
    8c0a:	84 17       	cp	r24, r20
    8c0c:	95 07       	cpc	r25, r21
    8c0e:	08 f4       	brcc	.+2      	; 0x8c12 <malloc+0x5c>
    8c10:	ac 01       	movw	r20, r24
    8c12:	fe 01       	movw	r30, r28
    8c14:	8a 81       	ldd	r24, Y+2	; 0x02
    8c16:	9b 81       	ldd	r25, Y+3	; 0x03
    8c18:	9c 01       	movw	r18, r24
    8c1a:	e9 01       	movw	r28, r18
    8c1c:	20 97       	sbiw	r28, 0x00	; 0
    8c1e:	e9 f6       	brne	.-70     	; 0x8bda <malloc+0x24>
    8c20:	41 15       	cp	r20, r1
    8c22:	51 05       	cpc	r21, r1
    8c24:	a9 f1       	breq	.+106    	; 0x8c90 <malloc+0xda>
    8c26:	ca 01       	movw	r24, r20
    8c28:	86 1b       	sub	r24, r22
    8c2a:	97 0b       	sbc	r25, r23
    8c2c:	04 97       	sbiw	r24, 0x04	; 4
    8c2e:	08 f4       	brcc	.+2      	; 0x8c32 <malloc+0x7c>
    8c30:	ba 01       	movw	r22, r20
    8c32:	e0 e0       	ldi	r30, 0x00	; 0
    8c34:	f0 e0       	ldi	r31, 0x00	; 0
    8c36:	2a c0       	rjmp	.+84     	; 0x8c8c <malloc+0xd6>
    8c38:	8d 91       	ld	r24, X+
    8c3a:	9c 91       	ld	r25, X
    8c3c:	11 97       	sbiw	r26, 0x01	; 1
    8c3e:	84 17       	cp	r24, r20
    8c40:	95 07       	cpc	r25, r21
    8c42:	f9 f4       	brne	.+62     	; 0x8c82 <malloc+0xcc>
    8c44:	64 17       	cp	r22, r20
    8c46:	75 07       	cpc	r23, r21
    8c48:	81 f4       	brne	.+32     	; 0x8c6a <malloc+0xb4>
    8c4a:	12 96       	adiw	r26, 0x02	; 2
    8c4c:	8d 91       	ld	r24, X+
    8c4e:	9c 91       	ld	r25, X
    8c50:	13 97       	sbiw	r26, 0x03	; 3
    8c52:	30 97       	sbiw	r30, 0x00	; 0
    8c54:	19 f0       	breq	.+6      	; 0x8c5c <malloc+0xa6>
    8c56:	93 83       	std	Z+3, r25	; 0x03
    8c58:	82 83       	std	Z+2, r24	; 0x02
    8c5a:	04 c0       	rjmp	.+8      	; 0x8c64 <malloc+0xae>
    8c5c:	90 93 c9 04 	sts	0x04C9, r25
    8c60:	80 93 c8 04 	sts	0x04C8, r24
    8c64:	fd 01       	movw	r30, r26
    8c66:	32 96       	adiw	r30, 0x02	; 2
    8c68:	4f c0       	rjmp	.+158    	; 0x8d08 <malloc+0x152>
    8c6a:	ca 01       	movw	r24, r20
    8c6c:	86 1b       	sub	r24, r22
    8c6e:	97 0b       	sbc	r25, r23
    8c70:	fd 01       	movw	r30, r26
    8c72:	e8 0f       	add	r30, r24
    8c74:	f9 1f       	adc	r31, r25
    8c76:	61 93       	st	Z+, r22
    8c78:	71 93       	st	Z+, r23
    8c7a:	02 97       	sbiw	r24, 0x02	; 2
    8c7c:	8d 93       	st	X+, r24
    8c7e:	9c 93       	st	X, r25
    8c80:	43 c0       	rjmp	.+134    	; 0x8d08 <malloc+0x152>
    8c82:	fd 01       	movw	r30, r26
    8c84:	82 81       	ldd	r24, Z+2	; 0x02
    8c86:	93 81       	ldd	r25, Z+3	; 0x03
    8c88:	9c 01       	movw	r18, r24
    8c8a:	d9 01       	movw	r26, r18
    8c8c:	10 97       	sbiw	r26, 0x00	; 0
    8c8e:	a1 f6       	brne	.-88     	; 0x8c38 <malloc+0x82>
    8c90:	80 91 c6 04 	lds	r24, 0x04C6
    8c94:	90 91 c7 04 	lds	r25, 0x04C7
    8c98:	89 2b       	or	r24, r25
    8c9a:	41 f4       	brne	.+16     	; 0x8cac <malloc+0xf6>
    8c9c:	80 91 00 03 	lds	r24, 0x0300
    8ca0:	90 91 01 03 	lds	r25, 0x0301
    8ca4:	90 93 c7 04 	sts	0x04C7, r25
    8ca8:	80 93 c6 04 	sts	0x04C6, r24
    8cac:	40 91 02 03 	lds	r20, 0x0302
    8cb0:	50 91 03 03 	lds	r21, 0x0303
    8cb4:	41 15       	cp	r20, r1
    8cb6:	51 05       	cpc	r21, r1
    8cb8:	41 f4       	brne	.+16     	; 0x8cca <malloc+0x114>
    8cba:	4d b7       	in	r20, 0x3d	; 61
    8cbc:	5e b7       	in	r21, 0x3e	; 62
    8cbe:	80 91 fe 02 	lds	r24, 0x02FE
    8cc2:	90 91 ff 02 	lds	r25, 0x02FF
    8cc6:	48 1b       	sub	r20, r24
    8cc8:	59 0b       	sbc	r21, r25
    8cca:	20 91 c6 04 	lds	r18, 0x04C6
    8cce:	30 91 c7 04 	lds	r19, 0x04C7
    8cd2:	24 17       	cp	r18, r20
    8cd4:	35 07       	cpc	r19, r21
    8cd6:	b0 f4       	brcc	.+44     	; 0x8d04 <malloc+0x14e>
    8cd8:	ca 01       	movw	r24, r20
    8cda:	82 1b       	sub	r24, r18
    8cdc:	93 0b       	sbc	r25, r19
    8cde:	86 17       	cp	r24, r22
    8ce0:	97 07       	cpc	r25, r23
    8ce2:	80 f0       	brcs	.+32     	; 0x8d04 <malloc+0x14e>
    8ce4:	ab 01       	movw	r20, r22
    8ce6:	4e 5f       	subi	r20, 0xFE	; 254
    8ce8:	5f 4f       	sbci	r21, 0xFF	; 255
    8cea:	84 17       	cp	r24, r20
    8cec:	95 07       	cpc	r25, r21
    8cee:	50 f0       	brcs	.+20     	; 0x8d04 <malloc+0x14e>
    8cf0:	42 0f       	add	r20, r18
    8cf2:	53 1f       	adc	r21, r19
    8cf4:	50 93 c7 04 	sts	0x04C7, r21
    8cf8:	40 93 c6 04 	sts	0x04C6, r20
    8cfc:	f9 01       	movw	r30, r18
    8cfe:	61 93       	st	Z+, r22
    8d00:	71 93       	st	Z+, r23
    8d02:	02 c0       	rjmp	.+4      	; 0x8d08 <malloc+0x152>
    8d04:	e0 e0       	ldi	r30, 0x00	; 0
    8d06:	f0 e0       	ldi	r31, 0x00	; 0
    8d08:	cf 01       	movw	r24, r30
    8d0a:	df 91       	pop	r29
    8d0c:	cf 91       	pop	r28
    8d0e:	08 95       	ret

00008d10 <free>:
    8d10:	cf 93       	push	r28
    8d12:	df 93       	push	r29
    8d14:	00 97       	sbiw	r24, 0x00	; 0
    8d16:	09 f4       	brne	.+2      	; 0x8d1a <free+0xa>
    8d18:	50 c0       	rjmp	.+160    	; 0x8dba <free+0xaa>
    8d1a:	ec 01       	movw	r28, r24
    8d1c:	22 97       	sbiw	r28, 0x02	; 2
    8d1e:	1b 82       	std	Y+3, r1	; 0x03
    8d20:	1a 82       	std	Y+2, r1	; 0x02
    8d22:	a0 91 c8 04 	lds	r26, 0x04C8
    8d26:	b0 91 c9 04 	lds	r27, 0x04C9
    8d2a:	10 97       	sbiw	r26, 0x00	; 0
    8d2c:	09 f1       	breq	.+66     	; 0x8d70 <free+0x60>
    8d2e:	40 e0       	ldi	r20, 0x00	; 0
    8d30:	50 e0       	ldi	r21, 0x00	; 0
    8d32:	ac 17       	cp	r26, r28
    8d34:	bd 07       	cpc	r27, r29
    8d36:	08 f1       	brcs	.+66     	; 0x8d7a <free+0x6a>
    8d38:	bb 83       	std	Y+3, r27	; 0x03
    8d3a:	aa 83       	std	Y+2, r26	; 0x02
    8d3c:	fe 01       	movw	r30, r28
    8d3e:	21 91       	ld	r18, Z+
    8d40:	31 91       	ld	r19, Z+
    8d42:	e2 0f       	add	r30, r18
    8d44:	f3 1f       	adc	r31, r19
    8d46:	ae 17       	cp	r26, r30
    8d48:	bf 07       	cpc	r27, r31
    8d4a:	79 f4       	brne	.+30     	; 0x8d6a <free+0x5a>
    8d4c:	8d 91       	ld	r24, X+
    8d4e:	9c 91       	ld	r25, X
    8d50:	11 97       	sbiw	r26, 0x01	; 1
    8d52:	28 0f       	add	r18, r24
    8d54:	39 1f       	adc	r19, r25
    8d56:	2e 5f       	subi	r18, 0xFE	; 254
    8d58:	3f 4f       	sbci	r19, 0xFF	; 255
    8d5a:	39 83       	std	Y+1, r19	; 0x01
    8d5c:	28 83       	st	Y, r18
    8d5e:	12 96       	adiw	r26, 0x02	; 2
    8d60:	8d 91       	ld	r24, X+
    8d62:	9c 91       	ld	r25, X
    8d64:	13 97       	sbiw	r26, 0x03	; 3
    8d66:	9b 83       	std	Y+3, r25	; 0x03
    8d68:	8a 83       	std	Y+2, r24	; 0x02
    8d6a:	41 15       	cp	r20, r1
    8d6c:	51 05       	cpc	r21, r1
    8d6e:	71 f4       	brne	.+28     	; 0x8d8c <free+0x7c>
    8d70:	d0 93 c9 04 	sts	0x04C9, r29
    8d74:	c0 93 c8 04 	sts	0x04C8, r28
    8d78:	20 c0       	rjmp	.+64     	; 0x8dba <free+0xaa>
    8d7a:	12 96       	adiw	r26, 0x02	; 2
    8d7c:	8d 91       	ld	r24, X+
    8d7e:	9c 91       	ld	r25, X
    8d80:	13 97       	sbiw	r26, 0x03	; 3
    8d82:	ad 01       	movw	r20, r26
    8d84:	00 97       	sbiw	r24, 0x00	; 0
    8d86:	11 f0       	breq	.+4      	; 0x8d8c <free+0x7c>
    8d88:	dc 01       	movw	r26, r24
    8d8a:	d3 cf       	rjmp	.-90     	; 0x8d32 <free+0x22>
    8d8c:	fa 01       	movw	r30, r20
    8d8e:	d3 83       	std	Z+3, r29	; 0x03
    8d90:	c2 83       	std	Z+2, r28	; 0x02
    8d92:	21 91       	ld	r18, Z+
    8d94:	31 91       	ld	r19, Z+
    8d96:	e2 0f       	add	r30, r18
    8d98:	f3 1f       	adc	r31, r19
    8d9a:	ce 17       	cp	r28, r30
    8d9c:	df 07       	cpc	r29, r31
    8d9e:	69 f4       	brne	.+26     	; 0x8dba <free+0xaa>
    8da0:	88 81       	ld	r24, Y
    8da2:	99 81       	ldd	r25, Y+1	; 0x01
    8da4:	28 0f       	add	r18, r24
    8da6:	39 1f       	adc	r19, r25
    8da8:	2e 5f       	subi	r18, 0xFE	; 254
    8daa:	3f 4f       	sbci	r19, 0xFF	; 255
    8dac:	fa 01       	movw	r30, r20
    8dae:	31 83       	std	Z+1, r19	; 0x01
    8db0:	20 83       	st	Z, r18
    8db2:	8a 81       	ldd	r24, Y+2	; 0x02
    8db4:	9b 81       	ldd	r25, Y+3	; 0x03
    8db6:	93 83       	std	Z+3, r25	; 0x03
    8db8:	82 83       	std	Z+2, r24	; 0x02
    8dba:	df 91       	pop	r29
    8dbc:	cf 91       	pop	r28
    8dbe:	08 95       	ret

00008dc0 <strtol>:
    8dc0:	2f 92       	push	r2
    8dc2:	3f 92       	push	r3
    8dc4:	5f 92       	push	r5
    8dc6:	6f 92       	push	r6
    8dc8:	7f 92       	push	r7
    8dca:	8f 92       	push	r8
    8dcc:	9f 92       	push	r9
    8dce:	af 92       	push	r10
    8dd0:	bf 92       	push	r11
    8dd2:	cf 92       	push	r12
    8dd4:	df 92       	push	r13
    8dd6:	ef 92       	push	r14
    8dd8:	ff 92       	push	r15
    8dda:	0f 93       	push	r16
    8ddc:	1f 93       	push	r17
    8dde:	cf 93       	push	r28
    8de0:	df 93       	push	r29
    8de2:	8c 01       	movw	r16, r24
    8de4:	1b 01       	movw	r2, r22
    8de6:	ea 01       	movw	r28, r20
    8de8:	61 15       	cp	r22, r1
    8dea:	71 05       	cpc	r23, r1
    8dec:	19 f0       	breq	.+6      	; 0x8df4 <strtol+0x34>
    8dee:	fb 01       	movw	r30, r22
    8df0:	91 83       	std	Z+1, r25	; 0x01
    8df2:	80 83       	st	Z, r24
    8df4:	20 97       	sbiw	r28, 0x00	; 0
    8df6:	49 f0       	breq	.+18     	; 0x8e0a <strtol+0x4a>
    8df8:	ce 01       	movw	r24, r28
    8dfa:	02 97       	sbiw	r24, 0x02	; 2
    8dfc:	83 97       	sbiw	r24, 0x23	; 35
    8dfe:	28 f0       	brcs	.+10     	; 0x8e0a <strtol+0x4a>
    8e00:	20 e0       	ldi	r18, 0x00	; 0
    8e02:	30 e0       	ldi	r19, 0x00	; 0
    8e04:	40 e0       	ldi	r20, 0x00	; 0
    8e06:	50 e0       	ldi	r21, 0x00	; 0
    8e08:	f6 c0       	rjmp	.+492    	; 0x8ff6 <strtol+0x236>
    8e0a:	f8 01       	movw	r30, r16
    8e0c:	a1 90       	ld	r10, Z+
    8e0e:	8f 01       	movw	r16, r30
    8e10:	8a 2d       	mov	r24, r10
    8e12:	90 e0       	ldi	r25, 0x00	; 0
    8e14:	0e 94 09 49 	call	0x9212	; 0x9212 <isspace>
    8e18:	89 2b       	or	r24, r25
    8e1a:	b9 f7       	brne	.-18     	; 0x8e0a <strtol+0x4a>
    8e1c:	fd e2       	ldi	r31, 0x2D	; 45
    8e1e:	af 16       	cp	r10, r31
    8e20:	31 f4       	brne	.+12     	; 0x8e2e <strtol+0x6e>
    8e22:	f8 01       	movw	r30, r16
    8e24:	a1 90       	ld	r10, Z+
    8e26:	8f 01       	movw	r16, r30
    8e28:	55 24       	eor	r5, r5
    8e2a:	53 94       	inc	r5
    8e2c:	07 c0       	rjmp	.+14     	; 0x8e3c <strtol+0x7c>
    8e2e:	fb e2       	ldi	r31, 0x2B	; 43
    8e30:	af 16       	cp	r10, r31
    8e32:	19 f4       	brne	.+6      	; 0x8e3a <strtol+0x7a>
    8e34:	f8 01       	movw	r30, r16
    8e36:	a1 90       	ld	r10, Z+
    8e38:	8f 01       	movw	r16, r30
    8e3a:	55 24       	eor	r5, r5
    8e3c:	20 97       	sbiw	r28, 0x00	; 0
    8e3e:	19 f0       	breq	.+6      	; 0x8e46 <strtol+0x86>
    8e40:	c0 31       	cpi	r28, 0x10	; 16
    8e42:	d1 05       	cpc	r29, r1
    8e44:	c1 f4       	brne	.+48     	; 0x8e76 <strtol+0xb6>
    8e46:	f0 e3       	ldi	r31, 0x30	; 48
    8e48:	af 16       	cp	r10, r31
    8e4a:	79 f4       	brne	.+30     	; 0x8e6a <strtol+0xaa>
    8e4c:	f8 01       	movw	r30, r16
    8e4e:	80 81       	ld	r24, Z
    8e50:	88 37       	cpi	r24, 0x78	; 120
    8e52:	11 f0       	breq	.+4      	; 0x8e58 <strtol+0x98>
    8e54:	88 35       	cpi	r24, 0x58	; 88
    8e56:	49 f4       	brne	.+18     	; 0x8e6a <strtol+0xaa>
    8e58:	f8 01       	movw	r30, r16
    8e5a:	a1 80       	ldd	r10, Z+1	; 0x01
    8e5c:	0e 5f       	subi	r16, 0xFE	; 254
    8e5e:	1f 4f       	sbci	r17, 0xFF	; 255
    8e60:	f2 e0       	ldi	r31, 0x02	; 2
    8e62:	5f 2a       	or	r5, r31
    8e64:	c0 e1       	ldi	r28, 0x10	; 16
    8e66:	d0 e0       	ldi	r29, 0x00	; 0
    8e68:	06 c0       	rjmp	.+12     	; 0x8e76 <strtol+0xb6>
    8e6a:	20 97       	sbiw	r28, 0x00	; 0
    8e6c:	21 f4       	brne	.+8      	; 0x8e76 <strtol+0xb6>
    8e6e:	80 e3       	ldi	r24, 0x30	; 48
    8e70:	a8 16       	cp	r10, r24
    8e72:	e9 f4       	brne	.+58     	; 0x8eae <strtol+0xee>
    8e74:	27 c0       	rjmp	.+78     	; 0x8ec4 <strtol+0x104>
    8e76:	c8 30       	cpi	r28, 0x08	; 8
    8e78:	d1 05       	cpc	r29, r1
    8e7a:	31 f1       	breq	.+76     	; 0x8ec8 <strtol+0x108>
    8e7c:	c9 30       	cpi	r28, 0x09	; 9
    8e7e:	d1 05       	cpc	r29, r1
    8e80:	24 f4       	brge	.+8      	; 0x8e8a <strtol+0xca>
    8e82:	c2 30       	cpi	r28, 0x02	; 2
    8e84:	d1 05       	cpc	r29, r1
    8e86:	31 f5       	brne	.+76     	; 0x8ed4 <strtol+0x114>
    8e88:	0c c0       	rjmp	.+24     	; 0x8ea2 <strtol+0xe2>
    8e8a:	ca 30       	cpi	r28, 0x0A	; 10
    8e8c:	d1 05       	cpc	r29, r1
    8e8e:	89 f0       	breq	.+34     	; 0x8eb2 <strtol+0xf2>
    8e90:	c0 31       	cpi	r28, 0x10	; 16
    8e92:	d1 05       	cpc	r29, r1
    8e94:	f9 f4       	brne	.+62     	; 0x8ed4 <strtol+0x114>
    8e96:	c1 2c       	mov	r12, r1
    8e98:	d1 2c       	mov	r13, r1
    8e9a:	e1 2c       	mov	r14, r1
    8e9c:	b8 e0       	ldi	r27, 0x08	; 8
    8e9e:	fb 2e       	mov	r15, r27
    8ea0:	28 c0       	rjmp	.+80     	; 0x8ef2 <strtol+0x132>
    8ea2:	c1 2c       	mov	r12, r1
    8ea4:	d1 2c       	mov	r13, r1
    8ea6:	e1 2c       	mov	r14, r1
    8ea8:	a0 e4       	ldi	r26, 0x40	; 64
    8eaa:	fa 2e       	mov	r15, r26
    8eac:	22 c0       	rjmp	.+68     	; 0x8ef2 <strtol+0x132>
    8eae:	ca e0       	ldi	r28, 0x0A	; 10
    8eb0:	d0 e0       	ldi	r29, 0x00	; 0
    8eb2:	fc ec       	ldi	r31, 0xCC	; 204
    8eb4:	cf 2e       	mov	r12, r31
    8eb6:	fc ec       	ldi	r31, 0xCC	; 204
    8eb8:	df 2e       	mov	r13, r31
    8eba:	fc ec       	ldi	r31, 0xCC	; 204
    8ebc:	ef 2e       	mov	r14, r31
    8ebe:	fc e0       	ldi	r31, 0x0C	; 12
    8ec0:	ff 2e       	mov	r15, r31
    8ec2:	17 c0       	rjmp	.+46     	; 0x8ef2 <strtol+0x132>
    8ec4:	c8 e0       	ldi	r28, 0x08	; 8
    8ec6:	d0 e0       	ldi	r29, 0x00	; 0
    8ec8:	c1 2c       	mov	r12, r1
    8eca:	d1 2c       	mov	r13, r1
    8ecc:	e1 2c       	mov	r14, r1
    8ece:	e0 e1       	ldi	r30, 0x10	; 16
    8ed0:	fe 2e       	mov	r15, r30
    8ed2:	0f c0       	rjmp	.+30     	; 0x8ef2 <strtol+0x132>
    8ed4:	9e 01       	movw	r18, r28
    8ed6:	44 27       	eor	r20, r20
    8ed8:	37 fd       	sbrc	r19, 7
    8eda:	40 95       	com	r20
    8edc:	54 2f       	mov	r21, r20
    8ede:	60 e0       	ldi	r22, 0x00	; 0
    8ee0:	70 e0       	ldi	r23, 0x00	; 0
    8ee2:	80 e0       	ldi	r24, 0x00	; 0
    8ee4:	90 e8       	ldi	r25, 0x80	; 128
    8ee6:	0e 94 07 4c 	call	0x980e	; 0x980e <__udivmodsi4>
    8eea:	c9 01       	movw	r24, r18
    8eec:	da 01       	movw	r26, r20
    8eee:	6c 01       	movw	r12, r24
    8ef0:	7d 01       	movw	r14, r26
    8ef2:	20 e0       	ldi	r18, 0x00	; 0
    8ef4:	30 e0       	ldi	r19, 0x00	; 0
    8ef6:	40 e0       	ldi	r20, 0x00	; 0
    8ef8:	50 e0       	ldi	r21, 0x00	; 0
    8efa:	60 e0       	ldi	r22, 0x00	; 0
    8efc:	3e 01       	movw	r6, r28
    8efe:	88 24       	eor	r8, r8
    8f00:	77 fc       	sbrc	r7, 7
    8f02:	80 94       	com	r8
    8f04:	98 2c       	mov	r9, r8
    8f06:	70 ed       	ldi	r23, 0xD0	; 208
    8f08:	b7 2e       	mov	r11, r23
    8f0a:	ba 0c       	add	r11, r10
    8f0c:	e9 e0       	ldi	r30, 0x09	; 9
    8f0e:	eb 15       	cp	r30, r11
    8f10:	70 f4       	brcc	.+28     	; 0x8f2e <strtol+0x16e>
    8f12:	8a 2d       	mov	r24, r10
    8f14:	81 54       	subi	r24, 0x41	; 65
    8f16:	8a 31       	cpi	r24, 0x1A	; 26
    8f18:	18 f4       	brcc	.+6      	; 0x8f20 <strtol+0x160>
    8f1a:	99 ec       	ldi	r25, 0xC9	; 201
    8f1c:	b9 2e       	mov	r11, r25
    8f1e:	06 c0       	rjmp	.+12     	; 0x8f2c <strtol+0x16c>
    8f20:	8a 2d       	mov	r24, r10
    8f22:	81 56       	subi	r24, 0x61	; 97
    8f24:	8a 31       	cpi	r24, 0x1A	; 26
    8f26:	50 f5       	brcc	.+84     	; 0x8f7c <strtol+0x1bc>
    8f28:	89 ea       	ldi	r24, 0xA9	; 169
    8f2a:	b8 2e       	mov	r11, r24
    8f2c:	ba 0c       	add	r11, r10
    8f2e:	8b 2d       	mov	r24, r11
    8f30:	90 e0       	ldi	r25, 0x00	; 0
    8f32:	8c 17       	cp	r24, r28
    8f34:	9d 07       	cpc	r25, r29
    8f36:	14 f5       	brge	.+68     	; 0x8f7c <strtol+0x1bc>
    8f38:	6f 3f       	cpi	r22, 0xFF	; 255
    8f3a:	e1 f0       	breq	.+56     	; 0x8f74 <strtol+0x1b4>
    8f3c:	c2 16       	cp	r12, r18
    8f3e:	d3 06       	cpc	r13, r19
    8f40:	e4 06       	cpc	r14, r20
    8f42:	f5 06       	cpc	r15, r21
    8f44:	b0 f0       	brcs	.+44     	; 0x8f72 <strtol+0x1b2>
    8f46:	ca 01       	movw	r24, r20
    8f48:	b9 01       	movw	r22, r18
    8f4a:	a4 01       	movw	r20, r8
    8f4c:	93 01       	movw	r18, r6
    8f4e:	0e 94 e8 4b 	call	0x97d0	; 0x97d0 <__mulsi3>
    8f52:	9b 01       	movw	r18, r22
    8f54:	ac 01       	movw	r20, r24
    8f56:	2b 0d       	add	r18, r11
    8f58:	31 1d       	adc	r19, r1
    8f5a:	41 1d       	adc	r20, r1
    8f5c:	51 1d       	adc	r21, r1
    8f5e:	21 30       	cpi	r18, 0x01	; 1
    8f60:	f0 e0       	ldi	r31, 0x00	; 0
    8f62:	3f 07       	cpc	r19, r31
    8f64:	f0 e0       	ldi	r31, 0x00	; 0
    8f66:	4f 07       	cpc	r20, r31
    8f68:	f0 e8       	ldi	r31, 0x80	; 128
    8f6a:	5f 07       	cpc	r21, r31
    8f6c:	10 f4       	brcc	.+4      	; 0x8f72 <strtol+0x1b2>
    8f6e:	61 e0       	ldi	r22, 0x01	; 1
    8f70:	01 c0       	rjmp	.+2      	; 0x8f74 <strtol+0x1b4>
    8f72:	6f ef       	ldi	r22, 0xFF	; 255
    8f74:	f8 01       	movw	r30, r16
    8f76:	a1 90       	ld	r10, Z+
    8f78:	8f 01       	movw	r16, r30
    8f7a:	c5 cf       	rjmp	.-118    	; 0x8f06 <strtol+0x146>
    8f7c:	21 14       	cp	r2, r1
    8f7e:	31 04       	cpc	r3, r1
    8f80:	81 f0       	breq	.+32     	; 0x8fa2 <strtol+0x1e2>
    8f82:	66 23       	and	r22, r22
    8f84:	31 f0       	breq	.+12     	; 0x8f92 <strtol+0x1d2>
    8f86:	01 50       	subi	r16, 0x01	; 1
    8f88:	10 40       	sbci	r17, 0x00	; 0
    8f8a:	f1 01       	movw	r30, r2
    8f8c:	11 83       	std	Z+1, r17	; 0x01
    8f8e:	00 83       	st	Z, r16
    8f90:	08 c0       	rjmp	.+16     	; 0x8fa2 <strtol+0x1e2>
    8f92:	51 fe       	sbrs	r5, 1
    8f94:	1a c0       	rjmp	.+52     	; 0x8fca <strtol+0x20a>
    8f96:	02 50       	subi	r16, 0x02	; 2
    8f98:	10 40       	sbci	r17, 0x00	; 0
    8f9a:	f1 01       	movw	r30, r2
    8f9c:	11 83       	std	Z+1, r17	; 0x01
    8f9e:	00 83       	st	Z, r16
    8fa0:	14 c0       	rjmp	.+40     	; 0x8fca <strtol+0x20a>
    8fa2:	67 ff       	sbrs	r22, 7
    8fa4:	12 c0       	rjmp	.+36     	; 0x8fca <strtol+0x20a>
    8fa6:	50 fc       	sbrc	r5, 0
    8fa8:	05 c0       	rjmp	.+10     	; 0x8fb4 <strtol+0x1f4>
    8faa:	2f ef       	ldi	r18, 0xFF	; 255
    8fac:	3f ef       	ldi	r19, 0xFF	; 255
    8fae:	4f ef       	ldi	r20, 0xFF	; 255
    8fb0:	5f e7       	ldi	r21, 0x7F	; 127
    8fb2:	04 c0       	rjmp	.+8      	; 0x8fbc <strtol+0x1fc>
    8fb4:	20 e0       	ldi	r18, 0x00	; 0
    8fb6:	30 e0       	ldi	r19, 0x00	; 0
    8fb8:	40 e0       	ldi	r20, 0x00	; 0
    8fba:	50 e8       	ldi	r21, 0x80	; 128
    8fbc:	82 e2       	ldi	r24, 0x22	; 34
    8fbe:	90 e0       	ldi	r25, 0x00	; 0
    8fc0:	90 93 cb 04 	sts	0x04CB, r25
    8fc4:	80 93 ca 04 	sts	0x04CA, r24
    8fc8:	16 c0       	rjmp	.+44     	; 0x8ff6 <strtol+0x236>
    8fca:	50 fe       	sbrs	r5, 0
    8fcc:	08 c0       	rjmp	.+16     	; 0x8fde <strtol+0x21e>
    8fce:	50 95       	com	r21
    8fd0:	40 95       	com	r20
    8fd2:	30 95       	com	r19
    8fd4:	21 95       	neg	r18
    8fd6:	3f 4f       	sbci	r19, 0xFF	; 255
    8fd8:	4f 4f       	sbci	r20, 0xFF	; 255
    8fda:	5f 4f       	sbci	r21, 0xFF	; 255
    8fdc:	0c c0       	rjmp	.+24     	; 0x8ff6 <strtol+0x236>
    8fde:	57 ff       	sbrs	r21, 7
    8fe0:	0a c0       	rjmp	.+20     	; 0x8ff6 <strtol+0x236>
    8fe2:	82 e2       	ldi	r24, 0x22	; 34
    8fe4:	90 e0       	ldi	r25, 0x00	; 0
    8fe6:	90 93 cb 04 	sts	0x04CB, r25
    8fea:	80 93 ca 04 	sts	0x04CA, r24
    8fee:	2f ef       	ldi	r18, 0xFF	; 255
    8ff0:	3f ef       	ldi	r19, 0xFF	; 255
    8ff2:	4f ef       	ldi	r20, 0xFF	; 255
    8ff4:	5f e7       	ldi	r21, 0x7F	; 127
    8ff6:	b9 01       	movw	r22, r18
    8ff8:	ca 01       	movw	r24, r20
    8ffa:	df 91       	pop	r29
    8ffc:	cf 91       	pop	r28
    8ffe:	1f 91       	pop	r17
    9000:	0f 91       	pop	r16
    9002:	ff 90       	pop	r15
    9004:	ef 90       	pop	r14
    9006:	df 90       	pop	r13
    9008:	cf 90       	pop	r12
    900a:	bf 90       	pop	r11
    900c:	af 90       	pop	r10
    900e:	9f 90       	pop	r9
    9010:	8f 90       	pop	r8
    9012:	7f 90       	pop	r7
    9014:	6f 90       	pop	r6
    9016:	5f 90       	pop	r5
    9018:	3f 90       	pop	r3
    901a:	2f 90       	pop	r2
    901c:	08 95       	ret

0000901e <atof>:
    901e:	66 27       	eor	r22, r22
    9020:	77 27       	eor	r23, r23
    9022:	0c 94 5f 4a 	jmp	0x94be	; 0x94be <strtod>

00009026 <atoi>:
    9026:	fc 01       	movw	r30, r24
    9028:	88 27       	eor	r24, r24
    902a:	99 27       	eor	r25, r25
    902c:	e8 94       	clt
    902e:	21 91       	ld	r18, Z+
    9030:	20 32       	cpi	r18, 0x20	; 32
    9032:	e9 f3       	breq	.-6      	; 0x902e <atoi+0x8>
    9034:	29 30       	cpi	r18, 0x09	; 9
    9036:	10 f0       	brcs	.+4      	; 0x903c <atoi+0x16>
    9038:	2e 30       	cpi	r18, 0x0E	; 14
    903a:	c8 f3       	brcs	.-14     	; 0x902e <atoi+0x8>
    903c:	2b 32       	cpi	r18, 0x2B	; 43
    903e:	41 f0       	breq	.+16     	; 0x9050 <atoi+0x2a>
    9040:	2d 32       	cpi	r18, 0x2D	; 45
    9042:	39 f4       	brne	.+14     	; 0x9052 <atoi+0x2c>
    9044:	68 94       	set
    9046:	04 c0       	rjmp	.+8      	; 0x9050 <atoi+0x2a>
    9048:	0e 94 6a 49 	call	0x92d4	; 0x92d4 <__mulhi_const_10>
    904c:	82 0f       	add	r24, r18
    904e:	91 1d       	adc	r25, r1
    9050:	21 91       	ld	r18, Z+
    9052:	20 53       	subi	r18, 0x30	; 48
    9054:	2a 30       	cpi	r18, 0x0A	; 10
    9056:	c0 f3       	brcs	.-16     	; 0x9048 <atoi+0x22>
    9058:	1e f4       	brtc	.+6      	; 0x9060 <atoi+0x3a>
    905a:	90 95       	com	r25
    905c:	81 95       	neg	r24
    905e:	9f 4f       	sbci	r25, 0xFF	; 255
    9060:	08 95       	ret

00009062 <__ftoa_engine>:
    9062:	28 30       	cpi	r18, 0x08	; 8
    9064:	08 f0       	brcs	.+2      	; 0x9068 <__ftoa_engine+0x6>
    9066:	27 e0       	ldi	r18, 0x07	; 7
    9068:	33 27       	eor	r19, r19
    906a:	da 01       	movw	r26, r20
    906c:	99 0f       	add	r25, r25
    906e:	31 1d       	adc	r19, r1
    9070:	87 fd       	sbrc	r24, 7
    9072:	91 60       	ori	r25, 0x01	; 1
    9074:	00 96       	adiw	r24, 0x00	; 0
    9076:	61 05       	cpc	r22, r1
    9078:	71 05       	cpc	r23, r1
    907a:	39 f4       	brne	.+14     	; 0x908a <__ftoa_engine+0x28>
    907c:	32 60       	ori	r19, 0x02	; 2
    907e:	2e 5f       	subi	r18, 0xFE	; 254
    9080:	3d 93       	st	X+, r19
    9082:	30 e3       	ldi	r19, 0x30	; 48
    9084:	2a 95       	dec	r18
    9086:	e1 f7       	brne	.-8      	; 0x9080 <__ftoa_engine+0x1e>
    9088:	08 95       	ret
    908a:	9f 3f       	cpi	r25, 0xFF	; 255
    908c:	30 f0       	brcs	.+12     	; 0x909a <__ftoa_engine+0x38>
    908e:	80 38       	cpi	r24, 0x80	; 128
    9090:	71 05       	cpc	r23, r1
    9092:	61 05       	cpc	r22, r1
    9094:	09 f0       	breq	.+2      	; 0x9098 <__ftoa_engine+0x36>
    9096:	3c 5f       	subi	r19, 0xFC	; 252
    9098:	3c 5f       	subi	r19, 0xFC	; 252
    909a:	3d 93       	st	X+, r19
    909c:	91 30       	cpi	r25, 0x01	; 1
    909e:	08 f0       	brcs	.+2      	; 0x90a2 <__ftoa_engine+0x40>
    90a0:	80 68       	ori	r24, 0x80	; 128
    90a2:	91 1d       	adc	r25, r1
    90a4:	df 93       	push	r29
    90a6:	cf 93       	push	r28
    90a8:	1f 93       	push	r17
    90aa:	0f 93       	push	r16
    90ac:	ff 92       	push	r15
    90ae:	ef 92       	push	r14
    90b0:	19 2f       	mov	r17, r25
    90b2:	98 7f       	andi	r25, 0xF8	; 248
    90b4:	96 95       	lsr	r25
    90b6:	e9 2f       	mov	r30, r25
    90b8:	96 95       	lsr	r25
    90ba:	96 95       	lsr	r25
    90bc:	e9 0f       	add	r30, r25
    90be:	ff 27       	eor	r31, r31
    90c0:	e0 52       	subi	r30, 0x20	; 32
    90c2:	fa 4f       	sbci	r31, 0xFA	; 250
    90c4:	99 27       	eor	r25, r25
    90c6:	33 27       	eor	r19, r19
    90c8:	ee 24       	eor	r14, r14
    90ca:	ff 24       	eor	r15, r15
    90cc:	a7 01       	movw	r20, r14
    90ce:	e7 01       	movw	r28, r14
    90d0:	05 90       	lpm	r0, Z+
    90d2:	08 94       	sec
    90d4:	07 94       	ror	r0
    90d6:	28 f4       	brcc	.+10     	; 0x90e2 <__ftoa_engine+0x80>
    90d8:	36 0f       	add	r19, r22
    90da:	e7 1e       	adc	r14, r23
    90dc:	f8 1e       	adc	r15, r24
    90de:	49 1f       	adc	r20, r25
    90e0:	51 1d       	adc	r21, r1
    90e2:	66 0f       	add	r22, r22
    90e4:	77 1f       	adc	r23, r23
    90e6:	88 1f       	adc	r24, r24
    90e8:	99 1f       	adc	r25, r25
    90ea:	06 94       	lsr	r0
    90ec:	a1 f7       	brne	.-24     	; 0x90d6 <__ftoa_engine+0x74>
    90ee:	05 90       	lpm	r0, Z+
    90f0:	07 94       	ror	r0
    90f2:	28 f4       	brcc	.+10     	; 0x90fe <__ftoa_engine+0x9c>
    90f4:	e7 0e       	add	r14, r23
    90f6:	f8 1e       	adc	r15, r24
    90f8:	49 1f       	adc	r20, r25
    90fa:	56 1f       	adc	r21, r22
    90fc:	c1 1d       	adc	r28, r1
    90fe:	77 0f       	add	r23, r23
    9100:	88 1f       	adc	r24, r24
    9102:	99 1f       	adc	r25, r25
    9104:	66 1f       	adc	r22, r22
    9106:	06 94       	lsr	r0
    9108:	a1 f7       	brne	.-24     	; 0x90f2 <__ftoa_engine+0x90>
    910a:	05 90       	lpm	r0, Z+
    910c:	07 94       	ror	r0
    910e:	28 f4       	brcc	.+10     	; 0x911a <__ftoa_engine+0xb8>
    9110:	f8 0e       	add	r15, r24
    9112:	49 1f       	adc	r20, r25
    9114:	56 1f       	adc	r21, r22
    9116:	c7 1f       	adc	r28, r23
    9118:	d1 1d       	adc	r29, r1
    911a:	88 0f       	add	r24, r24
    911c:	99 1f       	adc	r25, r25
    911e:	66 1f       	adc	r22, r22
    9120:	77 1f       	adc	r23, r23
    9122:	06 94       	lsr	r0
    9124:	a1 f7       	brne	.-24     	; 0x910e <__ftoa_engine+0xac>
    9126:	05 90       	lpm	r0, Z+
    9128:	07 94       	ror	r0
    912a:	20 f4       	brcc	.+8      	; 0x9134 <__ftoa_engine+0xd2>
    912c:	49 0f       	add	r20, r25
    912e:	56 1f       	adc	r21, r22
    9130:	c7 1f       	adc	r28, r23
    9132:	d8 1f       	adc	r29, r24
    9134:	99 0f       	add	r25, r25
    9136:	66 1f       	adc	r22, r22
    9138:	77 1f       	adc	r23, r23
    913a:	88 1f       	adc	r24, r24
    913c:	06 94       	lsr	r0
    913e:	a9 f7       	brne	.-22     	; 0x912a <__ftoa_engine+0xc8>
    9140:	84 91       	lpm	r24, Z+
    9142:	10 95       	com	r17
    9144:	17 70       	andi	r17, 0x07	; 7
    9146:	41 f0       	breq	.+16     	; 0x9158 <__ftoa_engine+0xf6>
    9148:	d6 95       	lsr	r29
    914a:	c7 95       	ror	r28
    914c:	57 95       	ror	r21
    914e:	47 95       	ror	r20
    9150:	f7 94       	ror	r15
    9152:	e7 94       	ror	r14
    9154:	1a 95       	dec	r17
    9156:	c1 f7       	brne	.-16     	; 0x9148 <__ftoa_engine+0xe6>
    9158:	e6 e8       	ldi	r30, 0x86	; 134
    915a:	f5 e0       	ldi	r31, 0x05	; 5
    915c:	68 94       	set
    915e:	15 90       	lpm	r1, Z+
    9160:	15 91       	lpm	r17, Z+
    9162:	35 91       	lpm	r19, Z+
    9164:	65 91       	lpm	r22, Z+
    9166:	95 91       	lpm	r25, Z+
    9168:	05 90       	lpm	r0, Z+
    916a:	7f e2       	ldi	r23, 0x2F	; 47
    916c:	73 95       	inc	r23
    916e:	e1 18       	sub	r14, r1
    9170:	f1 0a       	sbc	r15, r17
    9172:	43 0b       	sbc	r20, r19
    9174:	56 0b       	sbc	r21, r22
    9176:	c9 0b       	sbc	r28, r25
    9178:	d0 09       	sbc	r29, r0
    917a:	c0 f7       	brcc	.-16     	; 0x916c <__ftoa_engine+0x10a>
    917c:	e1 0c       	add	r14, r1
    917e:	f1 1e       	adc	r15, r17
    9180:	43 1f       	adc	r20, r19
    9182:	56 1f       	adc	r21, r22
    9184:	c9 1f       	adc	r28, r25
    9186:	d0 1d       	adc	r29, r0
    9188:	7e f4       	brtc	.+30     	; 0x91a8 <__ftoa_engine+0x146>
    918a:	70 33       	cpi	r23, 0x30	; 48
    918c:	11 f4       	brne	.+4      	; 0x9192 <__ftoa_engine+0x130>
    918e:	8a 95       	dec	r24
    9190:	e6 cf       	rjmp	.-52     	; 0x915e <__ftoa_engine+0xfc>
    9192:	e8 94       	clt
    9194:	01 50       	subi	r16, 0x01	; 1
    9196:	30 f0       	brcs	.+12     	; 0x91a4 <__ftoa_engine+0x142>
    9198:	08 0f       	add	r16, r24
    919a:	0a f4       	brpl	.+2      	; 0x919e <__ftoa_engine+0x13c>
    919c:	00 27       	eor	r16, r16
    919e:	02 17       	cp	r16, r18
    91a0:	08 f4       	brcc	.+2      	; 0x91a4 <__ftoa_engine+0x142>
    91a2:	20 2f       	mov	r18, r16
    91a4:	23 95       	inc	r18
    91a6:	02 2f       	mov	r16, r18
    91a8:	7a 33       	cpi	r23, 0x3A	; 58
    91aa:	28 f0       	brcs	.+10     	; 0x91b6 <__ftoa_engine+0x154>
    91ac:	79 e3       	ldi	r23, 0x39	; 57
    91ae:	7d 93       	st	X+, r23
    91b0:	2a 95       	dec	r18
    91b2:	e9 f7       	brne	.-6      	; 0x91ae <__ftoa_engine+0x14c>
    91b4:	10 c0       	rjmp	.+32     	; 0x91d6 <__ftoa_engine+0x174>
    91b6:	7d 93       	st	X+, r23
    91b8:	2a 95       	dec	r18
    91ba:	89 f6       	brne	.-94     	; 0x915e <__ftoa_engine+0xfc>
    91bc:	06 94       	lsr	r0
    91be:	97 95       	ror	r25
    91c0:	67 95       	ror	r22
    91c2:	37 95       	ror	r19
    91c4:	17 95       	ror	r17
    91c6:	17 94       	ror	r1
    91c8:	e1 18       	sub	r14, r1
    91ca:	f1 0a       	sbc	r15, r17
    91cc:	43 0b       	sbc	r20, r19
    91ce:	56 0b       	sbc	r21, r22
    91d0:	c9 0b       	sbc	r28, r25
    91d2:	d0 09       	sbc	r29, r0
    91d4:	98 f0       	brcs	.+38     	; 0x91fc <__ftoa_engine+0x19a>
    91d6:	23 95       	inc	r18
    91d8:	7e 91       	ld	r23, -X
    91da:	73 95       	inc	r23
    91dc:	7a 33       	cpi	r23, 0x3A	; 58
    91de:	08 f0       	brcs	.+2      	; 0x91e2 <__ftoa_engine+0x180>
    91e0:	70 e3       	ldi	r23, 0x30	; 48
    91e2:	7c 93       	st	X, r23
    91e4:	20 13       	cpse	r18, r16
    91e6:	b8 f7       	brcc	.-18     	; 0x91d6 <__ftoa_engine+0x174>
    91e8:	7e 91       	ld	r23, -X
    91ea:	70 61       	ori	r23, 0x10	; 16
    91ec:	7d 93       	st	X+, r23
    91ee:	30 f0       	brcs	.+12     	; 0x91fc <__ftoa_engine+0x19a>
    91f0:	83 95       	inc	r24
    91f2:	71 e3       	ldi	r23, 0x31	; 49
    91f4:	7d 93       	st	X+, r23
    91f6:	70 e3       	ldi	r23, 0x30	; 48
    91f8:	2a 95       	dec	r18
    91fa:	e1 f7       	brne	.-8      	; 0x91f4 <__ftoa_engine+0x192>
    91fc:	11 24       	eor	r1, r1
    91fe:	ef 90       	pop	r14
    9200:	ff 90       	pop	r15
    9202:	0f 91       	pop	r16
    9204:	1f 91       	pop	r17
    9206:	cf 91       	pop	r28
    9208:	df 91       	pop	r29
    920a:	99 27       	eor	r25, r25
    920c:	87 fd       	sbrc	r24, 7
    920e:	90 95       	com	r25
    9210:	08 95       	ret

00009212 <isspace>:
    9212:	91 11       	cpse	r25, r1
    9214:	c2 c2       	rjmp	.+1412   	; 0x979a <__ctype_isfalse>
    9216:	80 32       	cpi	r24, 0x20	; 32
    9218:	19 f0       	breq	.+6      	; 0x9220 <isspace+0xe>
    921a:	89 50       	subi	r24, 0x09	; 9
    921c:	85 50       	subi	r24, 0x05	; 5
    921e:	d0 f7       	brcc	.-12     	; 0x9214 <isspace+0x2>
    9220:	08 95       	ret

00009222 <strcpy_P>:
    9222:	fb 01       	movw	r30, r22
    9224:	dc 01       	movw	r26, r24
    9226:	05 90       	lpm	r0, Z+
    9228:	0d 92       	st	X+, r0
    922a:	00 20       	and	r0, r0
    922c:	e1 f7       	brne	.-8      	; 0x9226 <strcpy_P+0x4>
    922e:	08 95       	ret

00009230 <strnlen_P>:
    9230:	fc 01       	movw	r30, r24
    9232:	05 90       	lpm	r0, Z+
    9234:	61 50       	subi	r22, 0x01	; 1
    9236:	70 40       	sbci	r23, 0x00	; 0
    9238:	01 10       	cpse	r0, r1
    923a:	d8 f7       	brcc	.-10     	; 0x9232 <strnlen_P+0x2>
    923c:	80 95       	com	r24
    923e:	90 95       	com	r25
    9240:	8e 0f       	add	r24, r30
    9242:	9f 1f       	adc	r25, r31
    9244:	08 95       	ret

00009246 <strtok>:
    9246:	48 e0       	ldi	r20, 0x08	; 8
    9248:	53 e0       	ldi	r21, 0x03	; 3
    924a:	0e 94 43 49 	call	0x9286	; 0x9286 <strtok_r>
    924e:	08 95       	ret

00009250 <strcmp>:
    9250:	fb 01       	movw	r30, r22
    9252:	dc 01       	movw	r26, r24
    9254:	8d 91       	ld	r24, X+
    9256:	01 90       	ld	r0, Z+
    9258:	80 19       	sub	r24, r0
    925a:	01 10       	cpse	r0, r1
    925c:	d9 f3       	breq	.-10     	; 0x9254 <strcmp+0x4>
    925e:	99 0b       	sbc	r25, r25
    9260:	08 95       	ret

00009262 <strcpy>:
    9262:	fb 01       	movw	r30, r22
    9264:	dc 01       	movw	r26, r24
    9266:	01 90       	ld	r0, Z+
    9268:	0d 92       	st	X+, r0
    926a:	00 20       	and	r0, r0
    926c:	e1 f7       	brne	.-8      	; 0x9266 <strcpy+0x4>
    926e:	08 95       	ret

00009270 <strnlen>:
    9270:	fc 01       	movw	r30, r24
    9272:	61 50       	subi	r22, 0x01	; 1
    9274:	70 40       	sbci	r23, 0x00	; 0
    9276:	01 90       	ld	r0, Z+
    9278:	01 10       	cpse	r0, r1
    927a:	d8 f7       	brcc	.-10     	; 0x9272 <strnlen+0x2>
    927c:	80 95       	com	r24
    927e:	90 95       	com	r25
    9280:	8e 0f       	add	r24, r30
    9282:	9f 1f       	adc	r25, r31
    9284:	08 95       	ret

00009286 <strtok_r>:
    9286:	fa 01       	movw	r30, r20
    9288:	a1 91       	ld	r26, Z+
    928a:	b0 81       	ld	r27, Z
    928c:	00 97       	sbiw	r24, 0x00	; 0
    928e:	19 f4       	brne	.+6      	; 0x9296 <strtok_r+0x10>
    9290:	10 97       	sbiw	r26, 0x00	; 0
    9292:	e1 f0       	breq	.+56     	; 0x92cc <strtok_r+0x46>
    9294:	cd 01       	movw	r24, r26
    9296:	dc 01       	movw	r26, r24
    9298:	cd 01       	movw	r24, r26
    929a:	0d 90       	ld	r0, X+
    929c:	00 20       	and	r0, r0
    929e:	11 f4       	brne	.+4      	; 0x92a4 <strtok_r+0x1e>
    92a0:	c0 01       	movw	r24, r0
    92a2:	13 c0       	rjmp	.+38     	; 0x92ca <strtok_r+0x44>
    92a4:	fb 01       	movw	r30, r22
    92a6:	21 91       	ld	r18, Z+
    92a8:	22 23       	and	r18, r18
    92aa:	19 f0       	breq	.+6      	; 0x92b2 <strtok_r+0x2c>
    92ac:	20 15       	cp	r18, r0
    92ae:	d9 f7       	brne	.-10     	; 0x92a6 <strtok_r+0x20>
    92b0:	f3 cf       	rjmp	.-26     	; 0x9298 <strtok_r+0x12>
    92b2:	fb 01       	movw	r30, r22
    92b4:	21 91       	ld	r18, Z+
    92b6:	20 15       	cp	r18, r0
    92b8:	19 f4       	brne	.+6      	; 0x92c0 <strtok_r+0x3a>
    92ba:	1e 92       	st	-X, r1
    92bc:	11 96       	adiw	r26, 0x01	; 1
    92be:	06 c0       	rjmp	.+12     	; 0x92cc <strtok_r+0x46>
    92c0:	22 23       	and	r18, r18
    92c2:	c1 f7       	brne	.-16     	; 0x92b4 <strtok_r+0x2e>
    92c4:	0d 90       	ld	r0, X+
    92c6:	00 20       	and	r0, r0
    92c8:	a1 f7       	brne	.-24     	; 0x92b2 <strtok_r+0x2c>
    92ca:	d0 01       	movw	r26, r0
    92cc:	fa 01       	movw	r30, r20
    92ce:	a1 93       	st	Z+, r26
    92d0:	b0 83       	st	Z, r27
    92d2:	08 95       	ret

000092d4 <__mulhi_const_10>:
    92d4:	7a e0       	ldi	r23, 0x0A	; 10
    92d6:	97 9f       	mul	r25, r23
    92d8:	90 2d       	mov	r25, r0
    92da:	87 9f       	mul	r24, r23
    92dc:	80 2d       	mov	r24, r0
    92de:	91 0d       	add	r25, r1
    92e0:	11 24       	eor	r1, r1
    92e2:	08 95       	ret

000092e4 <fputc>:
    92e4:	0f 93       	push	r16
    92e6:	1f 93       	push	r17
    92e8:	cf 93       	push	r28
    92ea:	df 93       	push	r29
    92ec:	8c 01       	movw	r16, r24
    92ee:	eb 01       	movw	r28, r22
    92f0:	8b 81       	ldd	r24, Y+3	; 0x03
    92f2:	81 ff       	sbrs	r24, 1
    92f4:	1b c0       	rjmp	.+54     	; 0x932c <fputc+0x48>
    92f6:	82 ff       	sbrs	r24, 2
    92f8:	0d c0       	rjmp	.+26     	; 0x9314 <fputc+0x30>
    92fa:	2e 81       	ldd	r18, Y+6	; 0x06
    92fc:	3f 81       	ldd	r19, Y+7	; 0x07
    92fe:	8c 81       	ldd	r24, Y+4	; 0x04
    9300:	9d 81       	ldd	r25, Y+5	; 0x05
    9302:	28 17       	cp	r18, r24
    9304:	39 07       	cpc	r19, r25
    9306:	64 f4       	brge	.+24     	; 0x9320 <fputc+0x3c>
    9308:	e8 81       	ld	r30, Y
    930a:	f9 81       	ldd	r31, Y+1	; 0x01
    930c:	01 93       	st	Z+, r16
    930e:	f9 83       	std	Y+1, r31	; 0x01
    9310:	e8 83       	st	Y, r30
    9312:	06 c0       	rjmp	.+12     	; 0x9320 <fputc+0x3c>
    9314:	e8 85       	ldd	r30, Y+8	; 0x08
    9316:	f9 85       	ldd	r31, Y+9	; 0x09
    9318:	80 2f       	mov	r24, r16
    931a:	09 95       	icall
    931c:	89 2b       	or	r24, r25
    931e:	31 f4       	brne	.+12     	; 0x932c <fputc+0x48>
    9320:	8e 81       	ldd	r24, Y+6	; 0x06
    9322:	9f 81       	ldd	r25, Y+7	; 0x07
    9324:	01 96       	adiw	r24, 0x01	; 1
    9326:	9f 83       	std	Y+7, r25	; 0x07
    9328:	8e 83       	std	Y+6, r24	; 0x06
    932a:	02 c0       	rjmp	.+4      	; 0x9330 <fputc+0x4c>
    932c:	0f ef       	ldi	r16, 0xFF	; 255
    932e:	1f ef       	ldi	r17, 0xFF	; 255
    9330:	c8 01       	movw	r24, r16
    9332:	df 91       	pop	r29
    9334:	cf 91       	pop	r28
    9336:	1f 91       	pop	r17
    9338:	0f 91       	pop	r16
    933a:	08 95       	ret

0000933c <sprintf>:
    933c:	0f 93       	push	r16
    933e:	1f 93       	push	r17
    9340:	df 93       	push	r29
    9342:	cf 93       	push	r28
    9344:	cd b7       	in	r28, 0x3d	; 61
    9346:	de b7       	in	r29, 0x3e	; 62
    9348:	2e 97       	sbiw	r28, 0x0e	; 14
    934a:	0f b6       	in	r0, 0x3f	; 63
    934c:	f8 94       	cli
    934e:	de bf       	out	0x3e, r29	; 62
    9350:	0f be       	out	0x3f, r0	; 63
    9352:	cd bf       	out	0x3d, r28	; 61
    9354:	0d 89       	ldd	r16, Y+21	; 0x15
    9356:	1e 89       	ldd	r17, Y+22	; 0x16
    9358:	86 e0       	ldi	r24, 0x06	; 6
    935a:	8c 83       	std	Y+4, r24	; 0x04
    935c:	1a 83       	std	Y+2, r17	; 0x02
    935e:	09 83       	std	Y+1, r16	; 0x01
    9360:	8f ef       	ldi	r24, 0xFF	; 255
    9362:	9f e7       	ldi	r25, 0x7F	; 127
    9364:	9e 83       	std	Y+6, r25	; 0x06
    9366:	8d 83       	std	Y+5, r24	; 0x05
    9368:	9e 01       	movw	r18, r28
    936a:	27 5e       	subi	r18, 0xE7	; 231
    936c:	3f 4f       	sbci	r19, 0xFF	; 255
    936e:	ce 01       	movw	r24, r28
    9370:	01 96       	adiw	r24, 0x01	; 1
    9372:	6f 89       	ldd	r22, Y+23	; 0x17
    9374:	78 8d       	ldd	r23, Y+24	; 0x18
    9376:	a9 01       	movw	r20, r18
    9378:	0e 94 76 3f 	call	0x7eec	; 0x7eec <vfprintf>
    937c:	2f 81       	ldd	r18, Y+7	; 0x07
    937e:	38 85       	ldd	r19, Y+8	; 0x08
    9380:	02 0f       	add	r16, r18
    9382:	13 1f       	adc	r17, r19
    9384:	f8 01       	movw	r30, r16
    9386:	10 82       	st	Z, r1
    9388:	2e 96       	adiw	r28, 0x0e	; 14
    938a:	0f b6       	in	r0, 0x3f	; 63
    938c:	f8 94       	cli
    938e:	de bf       	out	0x3e, r29	; 62
    9390:	0f be       	out	0x3f, r0	; 63
    9392:	cd bf       	out	0x3d, r28	; 61
    9394:	cf 91       	pop	r28
    9396:	df 91       	pop	r29
    9398:	1f 91       	pop	r17
    939a:	0f 91       	pop	r16
    939c:	08 95       	ret

0000939e <__ultoa_invert>:
    939e:	fa 01       	movw	r30, r20
    93a0:	aa 27       	eor	r26, r26
    93a2:	28 30       	cpi	r18, 0x08	; 8
    93a4:	51 f1       	breq	.+84     	; 0x93fa <__ultoa_invert+0x5c>
    93a6:	20 31       	cpi	r18, 0x10	; 16
    93a8:	81 f1       	breq	.+96     	; 0x940a <__ultoa_invert+0x6c>
    93aa:	e8 94       	clt
    93ac:	6f 93       	push	r22
    93ae:	6e 7f       	andi	r22, 0xFE	; 254
    93b0:	6e 5f       	subi	r22, 0xFE	; 254
    93b2:	7f 4f       	sbci	r23, 0xFF	; 255
    93b4:	8f 4f       	sbci	r24, 0xFF	; 255
    93b6:	9f 4f       	sbci	r25, 0xFF	; 255
    93b8:	af 4f       	sbci	r26, 0xFF	; 255
    93ba:	b1 e0       	ldi	r27, 0x01	; 1
    93bc:	3e d0       	rcall	.+124    	; 0x943a <__ultoa_invert+0x9c>
    93be:	b4 e0       	ldi	r27, 0x04	; 4
    93c0:	3c d0       	rcall	.+120    	; 0x943a <__ultoa_invert+0x9c>
    93c2:	67 0f       	add	r22, r23
    93c4:	78 1f       	adc	r23, r24
    93c6:	89 1f       	adc	r24, r25
    93c8:	9a 1f       	adc	r25, r26
    93ca:	a1 1d       	adc	r26, r1
    93cc:	68 0f       	add	r22, r24
    93ce:	79 1f       	adc	r23, r25
    93d0:	8a 1f       	adc	r24, r26
    93d2:	91 1d       	adc	r25, r1
    93d4:	a1 1d       	adc	r26, r1
    93d6:	6a 0f       	add	r22, r26
    93d8:	71 1d       	adc	r23, r1
    93da:	81 1d       	adc	r24, r1
    93dc:	91 1d       	adc	r25, r1
    93de:	a1 1d       	adc	r26, r1
    93e0:	20 d0       	rcall	.+64     	; 0x9422 <__ultoa_invert+0x84>
    93e2:	09 f4       	brne	.+2      	; 0x93e6 <__ultoa_invert+0x48>
    93e4:	68 94       	set
    93e6:	3f 91       	pop	r19
    93e8:	2a e0       	ldi	r18, 0x0A	; 10
    93ea:	26 9f       	mul	r18, r22
    93ec:	11 24       	eor	r1, r1
    93ee:	30 19       	sub	r19, r0
    93f0:	30 5d       	subi	r19, 0xD0	; 208
    93f2:	31 93       	st	Z+, r19
    93f4:	de f6       	brtc	.-74     	; 0x93ac <__ultoa_invert+0xe>
    93f6:	cf 01       	movw	r24, r30
    93f8:	08 95       	ret
    93fa:	46 2f       	mov	r20, r22
    93fc:	47 70       	andi	r20, 0x07	; 7
    93fe:	40 5d       	subi	r20, 0xD0	; 208
    9400:	41 93       	st	Z+, r20
    9402:	b3 e0       	ldi	r27, 0x03	; 3
    9404:	0f d0       	rcall	.+30     	; 0x9424 <__ultoa_invert+0x86>
    9406:	c9 f7       	brne	.-14     	; 0x93fa <__ultoa_invert+0x5c>
    9408:	f6 cf       	rjmp	.-20     	; 0x93f6 <__ultoa_invert+0x58>
    940a:	46 2f       	mov	r20, r22
    940c:	4f 70       	andi	r20, 0x0F	; 15
    940e:	40 5d       	subi	r20, 0xD0	; 208
    9410:	4a 33       	cpi	r20, 0x3A	; 58
    9412:	18 f0       	brcs	.+6      	; 0x941a <__ultoa_invert+0x7c>
    9414:	49 5d       	subi	r20, 0xD9	; 217
    9416:	31 fd       	sbrc	r19, 1
    9418:	40 52       	subi	r20, 0x20	; 32
    941a:	41 93       	st	Z+, r20
    941c:	02 d0       	rcall	.+4      	; 0x9422 <__ultoa_invert+0x84>
    941e:	a9 f7       	brne	.-22     	; 0x940a <__ultoa_invert+0x6c>
    9420:	ea cf       	rjmp	.-44     	; 0x93f6 <__ultoa_invert+0x58>
    9422:	b4 e0       	ldi	r27, 0x04	; 4
    9424:	a6 95       	lsr	r26
    9426:	97 95       	ror	r25
    9428:	87 95       	ror	r24
    942a:	77 95       	ror	r23
    942c:	67 95       	ror	r22
    942e:	ba 95       	dec	r27
    9430:	c9 f7       	brne	.-14     	; 0x9424 <__ultoa_invert+0x86>
    9432:	00 97       	sbiw	r24, 0x00	; 0
    9434:	61 05       	cpc	r22, r1
    9436:	71 05       	cpc	r23, r1
    9438:	08 95       	ret
    943a:	9b 01       	movw	r18, r22
    943c:	ac 01       	movw	r20, r24
    943e:	0a 2e       	mov	r0, r26
    9440:	06 94       	lsr	r0
    9442:	57 95       	ror	r21
    9444:	47 95       	ror	r20
    9446:	37 95       	ror	r19
    9448:	27 95       	ror	r18
    944a:	ba 95       	dec	r27
    944c:	c9 f7       	brne	.-14     	; 0x9440 <__ultoa_invert+0xa2>
    944e:	62 0f       	add	r22, r18
    9450:	73 1f       	adc	r23, r19
    9452:	84 1f       	adc	r24, r20
    9454:	95 1f       	adc	r25, r21
    9456:	a0 1d       	adc	r26, r0
    9458:	08 95       	ret

0000945a <__eerd_block_m1284p>:
    945a:	dc 01       	movw	r26, r24
    945c:	cb 01       	movw	r24, r22

0000945e <__eerd_blraw_m1284p>:
    945e:	fc 01       	movw	r30, r24
    9460:	f9 99       	sbic	0x1f, 1	; 31
    9462:	fe cf       	rjmp	.-4      	; 0x9460 <__eerd_blraw_m1284p+0x2>
    9464:	06 c0       	rjmp	.+12     	; 0x9472 <__eerd_blraw_m1284p+0x14>
    9466:	f2 bd       	out	0x22, r31	; 34
    9468:	e1 bd       	out	0x21, r30	; 33
    946a:	f8 9a       	sbi	0x1f, 0	; 31
    946c:	31 96       	adiw	r30, 0x01	; 1
    946e:	00 b4       	in	r0, 0x20	; 32
    9470:	0d 92       	st	X+, r0
    9472:	41 50       	subi	r20, 0x01	; 1
    9474:	50 40       	sbci	r21, 0x00	; 0
    9476:	b8 f7       	brcc	.-18     	; 0x9466 <__eerd_blraw_m1284p+0x8>
    9478:	08 95       	ret

0000947a <__eeupd_block_m1284p>:
    947a:	dc 01       	movw	r26, r24
    947c:	a4 0f       	add	r26, r20
    947e:	b5 1f       	adc	r27, r21
    9480:	41 50       	subi	r20, 0x01	; 1
    9482:	50 40       	sbci	r21, 0x00	; 0
    9484:	48 f0       	brcs	.+18     	; 0x9498 <__eeupd_block_m1284p+0x1e>
    9486:	cb 01       	movw	r24, r22
    9488:	84 0f       	add	r24, r20
    948a:	95 1f       	adc	r25, r21
    948c:	2e 91       	ld	r18, -X
    948e:	0e 94 4e 4a 	call	0x949c	; 0x949c <__eeupd_r18_m1284p>
    9492:	41 50       	subi	r20, 0x01	; 1
    9494:	50 40       	sbci	r21, 0x00	; 0
    9496:	d0 f7       	brcc	.-12     	; 0x948c <__eeupd_block_m1284p+0x12>
    9498:	08 95       	ret

0000949a <__eeupd_byte_m1284p>:
    949a:	26 2f       	mov	r18, r22

0000949c <__eeupd_r18_m1284p>:
    949c:	f9 99       	sbic	0x1f, 1	; 31
    949e:	fe cf       	rjmp	.-4      	; 0x949c <__eeupd_r18_m1284p>
    94a0:	92 bd       	out	0x22, r25	; 34
    94a2:	81 bd       	out	0x21, r24	; 33
    94a4:	f8 9a       	sbi	0x1f, 0	; 31
    94a6:	01 97       	sbiw	r24, 0x01	; 1
    94a8:	00 b4       	in	r0, 0x20	; 32
    94aa:	02 16       	cp	r0, r18
    94ac:	39 f0       	breq	.+14     	; 0x94bc <__eeupd_r18_m1284p+0x20>
    94ae:	1f ba       	out	0x1f, r1	; 31
    94b0:	20 bd       	out	0x20, r18	; 32
    94b2:	0f b6       	in	r0, 0x3f	; 63
    94b4:	f8 94       	cli
    94b6:	fa 9a       	sbi	0x1f, 2	; 31
    94b8:	f9 9a       	sbi	0x1f, 1	; 31
    94ba:	0f be       	out	0x3f, r0	; 63
    94bc:	08 95       	ret

000094be <strtod>:
    94be:	8f 92       	push	r8
    94c0:	9f 92       	push	r9
    94c2:	af 92       	push	r10
    94c4:	bf 92       	push	r11
    94c6:	cf 92       	push	r12
    94c8:	df 92       	push	r13
    94ca:	ef 92       	push	r14
    94cc:	ff 92       	push	r15
    94ce:	0f 93       	push	r16
    94d0:	1f 93       	push	r17
    94d2:	cf 93       	push	r28
    94d4:	df 93       	push	r29
    94d6:	ec 01       	movw	r28, r24
    94d8:	5b 01       	movw	r10, r22
    94da:	61 15       	cp	r22, r1
    94dc:	71 05       	cpc	r23, r1
    94de:	19 f0       	breq	.+6      	; 0x94e6 <strtod+0x28>
    94e0:	fb 01       	movw	r30, r22
    94e2:	91 83       	std	Z+1, r25	; 0x01
    94e4:	80 83       	st	Z, r24
    94e6:	f9 90       	ld	r15, Y+
    94e8:	8f 2d       	mov	r24, r15
    94ea:	90 e0       	ldi	r25, 0x00	; 0
    94ec:	0e 94 09 49 	call	0x9212	; 0x9212 <isspace>
    94f0:	89 2b       	or	r24, r25
    94f2:	c9 f7       	brne	.-14     	; 0x94e6 <strtod+0x28>
    94f4:	fd e2       	ldi	r31, 0x2D	; 45
    94f6:	ff 16       	cp	r15, r31
    94f8:	21 f4       	brne	.+8      	; 0x9502 <strtod+0x44>
    94fa:	f9 90       	ld	r15, Y+
    94fc:	ee 24       	eor	r14, r14
    94fe:	e3 94       	inc	r14
    9500:	05 c0       	rjmp	.+10     	; 0x950c <strtod+0x4e>
    9502:	2b e2       	ldi	r18, 0x2B	; 43
    9504:	f2 16       	cp	r15, r18
    9506:	09 f4       	brne	.+2      	; 0x950a <strtod+0x4c>
    9508:	f9 90       	ld	r15, Y+
    950a:	ee 24       	eor	r14, r14
    950c:	8e 01       	movw	r16, r28
    950e:	01 50       	subi	r16, 0x01	; 1
    9510:	10 40       	sbci	r17, 0x00	; 0
    9512:	c8 01       	movw	r24, r16
    9514:	60 e8       	ldi	r22, 0x80	; 128
    9516:	76 e0       	ldi	r23, 0x06	; 6
    9518:	43 e0       	ldi	r20, 0x03	; 3
    951a:	50 e0       	ldi	r21, 0x00	; 0
    951c:	0e 94 d0 4b 	call	0x97a0	; 0x97a0 <strncasecmp_P>
    9520:	89 2b       	or	r24, r25
    9522:	01 f5       	brne	.+64     	; 0x9564 <strtod+0xa6>
    9524:	8e 01       	movw	r16, r28
    9526:	0e 5f       	subi	r16, 0xFE	; 254
    9528:	1f 4f       	sbci	r17, 0xFF	; 255
    952a:	c8 01       	movw	r24, r16
    952c:	63 e8       	ldi	r22, 0x83	; 131
    952e:	76 e0       	ldi	r23, 0x06	; 6
    9530:	45 e0       	ldi	r20, 0x05	; 5
    9532:	50 e0       	ldi	r21, 0x00	; 0
    9534:	0e 94 d0 4b 	call	0x97a0	; 0x97a0 <strncasecmp_P>
    9538:	89 2b       	or	r24, r25
    953a:	19 f4       	brne	.+6      	; 0x9542 <strtod+0x84>
    953c:	8e 01       	movw	r16, r28
    953e:	09 5f       	subi	r16, 0xF9	; 249
    9540:	1f 4f       	sbci	r17, 0xFF	; 255
    9542:	a1 14       	cp	r10, r1
    9544:	b1 04       	cpc	r11, r1
    9546:	19 f0       	breq	.+6      	; 0x954e <strtod+0x90>
    9548:	f5 01       	movw	r30, r10
    954a:	11 83       	std	Z+1, r17	; 0x01
    954c:	00 83       	st	Z, r16
    954e:	e0 fc       	sbrc	r14, 0
    9550:	04 c0       	rjmp	.+8      	; 0x955a <strtod+0x9c>
    9552:	70 e0       	ldi	r23, 0x00	; 0
    9554:	90 e0       	ldi	r25, 0x00	; 0
    9556:	80 e8       	ldi	r24, 0x80	; 128
    9558:	14 c0       	rjmp	.+40     	; 0x9582 <strtod+0xc4>
    955a:	70 e0       	ldi	r23, 0x00	; 0
    955c:	90 e0       	ldi	r25, 0x00	; 0
    955e:	80 e8       	ldi	r24, 0x80	; 128
    9560:	6f ef       	ldi	r22, 0xFF	; 255
    9562:	08 c1       	rjmp	.+528    	; 0x9774 <strtod+0x2b6>
    9564:	c8 01       	movw	r24, r16
    9566:	68 e8       	ldi	r22, 0x88	; 136
    9568:	76 e0       	ldi	r23, 0x06	; 6
    956a:	43 e0       	ldi	r20, 0x03	; 3
    956c:	50 e0       	ldi	r21, 0x00	; 0
    956e:	0e 94 d0 4b 	call	0x97a0	; 0x97a0 <strncasecmp_P>
    9572:	89 2b       	or	r24, r25
    9574:	69 f4       	brne	.+26     	; 0x9590 <strtod+0xd2>
    9576:	a1 14       	cp	r10, r1
    9578:	b1 04       	cpc	r11, r1
    957a:	29 f4       	brne	.+10     	; 0x9586 <strtod+0xc8>
    957c:	70 e0       	ldi	r23, 0x00	; 0
    957e:	90 e0       	ldi	r25, 0x00	; 0
    9580:	80 ec       	ldi	r24, 0xC0	; 192
    9582:	6f e7       	ldi	r22, 0x7F	; 127
    9584:	f7 c0       	rjmp	.+494    	; 0x9774 <strtod+0x2b6>
    9586:	22 96       	adiw	r28, 0x02	; 2
    9588:	f5 01       	movw	r30, r10
    958a:	d1 83       	std	Z+1, r29	; 0x01
    958c:	c0 83       	st	Z, r28
    958e:	f6 cf       	rjmp	.-20     	; 0x957c <strtod+0xbe>
    9590:	88 24       	eor	r8, r8
    9592:	99 24       	eor	r9, r9
    9594:	40 e0       	ldi	r20, 0x00	; 0
    9596:	50 e0       	ldi	r21, 0x00	; 0
    9598:	60 e0       	ldi	r22, 0x00	; 0
    959a:	70 e0       	ldi	r23, 0x00	; 0
    959c:	ef 2d       	mov	r30, r15
    959e:	e0 53       	subi	r30, 0x30	; 48
    95a0:	ea 30       	cpi	r30, 0x0A	; 10
    95a2:	a0 f5       	brcc	.+104    	; 0x960c <strtod+0x14e>
    95a4:	f2 e0       	ldi	r31, 0x02	; 2
    95a6:	ef 2a       	or	r14, r31
    95a8:	8e 2d       	mov	r24, r14
    95aa:	90 e0       	ldi	r25, 0x00	; 0
    95ac:	9c 01       	movw	r18, r24
    95ae:	28 70       	andi	r18, 0x08	; 8
    95b0:	30 70       	andi	r19, 0x00	; 0
    95b2:	e2 fe       	sbrs	r14, 2
    95b4:	06 c0       	rjmp	.+12     	; 0x95c2 <strtod+0x104>
    95b6:	23 2b       	or	r18, r19
    95b8:	79 f5       	brne	.+94     	; 0x9618 <strtod+0x15a>
    95ba:	08 94       	sec
    95bc:	81 1c       	adc	r8, r1
    95be:	91 1c       	adc	r9, r1
    95c0:	2b c0       	rjmp	.+86     	; 0x9618 <strtod+0x15a>
    95c2:	23 2b       	or	r18, r19
    95c4:	19 f0       	breq	.+6      	; 0x95cc <strtod+0x10e>
    95c6:	08 94       	sec
    95c8:	81 08       	sbc	r8, r1
    95ca:	91 08       	sbc	r9, r1
    95cc:	db 01       	movw	r26, r22
    95ce:	ca 01       	movw	r24, r20
    95d0:	12 e0       	ldi	r17, 0x02	; 2
    95d2:	88 0f       	add	r24, r24
    95d4:	99 1f       	adc	r25, r25
    95d6:	aa 1f       	adc	r26, r26
    95d8:	bb 1f       	adc	r27, r27
    95da:	1a 95       	dec	r17
    95dc:	d1 f7       	brne	.-12     	; 0x95d2 <strtod+0x114>
    95de:	48 0f       	add	r20, r24
    95e0:	59 1f       	adc	r21, r25
    95e2:	6a 1f       	adc	r22, r26
    95e4:	7b 1f       	adc	r23, r27
    95e6:	44 0f       	add	r20, r20
    95e8:	55 1f       	adc	r21, r21
    95ea:	66 1f       	adc	r22, r22
    95ec:	77 1f       	adc	r23, r23
    95ee:	4e 0f       	add	r20, r30
    95f0:	51 1d       	adc	r21, r1
    95f2:	61 1d       	adc	r22, r1
    95f4:	71 1d       	adc	r23, r1
    95f6:	48 39       	cpi	r20, 0x98	; 152
    95f8:	29 e9       	ldi	r18, 0x99	; 153
    95fa:	52 07       	cpc	r21, r18
    95fc:	29 e9       	ldi	r18, 0x99	; 153
    95fe:	62 07       	cpc	r22, r18
    9600:	29 e1       	ldi	r18, 0x19	; 25
    9602:	72 07       	cpc	r23, r18
    9604:	48 f0       	brcs	.+18     	; 0x9618 <strtod+0x15a>
    9606:	84 e0       	ldi	r24, 0x04	; 4
    9608:	e8 2a       	or	r14, r24
    960a:	06 c0       	rjmp	.+12     	; 0x9618 <strtod+0x15a>
    960c:	ee 3f       	cpi	r30, 0xFE	; 254
    960e:	31 f4       	brne	.+12     	; 0x961c <strtod+0x15e>
    9610:	e3 fc       	sbrc	r14, 3
    9612:	39 c0       	rjmp	.+114    	; 0x9686 <strtod+0x1c8>
    9614:	98 e0       	ldi	r25, 0x08	; 8
    9616:	e9 2a       	or	r14, r25
    9618:	f9 90       	ld	r15, Y+
    961a:	c0 cf       	rjmp	.-128    	; 0x959c <strtod+0xde>
    961c:	e5 33       	cpi	r30, 0x35	; 53
    961e:	11 f0       	breq	.+4      	; 0x9624 <strtod+0x166>
    9620:	e5 31       	cpi	r30, 0x15	; 21
    9622:	89 f5       	brne	.+98     	; 0x9686 <strtod+0x1c8>
    9624:	29 91       	ld	r18, Y+
    9626:	2d 32       	cpi	r18, 0x2D	; 45
    9628:	19 f4       	brne	.+6      	; 0x9630 <strtod+0x172>
    962a:	e0 e1       	ldi	r30, 0x10	; 16
    962c:	ee 2a       	or	r14, r30
    962e:	05 c0       	rjmp	.+10     	; 0x963a <strtod+0x17c>
    9630:	2b 32       	cpi	r18, 0x2B	; 43
    9632:	19 f0       	breq	.+6      	; 0x963a <strtod+0x17c>
    9634:	81 e0       	ldi	r24, 0x01	; 1
    9636:	90 e0       	ldi	r25, 0x00	; 0
    9638:	03 c0       	rjmp	.+6      	; 0x9640 <strtod+0x182>
    963a:	29 91       	ld	r18, Y+
    963c:	82 e0       	ldi	r24, 0x02	; 2
    963e:	90 e0       	ldi	r25, 0x00	; 0
    9640:	e2 2f       	mov	r30, r18
    9642:	e0 53       	subi	r30, 0x30	; 48
    9644:	ea 30       	cpi	r30, 0x0A	; 10
    9646:	18 f0       	brcs	.+6      	; 0x964e <strtod+0x190>
    9648:	c8 1b       	sub	r28, r24
    964a:	d9 0b       	sbc	r29, r25
    964c:	1c c0       	rjmp	.+56     	; 0x9686 <strtod+0x1c8>
    964e:	20 e0       	ldi	r18, 0x00	; 0
    9650:	30 e0       	ldi	r19, 0x00	; 0
    9652:	fc e0       	ldi	r31, 0x0C	; 12
    9654:	20 38       	cpi	r18, 0x80	; 128
    9656:	3f 07       	cpc	r19, r31
    9658:	5c f4       	brge	.+22     	; 0x9670 <strtod+0x1b2>
    965a:	c9 01       	movw	r24, r18
    965c:	88 0f       	add	r24, r24
    965e:	99 1f       	adc	r25, r25
    9660:	88 0f       	add	r24, r24
    9662:	99 1f       	adc	r25, r25
    9664:	28 0f       	add	r18, r24
    9666:	39 1f       	adc	r19, r25
    9668:	22 0f       	add	r18, r18
    966a:	33 1f       	adc	r19, r19
    966c:	2e 0f       	add	r18, r30
    966e:	31 1d       	adc	r19, r1
    9670:	e9 91       	ld	r30, Y+
    9672:	e0 53       	subi	r30, 0x30	; 48
    9674:	ea 30       	cpi	r30, 0x0A	; 10
    9676:	68 f3       	brcs	.-38     	; 0x9652 <strtod+0x194>
    9678:	e4 fe       	sbrs	r14, 4
    967a:	03 c0       	rjmp	.+6      	; 0x9682 <strtod+0x1c4>
    967c:	30 95       	com	r19
    967e:	21 95       	neg	r18
    9680:	3f 4f       	sbci	r19, 0xFF	; 255
    9682:	82 0e       	add	r8, r18
    9684:	93 1e       	adc	r9, r19
    9686:	ce 2c       	mov	r12, r14
    9688:	dd 24       	eor	r13, r13
    968a:	e1 fe       	sbrs	r14, 1
    968c:	07 c0       	rjmp	.+14     	; 0x969c <strtod+0x1de>
    968e:	a1 14       	cp	r10, r1
    9690:	b1 04       	cpc	r11, r1
    9692:	21 f0       	breq	.+8      	; 0x969c <strtod+0x1de>
    9694:	21 97       	sbiw	r28, 0x01	; 1
    9696:	f5 01       	movw	r30, r10
    9698:	d1 83       	std	Z+1, r29	; 0x01
    969a:	c0 83       	st	Z, r28
    969c:	cb 01       	movw	r24, r22
    969e:	ba 01       	movw	r22, r20
    96a0:	0e 94 28 44 	call	0x8850	; 0x8850 <__floatunsisf>
    96a4:	7b 01       	movw	r14, r22
    96a6:	8c 01       	movw	r16, r24
    96a8:	f3 e0       	ldi	r31, 0x03	; 3
    96aa:	cf 22       	and	r12, r31
    96ac:	dd 24       	eor	r13, r13
    96ae:	23 e0       	ldi	r18, 0x03	; 3
    96b0:	c2 16       	cp	r12, r18
    96b2:	d1 04       	cpc	r13, r1
    96b4:	21 f4       	brne	.+8      	; 0x96be <strtod+0x200>
    96b6:	17 fb       	bst	r17, 7
    96b8:	10 95       	com	r17
    96ba:	17 f9       	bld	r17, 7
    96bc:	10 95       	com	r17
    96be:	57 01       	movw	r10, r14
    96c0:	68 01       	movw	r12, r16
    96c2:	c8 01       	movw	r24, r16
    96c4:	b7 01       	movw	r22, r14
    96c6:	20 e0       	ldi	r18, 0x00	; 0
    96c8:	30 e0       	ldi	r19, 0x00	; 0
    96ca:	40 e0       	ldi	r20, 0x00	; 0
    96cc:	50 e0       	ldi	r21, 0x00	; 0
    96ce:	0e 94 8b 43 	call	0x8716	; 0x8716 <__cmpsf2>
    96d2:	88 23       	and	r24, r24
    96d4:	09 f4       	brne	.+2      	; 0x96d8 <strtod+0x21a>
    96d6:	4a c0       	rjmp	.+148    	; 0x976c <strtod+0x2ae>
    96d8:	97 fe       	sbrs	r9, 7
    96da:	0d c0       	rjmp	.+26     	; 0x96f6 <strtod+0x238>
    96dc:	2f e9       	ldi	r18, 0x9F	; 159
    96de:	e2 2e       	mov	r14, r18
    96e0:	26 e0       	ldi	r18, 0x06	; 6
    96e2:	f2 2e       	mov	r15, r18
    96e4:	90 94       	com	r9
    96e6:	81 94       	neg	r8
    96e8:	91 08       	sbc	r9, r1
    96ea:	93 94       	inc	r9
    96ec:	c0 e2       	ldi	r28, 0x20	; 32
    96ee:	d0 e0       	ldi	r29, 0x00	; 0
    96f0:	00 e0       	ldi	r16, 0x00	; 0
    96f2:	10 e0       	ldi	r17, 0x00	; 0
    96f4:	12 c0       	rjmp	.+36     	; 0x971a <strtod+0x25c>
    96f6:	97 eb       	ldi	r25, 0xB7	; 183
    96f8:	e9 2e       	mov	r14, r25
    96fa:	96 e0       	ldi	r25, 0x06	; 6
    96fc:	f9 2e       	mov	r15, r25
    96fe:	f6 cf       	rjmp	.-20     	; 0x96ec <strtod+0x22e>
    9700:	f7 01       	movw	r30, r14
    9702:	25 91       	lpm	r18, Z+
    9704:	35 91       	lpm	r19, Z+
    9706:	45 91       	lpm	r20, Z+
    9708:	54 91       	lpm	r21, Z+
    970a:	c6 01       	movw	r24, r12
    970c:	b5 01       	movw	r22, r10
    970e:	0e 94 31 45 	call	0x8a62	; 0x8a62 <__mulsf3>
    9712:	5b 01       	movw	r10, r22
    9714:	6c 01       	movw	r12, r24
    9716:	8c 1a       	sub	r8, r28
    9718:	9d 0a       	sbc	r9, r29
    971a:	8c 16       	cp	r8, r28
    971c:	9d 06       	cpc	r9, r29
    971e:	84 f7       	brge	.-32     	; 0x9700 <strtod+0x242>
    9720:	d5 95       	asr	r29
    9722:	c7 95       	ror	r28
    9724:	0f 5f       	subi	r16, 0xFF	; 255
    9726:	1f 4f       	sbci	r17, 0xFF	; 255
    9728:	06 30       	cpi	r16, 0x06	; 6
    972a:	11 05       	cpc	r17, r1
    972c:	29 f0       	breq	.+10     	; 0x9738 <strtod+0x27a>
    972e:	8c ef       	ldi	r24, 0xFC	; 252
    9730:	9f ef       	ldi	r25, 0xFF	; 255
    9732:	e8 0e       	add	r14, r24
    9734:	f9 1e       	adc	r15, r25
    9736:	f1 cf       	rjmp	.-30     	; 0x971a <strtod+0x25c>
    9738:	c5 01       	movw	r24, r10
    973a:	d6 01       	movw	r26, r12
    973c:	7c 01       	movw	r14, r24
    973e:	8d 01       	movw	r16, r26
    9740:	8c 2d       	mov	r24, r12
    9742:	88 0f       	add	r24, r24
    9744:	8d 2d       	mov	r24, r13
    9746:	88 1f       	adc	r24, r24
    9748:	8f 3f       	cpi	r24, 0xFF	; 255
    974a:	51 f0       	breq	.+20     	; 0x9760 <strtod+0x2a2>
    974c:	c6 01       	movw	r24, r12
    974e:	b5 01       	movw	r22, r10
    9750:	20 e0       	ldi	r18, 0x00	; 0
    9752:	30 e0       	ldi	r19, 0x00	; 0
    9754:	40 e0       	ldi	r20, 0x00	; 0
    9756:	50 e0       	ldi	r21, 0x00	; 0
    9758:	0e 94 8b 43 	call	0x8716	; 0x8716 <__cmpsf2>
    975c:	88 23       	and	r24, r24
    975e:	31 f4       	brne	.+12     	; 0x976c <strtod+0x2ae>
    9760:	82 e2       	ldi	r24, 0x22	; 34
    9762:	90 e0       	ldi	r25, 0x00	; 0
    9764:	90 93 cb 04 	sts	0x04CB, r25
    9768:	80 93 ca 04 	sts	0x04CA, r24
    976c:	7e 2d       	mov	r23, r14
    976e:	9f 2d       	mov	r25, r15
    9770:	80 2f       	mov	r24, r16
    9772:	61 2f       	mov	r22, r17
    9774:	27 2f       	mov	r18, r23
    9776:	39 2f       	mov	r19, r25
    9778:	48 2f       	mov	r20, r24
    977a:	56 2f       	mov	r21, r22
    977c:	b9 01       	movw	r22, r18
    977e:	ca 01       	movw	r24, r20
    9780:	df 91       	pop	r29
    9782:	cf 91       	pop	r28
    9784:	1f 91       	pop	r17
    9786:	0f 91       	pop	r16
    9788:	ff 90       	pop	r15
    978a:	ef 90       	pop	r14
    978c:	df 90       	pop	r13
    978e:	cf 90       	pop	r12
    9790:	bf 90       	pop	r11
    9792:	af 90       	pop	r10
    9794:	9f 90       	pop	r9
    9796:	8f 90       	pop	r8
    9798:	08 95       	ret

0000979a <__ctype_isfalse>:
    979a:	99 27       	eor	r25, r25
    979c:	88 27       	eor	r24, r24

0000979e <__ctype_istrue>:
    979e:	08 95       	ret

000097a0 <strncasecmp_P>:
    97a0:	fb 01       	movw	r30, r22
    97a2:	dc 01       	movw	r26, r24
    97a4:	41 50       	subi	r20, 0x01	; 1
    97a6:	50 40       	sbci	r21, 0x00	; 0
    97a8:	88 f0       	brcs	.+34     	; 0x97cc <strncasecmp_P+0x2c>
    97aa:	8d 91       	ld	r24, X+
    97ac:	81 34       	cpi	r24, 0x41	; 65
    97ae:	1c f0       	brlt	.+6      	; 0x97b6 <strncasecmp_P+0x16>
    97b0:	8b 35       	cpi	r24, 0x5B	; 91
    97b2:	0c f4       	brge	.+2      	; 0x97b6 <strncasecmp_P+0x16>
    97b4:	80 5e       	subi	r24, 0xE0	; 224
    97b6:	65 91       	lpm	r22, Z+
    97b8:	61 34       	cpi	r22, 0x41	; 65
    97ba:	1c f0       	brlt	.+6      	; 0x97c2 <strncasecmp_P+0x22>
    97bc:	6b 35       	cpi	r22, 0x5B	; 91
    97be:	0c f4       	brge	.+2      	; 0x97c2 <strncasecmp_P+0x22>
    97c0:	60 5e       	subi	r22, 0xE0	; 224
    97c2:	86 1b       	sub	r24, r22
    97c4:	61 11       	cpse	r22, r1
    97c6:	71 f3       	breq	.-36     	; 0x97a4 <strncasecmp_P+0x4>
    97c8:	99 0b       	sbc	r25, r25
    97ca:	08 95       	ret
    97cc:	88 1b       	sub	r24, r24
    97ce:	fc cf       	rjmp	.-8      	; 0x97c8 <strncasecmp_P+0x28>

000097d0 <__mulsi3>:
    97d0:	62 9f       	mul	r22, r18
    97d2:	d0 01       	movw	r26, r0
    97d4:	73 9f       	mul	r23, r19
    97d6:	f0 01       	movw	r30, r0
    97d8:	82 9f       	mul	r24, r18
    97da:	e0 0d       	add	r30, r0
    97dc:	f1 1d       	adc	r31, r1
    97de:	64 9f       	mul	r22, r20
    97e0:	e0 0d       	add	r30, r0
    97e2:	f1 1d       	adc	r31, r1
    97e4:	92 9f       	mul	r25, r18
    97e6:	f0 0d       	add	r31, r0
    97e8:	83 9f       	mul	r24, r19
    97ea:	f0 0d       	add	r31, r0
    97ec:	74 9f       	mul	r23, r20
    97ee:	f0 0d       	add	r31, r0
    97f0:	65 9f       	mul	r22, r21
    97f2:	f0 0d       	add	r31, r0
    97f4:	99 27       	eor	r25, r25
    97f6:	72 9f       	mul	r23, r18
    97f8:	b0 0d       	add	r27, r0
    97fa:	e1 1d       	adc	r30, r1
    97fc:	f9 1f       	adc	r31, r25
    97fe:	63 9f       	mul	r22, r19
    9800:	b0 0d       	add	r27, r0
    9802:	e1 1d       	adc	r30, r1
    9804:	f9 1f       	adc	r31, r25
    9806:	bd 01       	movw	r22, r26
    9808:	cf 01       	movw	r24, r30
    980a:	11 24       	eor	r1, r1
    980c:	08 95       	ret

0000980e <__udivmodsi4>:
    980e:	a1 e2       	ldi	r26, 0x21	; 33
    9810:	1a 2e       	mov	r1, r26
    9812:	aa 1b       	sub	r26, r26
    9814:	bb 1b       	sub	r27, r27
    9816:	fd 01       	movw	r30, r26
    9818:	0d c0       	rjmp	.+26     	; 0x9834 <__udivmodsi4_ep>

0000981a <__udivmodsi4_loop>:
    981a:	aa 1f       	adc	r26, r26
    981c:	bb 1f       	adc	r27, r27
    981e:	ee 1f       	adc	r30, r30
    9820:	ff 1f       	adc	r31, r31
    9822:	a2 17       	cp	r26, r18
    9824:	b3 07       	cpc	r27, r19
    9826:	e4 07       	cpc	r30, r20
    9828:	f5 07       	cpc	r31, r21
    982a:	20 f0       	brcs	.+8      	; 0x9834 <__udivmodsi4_ep>
    982c:	a2 1b       	sub	r26, r18
    982e:	b3 0b       	sbc	r27, r19
    9830:	e4 0b       	sbc	r30, r20
    9832:	f5 0b       	sbc	r31, r21

00009834 <__udivmodsi4_ep>:
    9834:	66 1f       	adc	r22, r22
    9836:	77 1f       	adc	r23, r23
    9838:	88 1f       	adc	r24, r24
    983a:	99 1f       	adc	r25, r25
    983c:	1a 94       	dec	r1
    983e:	69 f7       	brne	.-38     	; 0x981a <__udivmodsi4_loop>
    9840:	60 95       	com	r22
    9842:	70 95       	com	r23
    9844:	80 95       	com	r24
    9846:	90 95       	com	r25
    9848:	9b 01       	movw	r18, r22
    984a:	ac 01       	movw	r20, r24
    984c:	bd 01       	movw	r22, r26
    984e:	cf 01       	movw	r24, r30
    9850:	08 95       	ret

00009852 <_exit>:
    9852:	f8 94       	cli

00009854 <__stop_program>:
    9854:	ff cf       	rjmp	.-2      	; 0x9854 <__stop_program>
